110-}
111-
112-static dui_test_api_v1 g_test_api;
113-static dui_native_api_v1 g_native_api;
114-static dui_action_api_v1 g_action_api;
115-
116-static dui_result win32_test_post_event(dui_context* ctx, const dui_event_v1* ev)
117-{
118-    if (!ctx || !ev) {
119-        return DUI_ERR_NULL;
120-    }
121-    if (dui_event_queue_push(&ctx->q, ev) != 0) {
122-        return DUI_ERR;
123-    }
124-    return DUI_OK;
125-}
126-
127-static void* win32_get_native_window_handle(dui_window* win)
128-{
129-#if defined(_WIN32)
130:    return win ? (void*)win->hwnd : (void*)0;
131-#else
132-    (void)win;
133-    return (void*)0;
134-#endif
135-}
136-
137-static void win32_set_action_dispatch(dui_context* ctx, domui_action_fn fn, void* user_ctx)
138-{
139-    if (!ctx) {
140-        return;
141-    }
142-    ctx->action_dispatch = fn;
143-    ctx->action_user_ctx = user_ctx;
144-}
145-
146-static dom_abi_result win32_query_interface(dom_iid iid, void** out_iface)
147-{
148-    if (!out_iface) {
149-        return (dom_abi_result)DUI_ERR_NULL;
150-    }
151-    *out_iface = (void*)0;
152-
153-    if (iid == DUI_IID_TEST_API_V1) {
154-        g_test_api.abi_version = DUI_API_ABI_VERSION;
155-        g_test_api.struct_size = (u32)sizeof(g_test_api);
156-        g_test_api.post_event = win32_test_post_event;
157-        *out_iface = (void*)&g_test_api;
158-        return 0;
159-    }
160-    if (iid == DUI_IID_NATIVE_API_V1) {
161-        g_native_api.abi_version = DUI_API_ABI_VERSION;
162-        g_native_api.struct_size = (u32)sizeof(g_native_api);
163-        g_native_api.get_native_window_handle = win32_get_native_window_handle;
164-        *out_iface = (void*)&g_native_api;
165-        return 0;
166-    }
167-    if (iid == DUI_IID_ACTION_API_V1) {
168-        g_action_api.abi_version = DUI_API_ABI_VERSION;
169-        g_action_api.struct_size = (u32)sizeof(g_action_api);
170-        g_action_api.set_action_dispatch = win32_set_action_dispatch;
--
518-    }
519-    (void)dui_event_queue_push(&ctx->q, &ev);
520-
521-    {
522-        domui_value a = win32_domui_value_str(text ? text : "", n);
523-        domui_value b = win32_domui_value_none();
524-        win32_dispatch_domui_event(ctx, action_id, widget_id, DOMUI_EVENT_CHANGE, a, b, backend_ext);
525-    }
526-}
527-
528-static int win32_node_visible(const dui_window* win, const dui_schema_node* n)
529-{
530-    if (!n) {
531-        return 0;
532-    }
533-    if (n->required_caps != 0u) {
534-        if ((win32_caps() & n->required_caps) != n->required_caps) {
535-            return 0;
536-        }
537-    }
538:    if (n->visible_bind_id != 0u && win && win->state) {
539-        u32 v = 1u;
540:        if (dui_state_get_u32(win->state, win->state_len, n->visible_bind_id, &v)) {
541-            if (v == 0u) {
542-                return 0;
543-            }
544-        }
545-    }
546-    return 1;
547-}
548-
549-static int win32_is_leaf_kind(u32 kind)
550-{
551-    switch ((dui_node_kind)kind) {
552-    case DUI_NODE_LABEL:
553-    case DUI_NODE_BUTTON:
554-    case DUI_NODE_CHECKBOX:
555-    case DUI_NODE_LIST:
556-    case DUI_NODE_TEXT_FIELD:
557-    case DUI_NODE_PROGRESS:
558-        return 1;
559-    default:
560-        break;
561-    }
562-    return 0;
563-}
564-
565-static void win32_destroy_child_controls(dui_schema_node* n)
566-{
567-    dui_schema_node* child;
568-    if (!n) {
569-        return;
570-    }
571-    if (n->native) {
572-        DestroyWindow((HWND)n->native);
573-        n->native = (void*)0;
574-    }
575-    if (n->native_aux) {
576-        DestroyWindow((HWND)n->native_aux);
577-        n->native_aux = (void*)0;
578-    }
579-    child = n->first_child;
580-    while (child) {
--
595-    }
596-
597-    child_parent = parent_hwnd;
598-
599-    if (n->kind == (u32)DUI_NODE_TABS) {
600-        DWORD style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
601-        HWND h = CreateWindowExA(
602-            0,
603-            WC_TABCONTROLA,
604-            "",
605-            style,
606-            0, 0, 10, 10,
607-            parent_hwnd,
608-            (HMENU)(INT_PTR)n->id,
609-            GetModuleHandleA(NULL),
610-            NULL);
611-        if (h) {
612-            u32 page_count = 0u;
613-            int use_explicit_pages = 0;
614-            int index = 0;
615:            if (!win->font) {
616:                win->font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
617-            }
618:            SendMessageA(h, WM_SETFONT, (WPARAM)win->font, TRUE);
619-            child = n->first_child;
620-            while (child) {
621-                if (child->kind == (u32)DUI_NODE_TAB_PAGE) {
622-                    use_explicit_pages = 1;
623-                    break;
624-                }
625-                child = child->next_sibling;
626-            }
627-            child = n->first_child;
628-            while (child) {
629-                if (!use_explicit_pages || child->kind == (u32)DUI_NODE_TAB_PAGE) {
630-                    TCITEMA item;
631-                    char label[64];
632-                    const char* text = (child->text && child->text[0]) ? child->text : (const char*)0;
633-                    memset(&item, 0, sizeof(item));
634-                    item.mask = TCIF_TEXT;
635-                    if (!text) {
636-                        sprintf(label, "Tab %u", (unsigned int)(page_count + 1u));
637-                        item.pszText = label;
638-                    } else {
639-                        item.pszText = (LPSTR)text;
640-                    }
641-                    (void)TabCtrl_InsertItem(h, index, &item);
642-                    index += 1;
643-                    page_count += 1u;
644-                }
645-                child = child->next_sibling;
646-            }
647-            if (page_count > 0u) {
648-                if (n->tabs_selected >= page_count) {
649-                    n->tabs_selected = page_count - 1u;
650-                }
651-                (void)TabCtrl_SetCurSel(h, (int)n->tabs_selected);
652-            }
653-            n->native = (void*)h;
654-        }
655-    } else if (n->kind == (u32)DUI_NODE_SCROLL_PANEL) {
656-        DWORD style = WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
657-        DWORD exstyle = WS_EX_CLIENTEDGE;
658-        dui_scrollpanel_data* data = (dui_scrollpanel_data*)malloc(sizeof(dui_scrollpanel_data));
--
742-            if ((n->flags & DUI_NODE_FLAG_FOCUSABLE) == 0u) {
743-                n->flags |= DUI_NODE_FLAG_FOCUSABLE;
744-            }
745-            if ((n->flags & DUI_NODE_FLAG_FLEX) == 0u) {
746-                n->flags |= DUI_NODE_FLAG_FLEX;
747-            }
748-        }
749-
750-        h = CreateWindowExA(
751-            exstyle,
752-            klass,
753-            text,
754-            style,
755-            0, 0, 10, 10,
756-            parent_hwnd,
757-            (HMENU)(INT_PTR)n->id,
758-            GetModuleHandleA(NULL),
759-            NULL);
760-
761-        if (h) {
762:            if (!win->font) {
763:                win->font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
764-            }
765:            SendMessageA(h, WM_SETFONT, (WPARAM)win->font, TRUE);
766-            if (n->kind == (u32)DUI_NODE_PROGRESS) {
767-                SendMessageA(h, PBM_SETRANGE, 0, MAKELPARAM(0, 1000));
768-                SendMessageA(h, PBM_SETPOS, (WPARAM)0, 0);
769-            }
770-            n->native = (void*)h;
771-        }
772-    }
773-
774-    child = n->first_child;
775-    while (child) {
776-        win32_create_controls_for_tree(win, child_parent, child);
777-        child = child->next_sibling;
778-    }
779-}
780-
781-static u32 win32_count_native_controls(const dui_schema_node* n)
782-{
783-    u32 count;
784-    const dui_schema_node* child;
785-    if (!n) {
786-        return 0u;
787-    }
788-    count = 0u;
789-    if (n->native) {
790-        count += 1u;
791-    }
792-    child = n->first_child;
793-    while (child) {
794-        count += win32_count_native_controls(child);
795-        child = child->next_sibling;
796-    }
797-    return count;
798-}
799-
800-static void win32_splitter_divider_rect(const dui_schema_node* n,
801-                                        int* out_x,
802-                                        int* out_y,
803-                                        int* out_w,
804-                                        int* out_h)
805-{
--
943-                              flags);
944-        if (n->kind == (u32)DUI_NODE_SCROLL_PANEL) {
945-            win32_scrollpanel_update((HWND)n->native, n);
946-            child_origin_x = (int)n->x + (int)n->scroll_x;
947-            child_origin_y = (int)n->y + (int)n->scroll_y;
948-        }
949-    }
950-    child = n->first_child;
951-    while (child) {
952-        hdwp = win32_defer_layout_to_tree(hdwp, child, child_origin_x, child_origin_y);
953-        child = child->next_sibling;
954-    }
955-    return hdwp;
956-}
957-
958-static void win32_apply_layout_to_tree(dui_window* win, dui_schema_node* root)
959-{
960-    u32 count;
961-    HDWP hdwp;
962-    dui_win32_batch_state* batch;
963:    if (!win || !root || !win->hwnd) {
964-        return;
965-    }
966-    count = win32_count_native_controls(root);
967-    if (count == 0u) {
968-        return;
969-    }
970:    batch = win32_batch_find(win->hwnd);
971-    if (batch && batch->depth > 0u && batch->hdwp) {
972-        batch->hdwp = win32_defer_layout_to_tree(batch->hdwp, root, 0, 0);
973-        if (!batch->hdwp) {
974-            win32_apply_layout_to_tree_fallback(root, 0, 0);
975-        }
976-        return;
977-    }
978-    hdwp = BeginDeferWindowPos((int)count);
979-    if (!hdwp) {
980-        win32_apply_layout_to_tree_fallback(root, 0, 0);
981-        return;
982-    }
983-    hdwp = win32_defer_layout_to_tree(hdwp, root, 0, 0);
984-    if (hdwp) {
985-        (void)EndDeferWindowPos(hdwp);
986-    }
987-}
988-
989-static void win32_build_node_text(const dui_schema_node* n,
990-                                  const unsigned char* state,
991-                                  u32 state_len,
992-                                  char* out_text,
993-                                  u32 out_cap)
994-{
995-    u32 text_len;
996-    if (!out_text || out_cap == 0u) {
997-        return;
998-    }
999-    out_text[0] = '\0';
1000-    text_len = 0u;
1001-    if (n && n->bind_id != 0u && state) {
1002-        (void)dui_state_get_text(state, state_len, n->bind_id, out_text, out_cap, &text_len);
1003-    }
1004-    if ((!out_text[0]) && n && n->text) {
1005-        u32 i = 0u;
1006-        while (i + 1u < out_cap && n->text[i]) {
1007-            out_text[i] = n->text[i];
1008-            i += 1u;
1009-        }
1010-        out_text[i] = '\0';
--
1065-    count = (int)SendMessageA(h, LB_GETCOUNT, 0, 0);
1066-    if (count <= 0) {
1067-        return -1;
1068-    }
1069-    for (i = 0; i < count; ++i) {
1070-        u32 id = (u32)SendMessageA(h, LB_GETITEMDATA, (WPARAM)i, 0);
1071-        if (id == item_id) {
1072-            return i;
1073-        }
1074-    }
1075-    return -1;
1076-}
1077-
1078-static void win32_batch_set_visibility(const dui_window* win, HWND hwnd, int visible)
1079-{
1080-    dui_win32_batch_state* state;
1081-    UINT flags;
1082-    if (!win || !hwnd) {
1083-        return;
1084-    }
1085:    state = win32_batch_find(win->hwnd);
1086-    if (state && state->depth > 0u && state->hdwp) {
1087-        flags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE |
1088-                (visible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW);
1089-        state->hdwp = DeferWindowPos(state->hdwp, hwnd, NULL, 0, 0, 0, 0, flags);
1090-        if (!state->hdwp) {
1091-            ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);
1092-        }
1093-    } else {
1094-        ShowWindow(hwnd, visible ? SW_SHOW : SW_HIDE);
1095-    }
1096-}
1097-
1098-static void win32_update_control_values(dui_window* win,
1099-                                       dui_schema_node* n,
1100-                                       int parent_visible,
1101-                                       const unsigned char* prev_state,
1102-                                       u32 prev_state_len)
1103-{
1104-    dui_schema_node* child;
1105-    char text[256];
1106-    u32 text_len;
1107-    char prev_text[256];
1108-    int visible;
1109-    if (!win || !n) {
1110-        return;
1111-    }
1112-    visible = parent_visible && win32_node_visible(win, n);
1113-    if (n->native) {
1114-        HWND h = (HWND)n->native;
1115-        const int cur_vis = IsWindowVisible(h) ? 1 : 0;
1116-        const int cur_en = IsWindowEnabled(h) ? 1 : 0;
1117-        if (cur_vis != (visible ? 1 : 0)) {
1118-            win32_batch_set_visibility(win, h, visible);
1119-        }
1120-        if (cur_en != (visible ? 1 : 0)) {
1121-            EnableWindow(h, visible ? TRUE : FALSE);
1122-        }
1123-    }
1124-
1125-    if (!visible) {
--
1137-        u32 selected = n->tabs_selected;
1138-        u32 page_index = 0u;
1139-        int use_explicit_pages = 0;
1140-        int cur_sel;
1141-        u32 state_sel = 0u;
1142-        child = n->first_child;
1143-        while (child) {
1144-            if (child->kind == (u32)DUI_NODE_TAB_PAGE) {
1145-                use_explicit_pages = 1;
1146-                break;
1147-            }
1148-            child = child->next_sibling;
1149-        }
1150-        child = n->first_child;
1151-        while (child) {
1152-            if (!use_explicit_pages || child->kind == (u32)DUI_NODE_TAB_PAGE) {
1153-                page_count += 1u;
1154-            }
1155-            child = child->next_sibling;
1156-        }
1157:        if (n->bind_id != 0u && win->state) {
1158:            if (dui_state_get_u32(win->state, win->state_len, n->bind_id, &state_sel)) {
1159-                selected = state_sel;
1160-            }
1161-        }
1162-        if (page_count > 0u && selected >= page_count) {
1163-            selected = page_count - 1u;
1164-        }
1165-        n->tabs_selected = selected;
1166-        cur_sel = TabCtrl_GetCurSel((HWND)n->native);
1167-        if (page_count > 0u && cur_sel != (int)selected) {
1168-            (void)TabCtrl_SetCurSel((HWND)n->native, (int)selected);
1169-        }
1170-        child = n->first_child;
1171-        while (child) {
1172-            int is_page = (!use_explicit_pages || child->kind == (u32)DUI_NODE_TAB_PAGE) ? 1 : 0;
1173-            int child_visible = visible;
1174-            if (is_page) {
1175-                child_visible = (page_index == selected) ? 1 : 0;
1176-                page_index += 1u;
1177-            } else {
1178-                child_visible = 0;
1179-            }
1180-            win32_update_control_values(win, child, child_visible, prev_state, prev_state_len);
1181-            child = child->next_sibling;
1182-        }
1183-        return;
1184-    }
1185-
1186-    if (n->native && win32_is_leaf_kind(n->kind)) {
1187-        HWND h = (HWND)n->native;
1188-        if (n->kind == (u32)DUI_NODE_LABEL || n->kind == (u32)DUI_NODE_BUTTON) {
1189-            if (n->bind_id != 0u) {
1190:                win32_build_node_text(n, win->state, win->state_len, text, (u32)sizeof(text));
1191-                win32_build_node_text(n, prev_state, prev_state_len, prev_text, (u32)sizeof(prev_text));
1192-                if (strcmp(text, prev_text) != 0) {
1193-                    SetWindowTextA(h, text);
1194-                }
1195-            }
1196-        } else if (n->kind == (u32)DUI_NODE_CHECKBOX) {
1197-            u32 v = 0u;
1198:            if (n->bind_id != 0u && win->state) {
1199:                (void)dui_state_get_u32(win->state, win->state_len, n->bind_id, &v);
1200-            }
1201-            {
1202-                LRESULT st = SendMessageA(h, BM_GETCHECK, 0, 0);
1203-                const u32 cur = (st == BST_CHECKED) ? 1u : 0u;
1204-                if (cur != (v ? 1u : 0u)) {
1205-                    SendMessageA(h, BM_SETCHECK, (WPARAM)(v ? BST_CHECKED : BST_UNCHECKED), 0);
1206-                }
1207-            }
1208-        } else if (n->kind == (u32)DUI_NODE_TEXT_FIELD) {
1209-            text[0] = '\0';
1210-            text_len = 0u;
1211:            if (n->bind_id != 0u && win->state) {
1212:                (void)dui_state_get_text(win->state, win->state_len, n->bind_id, text, (u32)sizeof(text), &text_len);
1213-            }
1214-            {
1215-                char cur_text[256];
1216-                cur_text[0] = '\0';
1217-                GetWindowTextA(h, cur_text, (int)sizeof(cur_text));
1218-                if (strcmp(cur_text, text) != 0) {
1219-                    SetWindowTextA(h, text);
1220-                }
1221-            }
1222-        } else if (n->kind == (u32)DUI_NODE_PROGRESS) {
1223-            u32 v = 0u;
1224-            u32 prev_v = 0u;
1225:            if (n->bind_id != 0u && win->state) {
1226:                (void)dui_state_get_u32(win->state, win->state_len, n->bind_id, &v);
1227-            }
1228-            if (v > 1000u) v = 1000u;
1229-            if (n->bind_id != 0u && prev_state) {
1230-                (void)dui_state_get_u32(prev_state, prev_state_len, n->bind_id, &prev_v);
1231-                if (prev_v > 1000u) prev_v = 1000u;
1232-            }
1233-            if (!prev_state || prev_v != v) {
1234-                SendMessageA(h, PBM_SETPOS, (WPARAM)v, 0);
1235-            }
1236-        } else if (n->kind == (u32)DUI_NODE_LIST) {
1237-            u32 count = 0u;
1238-            u32 selected_id = 0u;
1239-            u32 prev_selected_id = 0u;
1240-            u32 i;
1241:            if (n->bind_id != 0u && win->state) {
1242:                (void)dui_state_get_list_item_count(win->state, win->state_len, n->bind_id, &count);
1243:                (void)dui_state_get_list_selected_item_id(win->state, win->state_len, n->bind_id, &selected_id);
1244-            }
1245-
1246-            if (n->bind_id != 0u && prev_state) {
1247-                (void)dui_state_get_list_selected_item_id(prev_state, prev_state_len, n->bind_id, &prev_selected_id);
1248-            }
1249-
1250-            if (!prev_state || !n->bind_id ||
1251:                !win32_list_items_equal(n->bind_id, prev_state, prev_state_len, win->state, win->state_len)) {
1252-                int top = (int)SendMessageA(h, LB_GETTOPINDEX, 0, 0);
1253-                int found_sel = -1;
1254-                dui_win32_begin_batch(h);
1255-                SendMessageA(h, LB_RESETCONTENT, 0, 0);
1256-                for (i = 0u; i < count; ++i) {
1257-                    u32 item_id = 0u;
1258-                    char item_text[256];
1259-                    u32 item_len = 0u;
1260-                    int idx;
1261-                    item_text[0] = '\0';
1262:                    if (!dui_state_get_list_item_at(win->state, win->state_len, n->bind_id, i, &item_id, item_text, (u32)sizeof(item_text), &item_len)) {
1263-                        continue;
1264-                    }
1265-                    idx = (int)SendMessageA(h, LB_ADDSTRING, 0, (LPARAM)item_text);
1266-                    if (idx >= 0) {
1267-                        SendMessageA(h, LB_SETITEMDATA, (WPARAM)idx, (LPARAM)item_id);
1268-                        if (item_id == selected_id) {
1269-                            found_sel = idx;
1270-                        }
1271-                    }
1272-                }
1273-                SendMessageA(h, LB_SETCURSEL, (WPARAM)found_sel, 0);
1274-                if (top >= 0 && (int)count > 0) {
1275-                    if (top >= (int)count) {
1276-                        top = (int)count - 1;
1277-                    }
1278-                    (void)SendMessageA(h, LB_SETTOPINDEX, (WPARAM)top, 0);
1279-                }
1280-                dui_win32_end_batch(h);
1281-            } else if (prev_selected_id != selected_id) {
1282-                int idx = -1;
1283-                if (selected_id != 0u) {
1284-                    idx = win32_list_find_index_by_item_id(h, selected_id);
1285-                }
1286-                SendMessageA(h, LB_SETCURSEL, (WPARAM)idx, 0);
1287-            }
1288-        }
1289-    }
1290-
1291-    child = n->first_child;
1292-    while (child) {
1293-        win32_update_control_values(win, child, visible, prev_state, prev_state_len);
1294-        child = child->next_sibling;
1295-    }
1296-}
1297-
1298-static void win32_relayout_with_size(dui_window* win, int width, int height, int use_size)
1299-{
1300-    RECT rc;
1301-    int w;
1302-    int h;
1303:    if (!win || !win->hwnd || !win->root) {
1304-        return;
1305-    }
1306-    if (!use_size) {
1307:        GetClientRect(win->hwnd, &rc);
1308-        w = (int)(rc.right - rc.left);
1309-        h = (int)(rc.bottom - rc.top);
1310-    } else {
1311-        w = width;
1312-        h = height;
1313-    }
1314-    if (w < 0) w = 0;
1315-    if (h < 0) h = 0;
1316-    win32_debug_inc_relayout();
1317:    dui_win32_begin_batch(win->hwnd);
1318:    dui_schema_layout(win->root, 0, 0, (i32)w, (i32)h);
1319:    win32_apply_layout_to_tree(win, win->root);
1320:    dui_win32_end_batch(win->hwnd);
1321-}
1322-
1323-static void win32_relayout(dui_window* win)
1324-{
1325-    win32_relayout_with_size(win, 0, 0, 0);
1326-}
1327-
1328-static void win32_schedule_relayout(dui_window* win, int width, int height)
1329-{
1330:    if (!win || !win->hwnd) {
1331-        return;
1332-    }
1333:    win->pending_w = width;
1334:    win->pending_h = height;
1335:    if (!win->relayout_pending) {
1336:        win->relayout_pending = 1;
1337:        PostMessageA(win->hwnd, DUI_WIN32_RELAYOUT_MSG, 0, 0);
1338-    }
1339-}
1340-
1341-static int win32_splitter_clamp_pos(const dui_schema_node* n, int axis_len, int pos)
1342-{
1343-    int thickness;
1344-    int avail_axis;
1345-    int min_a;
1346-    int min_b;
1347-
1348-    if (!n) {
1349-        return 0;
1350-    }
1351-    thickness = (int)n->splitter_thickness;
1352-    if (thickness < 1) {
1353-        thickness = 1;
1354-    }
1355-    avail_axis = axis_len - thickness;
1356-    if (avail_axis < 0) {
1357-        avail_axis = 0;
1358-    }
1359-    if (pos < 0) {
1360-        pos = avail_axis / 2;
1361-    }
1362-    min_a = (int)n->splitter_min_a;
1363-    min_b = (int)n->splitter_min_b;
1364-    if (min_a < 0) min_a = 0;
1365-    if (min_b < 0) min_b = 0;
1366-    if (pos < min_a) {
1367-        pos = min_a;
1368-    }
1369-    if (pos > (avail_axis - min_b)) {
1370-        pos = avail_axis - min_b;
1371-    }
1372-    if (pos < 0) {
1373-        pos = 0;
1374-    }
1375-    return pos;
1376-}
1377-
--
1393-            free(data);
1394-            data = (dui_splitter_data*)0;
1395-            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)0);
1396-        }
1397-        return 0;
1398-    }
1399-
1400-    if (!data || !data->win || !data->node) {
1401-        return DefWindowProcA(hwnd, msg, wparam, lparam);
1402-    }
1403-
1404-    if (msg == WM_LBUTTONDOWN) {
1405-        RECT rc;
1406-        POINT pt;
1407-        SetCapture(hwnd);
1408-        data->dragging = 1;
1409-        GetWindowRect(hwnd, &rc);
1410-        GetCursorPos(&pt);
1411-        {
1412-            POINT win_pt = { rc.left, rc.top };
1413:            ScreenToClient(data->win->hwnd, &win_pt);
1414:            ScreenToClient(data->win->hwnd, &pt);
1415-            if (data->node->splitter_orient == (u32)DUI_SPLIT_HORIZONTAL) {
1416-                data->drag_offset = pt.y - win_pt.y;
1417-            } else {
1418-                data->drag_offset = pt.x - win_pt.x;
1419-            }
1420-        }
1421-        return 0;
1422-    }
1423-
1424-    if (msg == WM_LBUTTONUP) {
1425-        data->dragging = 0;
1426-        ReleaseCapture();
1427-        return 0;
1428-    }
1429-
1430-    if (msg == WM_MOUSEMOVE && data->dragging) {
1431-        POINT pt;
1432-        int pos;
1433-        int axis_len = (data->node->splitter_orient == (u32)DUI_SPLIT_HORIZONTAL) ? (int)data->node->h : (int)data->node->w;
1434-        GetCursorPos(&pt);
1435:        ScreenToClient(data->win->hwnd, &pt);
1436-        if (data->node->splitter_orient == (u32)DUI_SPLIT_HORIZONTAL) {
1437-            pos = pt.y - (int)data->node->y - data->drag_offset;
1438-        } else {
1439-            pos = pt.x - (int)data->node->x - data->drag_offset;
1440-        }
1441-        pos = win32_splitter_clamp_pos(data->node, axis_len, pos);
1442-        data->node->splitter_pos = (u32)pos;
1443-        win32_relayout(data->win);
1444:        if (!data->win->suppress_events && data->node->bind_id != 0u) {
1445:            win32_emit_value_u32(data->win->ctx,
1446-                                 data->node->id,
1447-                                 data->node->action_id,
1448-                                 (u32)DUI_VALUE_U32,
1449-                                 (u32)pos,
1450-                                 0u,
1451-                                 hwnd);
1452-        }
1453-        return 0;
1454-    }
1455-
1456-    if (msg == WM_SETCURSOR) {
1457-        if (data->node->splitter_orient == (u32)DUI_SPLIT_HORIZONTAL) {
1458-            SetCursor(LoadCursor(NULL, IDC_SIZENS));
1459-        } else {
1460-            SetCursor(LoadCursor(NULL, IDC_SIZEWE));
1461-        }
1462-        return TRUE;
1463-    }
1464-
1465-    return DefWindowProcA(hwnd, msg, wparam, lparam);
1466-}
1467-
1468-static LRESULT CALLBACK win32_scrollpanel_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
1469-{
1470-    dui_scrollpanel_data* data = (dui_scrollpanel_data*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
1471-
1472-    if (msg == WM_CREATE) {
1473-        CREATESTRUCTA* cs = (CREATESTRUCTA*)lparam;
1474-        if (cs && cs->lpCreateParams) {
1475-            data = (dui_scrollpanel_data*)cs->lpCreateParams;
1476-            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)data);
1477-        }
1478-        return 0;
1479-    }
1480-
1481-    if (msg == WM_NCDESTROY) {
1482-        if (data) {
1483-            free(data);
1484-            data = (dui_scrollpanel_data*)0;
1485-            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)0);
--
1533-                win32_relayout(data->win);
1534-            }
1535-        }
1536-        return 0;
1537-    }
1538-
1539-    return DefWindowProcA(hwnd, msg, wparam, lparam);
1540-}
1541-
1542-static LRESULT CALLBACK dui_win32_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
1543-{
1544-    dui_window* win = DUI_GET_WND_PTR(hwnd);
1545-    dui_context* ctx = (dui_context*)0;
1546-
1547-    if (msg == WM_CREATE) {
1548-        CREATESTRUCTA* cs = (CREATESTRUCTA*)lparam;
1549-        if (cs && cs->lpCreateParams) {
1550-            win = (dui_window*)cs->lpCreateParams;
1551-            DUI_SET_WND_PTR(hwnd, win);
1552-            if (win) {
1553:                win->hwnd = hwnd;
1554-            }
1555-        }
1556-        return 0;
1557-    }
1558-
1559-    if (!win) {
1560-        return DefWindowProcA(hwnd, msg, wparam, lparam);
1561-    }
1562:    ctx = win->ctx;
1563-
1564-    if (msg == WM_PAINT) {
1565-        win32_debug_inc_paint();
1566-    } else if (msg == WM_ERASEBKGND) {
1567-        win32_debug_inc_erase();
1568-    }
1569-
1570-
1571-    if (msg == WM_COMMAND) {
1572-        const int ctrl_id = (int)LOWORD(wparam);
1573-        const int notify = (int)HIWORD(wparam);
1574-        HWND ctrl = (HWND)lparam;
1575-        dui_schema_node* n;
1576-
1577:        if (!ctx || !win->root || win->suppress_events) {
1578-            return 0;
1579-        }
1580:        n = dui_schema_find_by_id(win->root, (u32)ctrl_id);
1581-        if (!n || !ctrl) {
1582-            return 0;
1583-        }
1584-        if (n->kind == (u32)DUI_NODE_BUTTON) {
1585-            if (notify == BN_CLICKED) {
1586-                win32_emit_action_event(ctx, n->id, n->action_id, DOMUI_EVENT_CLICK, 0u, ctrl);
1587-            }
1588-            return 0;
1589-        }
1590-        if (n->kind == (u32)DUI_NODE_CHECKBOX) {
1591-            if (notify == BN_CLICKED) {
1592-                LRESULT st = SendMessageA(ctrl, BM_GETCHECK, 0, 0);
1593-                u32 v = (st == BST_CHECKED) ? 1u : 0u;
1594-                win32_emit_value_u32(ctx, n->id, n->action_id, (u32)DUI_VALUE_BOOL, v, 0u, ctrl);
1595-            }
1596-            return 0;
1597-        }
1598-        if (n->kind == (u32)DUI_NODE_TEXT_FIELD) {
1599-            if (notify == EN_CHANGE) {
1600-                char buf[256];
1601-                int len = GetWindowTextA(ctrl, buf, (int)sizeof(buf));
1602-                if (len < 0) {
1603-                    len = 0;
1604-                }
1605-                win32_emit_value_text(ctx, n->id, n->action_id, buf, (u32)len, ctrl);
1606-            }
1607-            return 0;
1608-        }
1609-        if (n->kind == (u32)DUI_NODE_LIST) {
1610-            if (notify == LBN_SELCHANGE || notify == LBN_DBLCLK) {
1611-                int sel = (int)SendMessageA(ctrl, LB_GETCURSEL, 0, 0);
1612-                u32 item_id = 0u;
1613-                if (sel >= 0) {
1614-                    item_id = (u32)SendMessageA(ctrl, LB_GETITEMDATA, (WPARAM)sel, 0);
1615-                }
1616-                if (notify == LBN_SELCHANGE) {
1617-                    win32_emit_value_u32(ctx, n->id, n->action_id, (u32)DUI_VALUE_LIST, (u32)((sel >= 0) ? sel : 0), item_id, ctrl);
1618-                } else if (notify == LBN_DBLCLK) {
1619-                    win32_emit_action_event(ctx, n->id, n->action_id, DOMUI_EVENT_SUBMIT, item_id, ctrl);
1620-                }
1621-            }
1622-            return 0;
1623-        }
1624-        return 0;
1625-    }
1626-
1627-    if (msg == WM_NOTIFY) {
1628-        NMHDR* hdr = (NMHDR*)lparam;
1629-        dui_schema_node* n;
1630:        if (!ctx || !win->root || win->suppress_events) {
1631-            return 0;
1632-        }
1633-        if (!hdr) {
1634-            return 0;
1635-        }
1636-        if (hdr->code == TCN_SELCHANGE) {
1637-            int sel = TabCtrl_GetCurSel(hdr->hwndFrom);
1638-            if (sel < 0) {
1639-                sel = 0;
1640-            }
1641:            n = dui_schema_find_by_id(win->root, (u32)hdr->idFrom);
1642-            if (!n || n->kind != (u32)DUI_NODE_TABS) {
1643-                return 0;
1644-            }
1645-            n->tabs_selected = (u32)sel;
1646:            if (!win->suppress_events) {
1647-                if (n->action_id != 0u) {
1648-                    win32_emit_action_event(ctx, n->id, n->action_id, DOMUI_EVENT_TAB_CHANGE, (u32)sel, hdr->hwndFrom);
1649-                }
1650-                win32_emit_value_u32(ctx, n->id, n->action_id, (u32)DUI_VALUE_U32, (u32)sel, 0u, hdr->hwndFrom);
1651-            }
1652-            {
1653-                u32 page_index = 0u;
1654-                int use_explicit_pages = 0;
1655-                dui_schema_node* child = n->first_child;
1656-                while (child) {
1657-                    if (child->kind == (u32)DUI_NODE_TAB_PAGE) {
1658-                        use_explicit_pages = 1;
1659-                        break;
1660-                    }
1661-                    child = child->next_sibling;
1662-                }
1663-                child = n->first_child;
1664:                dui_win32_begin_batch(win->hwnd);
1665-                while (child) {
1666-                    int is_page = (!use_explicit_pages || child->kind == (u32)DUI_NODE_TAB_PAGE) ? 1 : 0;
1667-                    int child_visible = 0;
1668-                    if (is_page) {
1669-                        child_visible = (page_index == (u32)sel) ? 1 : 0;
1670-                        page_index += 1u;
1671-                    }
1672:                    win32_update_control_values(win, child, child_visible, win->state, win->state_len);
1673-                    child = child->next_sibling;
1674-                }
1675:                dui_win32_end_batch(win->hwnd);
1676-            }
1677-            return 0;
1678-        }
1679-        return 0;
1680-    }
1681-
1682-    if (msg == DUI_WIN32_RELAYOUT_MSG) {
1683:        win->relayout_pending = 0;
1684:        win32_relayout_with_size(win, win->pending_w, win->pending_h, 1);
1685-        return 0;
1686-    }
1687-
1688-    if (msg == WM_SIZE) {
1689-        int w = (int)LOWORD(lparam);
1690-        int h = (int)HIWORD(lparam);
1691-        win32_schedule_relayout(win, w, h);
1692-        return 0;
1693-    }
1694-
1695-    if (msg == WM_CLOSE) {
1696-        /* Emit quit event; actual destruction is driven by caller via destroy_window. */
1697-        /* Post a WM_DESTROY to keep the message pump progressing. */
1698-        if (ctx) {
1699-            win32_emit_quit(ctx);
1700-        }
1701-        DestroyWindow(hwnd);
1702-        return 0;
1703-    }
1704-
1705-    if (msg == WM_DESTROY) {
1706-        PostQuitMessage(0);
1707-        return 0;
1708-    }
1709-
1710-    return DefWindowProcA(hwnd, msg, wparam, lparam);
1711-}
1712-
1713-static int win32_register_class(void)
1714-{
1715-    static int s_registered = 0;
1716-    WNDCLASSA wc;
1717-    if (s_registered) {
1718-        return 1;
1719-    }
1720-    memset(&wc, 0, sizeof(wc));
1721-    wc.lpfnWndProc = dui_win32_wndproc;
1722-    wc.hInstance = GetModuleHandleA(NULL);
1723-    wc.lpszClassName = dui_win32_class_name();
1724-    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
--
1801-    int h;
1802-    const char* title;
1803-    HWND parent_hwnd;
1804-    int is_child;
1805-    int win_x;
1806-    int win_y;
1807-    int win_w;
1808-    int win_h;
1809-#endif
1810-
1811-    if (!ctx || !out_win) {
1812-        return DUI_ERR_NULL;
1813-    }
1814-    *out_win = (dui_window*)0;
1815-
1816-    win = (dui_window*)malloc(sizeof(dui_window));
1817-    if (!win) {
1818-        return DUI_ERR;
1819-    }
1820-    memset(win, 0, sizeof(*win));
1821:    win->ctx = ctx;
1822-
1823-#if defined(_WIN32)
1824-    win32_init_common_controls();
1825-    if (!win32_register_class()) {
1826-        free(win);
1827-        return DUI_ERR_BACKEND_UNAVAILABLE;
1828-    }
1829-
1830-    title = (desc && desc->title) ? desc->title : "Dominium";
1831-    w = (desc) ? (int)desc->width : 800;
1832-    h = (desc) ? (int)desc->height : 600;
1833-    if (w <= 0) w = 800;
1834-    if (h <= 0) h = 600;
1835-    parent_hwnd = NULL;
1836-    is_child = 0;
1837-    if (desc && (desc->flags & DUI_WINDOW_FLAG_CHILD)) {
1838-        is_child = 1;
1839-        if (desc->struct_size >= (u32)sizeof(dui_window_desc_v1)) {
1840-            parent_hwnd = (HWND)desc->parent_hwnd;
1841-        }
1842-    }
1843-    if (is_child && parent_hwnd) {
1844-        style = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
1845-        win_x = 0;
1846-        win_y = 0;
1847-        win_w = w;
1848-        win_h = h;
1849-    } else {
1850-        style = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
1851-        rect.left = 0;
1852-        rect.top = 0;
1853-        rect.right = w;
1854-        rect.bottom = h;
1855-        AdjustWindowRect(&rect, style, FALSE);
1856-        win_x = CW_USEDEFAULT;
1857-        win_y = CW_USEDEFAULT;
1858-        win_w = rect.right - rect.left;
1859-        win_h = rect.bottom - rect.top;
1860-        parent_hwnd = NULL;
1861-        is_child = 0;
1862-    }
1863-
1864:    win->hwnd = CreateWindowExA(
1865-        0,
1866-        dui_win32_class_name(),
1867-        title,
1868-        style,
1869-        win_x,
1870-        win_y,
1871-        win_w,
1872-        win_h,
1873-        parent_hwnd,
1874-        NULL,
1875-        GetModuleHandleA(NULL),
1876-        win);
1877-
1878:    if (!win->hwnd) {
1879-        free(win);
1880-        return DUI_ERR_BACKEND_UNAVAILABLE;
1881-    }
1882:    ShowWindow(win->hwnd, SW_SHOW);
1883:    UpdateWindow(win->hwnd);
1884-
1885-    if (!is_child) {
1886-        ctx->primary_window = win;
1887-    }
1888-#else
1889-    (void)desc;
1890-    free(win);
1891-    return DUI_ERR_UNSUPPORTED;
1892-#endif
1893-
1894-    *out_win = win;
1895-    return DUI_OK;
1896-}
1897-
1898-static void win32_destroy_window(dui_window* win)
1899-{
1900-    if (!win) {
1901-        return;
1902-    }
1903-
1904-#if defined(_WIN32)
1905:    if (win->root) {
1906:        win32_destroy_child_controls(win->root);
1907-    }
1908:    if (win->hwnd) {
1909:        DestroyWindow(win->hwnd);
1910:        win->hwnd = (HWND)0;
1911-    }
1912-#endif
1913-
1914:    if (win->schema) {
1915:        free(win->schema);
1916:        win->schema = (unsigned char*)0;
1917:        win->schema_len = 0u;
1918-    }
1919:    if (win->state) {
1920:        free(win->state);
1921:        win->state = (unsigned char*)0;
1922:        win->state_len = 0u;
1923-    }
1924:    if (win->root) {
1925:        dui_schema_free(win->root);
1926:        win->root = (dui_schema_node*)0;
1927-    }
1928-    free(win);
1929-}
1930-
1931-static dui_result win32_set_schema_tlv(dui_window* win, const void* schema_tlv, u32 schema_len)
1932-{
1933-    unsigned char* copy;
1934-    dui_result perr;
1935-    if (!win || (!schema_tlv && schema_len != 0u)) {
1936-        return DUI_ERR_NULL;
1937-    }
1938-
1939-#if defined(_WIN32)
1940:    if (win->root) {
1941:        win32_destroy_child_controls(win->root);
1942-    }
1943-#endif
1944-
1945:    if (win->schema) {
1946:        free(win->schema);
1947:        win->schema = (unsigned char*)0;
1948:        win->schema_len = 0u;
1949-    }
1950:    if (win->root) {
1951:        dui_schema_free(win->root);
1952:        win->root = (dui_schema_node*)0;
1953-    }
1954-
1955-    if (!schema_tlv || schema_len == 0u) {
1956-        return DUI_OK;
1957-    }
1958-
1959-    copy = (unsigned char*)malloc((size_t)schema_len);
1960-    if (!copy) {
1961-        return DUI_ERR;
1962-    }
1963-    memcpy(copy, schema_tlv, (size_t)schema_len);
1964:    win->schema = copy;
1965:    win->schema_len = schema_len;
1966-
1967-    perr = DUI_OK;
1968:    win->root = dui_schema_parse_first_form_root(copy, schema_len, &perr);
1969:    if (!win->root) {
1970-        return perr;
1971-    }
1972-
1973-#if defined(_WIN32)
1974:    dui_win32_begin_batch(win->hwnd);
1975:    win32_create_controls_for_tree(win, win->hwnd, win->root);
1976-    win32_relayout(win);
1977:    win->suppress_events = 1u;
1978:    win32_update_control_values(win, win->root, 1, (const unsigned char*)0, 0u);
1979:    win->suppress_events = 0u;
1980:    dui_win32_end_batch(win->hwnd);
1981-#endif
1982-    return DUI_OK;
1983-}
1984-
1985-static dui_result win32_set_state_tlv(dui_window* win, const void* state_tlv, u32 state_len)
1986-{
1987-    unsigned char* copy;
1988-    unsigned char* prev_state;
1989-    u32 prev_state_len;
1990-    if (!win || (!state_tlv && state_len != 0u)) {
1991-        return DUI_ERR_NULL;
1992-    }
1993-
1994:    if (win->state && state_tlv && state_len == win->state_len && state_len != 0u) {
1995:        if (memcmp(win->state, state_tlv, (size_t)state_len) == 0) {
1996-            return DUI_OK;
1997-        }
1998-    }
1999-
2000:    prev_state = win->state;
2001:    prev_state_len = win->state_len;
2002:    win->state = (unsigned char*)0;
2003:    win->state_len = 0u;
2004-
2005-    if (!state_tlv || state_len == 0u) {
2006-        if (prev_state) {
2007-            free(prev_state);
2008-        }
2009-        return DUI_OK;
2010-    }
2011-    copy = (unsigned char*)malloc((size_t)state_len);
2012-    if (!copy) {
2013:        win->state = prev_state;
2014:        win->state_len = prev_state_len;
2015-        return DUI_ERR;
2016-    }
2017-    memcpy(copy, state_tlv, (size_t)state_len);
2018:    win->state = copy;
2019:    win->state_len = state_len;
2020-
2021-#if defined(_WIN32)
2022:    if (win->root) {
2023:        dui_win32_begin_batch(win->hwnd);
2024:        win->suppress_events = 1u;
2025:        win32_update_control_values(win, win->root, 1, prev_state, prev_state_len);
2026:        win->suppress_events = 0u;
2027:        dui_win32_end_batch(win->hwnd);
2028-    }
2029-#endif
2030-    if (prev_state) {
2031-        free(prev_state);
2032-    }
2033-    return DUI_OK;
2034-}
2035-
2036-static dui_result win32_render(dui_window* win)
2037-{
2038-    (void)win;
2039-    return DUI_OK;
2040-}
2041-
2042-static dui_result win32_pump(dui_context* ctx)
2043-{
2044-#if defined(_WIN32)
2045-    MSG msg;
2046-#endif
2047-    if (!ctx) {
2048-        return DUI_ERR_NULL;
2049-    }
2050-
2051-    if (ctx->quit_requested) {
2052-        if (ctx->primary_window && ctx->primary_window->hwnd) {
2053-#if defined(_WIN32)
2054-            PostMessageA(ctx->primary_window->hwnd, WM_CLOSE, 0, 0);
2055-#endif
2056-        } else {
2057-            win32_emit_quit(ctx);
2058-        }
2059-        ctx->quit_requested = 0u;
2060-    }
2061-
2062-#if defined(_WIN32)
2063-    while (PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE)) {
2064-        if (msg.message == WM_QUIT) {
2065-            win32_emit_quit(ctx);
2066-            break;
2067-        }
