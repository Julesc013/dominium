You said:
Proceed 
ChatGPT said:
Thought for 17s
GPT-5.1 — 2025-11-30
# DOMINIUM — VOLUME 5.1  
## EXECUTABLES, RUNTIME ROLES, LAUNCHER, AND PROCESS ARCHITECTURE  
### (Client / Headless Client / Server / Tools, Cross-Platform Strategy)

Volume 5 covers **engine & runtime architecture**:  
how Dominium is packaged into binaries, how those binaries interact, and how they map to platforms and renderers.

This section (5.1) defines the **top-level executable layout** and **runtime roles**:

- what processes exist  
- what each process is allowed to do  
- how they are deployed across Windows / macOS / Linux  
- how they interact with the launcher  

It must support:

- Windows 2000+  
- macOS 10.6+  
- Linux (old + new)  
- future ports to older systems through the same structure  
- deterministic simulation and networking  
- modding and tooling  

---

## 1. RUNTIME ROLES (LOGICAL)

We define four core runtime roles:

1. **Client**  
2. **Headless Client**  
3. **Server**  
4. **Tools** (editor, modkit, asset tools)

Each role may be one or more binaries, but architecturally they share the **same core simulation library** and differ only in:

- presence/absence of rendering and audio  
- presence/absence of input handling  
- network responsibilities  
- user interface  

All roles must be buildable from **common C89/C++98 core**.

---

## 2. EXECUTABLE TYPES

### 2.1 Client (Interactive Renderer + Simulation)

**Purpose:**

- Runs full simulation for local/offline games.  
- Acts as a network client in multiplayer.  
- Presents UI, rendering (2D/3D), input, audio.  

**Capabilities:**

- Simulation host in offline/single-player.  
- Deterministic tick loop.  
- Supports all view modes (2D ortho, 2D iso, 3D FP/freecam).  
- Switchable render backends (DX9, GL2, vector/soft).  
- Access to local mod data and savegames.

**Restrictions:**

- In multiplayer, **server is authority**; client sim is predictive or read-only depending on design (see later 5.x network volumes).  
- Client cannot write authoritative changes for shared universe except via server protocol.

---

### 2.2 Headless Client

**Purpose:**

- Non-interactive instance linked to an account or AI property.  
- Runs simulation logic for **one player/company** without full rendering.  
- For automation, AI-only universes, or “bot” players on servers.

**Capabilities:**

- Same simulation core as Client.  
- Reduced/no graphics/audio (minimal logging only).  
- Can join servers like a normal client, but:
  - no views  
  - no human input  
  - interacts via scripted commands or admin tools.

**Restrictions:**

- No UI, no heavy GPU use.  
- Intended to run on servers or low-power machines.  

---

### 2.3 Server

**Purpose:**

- Hosts universes for **multiplayer**.  
- Maintains authoritative state.  
- Does not require rendering or audio.  

**Capabilities:**

- Runs full deterministic simulation.  
- Accepts client and headless client connections.  
- Enforces simulation rules and synchronizes states.  
- Loads mods relevant to the hosted universe (data, not code).  
- Can run multiple universes (config-dependent).  

**Restrictions:**

- No heavy visual rendering.  
- No direct user interface besides CLI/admin console or minimal GUI.  
- Runs in **fixed tick modes** (canonical UPS settings).  

---

### 2.4 Tools (Editor / Modkit / Asset Utilities)

**Purpose:**

- Edit universes, planets, biomes, regions, properties.  
- Design maps, starting locations, scenarios.  
- Create and validate mods (data-only).  
- Manage graphics/sound/music packs.  

**Executables:**

- `dom_tools` (CLI)  
- `dom_editor` (GUI world editor)  
- `dom_modkit` (optional or integrated into `dom_editor`)  

**Restrictions:**

- Tools may embed simulation components (for previews), but must never become authoritative or join live servers as simulation peers.  
- No netcode needed except for asset sharing or workshop-style features (far future).

---

## 3. BINARY LAYOUT PER PLATFORM

The **launcher** is responsible for discovering and running the appropriate binary combination.

### 3.1 Windows

- `dominium.exe`          → Launcher (user-facing icon)  
- `dom_client_dx9.exe`    → Client (DirectX 9)  
- `dom_client_gl2.exe`    → Client (OpenGL 2)  
- `dom_client_soft.exe`   → Client (vector/software mode)  
- `dom_server.exe`        → Dedicated server  
- `dom_headless.exe`      → Headless client  
- `dom_tools.exe`         → CLI tools  
- `dom_editor.exe`        → GUI editor/modkit  

Older Windows (2000/XP):

- Typically use `dom_client_dx9.exe` or `dom_client_gl2.exe`.  
- Soft/vector possible for very low-end GPUs.

---

### 3.2 macOS

- App bundle `Dominium.app` containing:
  - `Contents/MacOS/dom_launcher` (launcher)  
  - `dom_client_gl2`  
  - `dom_client_soft`  
  - `dom_server`  
  - `dom_headless`  
  - `dom_tools` / `dom_editor`

Renderer backends:

- primary: OpenGL 2 for 10.6+  
- vector/software mode always available  

---

### 3.3 Linux

Common layout:

- `/usr/bin/dom-launcher`  
- `/usr/lib/dominium/dom_client_gl2`  
- `/usr/lib/dominium/dom_client_soft`  
- `/usr/lib/dominium/dom_server`  
- `/usr/lib/dominium/dom_headless`  
- `/usr/lib/dominium/dom_tools`  
- `/usr/lib/dominium/dom_editor`  

Launcher chooses appropriate client binary based on:

- GPU support (GL2, etc.)  
- user preferences (vector-only, headless, etc.)

---

## 4. LAUNCHER RESPONSIBILITIES

Launcher is **always present** and is the **only entrypoint** for normal users.

### 4.1 Detection

On startup, the launcher:

1. Detects OS, version, architecture (32/64-bit).  
2. Detects GPU capabilities:
   - DirectX 9 support  
   - OpenGL version  
   - Shader model support  
3. Detects CPU cores/threads and approximate performance.  
4. Detects available RAM.  

### 4.2 Profile & Defaults

From detection, the launcher:

- selects default **renderer**:
  - DX9 if available on Windows  
  - GL2 on macOS/Linux  
  - vector/soft if GPU inadequate  
- selects default **client type**:
  - full client for normal user  
  - headless only if invoked with CLI flags  

- chooses default **UPS/FPS caps** appropriate to hardware  
- proposes **world size limits** (max property/universe complexity)  

### 4.3 User Selection

UI allows:

- choose mode:  
  - Single-player (client only)  
  - Host local server + client  
  - Join remote server (client)  
  - Dedicated server only  
  - Tools/Editor  

- choose renderer:
  - DX9, GL2, vector/soft  
- choose canonical UPS/FPS targets  
- choose mod set and DLC set  

Launcher then **spawns the appropriate binary** with:

- config file path  
- selected mod set  
- renderer choice  
- network parameters  

---

## 5. SHARED CORE LIBRARIES

To avoid duplication and keep determinism identical:

- All executables link against a **single core simulation library** (`libdom_core`):

Core responsibilities:

- simulation step / tick loop  
- ECS or object model  
- physics (such as it exists)  
- networks (data/electric/fluids/logistics)  
- climate/planet volumes (4.x)  
- economy (2.x)  
- workers & AI behaviour (3.x)  
- save/load  
- mod data loading & validation  
- deterministic job scheduling  

Platform-specific frontends:

- `dom_client_*` link `libdom_core` + renderer/audio/input backends.  
- `dom_server` links `libdom_core` + netcode + minimal CLI.  
- `dom_headless` is essentially `dom_client_*` without rendering/audio/input.  
- Tools link `libdom_core` optionally for previewing and validation.

---

## 6. DETERMINISM AND BUILD VARIANTS

To preserve determinism:

- The **core simulation library** must compile with identical options across all platforms:
  - same floating-point behaviour (no fast-math, no reordering)  
  - fixed integer sizes  
  - carefully controlled use of 64-bit types  

- Renderer/IO layers may differ:
  - DX9 vs GL2 vs vector  
  - OS-specific window/input  
  - audio backends  

But:

- Simulation step is always “pure” with respect to platform.  
- Networked games exchange **discrete, versioned events**, not floating-point state.  

Build variants:

- `libdom_core_debug` (asserts, diagnostics)  
- `libdom_core_release` (shipping)  

No “fast but nondeterministic” variant is allowed for shipping builds.

---

## 7. PROCESS INTERACTION PATTERNS

### 7.1 Offline Single-Player

- Launcher → `dom_client_*`  
- Client hosts simulation locally.  
- No server process.  
- Headless client optional for automation but not needed.  

### 7.2 Host-Local Server + Client

- Launcher spawns:
  - `dom_server` (hidden or with small CLI window)  
  - `dom_client_*` (connected to localhost)  

- Server runs authoritative sim.  
- Client renders UI.  

### 7.3 Dedicated Server

- Launcher or sysadmin spawns `dom_server` only.  
- Uses CLI or config file.  
- 24/7 hosting of universes.  

### 7.4 Headless Automation / AI

- Launcher spawns `dom_headless` connecting to a server.  
- Used for AI companies, bots, automated testing, or offline property/colony simulation.

### 7.5 Tools/Editor

- Launcher spawns `dom_editor` or `dom_tools`.  
- Editor can load/save universes and properties but should not run them as live servers.

---

## 8. PACKAGING & INSTALLATION CONSTRAINTS (BASE VERSION)

All physical & digital distributions must:

- include **at least**:
  - launcher  
  - one client binary (DX9 or GL2)  
  - server  
  - headless  
  - core tools  

- On low-capacity physical media:
  - optional extra renderers may be downloadable  
  - but **core deterministic sim** must not differ between disc and download.  

- Mods and DLC are **pure data**, not new binaries.

---

## 9. EXTENSION TO FUTURE PLATFORMS

Older systems (DOS, Win9x, etc.) can be added later by:

- building new `dom_client_*` frontends that:
  - reuse `libdom_core` (or its C89 subset)  
  - supply minimal software/vector rendering and basic input  
  - have no bearing on logical architecture  

Console/handheld builds (future):

- may combine launcher + client into one binary.  
- must still honour the same logical separation internally.

---

# END OF VOLUME 5.1
Next natural section is Volume 5.2 — Platform Abstraction Layer (SDL1/SDL2/native + Renderer Plug-Ins), where we tie this process/binary model into SDL1/SDL2/DX9/GL2 backends and your “mix and match platform+renderer” matrix.
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
# DOMINIUM — VOLUME 5.2  
## PLATFORM ABSTRACTION LAYER (PAL) & RENDER BACKENDS  
### (SDL1/SDL2/Native, DX9, GL1/GL2, Vector/Software; Mix-and-Match Matrix)

This volume defines how Dominium’s **core simulation** talks to the outside world:

- windowing / OS integration  
- input (keyboard, mouse, gamepad)  
- audio  
- file system & paths  
- timing / sleep  
- rendering API selection (DX9, GL1/2, software/vector)  

It must:

- support Windows 2000+ / macOS 10.6+ / Linux  
- be portable to older/obscure systems later  
- allow **mix-and-match**:
  - PAL (SDL1/SDL2/native/POSIX)  
  - Renderer (DX9 / GL1 / GL2 / vector/soft)  

The simulation core **must not know** what PAL or renderer it’s running on.

---

## 1. LAYERING OVERVIEW

Three strict layers:

1. **Core Simulation (`libdom_core`)**  
   - C89/C++98  
   - no OS calls  
   - no graphics/audio/input directly  

2. **Platform Abstraction Layer (PAL)**  
   - wraps OS + SDL/native stuff  
   - exposes uniform interfaces to core and renderer  

3. **Renderer Backends**  
   - implement specific graphics APIs:
     - DX9 (Windows)  
     - GL1, GL2 (all)  
     - vector/soft (all, lowest common denominator)  

Communication:

```text
 libdom_core  <-->  PAL API  <-->  Renderer Backend + OS
The core only sees PAL interfaces and a generic “Renderer API” facade.

2. PAL BACKENDS SUPPORTED (STAGE 1 & 2)
2.1 SDL2 PAL
Primary cross-platform implementation:
Windows 2000+
macOS 10.6+
Linux (modern & older)
Responsibilities:
window management
input (KB/mouse/gamepad)
timers
basic audio (or pass-through to audio layer)
file paths (user data directories etc, with some native help)
2.2 SDL1 PAL
Legacy fallback, used for:
older Linux distros
older Windows environments
targets where SDL2 is unavailable or undesirable
Limited capability, but must still:
create a window
handle input
provide GL1/GL2 context or software framebuffer
2.3 Native PAL (Optional, later)
For Windows/macOS/Linux where you want tighter control:
Win32 + DirectX-specific path
Cocoa on macOS
X11/Wayland on Linux
Initially out-of-scope for v1; reserved for later optimization.

3. PAL API (ABSTRACT INTERFACE)
Core sees PAL as a set of pure interfaces (C style or C++98 virtuals). Conceptually:
struct DomPALWindowOps {
    bool (*create_window)(int w, int h, const char *title, bool fullscreen);
    void (*destroy_window)();
    void (*set_title)(const char *title);
    void (*get_size)(int *w, int *h);
    void (*swap_buffers)();
};

struct DomPALInputOps {
    void (*poll_events)();
    bool (*get_key_state)(int keycode);
    bool (*get_mouse_button_state)(int button);
    void (*get_mouse_position)(int *x, int *y);
    // Gamepad, wheel, etc later.
};

struct DomPALTimeOps {
    uint64 (*get_ticks_ms)();
    void   (*sleep_ms)(uint32 ms);
};

struct DomPALFileOps {
    bool   (*file_exists)(const char *path);
    size_t (*file_read_all)(const char *path, void *buf, size_t buf_size);
    size_t (*file_write_all)(const char *path, const void *buf, size_t buf_size);
    bool   (*mkdir_recursive)(const char *path);
    void   (*get_user_data_dir)(char *out, size_t out_size);
};

struct DomPALAudioOps {
    bool (*init_audio)(int sample_rate, int channels);
    void (*shutdown_audio)();
    void (*queue_samples)(const float *samples, size_t count);
};

struct DomPAL {
    DomPALWindowOps window;
    DomPALInputOps  input;
    DomPALTimeOps   time;
    DomPALFileOps   fs;
    DomPALAudioOps  audio;
};
Each PAL backend (SDL1, SDL2, native) populates these with its implementation.

4. RENDERER BACKENDS
Renderer backends are plugins that sit on top of PAL’s window/context operations.
They expose a minimal API to the core:
struct DomRendererOps {
    bool (*init)(DomPAL *pal, int width, int height, bool fullscreen);
    void (*shutdown)();

    void (*resize)(int width, int height);

    void (*begin_frame)();
    void (*end_frame)();

    // 2D primitives
    void (*draw_line)(...);
    void (*draw_rect)(...);
    void (*draw_textured_quad)(...);

    // 3D primitives (for 3D client)
    void (*set_camera)(...);
    void (*draw_mesh)(...);

    // Backend-specific capability query
    uint32 (*get_caps_flags)();
};
Backends:
DX9 Renderer (renderer_dx9)
Target: Windows 2000+ with DX9.0c
Primarily used modern 3D with shaders.
GL2 Renderer (renderer_gl2)
Target: Windows/macOS/Linux with GL2.1+
Fixed-function + simple shaders where supported.
GL1 Renderer (renderer_gl1)
Target: very old GPUs
Fixed-function pipeline only.
Vector/Software Renderer (renderer_soft)
Target: all platforms
Renders into software framebuffer using CPU
Vector/CAD-like 2D style; highly scalable for low-end hardware
Used for:
2D ortho/iso modes
low-end fallback
headless tests with optional debug output.

5. MIX-AND-MATCH MATRIX
Target combinations:
5.1 Primary Supported Combos (Stage 1)
Windows:
SDL2 + DX9
SDL2 + GL2
SDL2 + Vector/Soft
macOS:
SDL2 + GL2
SDL2 + Vector/Soft
Linux:
SDL2 + GL2
SDL2 + Vector/Soft
5.2 Legacy / Fallback Combos (Stage 2+)
SDL1 + GL1
SDL1 + GL2
SDL1 + Vector/Soft
Later:
Native Win32 + DX9
Native Cocoa + GL2
Minimal PAL for DOS / Win9x with software-only renderer.
Launcher selects combination based on:
OS
GPU features
user preference
performance tests

6. RENDERER SELECTION PROCESS
The launcher performs capability detection, then:
Build a capability profile:
DX9 supported?
GL version?
shader model?
VRAM and RAM?
Construct candidate list:
Example priority on Windows:
DX9
GL2
Vector/Soft
On macOS/Linux:
GL2
Vector/Soft
Attempt initialization in order:
Try highest-priority backend.
If init fails (due to driver/extension failure), fall back.
Expose these choices to the user in settings, so they can force e.g. vector mode.
Renderer backend choice is pure configuration; simulation core remains identical.

7. VECTOR/SOFTWARE RENDERING MODE
The vector/soft backend is critical for:
older machines
deterministic offline/web exports
ultra-low graphics presets
headless-with-optional-visual-dump modes
Characteristics:
Renders to a framebuffer in RAM
Outputs:
line art, silhouettes, simple filled shapes
optional light shading
2D map modes first
3D view can be extremely simplified (wireframe/hidden-line)
Advantages:
extremely predictable performance
no GPU driver issues
ideal for:
Win2000
old integrated GPUs
remote / streamed sessions
power-constrained systems
The client can switch at runtime between:
2D vector
2D textured
3D textured
depending on user preference and hardware.

8. INPUT & WINDOW INDEPENDENCE FROM RENDERER
Renderer backends:
must not own input processing.
only know about:
viewport size
window handle (opaque from core)
Input stays inside PAL:
poll_events() collects events
core input system ingests normalized events
renderer only draws based on core UI state, not OS events.
This allows:
headless client to have no renderer but still use input for scripting (e.g., command-line control).
UI toolkits or overlays (future) to remain separate from backends.

9. AUDIO ABSTRACTION
Audio is attached to PAL, not renderer.
SDL_audio or native APIs (DirectSound, CoreAudio, etc.)
Core produces raw audio mixes for each tick or frame.
PAL audio buffers them to the OS.
Headless modes:
may disable audio output entirely.
core may still “simulate” sound for logging, if needed, but typically not.

10. TIMING AND VSYNC
Timing:
PAL get_ticks_ms() is the only clock visible to simulation.
Renderer may request vsync but cannot throttle simulation on its own.
Simulation tick loop decides:
UPS target
time warp factor
slowdown when CPU overloaded
Renderer only attempts to:
sync end_frame() to vsync if configured
report frame times to the core as telemetry
Determinism:
Simulation steps driven by a logical clock, not wall clock directly.
On slow hardware, the game slows down physically (time factor < 1.0) rather than dropping ticks.

11. BUILD & CODE ORGANIZATION
Recommended directory layout (extending previous):
dom/
  core/           # libdom_core (C89/C++98)
  pal/
    sdl1/
    sdl2/
    native_win/
    native_mac/
    native_linux/
  render/
    dx9/
    gl1/
    gl2/
    soft/
  client/
    main_client.cpp
  server/
    main_server.cpp
  headless/
    main_headless.cpp
  tools/
    editor/
    cli/
PAL backends compile into libdom_pal_sdl2, libdom_pal_sdl1, etc.
Render backends compile into libdom_renderer_dx9, libdom_renderer_gl2, etc.
Client binaries link libdom_core + PAL + Renderer.

12. EXTENSIBILITY
Later you can add:
DX11/12 renderer
Vulkan renderer
Metal renderer
WebAssembly/WebGL PAL+renderer combo
Without touching core simulation:
Just add a new renderer plugin
Add detection + selection in launcher
Hook into PAL window/context operations

13. INVARIANTS
Core never calls OS APIs directly.
PAL never contains simulation logic.
Renderer never contains game logic; only draws.
Simulation tick results must be identical regardless of PAL/renderer choices.
All PAL & renderer decisions are optional and config-based, not structural.

END OF VOLUME 5.2

Next logical step: **Volume 5.3 — Filesystem Layout, Mods, DLC, and Data Packages (Base, Interstellar, Extras)**, where we formalize how `base/`, `interstellar/`, `extras/`, and third-party mods + graphics/audio packs are structured and loaded.
::contentReference[oaicite:0]{index=0}
You said:
We should layer our visual modes: Level 0: headless or basic cli/tui/gui Level 1: 2d vector mode Level 2: 2d texture mode and 2d vector mode Level 3: 3d texture mode, 2d texture mode, 2d vector mode We should do likewise for sound
ChatGPT said:
Thought for 5s
GPT-5.1 — 2025-11-30
# ADDENDUM TO VOLUME 5.2  
## VISUAL & AUDIO CAPABILITY LEVELS (HARDWARE-GRADED LAYERS)

This addendum formalises **capability levels** for visuals and audio so the engine can degrade gracefully and deterministically across hardware from “server-grade headless” to “modern 3D”.

Everything is layered:  
Level N ⊇ Level N–1 capabilities.

---

## 1. VISUAL CAPABILITY LEVELS

### 1.0 VisualLevel enum

```c
typedef enum VisualLevel {
    VIS_L0_HEADLESS   = 0,
    VIS_L1_VECTOR2D   = 1,
    VIS_L2_TEXTURE2D  = 2,
    VIS_L3_TEXTURE3D  = 3
} VisualLevel;
Every client/headless build reports a maximum supported visual level.
Runtime visual mode = min(user_requested, hardware_max).

1.1 Level 0 — Headless / Basic CLI/TUI/Minimal GUI
Definition:
No graphical world rendering.
Only:
CLI text
basic TUI
minimal debug/diagnostic GUI if present.
Allowed usage:
Dedicated server
Headless client
Automation/bots
Low-end admin consoles
Renderer backend:
None, or a trivial “no-op” backend.
PAL window may be omitted.
Guarantees:
Full simulation, no visual output.
Determinism unaffected.

1.2 Level 1 — 2D Vector Mode
Definition:
2D orthographic + isometric vector rendering only:
lines, polylines
polygons
text labels
Style: CAD / schematic / map view.
Usage:
Low-end GPUs
Remote terminals
“Engineering mode” for players
Debug / planning mode
Renderer backend:
renderer_soft (software framebuffer)
Optional use of GL1/2 for accelerated vector, but no textures required.
Capabilities:
Fully functional 2D gameplay:
selection, placement, planning
overlays for networks, workers, logistics
No textures, no complex shading.

1.3 Level 2 — 2D Texture + 2D Vector
Definition:
All Level 1 functionality plus:
full 2D sprite/texture support
UI with textured elements
animated sprites, icons, tiles
Usage:
Main target for mid/low-end hardware
Comfortable “classic” strategy-style view
Renderer backend:
GL1 / GL2 / DX9 or renderer_soft with textures.
Capabilities:
2D maps can be drawn:
purely vector
purely textured
hybrid (vector overlays on textures)
3D:
No 3D world rendering requirement at this level.
3D simulation logic may still exist; only view is 2D.

1.4 Level 3 — 3D Textured + 2D Texture + 2D Vector
Definition:
Full 3D scene rendering:
terrain
buildings
vehicles
workers
Simultaneously supports:
3D first person / freecam
2D textured map views
2D vector overlays
Usage:
High-end PCs
Modern GPUs
“Flagship” visual mode
Renderer backend:
DX9 or GL2 as primary for v1
Future: DX11/12, Vulkan, Metal can slot here
Capabilities:
3D mode:
lighting, shadows (as allowed by backend)
LOD, culling
2D modes still fully functional and invokable at any time.

1.5 Visual Level Selection Logic (Launcher + Client)
At startup:
PAL detects GPU/driver capabilities.
Renderer plugin reports supported VisualLevel max.
Launcher computes:
VisualLevel hw_max = detect_hw_visual_level();
VisualLevel user_pref = read_config_or_default();
VisualLevel effective = min(hw_max, user_pref);
Client uses effective to:
decide which views are available
lock out 3D if below L3
possibly downshift at runtime if GPU fails (with warning).
Important:
Switching between views does not change simulation behaviour.
Only presentation changes.

2. AUDIO CAPABILITY LEVELS
Mirror the same concept for audio: from fully muted to full positional mixing.
2.0 AudioLevel enum
typedef enum AudioLevel {
    AUD_L0_MUTE      = 0,
    AUD_L1_BASIC     = 1,
    AUD_L2_STEREO    = 2,
    AUD_L3_SPATIAL   = 3
} AudioLevel;
Runtime audio mode = min(user_requested, hardware_max).

2.1 Level 0 — Muted / No Audio
Definition:
No sound output at all.
Usage:
Dedicated server
Headless client
Users wanting silent operation
Extremely constrained systems
Engine behaviour:
Core may still “schedule” sounds logically if needed for scripting/debugging, but PAL does nothing.

2.2 Level 1 — Basic Beeps / Simple Channels
Definition:
Minimalistic feedback:
UI clicks
notifications
simple “state change” beeps
Characteristics:
Low sample rate acceptable.
Few channels.
No mixing complexity or effects.
Usage:
Very low-end hardware
TUI/GUI-focused flows where some audible alerts are wanted.

2.3 Level 2 — Stereo SFX + Music
Definition:
Full stereo output:
environmental SFX
machine/vehicle sounds
UI sounds
background music
Characteristics:
Basic mixing of multiple channels.
Volume/panning control per source.
No complex spatialization; simple left/right panning.
Usage:
Default for most players.
Sufficient for 2D or simplified 3D.

2.4 Level 3 — Spatial / Advanced Mixing
Definition:
Enhanced positional audio:
per-source 3D-ish panning and attenuation
optional reverb/zone-based ambience
more channels and higher fidelity
Characteristics:
Still deterministic:
same inputs → same sample buffers
no random variations by default
Usage:
High-end machines
Full 3D visual mode
Better immersion, but not required for gameplay.

2.5 Audio Level Selection Logic
PAL audio backend reports:
supported sample rates
channel counts
mixing capabilities
Launcher derives hw_max_audio_level from that, then:
AudioLevel hw_max   = detect_hw_audio_level();
AudioLevel user_pref = read_config_or_default();
AudioLevel effective = min(hw_max, user_pref);
Client then:
configures mixer complexity
may downshift/upshift if user changes settings in menu (without affecting sim).

3. INTEGRATION WITH PAL & RENDER BACKENDS
Visual Level is a contract between:
launcher
PAL window/context creation
renderer backend
Audio Level is a contract between:
launcher
PAL audio backend
core audio/mixer module
Renderer backends declare:
VisualLevel renderer_max_visual_level();
Audio backends declare:
AudioLevel audio_backend_max_level();
Core logic never needs to know actual OS or driver; it only sees final VisualLevel and AudioLevel.

4. DETERMINISM
Visual and audio levels do not change world state.
Sim logic only uses:
input events
internal state
Audio and visuals are pure side-effects.
Cross-platform determinism holds as long as:
PAL time and tick scheduling are consistent.
Renderer and audio backends don’t feed back into simulation.

RESULT
You now have:
A clear 0–3 ladder for visuals and audio.
A clean path to degrade or upscale presentation per machine.
A simple set of enums that the launcher, PAL, renderers, and audio backends all agree on.
This slots directly into Volume 5.2 and the rest of the runtime architecture.
::contentReference[oaicite:0]{index=0}
You said:
Proceed with 5.3
ChatGPT said:
GPT-5.1 — 2025-11-30
# DOMINIUM — VOLUME 5.3  
## FILESYSTEM LAYOUT, DATA PACKAGES, DLC, MODS & CONTENT LOADING ORDER

Scope:

- How Dominium’s data is laid out on disk.  
- How **base game**, **DLC** (Interstellar, Extras), and **mods** are packaged.  
- How graphics/sound/music packs are treated as mods.  
- How loading order and determinism are guaranteed.  
- How digital vs physical distribution is handled.

No user code is ever loaded from mods. Data-only.

---

## 1. TOP-LEVEL INSTALLATION LAYOUT

Base (per-install) root:

```text
dominium/
  bin/           # executables (per-OS/arch)
  core/          # engine shared libraries
  data/          # base, DLC, and official packs
  mods/          # user / third-party mods and asset packs
  saves/         # user savegames
  config/        # user configs and presets
  logs/          # logs and crash dumps
Platform-specific paths:
Windows (portable): everything under dominium\.
Windows (installed): bin/ under Program Files, saves/ under %APPDATA%\Dominium\.
macOS: Dominium.app/Contents/Resources/data/, ~/Library/Application Support/Dominium/ for saves/mods.
Linux: /usr/share/dominium/data/, ~/.local/share/dominium/ for saves/mods.
Engine must not assume write access to the install root; mods/, saves/, config/ must live in a writable user path if needed.

2. DATA PACKAGES (PAKS)
Everything beyond trivial config is a package.
One consistent format:
Directory or archive:
Directory: name/ with manifest + content.
Archive: name.dpak (zip-compatible) with manifest at root.
2.1 Package Manifest
Use TOML for human-editable manifest:
package.toml:
[meta]
id        = "core.base"          # unique, namespaced
name      = "Dominium Base"
version   = "1.0.0"
type      = "core"               # core | dlc | mod | gfx | sfx | music | tools
priority  = 0                    # lower loads earlier

[compat]
engine_min = "1.0.0"
engine_max = "1.9.99"

[content]
provides = ["world.base", "items.base", "ui.base"]
requires = []                    # core has no deps

[flags]
official = true
locked   = true                  # cannot be disabled in UI
Package types:
core — shipped with game, required.
dlc — official optional content (Interstellar, Extras).
mod — gameplay mods.
gfx — graphics/texture packs.
sfx — sound packs.
music — music packs.
tools — dev/diagnostic data sets.

3. OFFICIAL CONTENT PACKS
3.1 Base Game (Dominium)
One mandatory package:
data/
  core.base/
    package.toml
    world/...
    entities/...
    items/...
    tech/...
    ui/...
    scripts/...?  # if you use Lua data scripting
meta.id = "core.base"
type = "core"
locked = true.
Contains:
Earth-only universe content.
Base simulation definitions.
Base graphics/sound/music if you choose to bundle them here or in separate gfx/sfx/music packs.
3.2 DLC: Interstellar
Packaged as DLC data:
data/
  dlc.interstellar/
    package.toml
    universe/...
    systems/...
    planets/...
    spaceways/...
Example manifest bits:
[meta]
id       = "dlc.interstellar"
name     = "Dominium: Interstellar"
type     = "dlc"
priority = 10

[content]
requires = ["core.base"]
provides = ["universe.interstellar"]
Interstellar DLC:
Extends universe structure (Vol. 4.18–4.19).
Adds new planets, spaceways, orbital infrastructure definitions.
Uses the same engine features already present in core.
3.3 DLC: Extras
data/
  dlc.extras/
    package.toml
    docs/...
    art/...
    music/...
    devkit_templates/...
Primarily:
Modkit templates
World editor presets
Press kit contents
Soundtrack files
Design docs / blogs
Same loader path as any package, but UI shows it as “Extras” rather than simulation content.

4. USER MODS & ASSET PACKS
User content goes in:
mods/
  author.modname/
    package.toml
    ...
  author.gfxpack/
    package.toml
    ...
  author.soundpack/
    package.toml
    ...
Types:
mod — mechanics/balance/extra content.
gfx — textures, UI skins, model swaps.
sfx — sound effects.
music — OST replacements/expansions.
All treated identically by loader; only type-specific rules differ.
4.1 Graphics/Sound/Music as Mods
You wanted “graphics, sounds, and music packs loaded like mods in an OpenTTD style”.
Implementation:
GFX packs:
override sprites, textures, model materials, fonts.
SFX packs:
override sound effect assets.
Music packs:
add playlists or completely replace track list.
Manifest declares capabilities:
[content]
provides = ["gfx.ui", "gfx.world"]
requires = ["core.base"]         # must be compatible

[gfx]
kind = "replacement"             # replacement | overlay
Loading order decides which assets win on conflicts.

5. LOADING ORDER & PRIORITY
Deterministic, fixed ordering:
Core packages
Sorted by priority, then id (for tie-breaking).
core.base always present and lowest priority number.
Official DLC packages
type = "dlc", sorted by priority, then id.
Official asset packs (gfx/sfx/music shipped by devs)
Also under data/, sorted by priority, then id.
User mods / asset packs (under mods/)
Sorted by priority, then id.
User can toggle enable/disable; disabled packs are skipped.
Merge rules (for any data table):
First package defines base entries.
Later packages in order may:
add new entries
override existing IDs
Final effective data set is pure function of:
engine version
package list + versions
enable flags
priorities
No randomness. Savegames store the list of active packages.

6. MOD COMPATIBILITY & SAVEGAME BINDING
Each savegame stores:
save_header {
    engine_version;
    universe_seed;
    active_packages[] = { id, version, checksum };
}
Load logic:
Check engine version compatibility.
Resolve all required package.id and version.
Verify checksums.
If mismatch:
either hard-refuse,
or allow “unsafe load” with explicit warning and forced backup.
For determinism between clients/servers:
Server is authoritative; clients must have bit-identical active package set for that universe.
Launcher verifies and prevents joining if mismatched, unless in “debug/unsafe” mode.

7. CONTENT NAMESPACES
To avoid collisions, all game data is namespaced:
Examples:
entity.core_base.worker_human
entity.mod_author.my_new_vehicle
gfx.core_base.ui_default
gfx.pack_author.dark_theme
Internal IDs stored as:
namespace.id
where namespace is derived from package.meta.id.
Engine logic never depends on human-readable names; only on fully-qualified IDs.

8. DIGITAL vs PHYSICAL DISTRIBUTION
8.1 Digital
On the website / Steam:
Distribution unit is:
Base Dominium (contains core.base and any official base gfx/sfx/music packs).
Free DLC dlc.interstellar
Free DLC dlc.extras
Installers:
Place core.base and any integrated DLC under data/.
Optionally download extras on-demand.
8.2 Physical (CD/DVD “Dominium: Interstellar”)
Disc contents:
/autorun/ or installer
/bin/
/core/
/data/core.base/
/data/dlc.interstellar/
/data/dlc.extras/   # space permitting
/docs/ (if any)
Rules:
Disc must contain at least all content required to run base game + Interstellar DLC offline.
Extras may be truncated if disc capacity is insufficient:
extras content can be downloadable post-install.
Engine must treat disc-installed packages identically to digital ones.
No binary differences between physical vs digital for the same version.

9. USER DATA, CONFIG, AND LOGS
User-specific paths:
saves/
  universe1/
    save001.dom
    save002.dom
mods/                # user mods here
config/
  settings.toml      # renderer, PAL, visual/audio levels, UI prefs
  keybinds.toml
logs/
  dominium.log
  crash_YYYYMMDD_HHMMSS.log
Configuration for packages saved separately from core settings.
Per-universe config override is allowed but optional.

10. TOOLS & DEVKIT PATHS
Devkit (from DLC: Extras) uses the same package system:
Template mods under data/dlc.extras/devkit_templates/.
Tools read these to create new mod folders under mods/.
Export targets:
“Pack as directory” — easy development.
“Pack as .dpak archive” — release format.
World editor:
loads all enabled packages plus editor-specific helper data from dlc.extras or tools type packages.
saves custom universes as new packages or as scenario saves referencing existing packages.

11. INVARIANTS
No user code execution.
Mods are data only.
Engine scripting uses controlled languages (e.g. Lua) with restricted APIs.
Script code lives inside packages but is sandboxed and deterministic.
Deterministic content resolution.
Given engine version, package set, and settings, merged data is unique and reproducible.
Base game always has core.base active.
Cannot be disabled or replaced, only extended/overridden via mods in explicitly allowed ways.
DLC and Extras are just packages.
No special hardcoding.
UI just tags them as official.

END OF VOLUME 5.3

::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood. We now continue with:
VOLUME 5.4 — PLATFORM TARGETING, EXECUTABLE MATRIX, LAUNCHER LOGIC, RENDERER–PLATFORM PAIRING
This volume defines:
How Dominium ships multi-platform binaries
How the launcher chooses the correct executable
How renderer/platform combinations are validated
How headless/server/client modes are exposed
How this survives addition of legacy systems (Win98/Win95/MS-DOS/etc)

# VOLUME 5.4 — PLATFORM TARGETING & EXECUTABLE MATRIX

## 1. EXECUTABLE CLASSES

Dominium ships four fundamental binary types:

### (A) **Client**
Full graphical client.  
Can run:
- 2D vector
- 2D textured
- 3D textured
- Multi-layered rendering (depending on platform/renderer)

### (B) **Headless Client**
No graphics subsystem.  
Used for:
- Automated local players
- AI-only clients
- External automation tools
- Running local simulation without rendering

### (C) **Server**
Simulates universes.  
No rendering, no audio.  
Deterministic.  
Supports multiple simultaneous properties/companies.

### (D) **Headless Server**
Slimmest possible server with:
- Zero graphics
- Zero audio
- Minimal OS dependencies
- Designed for Win2000-era hardware and Linux VPS

All four must be deterministic and binary-compatible for networking.

---

## 2. EXECUTABLE NAMING-CONVENTION

Use a predictable, versioned, architecture-tagged naming scheme.

### Windows
dominium_client_win32.exe
dominium_client_win64.exe
dominium_server_win32.exe
dominium_server_win64.exe
dominium_headless_win32.exe
dominium_headless_win64.exe

### macOS
DominiumClient.app
DominiumServer.app
DominiumHeadless.app
Inside: x64/ARM slices.

### Linux
dominium_client_x86_64
dominium_client_i686
dominium_client_arm64
dominium_client_armhf
dominium_server_*
dominium_headless_*

### Future/Legacy Targets
Each legacy target has a suffix:

dominium_win98_dx9.exe
dominium_win95_dx7.exe
dominium_win3x_wing.exe
dominium_msdos_djgpp.exe
dominium_macos9_carbon
dominium_nds.nds
dominium_psp_eboot.pbp
dominium_vita.vpk
dominium_switch.nro
dominium_ps2.elf

No changes required in the launcher—targets declare themselves via a manifest.

---

## 3. PLATFORM MANIFESTS

Each binary ships with:

binary.toml

Example:

```toml
[platform]
os     = "windows"
arch   = "x86"
minver = "5.0"        # Win2000
maxver = "11.0"

[render]
supports = ["sdl1", "sdl2", "dx9", "gl2"]
default  = "sdl2"

[modes]
client   = true
server   = false
headless = true
Launcher reads these manifests without launching the executable.

4. LAUNCHER LOGIC
4.1 Detection
Launcher gathers detected data:
OS + version
CPU architecture
GPU vendor + feature flags
Renderer availability (DX9, GL1, GL2, Vulkan, Metal)
Low-memory mode (≤1GB RAM)
Legacy compatibility flags (Win98 mode, NT4 mode)
4.2 Filtering
Launcher filters binaries:
must match OS
must match architecture
must satisfy GPU capability
must support requested mode (client/server/headless)
must support chosen renderer
Those failing any test are excluded silently.
4.3 Fallback Order
Native preferred (dx9/gl2/sdl2)
Legacy safe (sdl1/gl1)
Software (2D vector or software raster 3D)
Minimal (headless client/server)
Launcher always shows the best compatible options.

5. RENDERER–PLATFORM PAIRING
5.1 Windows
Platform
SDL1
SDL2
DX7
DX9
GL1
GL2
SW
Win2000+
Yes
Yes
Optional
Yes
Yes
Yes
Yes
Win98SE
Yes
No
Yes
Limited
Yes
Limited
Yes
Win95
Yes
No
Yes
No
Yes
No
Yes
Win3.x
Via WinG
No
No
No
No
No
Yes
5.2 macOS
macOS Version
SDL1
SDL2
OpenGL1
OpenGL2
Metal
SW
10.6–10.14
Yes
Yes
Yes
Yes
No
Yes
10.15–13
No
Yes
No
Yes
Yes
Yes
14–current
No
Yes
No
No
Yes
Yes
5.3 Linux
All Linux platforms support:
SDL1
SDL2
OpenGL 1.1
OpenGL 2.x
Software
With optional Vulkan later
5.4 Consoles
Handled via specialized builds:
Switch → NVN + SDL2
PS4/PS5 → GNM/GNMX or custom renderer
Xbox → DX11/DX12
PSP/Vita → custom GLES subsystems
DS/3DS → software 2D/3D custom renderer
All console builds must obey determinism constraints.

6. MODE SELECTION (CLIENT/SERVER/HEADLESS)
Launcher exposes:
Run as:
  [ ] Client
  [ ] Client (headless)
  [ ] Server
  [ ] Server (headless)
Only valid combinations appear.
Examples:
Win98: cannot run 64-bit server; cannot run SDL2; cannot run DX11.
macOS 10.6: cannot run Metal; SDL1/SDL2 + GL1/GL2 only.
Linux ARM: may only have SDL2 + GL2 + software.

7. LOW-POWER MODES
To support low-end hardware:
7.1 Level 0
TUI or CLI
Headless simulation
For Win95/Win3.x/Linux server environments
7.2 Level 1
2D vector only
No textures
Minimal UI
For Win98SE/Win2000-era laptops
7.3 Level 2
2D textured + vector overlay
GL1/SDL1/SDL2
7.4 Level 3
Full 3D rendering
DX9/GL2
Optional DX11/Vulkan/Metal on modern systems
Mode is selected automatically or manually forced.

8. DETERMINISM ACROSS EXECUTABLES
All binaries must:
share identical world-state update logic
share identical tick scheduler
share identical floating-point configuration (FPU flags, rounding)
use integer math in core simulation
use fixed iteration ordering
disallow platform-dependent branching
Rendering may differ; simulation must not.

9. FUTURE LEGACY TARGETS & THIS SYSTEM
This structure already supports:
MS-DOS (real-mode stub + DJGPP DOS32 binary)
Windows 3.x (WinG-based)
Win95 (via DX7/SDL1)
MacOS 7–9 (Carbon or OpenTransport builds)
Android/iOS (touch UI package + SDL2)
WebAssembly (software 2D vector + GL1/ES2)
Each legacy platform is just another executable with its own binary.toml.

END OF VOLUME 5.4

If you want to proceed, the next is:

**Volume 5.5 — Build System, Toolchains, Cross-Compilation, Backward Compatibility Pipeline**

Confirm: **proceed?**
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.5 — BUILD SYSTEM, TOOLCHAINS, CROSS-COMPILATION, LEGACY SUPPORT PIPELINE

This volume defines the **complete build pipeline** for Dominium:

- Toolchain selection (modern and legacy)
- Cross-compilation workflow
- Deterministic builds
- Multi-platform CI
- Backwards compatibility (Win98 → Win11, macOS 10.6 → present, Linux universal)
- Future legacy platforms (MS-DOS, Win3.x, MacOS 7-9, consoles)
- Packaging rules
- Reproducibility guarantees

All design follows the constraints:
- Core code = **C89**
- Higher systems = **C++98**
- Lua allowed only for data scripting
- No UB
- Simulation deterministic everywhere

---

# 1. MASTER BUILD PHILOSOPHY

1. **One Source Tree** for all C89/C++98 core engine code  
2. **Many Toolchains** for many executables  
3. **Zero compiler extensions** required  
4. **Reproducible deterministic builds**  
5. **All builds performed in isolated containers**  
6. **Each platform build produces a manifest** declaring:
   - compiler version  
   - libc version  
   - feature flags  
   - build timestamp  
   - hash of source inputs  
7. **Launcher depends only on manifests**, not guessing.

---

# 2. HIGH-LEVEL BUILD SYSTEM STRUCTURE

Use a dual-layer system:

## 2.1 Build Orchestrator: *CMake + Python*  
CMake controls:

- source grouping  
- compiler selection  
- build options  
- enabling/disabling platform targets  

Python controls:

- toolchain environment setup  
- dependency fetching  
- manifest generation  
- packaging  
- cross-build orchestration

## 2.2 Supported Build Backends

- Makefiles (Unix, Win9x, DOS)
- Ninja (modern platforms)
- MSBuild (optional for Windows-native)
- Custom scripts for classic/console targets

---

# 3. SOURCE TREE STRUCTURE (ABRIDGED)

Everything lives under `src/`:

src/
core/ # C89 deterministic simulation kernel
engine/ # C++98 runtime systems
platform/ # OS/driver layers subdivided by family
renderer/ # DX9, GL1, GL2, software, SDL1/2
io/
net/
ui/
tools/ # build-time generators, converters

Plus toolchain files in:

build/toolchains/

Each file defines environment variables + flags.

---

# 4. SUPPORTED TOOLCHAINS

Grouped by era:

## 4.1 MODERN TOOLCHAINS

### Windows
- MSVC 2013 (maximum C++98 compliance without dropping Win2000)
- MSVC 2015–2022 (optional)
- MinGW-w64 (primary cross-compiler)
- Clang/LLVM (secondary)

### macOS
- Xcode 3.2 for 10.6 target (gcc-4.2)
- Clang 5–16 for universal binaries
- SDK slicing for Intel/ARM

### Linux
- GCC 4.8 (baseline)
- GCC 13+ (modern)
- Clang 10+

### WebAssembly
- Emscripten (C89/C++98 mode)
- Software renderer only
- SDL2 + WebGL1 fallback

## 4.2 LEGACY TOOLCHAINS

### MS-DOS
- DJGPP (GCC 3.4.6)
- Watcom C (for tiny builds)

### Windows 3.1 / Win95 / Win98
- Visual C++ 6.0
- MinGW (old) with Win9x CRT  
- Mesa GL1 fallback

### MacOS 7-9
- CodeWarrior Pro 6  
- CarbonLib  
- Handmade wrappers for classic QuickDraw

### Consoles (optional future)
- PSP: PSPSDK
- Vita: Dolcesdk
- Switch: devkitPro
- PS2: PS2SDK
- NDS/3DS: devkitARM

Consoles are optional but supported by the structure.

---

# 5. CROSS-COMPILATION MATRIX

## 5.1 Modern Windows (2000 → 11)

| Target | Toolchain | CRT | Renderer |
|--------|-----------|------|-----------|
| Win2000 | MinGW-w64 (win32) | msvcrt.dll | SDL1/SDL2/GL1/GL2/DX9 |
| WinXP | MSVC 2013 | msvcrt140 | DX9 |
| Win7–11 | MSVC/Clang | ucrt | DX9/GL2/DX11 (later) |

DX7 only for Win95/98 builds.

## 5.2 macOS

| Target | Toolchain | Notes |
|--------|-----------|--------|
| 10.6 | Xcode 3.2 GCC 4.2 | GL1/GL2 only |
| 10.7–10.14 | Clang | GL2 |
| 10.15+ | Clang | Metal + GL2 fallback |
| ARM macOS | Clang | Metal-only |

## 5.3 Linux

Single universal codebase, separate builds for:

- x86  
- x86_64  
- armhf  
- arm64  
- riscv64 (optional)

Renderers: SDL1/SDL2/GL1/GL2.

## 5.4 DOS / Win9x / Win3.x

- DJGPP builds produce **32-bit DOS ext** binaries  
- Watcom produces **small real-mode** stubs  
- Win95/98 use DX7 or SDL1  
- Win3.x uses WinG

## 5.5 WebAssembly

- GL1 → WebGL1  
- 2D vector → Canvas  
- Software fallback

---

# 6. BUILD MODES

## 6.1 Deterministic Release Build
Flags:

-DDETERMINISTIC=ON
-ffloat-store
-fno-unsafe-math-optimizations
-fno-fast-math

Must produce bit-identical results for:

- simulation  
- savegames  
- replay logs

## 6.2 Debug Build
- Logging enabled
- Assertion system active
- Deterministic by default unless overridden

## 6.3 Legacy Safe Build
Used for historical platforms:

- no SSE
- strict FPU precision
- no modern extensions
- fallback memory allocators

---

# 7. DEPENDENCY MANAGEMENT

Dependencies minimal and bundled with source:

- SDL1 (static)
- SDL2
- OpenGL 1.1 headers
- Mesa GL1 fallback for Win95/98/Linux
- Lua 5.1 (static, sandboxed)
- miniz for dpak archives
- Handmade audio mixing if needed

All libraries included as source and built per-target inside container.

No reliance on system packages except on Linux for modern builds.

---

# 8. REPRODUCIBLE BUILDS

## 8.1 Build Isolation
Each build invoked inside container with:

- fixed compiler version  
- fixed PATH  
- fixed timezone  
- fixed locale  
- fixed build timestamp (via SOURCE_DATE_EPOCH)  

## 8.2 Hashing
Each final binary includes a SHA256 of:

- all source files  
- all dependency source files  
- toolchain manifest  
- compile options  

Used to ensure network compatibility:
Clients and servers must match this hash.

---

# 9. AUTOMATED CI PIPELINE

A pipeline that builds everything:

ci/
build_win2000.yml
build_win98.yml
build_win11.yml
build_macos.yml
build_linux.yml
build_dos.yml
build_webasm.yml

Nightly CI produces:

- binaries  
- manifests  
- dpak packages  
- unit tests  
- determinism tests  
- replay tests

---

# 10. PACKAGING RULES

Every build produces:

dominium_<platform>_<arch>/
bin/<exe files>
core/<core libs>
data/core.base/
data/dlc.* (if bundled)
launcher/
manifests/
checksums/

For physical release:

- compress with ZIP for DVD  
- include all assets and extras  
- include Windows installers  
- include macOS .dmg  
- include Linux AppImage

Digital:

- release core installer + DLC downloads

---

# 11. LEGACY TIER BUILDS (LOW-LEVEL SPEC)

## 11.1 Win98/Win95
- Compiler: VC6 or MinGW-w32  
- Renderer: DX7, GL1, SDL1  
- No threading (use cooperative scheduler)  
- 512 MB RAM max assumption  
- Software renderer fallback

## 11.2 DOS
- DJGPP w/ CWSDPMI  
- 32-bit DPMI  
- software-only 2D vector mode  
- no floating point unless soft-float

## 11.3 Windows 3.x
- WinG or GDI  
- 16-bit real-mode stub calls 32-bit extender  
- No networking — offline only

## 11.4 MacOS 7-9
- CodeWarrior  
- Classic QuickDraw + software  
- Carbon optional for OS9

These builds exist as “compatibility variants”—not expected to run Interstellar DLC.

---

# 12. TOOLING & DEVELOPMENT ENVIRONMENT

All devs use:

- Windows 10 for main development  
- VSCode or CLion  
- Python 3.11  
- CMake 3.25+  
- Docker/Podman for cross-build containers  
- qemu for legacy emulation tests  
- VirtualBox/VMware images for Win98, XP, 2000, macOS 10.6  

Full suite of helper scripts:

tools/
build_all.py
build_target.py
run_tests.py
package_dpak.py
gen_manifests.py
verify_determinism.py

---

# 13. DETERMINISM & PLATFORM LOCKDOWN

To maintain cross-platform determinism:

- fixed tick rate scheduler  
- fixed integer math everywhere  
- floating point strictly isolated to render/audio layers  
- FPU set to 53-bit mantissa precision everywhere  
- no system random; use custom RNG with fixed seed  
- record/replay for CI

---

# 14. FUTURE-PROOFING

System designed to allow:

- DX11 renderer layer (modern Windows optional)
- Metal (macOS 10.15+)
- Vulkan (Linux/Windows optional)
- Consoles as separate SPMs (Standalone Platform Modules)
- Additional legacy targets without touching core code

---

# END OF VOLUME 5.5
Ready for Volume 5.6 — Unified Deterministic Networking & Multiplayer Pipeline or the next you specify.
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
Next volume is:
VOLUME 5.6 — UNIFIED DETERMINISTIC NETWORKING & MULTIPLAYER PIPELINE
This is one of the critical core volumes.
It defines:
deterministic lockstep networking
client–server and peer–server distinctions
replay, rollback, resync
input model
state hashing
cross-platform compatibility
headless servers
modded/unmodded universes
security, anti-cheat
universe-scale multiplayer (cross-property, cross-planet, cross-galaxy)
A full single-volume document is very large.
To avoid truncation, confirm:
Generate Volume 5.6 as one unified block, or split into sub-volumes?
Choices:
A — Unified (very large, 1 block)
B — Split:
5.6a Deterministic Simulation Model
5.6b Network Protocol & Sessions
5.6c State Sync, Lockstep, Rollback
5.6d Servers, Clients, Headless, Sharding
5.6e Security & Anti-Cheat
5.6f Modded Network Compatibility
5.6g Replays, Demos, Input Logs
Reply: A or B.
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Volume 5.6a — Deterministic Simulation Model.
This is the foundation for all networking, replays, multiplayer, servers, clients, mods, DLC, physics, economy, climate, transport, and workers.
Nothing in networking works unless 5.6a is perfect.
Everything here is engine law, not optional.

# VOLUME 5.6a — DETERMINISTIC SIMULATION MODEL  
Dominium Networking Core Specification

## 0. Purpose
Define the exact rules by which Dominium’s simulation:
- produces identical results on all platforms  
- remains sync-correct across machines, servers, and clients  
- supports modded and unmodded universes  
- supports wildly different hardware (Win2000 → Win11, Linux, macOS, old consoles)  
- survives timewarp, lag, disconnects, headless mode, replay mode, and save/load

This volume contains **no networking** yet.  
Only the *law of how the simulation evolves*.

---

# 1. SIMULATION TICK MODEL

## 1.1 Canonical Tick (CT)
A *Canonical Tick* is one discrete simulation step.

- Indexed: `tick = uint64`
- CT 0 = world creation
- CT increments by 1 each update
- All simulation occurs *only* on CT boundaries

## 1.2 Universal Update Rate (UUR)
The engine supports arbitrary canonical UPS (user-defined):

1, 2, 5, 10, 20, 30, 45, 60, 90, 120, 180, 240

Networked play uses one fixed UPS per universe.

If hardware cannot reach the chosen UPS → **real-time speed decreases**.  
Simulation never accelerates or decelerates internally.

## 1.3 Hard Separation: UPS vs FPS
- UPS = simulation  
- FPS = rendering  
FPS can drop/raise arbitrarily, UPS cannot, unless slowed uniformly.

Rendering has zero influence on simulation.

---

# 2. SIMULATION LAYERS

Ordered list.  
Every layer must run in this **exact order**, with integer math where defined and stable FP rules where allowed.

1. Input Integration  
2. Time Management  
3. Worker AI  
4. Machine Logic  
5. Network Systems (Electrical/Data/Fluid/Gas/Thermal/Chemical/etc)  
6. Vehicle Pathing  
7. Transport Networks  
8. Climate/Weather/Seasonal  
9. Biomes/Ecology  
10. Economy/Markets  
11. Inventory & Containers  
12. Construction/Blueprints  
13. Terrain Modification  
14. Events & Interrupts  
15. Replication/State Hash  
16. Output Packaging (for server/clients/replay)

No layer may observe results of a later layer within the same tick.

---

# 3. NUMERICAL RULES

### 3.1 Floating-Point Isolation
Floating-point permitted **only in rendering and audio**.
Simulation uses:
- `int32`
- `int64`
- fixed-point (`int32 scaled by 2^n`)
- rationals for certain systems (e.g., voltage/current)

### 3.2 FPU Lockdown
For platforms where FP is unavoidable:
- FPU forced to 53-bit mantissa (double-precision standard)  
- Rounding mode = round-to-nearest  
- Denormals flushed to zero  
- Deterministic math flags set at startup for every binary  

### 3.3 No Platform RNG
Simulation **never** calls:
- system RNG  
- time-based seeds  
- OS entropy devices  
All randomness = **deterministic pseudorandom**:
- XorShift128  
- Seed = universe_seed  
- Pure function from tick number

### 3.4 Order Induction
All arrays, entity lists, and graph iterations use:
- sorted stable order  
- integer indices  
- no hash-map nondeterminism  
- no pointer-order iteration

---

# 4. STATE MODEL

## 4.1 Single True State per Tick
Universe state at tick N is determined by:

S[N] = F(S[N-1], Input[N])

Where:
- `F()` is deterministic  
- `Input[N]` = sorted list of inputs (player, worker, machine)

## 4.2 Identity Rules
Every entity has a **deterministic ID**:

- 64-bit  
- Generated from construction history + incrementing counters  
- Never random  
- Never reused in a universe

Example:
entity_id = ((tick_created << 32) | local_counter)

## 4.3 Containers
All containers (inventories, pipelines, tanks):
- store items in sorted ID order  
- never allow reordering based on pointer order  
- never auto-compact nondeterministically

---

# 5. INPUT MODEL (FOUNDATIONAL FOR NETWORKING)

Nothing is predicted.  
Nothing is approximated.

For tick N, the simulation receives the full **input packet**:

Input[N] = {
per-player commands,
per-worker instructions,
scheduled interrupts,
machine instructions,
}

All commands must be deterministic and pure:
- “set machine mode X”
- “place blueprint at location L”
- “move worker A to B”
- “open UI panel” (ignored by sim)
- “special action”

No direct manipulation of world state is allowed by clients.  
Only **commands** that are transformed into world state by the sim.

---

# 6. TIMEWARP & SLOWDOWN RULES

## 6.1 Timewarp (Single Player Only)
Timewarp means:
- Launcher requests a higher UPS  
- Client runs faster than real time  
- Simulation remains deterministic  

Not allowed in multiplayer universes.

## 6.2 Slowdown Due to Load
If hardware cannot maintain UPS:
- real-time slows  
- tick length expands  
- simulation tick count does not change  
- determinism unaffected

This keeps single-player playable on low-end hardware.

---

# 7. SAVE/LOAD & SNAPSHOTS

## 7.1 Savegame = raw state snapshot

Save contains:

- complete universe state (compressed)
- tick index  
- active package list  
- deterministic seed  
- state hash  
- replay window buffer (optional)

## 7.2 Load restores state *exactly*.  
No re-simulation, no adjustments, no randomness.

## 7.3 Replay-compatible
Replays store only inputs.  
State is reconstructed by applying inputs from a known snapshot.

---

# 8. STATE HASHING

Every tick produces:

hash[N] = SHA256(serialize_state_minimal(S[N]))

Hash includes:
- entity positions
- inventories
- networks
- climate
- calendar
- random state
- tech progress
- construction

Hash excludes:
- graphics  
- audio  
- UI state  
- debug values

Hashes allow instant desync detection.

---

# 9. DESYNC HANDLING (PRE-NETWORKING RULES)

In simulation law:

- Desync = `hash_client != hash_server`  
- Client must:
  - request corrective snapshot OR  
  - disconnect from multiplayer session  

Snapshots are only allowed if universe policy allows it (e.g., co-op).

Otherwise, server kicks and client must reload.

---

# 10. MODDED / DLC DETERMINISM

Simulation law requires:

- identical package list  
- identical package versions  
- identical package checksums  
- identical deterministic scripts (Lua)  
- identical engine version  

Modding allowed only through:
- data tables  
- script hooks defined by the engine  
- no ability to mutate order of operations  
- no user DLL injection

Thus modded multiplayer is deterministic if package list matches.

---

# 11. SANDBOX VS PROPERTY SIMULATION

Two scopes:

### 11.1 Global Universe Simulation
- calendar  
- market  
- climate  
- orbit  
- interproperty transport  
Updated at UPS=1 or UPS=10 depending on system.

### 11.2 Local Property Simulation
- terrain  
- workers  
- machines  
- materials  
- networks  
- vehicles  
Runs at full canonical UPS (e.g., 60).

Property simulation uses only its own chunk data.  
Universe simulation uses aggregated summaries.  
Both run in deterministic order.

---

# 12. SHARDING & MULTI-PROPERTY PARALLELISM

Even though many properties exist, simulation law enforces:

- fixed ordering for properties  
- deterministic parallelism (static partitioning)  
- identical results on single-core and multi-core machines  

Parallelism allowed only when every thread works on a *disjoint* portion of the world and all results are merged in sorted order.

---

# 13. COMPLETE DETERMINISM GUARANTEE

Dominium guarantees:

Given:
same engine version,
same packages,
same settings,
same inputs,
We produce:
bit-identical universe

Across:
- Windows (2000–11)
- Linux (all)
- macOS (10.6–latest)
- Legacy platforms with appropriate variants
- Headless/server/client
- Timewarp or slowdown

This forms the foundation for volumes 5.6b–5.6g.

---

# END OF VOLUME 5.6a
Confirm when ready to continue with:
Volume 5.6b — Network Protocol & Session Model
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Volume 5.6b — Network Protocol & Session Model.
This volume defines:
How Dominium clients and servers communicate
The authoritative model
Packet types
Session lifecycle
Tick distribution
Drop/loss tolerance
NAT, relay, offline universes
Property/company ownership
First contact & compatibility checks
This is the second foundational layer before we reach lockstep/rollback/snapshots.

# VOLUME 5.6b — NETWORK PROTOCOL & SESSION MODEL  
Dominium Multiplayer Architecture, Part 2

## 0. Purpose
Define the *transport layer and session orchestration* for Dominium's deterministic simulation.

This does **not** define sync/rollback (5.6c), just:
- how machines talk  
- how packets are formed  
- how sessions start, run, and end  
- authoritative server responsibilities  
- security at the connection level  
- universe ownership rules  

---

# 1. CORE PHILOSOPHY OF NETWORKING

Dominium is:

- **server-authoritative**
- **deterministic lockstep**
- **input-stream synchronised**
- **never state-diff-sync except snapshots**
- **mod-locked** (all clients must match package list)
- **predictable** (no client prediction, no rollback on client side)
- **host migration impossible** (universe belongs to its server)

---

# 2. NETWORK TRANSPORT LAYER

## 2.1 Base Transport: UDP (primary)
UDP is required for:
- fixed-tick scheduling  
- low-latency inputs  
- explicit sequencing  
- no kernel-induced jitter  

## 2.2 Optional Reliable Overlay
A custom reliable-ordered sublayer (ROSL):

- selective retransmission  
- NACK-based  
- per-stream reassembly  
- deterministic ordering  
- lightweight compared to TCP  

Used for:
- login handshake  
- package lists  
- settings  
- snapshots  
- replay logs (if networked)  

## 2.3 TCP allowed only for:
- file downloads (mods, DLC, assets)  
- web services (if ever introduced)  
- never for simulation

---

# 3. PACKET STRUCTURE

Every packet begins with:

struct NetHeader {
uint32 magic; // "DOMN"
uint16 version; // protocol version
uint16 length; // payload length
uint64 session_id;
uint64 tick; // simulation tick (if applicable)
uint32 seq; // sequence number
uint32 ack; // last received sequence
}

Then a payload, typed:

enum PacketType {
HELLO,
WELCOME,
MOD_LIST,
MOD_MISMATCH,
SETTINGS,
INPUT,
INPUT_ACK,
SNAPSHOT,
SNAPSHOT_ACK,
KEEPALIVE,
PING,
PONG,
CHAT,
ERROR,
}

Payload is always deterministic when affecting simulation.

---

# 4. SESSION LIFECYCLE

Client → Server
┌──────┬─────────────┬─────────────────────────────┬─────────────┐
│Step │ Packet │ Contents │ Notes │
├──────┼─────────────┼─────────────────────────────┼─────────────┤
│ 1 │ HELLO │ engine ver, package list │ start │
│ 2 │ WELCOME │ session_id, tick_base │ server auth │
│ 3 │ MOD_LIST │ server package list │ comparison │
│ 4 │ SETTINGS │ UPS/FPS, universe opts │ must match │
│ 5 │ READY │ client ready │ │
│ 6 │ START │ begin lockstep │ tick sync │
└──────┴─────────────┴─────────────────────────────┴─────────────┘

If any incompatibility is detected during steps 1–4:
- client receives `MOD_MISMATCH`
- connection closes

---

# 5. SERVER AUTHORITATIVE MODEL

The server owns:

- all schedules  
- all tick boundaries  
- all input ordering  
- all state transitions  
- calendar  
- economy  
- climate  
- interproperty simulations  
- worker assignment  
- machine states  
- pathing state  
- universe expansion rules (property acquisition, area/continent claiming)

Clients **never** simulate ahead or behind server.  
They simulate only what the server approves.

Clients may render extrapolated animations (pure visual), but no sim-altering prediction.

---

# 6. CLIENT ROLES

Clients fall into 3 classes:

### 6.1 Player Client
- sends input packets  
- receives tick and event packets  
- must maintain mod and package parity  
- displays UI  
- may operate headless for automation

### 6.2 Spectator Client
- sends no inputs  
- receives broadcasts  
- optional if enabled by server  
- must still satisfy mod and package parity

### 6.3 Automation/AI Client
- operates like a player but actions come from scripts  
- runs in deterministic mode  
- useful for e-sports / test automation / load testing

---

# 7. INPUT PACKETS

Input packet format:

struct InputPacket {
uint64 tick; // the target tick for this input
uint16 player_id;
uint16 command_count;
Command commands[command_count];
}

Commands are small, pure, deterministic instructions.

Rules:
- client must send inputs for tick `T` before `T - (latency_budget)`
- server delays simulation until all required inputs arrive (lockstep)
- if client is late → server may enforce:
  - timeout → disconnect  
  - fallback → allow server to automate the player  
  (policy chosen by universe settings)

---

# 8. SERVER TICK DISTRIBUTION

For each canonical tick `N`:

1. Server gathers all input packets for tick N  
2. Server constructs `Input[N]`  
3. Server steps simulation → `S[N]`  
4. Server computes `hash[N]`  
5. Server broadcasts `TickAck(N, hash[N])`  
6. Clients:
   - step simulation locally  
   - verify `hash[N]`  
   - if mismatch → `DESYNC`

---

# 9. DESYNC RESPONSE (networking side)

If client hash != server hash:

- client sends `ERROR(DESYNC)`  
- server replies with one of:

### Mode A — Hard Consistency (default)
- Immediate disconnect  
- Client must reload save  
- No state repair during session

### Mode B — Soft Consistency (co-op servers)
- Server sends a **snapshot** of last good tick  
- Client rolls back  
- Replays inputs since snapshot  
- Only allowed if server policy = safe re-sync

Snapshots are expensive but deterministic.

---

# 10. PROPERTY / COMPANY OWNERSHIP

Each connection claims:

- a company ID  
- a property set  
- worker control scope  
- financial and administrative permissions  

Server enforces:

- no collisions of territory  
- no dual-ownership  
- no illegal expansion  
- no cross-universe sharing  
- local/offline universes cannot be merged into online universes

Ownership maps are deterministic and part of saved state.

---

# 11. SERVER MODES

### 11.1 Single-Universe Server
- one universe per server process  
- simplest mode  
- suitable for personal servers

### 11.2 Multi-Universe Server
- one server runs many universes  
- each universe = independent deterministic simulation  
- uses scheduler multiplexing  
- chunk border interactions still deterministic

### 11.3 Sharded Galaxy Server (future)
- multiple servers assigned per sector  
- federation protocol (separate spec)  
- deterministic but distributed  
- not part of base Dominium 1.x

---

# 12. NAT, FIREWALL, & CONNECTIVITY MODEL

Dominium supports:

- direct UDP hole-punching  
- relay servers (rendezvous)  
- explicit public IP publishing  
- LAN discovery (UDP broadcast)  
- VPN-friendly mode

All methods encapsulated inside the session handshake.

---

# 13. OFFLINE UNIVERSES

Offline universes run:

- no netcode  
- no latency  
- timewarp allowed  
- replay and save identical to networked universes  
- same deterministic rules

Offline universes cannot:
- join online servers  
- merge with online universes  
- share economies or markets

But players may **export/import** savegames manually.

---

# 14. BANDWIDTH PROFILE

### Inputs:
~200–2000 bytes per tick (depending on player count)

### Tick Acks:
~64–200 bytes per tick

### Snapshots:
~10KB–10MB depending on universe scale

Dominium expects low bandwidth and is playable over:
- DSL  
- 4G  
- low-grade satellite  
- rural wireless

---

# 15. ANTI-CHEAT (session-level)

Prevent:
- unauthorized commands  
- modified packages  
- mismatched hashes  
- manipulated latency  
- time drift  
- tick forging  
- client prediction injection  
- input flood

Server monitors:

- tick input timings  
- hash integrity  
- command rate  
- packet validity  
- replayability of session

Later volumes expand this further.

---

# 16. SESSION TERMINATION

A session ends when:

- server stops  
- client disconnects  
- hash mismatch not resolved  
- mod mismatch detected mid-session  
- player eviction  
- universe reset or rollback to snapshot 0  

Clients receive:

ERROR(reason_code)

Then disconnect.

---

# END OF VOLUME 5.6b
Confirm to proceed with:
Volume 5.6c — State Sync, Lockstep, Rollback, Snapshots
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Volume 5.6c — State Sync, Lockstep, Rollback, Snapshots.
This is the most mechanically critical part of Dominium’s networking system.
It defines how the simulation remains synchronized across all machines, how clients recover from latency, and how servers enforce correctness.

# VOLUME 5.6c — STATE SYNC, LOCKSTEP, ROLLBACK, SNAPSHOTS  
Dominium Multiplayer Architecture, Part 3

## 0. Purpose
Define the deterministic synchronization model:

- Lockstep tick control  
- Client/server buffering  
- Input pipelines  
- Rollback conditions  
- Snapshot format  
- Desync repairs  
- Timewarp restrictions  
- CPU starvation handling  

---

# 1. DEFINITIONS

## 1.1 Key Terms

**Canonical Tick (CT):**  
One deterministic simulation step.  
Shared across all machines in the session.

**Authoritative Server:**  
The only machine that decides the true tick order.

**Input Window:**  
How many ticks ahead client may submit inputs.

**Buffered Simulation:**  
Client simulates tick N only after receiving server approval for inputs for N.

**Rollback:**  
Reverting state to a previously known-good snapshot tick, then replaying inputs to current tick.

---

# 2. LOCKSTEP OVERVIEW

Dominium uses **strict deterministic lockstep**, similar in spirit to early RTS engines but cleaner and modernized.

Rules:

1. Server never advances tick N+1 until all required inputs for tick N have arrived or timeout policy chosen.
2. Clients never run ahead of server’s approved tick.
3. All simulation derives from:
S[N] = F(S[N-1], Input[N])
4. Server broadcasts tick completion + hash(N).
5. Clients verify and only then commit local state.

This guarantees universal determinism.

---

# 3. INPUT PIPELINE AND LATENCY MODEL

## 3.1 Client Lead-Time
Clients must submit inputs for tick N **L ticks** ahead:

L = ceil(latency_ms / tick_ms) + safety_margin

Example:
- latency = 60 ms  
- tick = 16.666 ms (60 UPS)  
- L = 4–6 ticks

Client maintains a circular buffer of outgoing inputs.

## 3.2 Server Input Integration
Server receives input packets and stores them by tick.  
For each canonical tick:

if all inputs for tick N received:
simulate N
else if timeout:
apply policy (kick, auto-pilot, or pause)

## 3.3 Late Inputs
If input for tick N arrives *after* simulation:

- if soft-policy universe:
  - rollback possible  
- if strict:
  - input discarded  
  - player desynced → kick

---

# 4. CLIENT SIMULATION RULES

Clients NEVER predict.  
Clients simulate tick N only when server says:

TickAck(N, hash[N])

Client steps simulation to N, computes hash locally, compares.

If mismatched → error.

Rendering may *interpolate or animate* ahead or behind, but simulation stays locked.

---

# 5. SERVER TICK PIPELINE

For each tick:

1. **Receive All Inputs**
2. **Sort Deterministically**
3. **Simulate Tick**
4. **Compute State Hash**
5. **Broadcast Ack**
6. **Optionally emit delta for replay log**

Server never diverges.

---

# 6. SNAPSHOTS

Snapshots are the only way to repair desync or allow mid-session join.

## 6.1 Snapshot Frequency

Configurable:

- Default: every 600 ticks (10 seconds @ 60 UPS)
- Low-power: every 3600 ticks
- High-reliability: every tick

Smaller universes use more frequent snapshots.

## 6.2 Snapshot Content

Snapshot includes:

- tick index  
- deterministic seed state  
- sorted entity array  
- terrain chunk metadata  
- networks (electrical, fluids, data)  
- inventories/containers  
- economy/market state  
- tech  
- workers, AI, vehicles  
- climate, weather, calendar  
- property ownership  
- pathfind caches  
- RNG state

Everything needed to reconstruct state, minus transient visuals.

## 6.3 Snapshot Encoding

Compressed deterministic binary format:

- LZ4 or zstd (without multithreading)  
- sorted stable serialization  
- endian-invariant  
- pointerless binary layout  
- uses stable numeric formats  

---

# 7. JOIN-IN-PROGRESS (JIP)

JIP in Dominium works via:

1. Client performs HELLO handshake  
2. Server checks compatibility  
3. Server pauses or continues simulation depending on config  
4. Server sends snapshot of tick T  
5. Client loads snapshot  
6. Server sends input logs from T → current tick  
7. Client replays  
8. Client joins at tick N

This supports universes with:

- multiple properties  
- many clients  
- AI companies  

Not allowed in strict/competitive universes unless explicitly enabled.

---

# 8. ROLLBACK

Rollback occurs only when:

- soft-consistency universe  
- network congestion  
- client desync detected  
- server-policy = rollback-permitted  
- snapshot available

## 8.1 Rollback Algorithm

1. Identify latest snapshot tick `S`
2. Load snapshot state
3. Reapply inputs for ticks `S+1` → `current_tick`
4. Recompute state hashes
5. Continue lockstep from repaired state

## 8.2 Deterministic Replays
Because all inputs are logged and deterministic, replay is exact.

---

# 9. VALIDATION & HASHING

Clients validate every tick:

client_hash[N] == server_hash[N]

If not:

- strict → immediate disconnect  
- soft → request snapshot  
- debug → halt simulation, dump state

Server validates only its own state.

Hash failures can reveal:

- corrupted mod  
- corrupted memory  
- divergent codepath  
- differing iteration order  
- hardware nondeterminism  

---

# 10. PAUSING & CATCH-UP

## 10.1 Server-Driven Pause
When client cannot keep up:
- server may pause simulation  
- or kick slow client  
- or allow auto-pilot fallback

## 10.2 Local Client Catch-Up
Client can run:
- 2× speed  
- 4× speed  
(but simulation still identical to 1× UPS since server sends inputs faster)

Rendering may be disabled during catch-up to increase CPU headroom.

---

# 11. TIMEWARP & MULTIPLAYER

**Timewarp disabled in multiplayer entirely**.

Server tick rate is always canonical UPS.  
Clients must conform.

---

# 12. MULTIPLE PROPERTIES / MULTIPLE PLANETS

Lockstep still functions:

- each property runs simulation  
- world is chunked  
- server simulates all chunks deterministically  
- only active chunks tick at full speed  
- inactive chunks tick at reduced speed (UPS=1)  
- still deterministic because all machines follow same rules

---

# 13. LOW-END HARDWARE SUPPORT

If device is too weak to maintain UPS:

- local slowdown  
- lower FPS  
- headless rendering  
- reduced animation  
- no prediction  
- client may remain in sync even at 10–20 UPS if server tick rate is lowered globally

If device is *too slow even after local slowdown*, must disconnect.

---

# 14. SERVER SHUTDOWN PROTOCOL

Steps:

1. Broadcast `SERVER_STOPPING`  
2. Final TickAck  
3. Final snapshot stored  
4. Clients save replay logs  
5. Close sockets  
6. Universe rolled forward on next startup from last snapshot + replay log

---

# 15. REPLAY LOG FORMAT

Replay logs store:

- universe seed  
- mod/package list  
- engine version  
- input list per tick  
- snapshots (optional)  
- tick hashes  

Replay files do not store world states except snapshots.

This makes demo playback deterministic.

---

# 16. HARD GUARANTEES

1. Server is never wrong  
2. Client must match server’s state  
3. Snapshots fully reconstruct state  
4. Replay logs always deterministically regenerate states  
5. Multiple platforms can interoperate  
6. Disconnections do not corrupt universe  
7. Lockstep always wins over prediction  

Dominium cannot ever have:
- divergent simulation paths  
- client-side physics  
- approximate or heuristic systems in simulation  
- local prediction altering state  

---

# END OF VOLUME 5.6c
Next volume:
Volume 5.6d — Servers, Clients, Headless, Sharding & Scheduling
Confirm: proceed?
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Acknowledged. Proceeding with:
VOLUME 5.6d — SERVERS, CLIENTS, HEADLESS, SHARDING & SCHEDULING
Dominium Multiplayer Architecture, Part 4
This volume defines:
The architectural roles of servers and clients
Differences between headless, graphical, and hybrid modes
Universe scheduling rules
Chunk/region activation
Multi-universe hosting
Multi-property and multi-planet simulation partitioning
(Optional) sharding architecture for future galaxy-scale multiplayer
This volume binds the deterministic model (5.6a) and the network session model (5.6b) into a scalable runtime topology.

# VOLUME 5.6d — SERVERS, CLIENTS, HEADLESS, SHARDING & SCHEDULING

## 0. Purpose
Define how Dominium runs:

- As a client  
- As a server  
- As a headless simulation node  
- As a multi-universe host  
- Across multi-property, multi-planet universes  
- And how it schedules CPU load deterministically

This volume ensures Dominium scales from:

- a single Win2000 laptop  
- to modern multi-core servers  
- to optional future distributed cluster hosting

---

# 1. SERVER ARCHITECTURE

Two categories:

## 1.1 Dedicated Server (Authoritative)
- Runs full universe simulation  
- No rendering  
- No audio  
- Lowest overhead  
- Ideal for 24/7 persistent universes  
- One process = one universe OR multiple universes  
- Enforces deterministic lockstep (5.6c)

## 1.2 Semi-Headless Server
- Same as dedicated  
- But includes 2D vector UI or text-mode status screen  
- Allows local admins to inspect world state  

---

# 2. CLIENT ARCHITECTURE

## 2.1 Full Client
- Renders world  
- Plays audio  
- Runs entire simulation (lockstep verified)  
- Submits input packets  
- Displays UI  
- May operate in low-end mode (2D vector)

## 2.2 Headless Client
- No rendering  
- Useful for:
  - automation bots  
  - multiplayer scripting  
  - AI players  
  - load testing  
  - remote/console-only play  
- Fully deterministic

## 2.3 Non-interactive Spectator
- Cannot send commands  
- May view world  
- Still simulates deterministically  
- Used for broadcast or replay streaming  
- Requires full package parity

---

# 3. UNIVERSE SCHEDULING CORE

Dominium’s world is immense:  
Properties → Areas → Continents → Planets → Systems → Galaxy.

Not all are simulated at full fidelity constantly.

### 3.1 Tick Budget Tiers

1. **Tier A (Active Chunks)**  
   - Player present  
   - Worker activity  
   - Machinery running  
   - UPS = canonical UPS (e.g., 60)

2. **Tier B (Peripheral Chunks)**  
   - No players present  
   - Machines idle or slow  
   - UPS = 10 or 1

3. **Tier C (Dormant Chunks)**  
   - No workers, no machines, no activity  
   - UPS = 1 (global tick)

4. **Tier D (Dormant Planets / Systems)**  
   - If no player owns anything  
   - No simulation runs  
   - Only global climate/economic summaries updated occasionally

### 3.2 Deterministic Tier Assignment
Tier assignment is:

- Calculated deterministically  
- Based on sorted lists  
- Independent of platform or hardware  

All machines agree which regions are active or dormant.

---

# 4. MULTI-PROPERTY SCHEDULING

Properties may be:

- Adjacent  
- Far apart  
- In different continents  
- On different planets  

Simulation is split by **chunk grids**, not by properties.

## 4.1 Property-level simulation
A property may span many chunks.  
Chunks simulated independently but deterministically.

## 4.2 Cross-property transport
Handled through global queues:
- big trucks  
- trains  
- aircraft  
- ships  
- data packets  
- power flows through interproperty ports  

These are simulated regardless of player presence but at reduced UPS if far from players.

---

# 5. MULTI-PLANET SCHEDULING

Planets are conceptually huge, but:

- Only local player properties get full UPS  
- Remote planets update climate and markets at UPS=1  
- Orbital mechanics update at UPS=1  
- Transport across planets (rockets, carriers) update on a per-tick queue at UPS=1  

This keeps load manageable but deterministic.

---

# 6. MULTI-UNIVERSE SERVERS

Servers may run many universes:

DominiumServer.exe --host Universe1
DominiumServer.exe --host Universe2
DominiumServer.exe --host Universe3

Or one binary can manage many universes:

DominiumMegaServer

## 6.1 Deterministic Scheduling Between Universes

Universes are isolated.  
Server scheduler does:

for each universe in sorted order:
tick_once()

Tick ordering across universes is deterministic by:

- universe ID  
- load  
- tick count  

Never parallelize universes unless merged results never interact.

---

# 7. MULTI-CORE SCHEDULING MODEL

Dominium supports multi-core execution under strict determinism.

## 7.1 The Rule:
Parallelism allowed **only when**:

- Work units operate on independent chunks  
- No shared writes  
- All results merged in sorted deterministic order  

## 7.2 Allowed Parallelism Examples

- Pathfinding on different chunks  
- Network simulation per chunk  
- Tick precomputation  
- Climate simulation  
- Market simulation  
- Input parsing

## 7.3 Forbidden Parallelism

- Physics operations that race  
- Shared entity lists  
- Hash map iteration  
- Any nondeterministic ordering  

---

# 8. SHARDING (OPTIONAL FUTURE EXTENSION)

Sharding is not part of Dominium 1.x but specification allows it.

### 8.1 Sharding Goals
- Galaxy-scale servers  
- Thousands of players  
- Multiple machines simulate different sectors  

### 8.2 Shard Types
- Property Shard  
- Planet Shard  
- System Shard

### 8.3 Determinism Requirement
Sharding uses **state channels**:

- each shard simulates its region  
- deterministic boundaries  
- periodic global commits  
- conflict resolution via timestamped command streams  
- frictionless deterministic merges

This allows optional future MMO scale.

---

# 9. SERVER STARTUP PROCEDURE

1. Load engine  
2. Load packages and validate  
3. Load universe  
4. Load snapshot or savegame  
5. Initialize deterministic seed  
6. Initialize chunk tier state  
7. Bind to network port  
8. Enter main loop

---

# 10. CLIENT STARTUP PROCEDURE

1. Load engine  
2. Load packages  
3. Show launcher UI  
4. Detect hardware & renderer  
5. Connect to server  
6. Perform session handshake  
7. Receive initial snapshot or tick sync  
8. Enter lockstep loop  
9. Render world (optional)

---

# 11. HEADLESS CLIENT/SERVER API

Headless mode offers:

- CLI for controlling workers  
- terminal UI for managing universes  
- API hooks for automation  
- no rendering code at all  
- minimal memory footprint  
- optional Lua for macros, still deterministic

Useful for:

- property bots  
- pipelines and machine tuning bots  
- fleet managers  
- multiplayer AI  
- hyper-low-end compatibility (Win2000-era hardware)

---

# 12. INTERPROPERTY & INTERPLANETARY NETWORK NODES

Dominium handles large-scale transport through deterministic queues:

- road corridors  
- rail corridors  
- airways  
- waterways  
- spaceways  

These queues:

- tick at UPS=1 globally  
- activate chunks near endpoints at full UPS  
- guarantee deterministic movement of cargo  
- allow workers to ride vehicles across distances  
- allow orbital travel (rockets) in deterministic discrete steps

---

# 13. SERVER RESOURCE MANAGEMENT

Dominium servers automatically:

- downscale UPS for dormant chunks  
- disable rendering  
- disable UI  
- disable sound  
- throttle logging  
- compress snapshots  
- reuse chunk caches  
- restrict memory allocation patterns  
- use fixed-size pools for determinism

Server never adapts simulation speed to hardware; only real-time slows.

---

# 14. DISCONNECT BEHAVIOR

When client disconnects:

Server options:

- auto-pilot worker & property  
- freeze property  
- relinquish to AI company  
- assign to shared ownership (co-op mode)  
- reassign workers to idle state  
- continue simulation unaffected  

Behavior defined by universe settings.

---

# 15. CONSISTENCY CHECKS

Every server tick after simulation:

1. Validate entity counts  
2. Validate network balances (power, fluids, etc)  
3. Validate inventory integrity  
4. Validate climate model  
5. Validate economy consistency  
6. Validate no illegal references  
7. Validate no dangling entities  
8. Compute hash and send to clients  

This prevents runaway desyncs.

---

# END OF VOLUME 5.6d
Next volume in sequence:
Volume 5.6e — Security, Anti-Cheat, Integrity Enforcement
Confirm: proceed?
You said:
Yes. I want minimal DRM and anticheat enforcement. We should provide the systems, but everything should be optional or overridable
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.6e — SECURITY, ANTI-CHEAT, INTEGRITY ENFORCEMENT  
Dominium Multiplayer Architecture, Part 5

Constraints from design goals:

- Minimal DRM  
- No intrusive anti-cheat  
- No kernel drivers, no process scanning, no hidden telemetry  
- All enforcement **server-side** by default  
- All enforcement **configurable** and **overridable** per-universe  
- Single-player and LAN allowed to disable almost everything  
- Competitive/“ranked” servers can opt into stricter modes

This volume specifies:

- What integrity checks exist  
- How they are enforced  
- How they can be disabled, relaxed, or overridden  
- What is *never* implemented (hard prohibitions)

---

## 0. PHILOSOPHY

1. **Ownership**: Once user buys the game, they own the binaries and may mod them offline.  
2. **Integrity over surveillance**: Focus on deterministic consistency checks, not spying on user’s machine.  
3. **Server choice**: Each server operator chooses enforcement strictness.  
4. **Transparency**: Client knows exactly which checks are enabled.  
5. **Reproducibility**: All integrity checks are reproducible from public information (hashes, logs), not black-box.

No DRM:

- No online activation requirement for offline.  
- No periodic online checks for single-player.  
- Physical release completely usable offline.

---

# 1. ENFORCEMENT LAYERS

We distinguish three distinct layers:

1. **Engine Determinism** (mandatory, non-DRM)  
2. **Session Integrity Checks** (optional, server-configurable)  
3. **Cheat Detection Policies** (optional, server-configurable, never intrusive)

All of these operate purely on:

- network traffic  
- engine state  
- hashes  
- input patterns  

No OS-level monitoring.

---

# 2. ENGINE DETERMINISM (MANDATORY)

These are not “anti-cheat” as such; they are **core correctness**:

1. Fixed tick model (5.6a)  
2. Deterministic state transitions  
3. Hashing of world state per tick  
4. Strict mod/package parity  
5. Fixed input semantics  

These cannot be disabled, because if they are disabled, the game stops being well-defined.

What this *prevents* by default:

- arbitrary client-side physics  
- random local state divergence  
- “I modified my economy locally” exploits  
- non-deterministic scripting

---

# 3. SESSION INTEGRITY CHECKS (SERVER-CONFIGURABLE)

Each universe/server can choose a **security profile**. Define a simple enum:

```toml
[security]
profile = "off"   # off | relaxed | normal | strict | custom
3.1 Checks
All checks operate on deterministic properties:
Engine version
Package list (id, version, checksum)
Binary manifest (hash of core engine libs)
Per-tick hashes
Input timing statistics
3.2 Profiles
3.2.1 off
No mod parity enforcement (beyond minimum needed to avoid crashes).
No binary manifest validation.
Only minimal handshake verification.
Desyncs still detected, but server can allow clients to continue or auto-resync.
Suitable for LAN, private co-op, experimental modded servers.
3.2.2 relaxed
Package list must match IDs, but versions may be tolerated with a warning.
Binary manifest not checked or only logged.
Hash mismatch yields warning; server may keep connection alive.
Snapshots allowed for resync.
Good default for casual public servers.
3.2.3 normal (suggested default)
Package id + version + checksum must match server.
Engine build-id must match; but no check on local file layout beyond that.
State hash mismatch → client required to resync from snapshot or disconnect.
No OS/anti-cheat hooks.
Enough to block trivial cheating through modded packages.
3.2.4 strict
Package list fully enforced.
Engine binary manifest (hash of core libs) must match server’s reference set or trusted list.
Hash mismatch: immediate disconnect (unless snapshot resync configured).
Abnormal input timing patterns flagged; possible auto-kick/auto-ban per server rules.
Intended for competitive / ranked / public ladder universes.
3.2.5 custom
Server operator defines per-check toggles in config:
[security.checks]
enforce_package_id      = true
enforce_package_version = true
enforce_package_hash    = true
enforce_engine_build    = false
enforce_engine_hash     = false

kick_on_hash_mismatch   = false
resync_on_hash_mismatch = true

log_suspicious_inputs   = true
kick_on_suspicious      = false

4. WHAT IS NEVER IMPLEMENTED
Hard prohibitions:
No kernel-mode anti-cheat.
No user-space process scanning.
No reading other process memory.
No file system scanning outside game directory.
No hardware fingerprinting beyond necessary for graphics/audio selection.
No per-user DRM tokens or cloud-based entitlement checks for offline play.
No “always-on” online requirement.
Multiplayer authentication can use:
simple username + password
optional external identity provider (Steam, etc.)
But engine itself does not depend on any DRM.

5. HASHES, MANIFESTS, AND WHAT THEY PROTECT
5.1 Engine Build Hash
Each shipped binary set has a manifest:
[engine]
id      = "dominium-1.0.0"
build   = "win32_dx9_release"
sha256  = "..."
Server can:
require matching id only
require id + build
require full sha256 match
All client sees:
exact requirements
local vs required values
explicit reason if not accepted
No hidden checks.
5.2 Package Hashes
Every package (core, DLC, mod) has:
[meta]
id      = "core.base"
version = "1.0.0"
sha256  = "..."
Server uses:
id to identify required content
version to negotiate compatibility
sha256 to enforce exact parity if configured

6. INPUT PATTERN ANALYSIS (OPTIONAL)
Minimal anti-cheat:
purely statistical
purely at server level
entirely optional
Examples:
impossible APM for human input
no network jitter but extremely high command throughput → script
consistent sub-tick reaction times → macro
Server can:
just log
add soft warning
throttle suspicious inputs
kick
ban (server-local list)
No global ban network. No central authority.
All thresholds are server-configurable.

7. DESYNC DETECTION & MISUSE
Desync is not automatically treated as cheating.
Reasons for desync:
CPU instability
memory corruption
broken mods
cross-platform FP issues (if rendering/audio violate rules)
intentionally modified binary
Server options:
treat desync as plain error → request resync
treat repeated desyncs as suspicious
only enforce for “strict” profile
Clear separation between:
technical fault
misconfigured mod
suspected exploit

8. SNAPSHOTS & ROLLBACK VS CHEATING
Snapshots can be abused in some systems (e.g. rollback to avoid losses).
Dominium mitigates via policies:
Snapshots only usable as repair for desync/late join, not as gameplay re-roll.
Server config:
[security.snapshots]
allow_resync = true
allow_rejoin = true
allow_rollback_for_loss_avoidance = false
No client-driven “load previous tick” in multiplayer.

9. OFFLINE & LAN MODES
Single-player and LAN-universe config:
[security]
profile = "off"

[security.offline]
ignore_engine_hash   = true
ignore_package_hash  = true
allow_local_mods     = true
allow_script_changes = true
Engine:
never phones home
never disables local content
never forces updates to continue playing offline
LAN server can be fully permissive.

10. SERVER-SIDE AUTH & PERMISSIONS
Not DRM, just multiplayer control.
Local user accounts per universe.
Optionally linked to external provider (Steam, GOG, etc.), but engine must not depend on one.
Permission groups:
owner
admin
trusted
guest
banned
All permissions stored in server config/save, not in global service.

11. TOOLS FOR AUDITABILITY
To keep anti-cheat honest and user-controllable, engine ships with tools:
dom_verifybuild — compute engine binary hashes
dom_verifypackage — compute dpak hashes
dom_verifyreplay — verify replays vs expected hashes
Server operator can publicly provide:
engine manifest
package manifests
replay + hash sets
Anyone can verify that no hidden modifications exist.

12. MODDING & BALANCE EXPLOITS
Engine does not block:
running unbalanced mods on private servers
modifying economy rules for sandbox play
“cheating” in single-player
Server only enforces:
consistent rules within one universe
no mid-session rule switching (unless server config allows it)
Mods and DLC define gameplay; security system only enforces consistency.

13. RANKED / COMPETITIVE SERVERS (OPTIONAL PRESET)
For rare “serious” universes:
profile = strict
engine hash pinned
official package list fixed
modding locked out (or limited)
no mid-session package changes
auto-kick on desync
input pattern heuristics fully enabled
Even here:
no kernel DRM
no intrusive scanning
no central ban lists
everything spelled out in server MOTD.

14. SUMMARY OF GUARANTEES
No DRM for offline and LAN.
No invasive anti-cheat.
All enforcement is:
transparent
deterministic
optional / per-server configurable
Core determinism is non-optional, but that is a correctness property, not DRM.
Modding is a first-class citizen; integrity is about consistency, not restriction.

END OF VOLUME 5.6e

Next in the sequence for networking would be:

- **5.6f — Modded Network Compatibility & Versioning**
- **5.6g — Replays, Demos, Input Logs & Tools**

If you want to keep pushing forward, pick one or just say “proceed” and I’ll continue in order.
::contentReference[oaicite:0]{index=0}
You said:
Go for 5.6f
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.6f — MODDED NETWORK COMPATIBILITY & VERSIONING  
Dominium Multiplayer Architecture, Part 6

Purpose:  
Define how Dominium supports **mods**, **DLC**, **graphics/sound packs**, **data overrides**, and **balance patches** *while preserving full determinism across multiplayer universes.*

Everything here must:

- Allow total creative freedom for modders and players  
- Allow official DLC to expand the game cleanly  
- Prevent desyncs  
- Maintain compatibility across platforms  
- Be fully optional and non-restrictive  
- Never include DRM  

This volume specifies how packages are identified, versioned, verified, synchronized, and how servers ensure consistency *without restricting single-player freedom*.

---

# 0. PHILOSOPHY

1. **Dominium is a data-driven game**: Everything modders touch is loaded through packages (*.dpak*).  
2. **Deterministic merging**: All packages merge in a stable, sorted order.  
3. **Server sovereignty**: Server decides allowed package list per universe.  
4. **Client transparency**: Client always sees exactly what is required and why.  
5. **Guaranteed determinism**: Multiplayer requires package parity. Offline requires none.  
6. **Zero DRM**: Installing mods never requires online activation.

---

# 1. PACKAGE MODEL (RECAP)

Packages are folders or archives with a manifest:

package.toml
assets/
data/
scripts/

Key fields:

```toml
[meta]
id        = "mod.author.pack"
version   = "1.2.3"
sha256    = "...hash..."
priority  = 25
type      = "mod"     # or dlc, gfx, sfx, music, tools

[compat]
engine_min = "1.0.0"
engine_max = "1.9.99"
Package identity = (id, version, sha256).
SHA256 is optional for offline, required for deterministic multiplayer depending on security profile (5.6e).

2. MERGE ORDER
Dominium loads packages in deterministic order:
Core packages
Official DLC
Official asset packs
User mods
User asset packs
Within each category:
Sort by priority ascending
Tie-break by id lexicographically
All data merges use:
Stable, deterministic table merges
No dependency on directory scan ordering
No reliance on file timestamps
No hashing of iteration-order-sensitive structures

3. DETERMINISTIC MOD LOADING
Dominium ensures:
All clients with identical package sets produce identical internal data
All scripts execute deterministically (Lua 5.1 sandbox with deterministic hooks)
All values defined in mods override base game in a deterministic, total order
No mod may introduce nondeterministic behavior (e.g., os.time, file I/O)
Mods cannot create new FPU or thread nondeterminism
Mods cannot change engine tick frequency or precision
Every mod is effectively input to a pure functional merge process.

4. MOD COMPATIBILITY CHECKS
4.1 Light Mode (single-player, LAN, relaxed)
Engine checks:
Manifest is syntactically valid
Mod loads without crash
Versioning irrelevant
Hash irrelevant
Everything allowed except binary injection
4.2 Deterministic Mode (multiplayer)
Engine checks:
id must match
version must match (unless server config allows range matching)
sha256 must match (depending on security profile)
No extras, no missing packages
Load order must be identical
Scripts must pass deterministic validation
Assets irrelevant for simulation (can differ only if they aren't used by sim)
Hash mismatch → mod mismatch screen → client cannot join unless server allows “unsafe”.
4.3 Strict Mode (competitive servers)
Server requires:
exact version
exact sha256
exact manifest
asset hashes optional (but possible)

5. MOD VERSIONING STRATEGY
Every mod should use semantic versioning:
MAJOR = breaking changes
MINOR = compatible additions
PATCH = non-breaking corrections
Universe savegames store:
active_packages = [
  {id="core.base", version="1.0.0", sha256="..."},
  {id="dlc.interstellar", ...},
  {id="mod.author.foo", version="1.2.0", sha256="..."},
]
On reloading:
Missing mod → cannot load
Wrong version → cannot load
Wrong hash → cannot load
Offline mode can bypass via config toggle.

6. PACKAGE DEPENDENCIES
A package may define:
[content]
requires = ["core.base", "dlc.interstellar"]
conflicts = ["mod.author.oldpack"]
Dependency rules:
All “requires” must be present
All “conflicts” must NOT be present
In multiplayer, conflicts resolved by server policy
In offline, conflicts may be ignored (user override)
Dependencies resolved deterministically and stored in savegames.

7. MULTIPLAYER PACKAGE NEGOTIATION (HANDSHAKE)
During HELLO/WELCOME (5.6b):
Client sends its package list (id, version, sha256)
Server sends required package list
Engine compares full specification
If mismatch:
Server sends MOD_MISMATCH
Client UI shows exact differences
Client may auto-download from server (optional policy)
Or must manually install
Engine never enforces DRM or blocks mod installation.

8. SERVER POLICIES FOR MODS
Server config includes:
[mods]
allow_mods           = true
allow_unverified     = true       # if false, sha256 must match
allow_client_override = false     # if true, clients may use custom gfx/sfx packs
auto_download_mods    = false     # future feature
This allows:
pure vanilla universes
fully modded universes
hybrid setups
experimental universes
scenario universes

9. BALANCE, EXPLOITS, AND FAIRNESS
In deterministic multiplayer:
all players share the same modded rules
exploits become part of the ruleset
server operators decide fairness
No global anti-mod system.
No forced online patching.
No central authority restricting content.

10. HOTLOADING VS SESSION INTEGRITY
Mods cannot be hotloaded during a multiplayer session unless:
server pauses
new package list published
all clients confirm
session restarts from a snapshot
This avoids mid-session rule changes that break determinism.
Offline mode may hotload freely.

11. CROSS-UNIVERSE VERSIONING
Universe file contains package fingerprint.
Universe created with mod pack A cannot load in an environment with mod pack B.
Players may:
clone universes
migrate universes
export/import
convert with explicit tools
But engine will not implicitly transform package sets.

12. MOD COMPATIBILITY ACROSS PLATFORMS
All mod content is platform-neutral:
no platform-specific code
path formats abstracted
assets loaded via engine
all scripting sandboxed
Therefore:
Win98, Win2000, Win11, macOS 10.6, Linux, even DOS versions can load identical data
Only differences may be unavailable renderers or audio drivers
All simulation-relevant content works identically across all platforms

13. DATATYPE GUARANTEES FOR MODDERS
Simulation-level datatypes:
integers (32/64-bit)
fixed-point
rational
deterministic random state
deterministic Lua types
Modders cannot create:
platform-specific float behavior
nondeterministic ordering
race conditions
dynamic thread creation
dynamic memory loads that reorder entities
All table merges obey deterministic order rules.

14. INVALID MODS (DETERMINISM VIOLATIONS)
Engine will reject a mod if:
it attempts to run nondeterministic operations
it modifies tick order
it uses unpredictable timers
it invokes Lua os.* functions
it performs file I/O inside simulation steps
it uses external APIs
it introduces random iteration order
Invalid mods raise crisp error messages during loading.

15. MOD/UNIVERSE AUDIT TOOLS
Dominium includes:
dom_mod_inspect: displays mod contents, dependencies, deterministic validation
dom_mod_hash: prints package sha256
dom_dump_universe: prints universe package list and hashes
dom_compare_packages: compares two modsets for equality
dom_rebuild_mod: builds a dpak from source folder
All tools transparent and offline.

16. OFFICIAL DLC VERSIONING
Interstellar and Extras DLC follow same rules:
They are not hard-coded
They are packages
They follow versioning:
Interstellar: dlc.interstellar
Extras: dlc.extras
They can be updated independently
Server may require specific versions
Physical disc ships with fixed versions
The engine does not force DLC installation for offline play.

17. SUMMARY OF GUARANTEES
Modding is unrestricted in offline play.
Multiplayer requires deterministic parity but no DRM.
Package metadata is minimal and human-readable.
All merges deterministic, platform-neutral, stable.
Mods never execute unsafe or nondeterministic code.
Server operators choose enforcement level.
Modders have full freedom to extend content, graphics, audio, UI, but not engine core.
Package consistency ensures stable multiplayer for thousands of hours of gameplay.

END OF VOLUME 5.6f

Next:  
**Volume 5.6g — Replays, Demos, Input Logs & Analysis Tools**

Confirm: **proceed?**
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.6g — REPLAYS, DEMOS, INPUT LOGS & ANALYSIS TOOLS  
Dominium Multiplayer Architecture, Part 7

Purpose:  
Define deterministic replay, debugging, forensics, analysis, and archival systems used by Dominium across all platforms, all mods, and all universes.

Goals:

- Perfect determinism, byte-identical replays  
- Zero reliance on floating point or non-deterministic APIs  
- Low storage footprint  
- Works with mods, DLC, and custom universes  
- Real-time scrubbing and rewinding  
- Usable by players, developers, modders, and server operators  
- Available on Win98–Win11, macOS 10.6+, Linux, and all future ports  

No DRM, no telemetry, no online requirement.

---

# 0. Philosophy

1. **The simulation is input-driven**, not state-dumped.  
2. A replay is simply:  
   - a snapshot  
   - plus a stream of inputs  
   - plus a mod package fingerprint  
   - plus deterministic tick ordering  
   - plus metadata  
3. No randomness.  
4. No divergence allowed.  
5. If divergence happens, the engine stops immediately and reports the exact tick and entity.

---

# 1. Replay File Structure

A `.domreplay` file contains:

header
engine_version
universe_seed
replay_start_timestamp
sim_start_tick
package_manifest[]
compression_type
replay_uuid
snapshot
serialized world state
inputs[]
tick_number
input_events[]
analysis_metadata
optional_chunks

### Header is fully deterministic
- No local timestamps except optional metadata fields  
- No machine-dependent floats  
- Everything uses fixed-width integers and fixed seeds

### Snapshot
Minimal canonical binary encoding:
- Entities
- Buffers
- Networks
- Clocks
- Research states
- Worker states
- Inventories
- Vehicle positions
- Power/data/fluids networks

### Inputs
Only the **authoritative inputs**:
- Player actions  
- Player UI commands  
- AI decisions  
- Mod script inputs  
- External sync events  
- Universe rules (e.g., weather seed adjustments)

Inputs are delta-encoded and optionally compressed via zstd or LZ4.

---

# 2. Replay Determinism Enforcement

When loading a replay:

1. Engine loads packages and verifies fingerprints  
2. Engine loads snapshot  
3. Engine begins ticking  
4. Engine replays input stream  
5. At every N ticks (default 600), engine computes hash of critical state

If hash mismatch:
- Replay halts  
- Dump diagnostic trace  
- Produce diff of expected vs actual  
- Offer hex dump of divergent entity  
- Provide direct link to offending mod script

This allows modders and server operators to pinpoint determinism breaks.

---

# 3. Snapshot System

Snapshots are generic binary blobs compressed with zstd.

Types:

- **Full snapshot** (default every 10k–100k ticks)
- **Mini snapshot** (small incremental snapshots)
- **Volatile snapshot** (RAM only, for quick rewinds)
- **Stable snapshot** (saved to disk)

Snapshots allow:

- rewind  
- pause and inspect  
- re-simulate from arbitrary tick  
- branch to new universes  
- local debugging  
- server-side crashes to restore instantly

Servers may store only snapshots, rotating them based on policy.

---

# 4. Fast-Forward, Rewind, Branching

### Fast-forward
Replay can simulate at:
- 1×  
- 2×  
- 4×  
- 8×  
- unlimited speed (UPS uncapped)

Since simulation is deterministic, speed has no effect on correctness.

### Rewind
Possible via loading the closest prior snapshot and replaying forward.

### Branching (FORK)
User selects a tick → engine creates a *forked universe file*:

myuniverse.dom (original)
myuniverse-branch-123456.dom (new)

This enables:
- alternative decisions  
- scenario testing  
- speedrun practice  
- mod compatibility verification  

---

# 5. Incremental Replay Encoding

To minimise file size:

1. Inputs delta-encoded per tick  
2. Zero events omitted  
3. Use varint encoding  
4. Use bit-packing for flags  
5. Input quanta < 16 bytes/tick typical  

Expected replay sizes:

- Idle server: ~1 KB/minute  
- Heavy play: ~50 KB/minute  
- 100h game: ~300 MB compressed  
- With snapshots: +50–200 MB

Replay retention is configurable.

---

# 6. Replay Viewer

Provided as separate executable:

dom_viewer.exe

Capabilities:

- Step tick-by-tick  
- Jump to snapshot  
- Slow-motion  
- Reverse stepping (via pre-snapshot rewind)  
- Scrub bar at microsecond precision  
- Show overlays:
  - Power flow
  - Data packets
  - Fluids and pressure
  - Pathfinding graphs
  - Vehicle routes
  - Worker tasks  
  - Heat maps (density, traffic, resource flow)
- Export as:
  - MP4 (software encoder)
  - PNG sequence  
  - CSV (input stream)
  - JSON (entity state dump)
- Zero-GPU mode for Win98 machines

Viewer uses **Level 1 or Level 0 visual mode** (2D vector or TUI) unless GPU available.

---

# 7. Demo Files (“.domdemo”)

Demonstrations are lightweight, no-snapshot replays containing only:

- input log  
- seed  
- package manifest  

Used for:
- speedrunning  
- esports scenarios  
- extremely small file sizes (~100 KB/hour)

Demonstrations require the universe to be reconstructed from scratch.  
They are invalidated if mods change.

---

# 8. Input Logs (“.dominput”)

Raw input logs are independent of replay state.

Contain only:
- player input events  
- tick stamps  
- compatible metadata  

Used for:
- input replay in UI testing  
- reproducing performance bugs  
- AI behaviour testing  
- deterministic stress tests  

Log size: ~1–2 MB/hour.

---

# 9. Forensic Mode

For debugging determinism violations:

- Engine enables verbose hashing  
- Engine logs entity-level deltas  
- Produces JSON diff for divergent states  
- Logs all Lua script entry/exit points  
- Records last 1024 random numbers (fixed RNG)  
- Captures all network packet timing  
- Logs every scheduling slice for concurrency sim

Forensic mode disabled by default (performance-heavy).

---

# 10. Multiplayer Integration

### Live replay streaming  
Server can send replay data to spectators:

- No access to hidden information (fog-of-war filtered)  
- No effect on determinism  
- Stream is essentially:  
  - snapshot + input stream (filtered)  

### Server replay archives  
Servers maintain:
- rotating hourly replays  
- crash recovery logs  
- suspect logs for debugging mods  
- long-term archive for tournaments

### State rollback across clients  
Replays assist in instant rollback on rare desyncs.

---

# 11. Replays and Mods

Replay includes:
- hash of mod list  
- exact versions  
- exact load order  
- deterministic seed  
- optional content diff for local analysis

Replay refuses to load if:
- modset differs  
- hash differs  
- mod is missing

Offline mode can override mismatch for debugging.

---

# 12. Export and Analytics Tools

Bundled tools:

dom_replay_trim # cut sections
dom_replay_concat # stitch segments
dom_replay_to_json # decode replay
dom_replay_to_csv # export input list
dom_replay_stats # UPS/FPS/load analysis
dom_replay_hash # verify determinism
dom_scenario_builder # generate scenarios from replays
dom_spectator # standalone viewer

All tools available for Windows 98+, macOS, and Linux.

---

# 13. Optional Privacy Mode

All timestamps can be stripped.  
All usernames can be anonymised.  
All metadata can be replaced with nulls.

No DRM.  
No authentication.  
No usage reporting.  
Replays 100% local and offline.

---

# 14. Summary of Guarantees

- Perfect determinism in replays across platforms  
- Multiplatform: Win98–Win11 / macOS 10.6+ / Linux / future ports  
- Rewinds, fast-forwards, branching  
- Debugging and mod development tools  
- Lightweight demo format  
- Secure-input logging  
- Spectator support via input-stream replication  
- Zero DRM, full local control  
- Fully compatible with headless servers  
- Precise tick-level reproducibility  

---

# END OF VOLUME 5.6g
Next in sequence:
Volume 5.7 — Savegame Architecture & Universe Serialization
Confirm to proceed.
You said:
Before we proceed with 5.7... I do want to integrate with steam discord gog Spotify YouTube twitch etc. How should we design our content and mod portal? Can we synchronise and integrate steam workshop and a self hosted portal and any other services? Can we make it manageable in launcher or in game? Can we make it work if all services are disconnected? What about achievements, replays, screenshots, etc?
ChatGPT said:
Thought for 23s
GPT-5.1 — 2025-11-30
You want full integration with the ecosystem but zero hard dependency. The only sane way is: offline-first core, pluggable adapters for every service, and a unified content/achievement layer that never affects simulation.
I’ll lay it out in pieces.

1. Core principles (non-negotiable)
Offline-first.
Game, mods, saves, replays, screenshots all work with no network and no platform services.
Any external integration is a cache or a mirror of local state, not the source of truth.
Platform-agnostic content format.
Everything is dpak packages with package.toml (what we already specced).
Steam Workshop, GOG, “self-hosted portal”, etc. are distribution channels for dpaks, not different mod formats.
Adapters, not entanglement.
“Steam adapter”, “GOG adapter”, “Discord adapter”, “Twitch/YouTube presence adapter”, “Self-hosted adapter”.
If the adapter isn’t present or the service is unreachable, the rest of the system continues unaffected.
Determinism firewall.
External services must not change simulation:
No net-driven randomness.
No “online events” altering economy, etc.
Achievements, screenshots, rich presence are read-only observers.

2. Unified Content & Mod Portal Architecture
2.1 Internal concept: Content Registry
Introduce a core module:
core/content_registry/
It knows about:
Installed packages (from data/ and mods/)
Their metadata, versions, dependencies, conflicts
Which are active per universe
It doesn’t care where they came from.
2.2 External concept: Content Sources
Define a simple interface:
interface IContentSource {
    id: string               # "local", "steam", "selfhosted", "gog", "nexus", ...
    display_name: string

    list_catalog(filters) -> [RemoteItem]    # Browse available items
    get_item_metadata(item_id) -> Metadata
    download_item(item_id, dest_dir)         # Emits a dpak or folder into mods/
    check_updates(local_package) -> UpdateInfo
}
Concrete implementations:
LocalSource
Scans mods/, data/, removable media.
Always available.
SelfHostedSource
Talks to your own HTTP/REST “Dominium Portal”.
This portal just hosts .dpak + JSON metadata.
SteamWorkshopSource
Wraps Steamworks API to list Workshop items tagged for Dominium.
For each Workshop item, you export/unwrap into a mods/author.id/ dpak structure after download.
GOGSource, EpicSource, etc.
Same pattern if you care to add them later.
If network is down, only LocalSource works. Nothing breaks.
2.3 Unified UI: launcher + in-game
Use one shared “Content Manager” module that’s callable from:
Launcher (“Mods & Content” tab)
In-game menu (“Mods / Data Packs”, “Graphics Packs”, etc.)
Capabilities:
Browse sources: Local, Steam Workshop, Self-Hosted, etc.
Search, filter, sort (by author, rating, size, version).
Install / uninstall / update mods.
Enable/disable mods for current profile or universe.
Show dependency tree and compatibility status.
Show external link (Workshop page / self-hosted page) as a URL.
All of this must map back to your existing dpak architecture and load-order rules.

3. Steam / GOG / Discord / Twitch / YouTube / Spotify integrations
You treat each as a thin, optional adapter layer.
3.1 Steam
Components:
Workshop Adapter
Mapping: WorkshopItemID ↔ dpak package.
On “Subscribe”:
Steam downloads to a depot cache.
Your game copies/unpacks into mods/steam/<workshop_id>/.
Generate/update package.toml if needed.
On “Unsubscribe”:
Optionally remove local data, or just disable it.
Achievements Adapter
Dominium has its own internal achievement system.
Steam adapter synchronises:
dom_achievement_X_unlocked → SteamUserStats->SetAchievement("ACH_X").
Rich Presence / Friends Join
Publish:
planet / area / property
universe name
playing mode (offline/online/server)
Allow “join game” via your own JoinByIP or rendezvous.
Screenshots
You implement an internal screenshot mechanism (PNG to screenshots/).
Steam adapter optionally forwards them via Steam screenshot API when on Steam.
Replays
Keep replays local (.domreplay).
Optionally add a button “Upload replay to Workshop” which simply:
wraps .domreplay + metadata in a Workshop item
it’s just another dpak or data blob.
3.2 GOG / others
Same pattern:
Use their SDK to mirror achievements and some stats.
Maybe use their own “mods” or “cloud saves” if they have them.
Internally, you do not fork formats—everything is still dpak.
3.3 Discord
Rich presence and “Join via Discord”:
Show what universe, rough progress, current property/planet.
Invite link calls into your normal join code.
Optional voice overlay:
Outsourced to Discord. You don’t embed audio; you only expose metadata.
No sim-critical functionality.
3.4 Twitch / YouTube
Keep it simple:
Streaming:
You do not embed streaming tech. The player uses OBS/other capture.
You can provide:
an in-game “Streamer HUD” layout that hides spoilers, debug info, etc.
a “streamer mode” that anonymises worker/company names.
Chat integration (optional):
Non-deterministic by default, so you keep it visual only:
overlay chat in UI
no direct effect on sim
If you want chat-driven gameplay, that has to be completely separated / flagged as nondeterministic mode.
Replays export:
Provide export to video (or frame sequence) for editing/upload.
3.5 Spotify / Music
The correct approach:
Dominium has internally shipped OST as music dpaks.
Spotify integration is a cosmetic “Now Playing Dominium” presence plus maybe a link to official playlists.
Do not rely on Spotify for in-game audio (streaming is latency and DRM hell; not worth tying to sim).

4. Achievements, replays, screenshots: architecture
4.1 Achievements
You need an internal, deterministic achievement engine:
Trigger sources:
simulation events (tick N)
aggregated progress stats
Conditions:
expressed in pure data / script (Lua) but only reading deterministic state
Storage:
config/achievements_local.toml per user
Sync:
Platform adapters translate local unlocks to:
Steam achievements
GOG Galaxy achievements
“self-hosted profile” if you add that in future
Achievements must never feed back into game logic.
Impact on determinism: zero.
4.2 Replays
You already have 5.6g. Integration is:
Motivation:
Export replays to:
self-hosted portal (HTTP upload)
Workshop items
generic file system
UI:
“Share replay” button: open a dialog listing available destinations.
“Download replays” tab in Content Manager, same as mods but a different content type.
Nothing in replay architecture changes for service integration.
4.3 Screenshots
Implement:
screenshots/YYYYMMDD-HHMMSS-<tag>.png
Optional adapters:
Steam: push to Steam Cloud / Steam Screenshot UI.
Self-hosted: optional upload / link generator.
All optional. If offline, they just save locally.

5. Working when everything is disconnected
You need a clear offline behaviour spec.
When no external service is reachable:
Content Sources:
Only LocalSource is active.
Remote catalogs display “offline” status, but game still loads and sorts local mods as usual.
Achievements:
Internal tracking continues.
External sync is queued; adapters attempt to flush when service becomes available again.
Replays:
Fully functional: record, view, export.
Screenshots:
Saved to disk only. No uploads.
Presence / streaming / rich presence:
Disabled silently.
No error popups for normal play. Only optional warnings in a “network” status panel.

6. Launcher vs in-game management
You should centralise around one “content/identity subsystem” and expose two surfaces:
Launcher Content/Accounts UI
Configure linked services:
login/out of Steam/GOG/etc (where needed)
toggle Discord/Twitch presence
Manage mods:
browse, install, uninstall, update
Configure what accounts are primary for achievements.
In-Game Content UI
A safe subset:
Enable/disable mods for new universes
See which mods are active in this universe
View metadata, changelog, dependencies
Export/share scenario or replay
In-game should not change core package set of running universe; only for next session. That keeps determinism and complexity manageable.

7. Self-hosted portal details
If you build your own “Dominium Portal”:
7.1 Data model
On the server:
mods/:
*.dpak blobs.
index.json:
For each mod:
id, version, sha256
title, description
tags, author
required engine versions
download URL
preview images, etc.
On the client:
SelfHostedSource fetches index.json, caches it.
Uses download URLs to grab dpaks into mods/portal/<mod-id>/.
7.2 Offline
Client keeps a cached catalog, but obviously can’t download new mods when offline.
Installed mods remain usable.

8. Keeping it manageable and clean
You avoid mess by:
Single internal format: dpaks + manifests.
Single central registry: the engine only knows dpaks and the load graph.
Thin adapters: each service is just:
a way to query mod metadata
a way to download/upload dpaks
optionally a way to mirror achievements/stats.
Hard separation:
Simulation / determinism core
Presentation (render/audio)
Portal/integration layer
All of this sits at the top; you can cut it entirely and the base game still functions on Win2000 with SDL1 and software renderer.

You can fold this into a new volume later (e.g. “5.8 — External Services & Content Portal”) if you want the spec fully formalised.
You said:
I want it formalized yes, we will add it to the end of volume 5. For now, we will continue with 5.7
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.7 — SAVEGAME ARCHITECTURE & UNIVERSE SERIALIZATION

Dominium Engine Specification — Volume 5.7  
Scope: Savegames, serialization, compression, upgrades, backups, universes, properties, and cross-platform persistence.

This volume defines:

- How universes, properties, and player state are serialized
- How saves are structured on disk
- How versions and migrations work
- How determinism is preserved across save/load
- How backups, autosaves, rolling saves operate
- How mods and DLC interact with save format
- How servers persist long-running universes

No DRM, no online requirement, fully offline-capable.

---

## 0. GOALS & CONSTRAINTS

1. **Deterministic**  
   Loading a save must restore world state *exactly* as if the simulation had advanced to that tick without interruption.

2. **Stable**  
   Save format must be:
   - platform-independent
   - endian-neutral
   - forward- and backward- upgradable (with defined limits)

3. **Mod-aware**  
   Saves are tied to a specific package set:
   - packages and versions stored in save header
   - load fails cleanly if packages are missing or mismatched (unless explicitly overridden offline)

4. **Chunked & scalable**  
   Can handle:
   - large universes
   - many properties
   - many planets/systems
   - sparse activation (not all chunks loaded at once)

5. **Resilient**  
   Support:
   - autosaves
   - rolling backups
   - crash-safe atomic writes

6. **Transparent**  
   Layout is documented and introspectable; external tools can read/edit with some care.

---

# 1. SAVE STRUCTURE OVERVIEW

A *savegame* is a directory with a manifest and multiple binary blobs.

Example:

saves/
my_universe_01/
save.toml
universe.dat
planets/
planet_earth.dat
planet_mars.dat
properties/
prop_000001.dat
prop_000002.dat
chunks/
chunk_earth_0000_0000.dat
chunk_earth_0000_0001.dat
...
players/
player_isaac.dat
player_ai_001.dat
economy.dat
climate.dat
research.dat
rng_state.dat
snapshots/
snap_00000000.dat
snap_00010000.dat
backup/
...

A *universe file* (`*.domuniverse`) for distribution/backup is a compressed archive of that directory (e.g. zip or custom container).

---

# 2. SAVE MANIFEST: `save.toml`

The canonical metadata file:

```toml
[meta]
format_version = 1          # Save format version
engine_version = "1.0.0"    # Dominium engine version
universe_name  = "MyUniverse01"
created_at     = "2025-11-30T12:34:56Z"
last_saved_at  = "2025-12-01T00:01:23Z"
tick           = 1234567
rng_seed       = 987654321

[packages]
count = 5

[[packages.list]]
id      = "core.base"
version = "1.0.0"
sha256  = "..."

[[packages.list]]
id      = "dlc.interstellar"
version = "1.0.0"
sha256  = "..."

[[packages.list]]
id      = "mod.author.foo"
version = "1.2.0"
sha256  = "..."

[settings]
canonical_ups      = 60
difficulty         = "standard"
universe_seed      = 424242
fog_of_war         = true
permadeath         = false
This manifest:
identifies the universe
pins the engine version and package set
stores global simulation parameters

3. BINARY FORMAT PRINCIPLES
All *.dat files obey:
little-endian integers
fixed field ordering
no direct pointers
offset tables for variable-length blocks
versioned structs with tagged fields for forward extension
optional compression (LZ4 or zstd) at the file level
Base wrapping structure:
struct DomFileHeader {
    uint32 magic;      // "DOMF"
    uint16 version;    // file format version
    uint16 flags;      // compression flags, etc.
    uint64 length;     // uncompressed length
    uint64 crc64;      // optional integrity check
};
Followed by file-type-specific payload.

4. UNIVERSE CORE FILE: universe.dat
Contains:
global calendar
climate summary
galactic map
system map
planet list references
area/continent/region metadata
interplanetary transport schedules
global RNG state
global economy hooks
Structure:
struct UniverseData {
    uint64 tick;
    uint64 universe_seed;

    // Time
    int32 year;
    int16 month;
    int16 day;
    int32 day_of_year;
    int32 seconds_since_midnight;

    // Climate meta per planet index
    uint16 planet_count;
    PlanetSummary planet_summaries[planet_count];

    // Galactic / system graphs
    uint16 system_count;
    SystemSummary system_summaries[system_count];

    // Global economy state
    EconomySummary economy;

    // Global RNG state
    RNGState global_rng;

    // Additional tagged sections for future extension
    // (e.g., war system, diplomacy system when DLC)
};
All heavy-detail data per planet/property goes into dedicated files.

5. PLANET FILES: planets/planet_<id>.dat
Per planet:
local climate state
orbital parameters
land/water distribution summary
biome distribution
sea level & tides model
mapping from “area” / “continent” IDs to chunk references
Structure (simplified):
struct PlanetData {
    uint32 planet_id;
    char   name[64];

    // Orbit & rotation
    double semi_major_axis_m;     // stored as scaled integer internally
    double eccentricity;
    double obliquity_deg;

    // Climate backbone
    float  global_temp_anomaly;
    float  greenhouse_ppm;
    float  albedo;
    float  ocean_heat;
    float  land_heat;

    // Area/continent index (logical)
    uint32 area_count;
    AreaMeta areas[area_count];

    // Sea level / coastline meta
    float sea_level_m;
    uint32 coastline_seed;       // for terrain generation consistency

    // Future extension tags
};
Large terrain / chunk data lives in chunks/.

6. PROPERTY FILES: properties/prop_<id>.dat
Each property file contains:
property ID and name
owner company
coordinates on planet
bounding extent
property-wide parameters (tax rules, laws, zoning)
list of local chunk references
local RNG seed
Structure:
struct PropertyData {
    uint64 property_id;
    char   name[64];
    uint32 planet_id;

    // Location in planet coordinates
    int64 origin_x_m;    // global coordinate meters
    int64 origin_y_m;
    int64 width_m;
    int64 height_m;

    // Governance & config
    uint64 owner_company_id;
    uint32 property_flags;
    uint32 zoning_profile_id;

    // Chunk references
    uint32 chunk_ref_count;
    ChunkRef chunk_refs[chunk_ref_count];

    // Property-specific RNG
    RNGState property_rng;

    // Local policies, e.g., taxation, labour rules, power export/import
};

7. CHUNK FILES: chunks/chunk_<planet>_<cx>_<cy>.dat
Chunk files serialize spatial simulation state at chunk level:
terrain heights
ground materials
buildings and structures
networks (power, data, fluids, transport)
vehicles and workers inside the chunk
per-chunk pathfinding caches
subchunks for efficient loading
Chunk identifier:
planet_id
chunk_x, chunk_y (e.g., 256m tiles)
layer optional (if vertical slicing introduced later)
Structure:
struct ChunkData {
    uint32 planet_id;
    int32  chunk_x;
    int32  chunk_y;

    uint32 version;

    // Terrain
    TerrainBlock terrain;

    // Structures
    uint32 building_count;
    Building building_list[building_count];

    // Machines
    uint32 machine_count;
    Machine machine_list[machine_count];

    // Networks (summaries + references to network cores)
    NetworkSummary power;
    NetworkSummary data;
    NetworkSummary fluids;
    NetworkSummary transport;

    // Entities present in chunk (workers, vehicles)
    uint32 entity_count;
    EntityRef entity_list[entity_count];

    // Chunk-level RNG state
    RNGState chunk_rng;

    // Pathfinding caches / navmesh (optional, can be regenerated)
    NavMeshData nav_data;

    // Tagged extensions
};
Note: Some network data may be stored centrally instead (per property or per planet). We keep both options open with NetworkSummary referencing central storage.

8. PLAYER / COMPANY FILES
players/player_<id>.dat
Contains:
player identity
UI config
keybindings
camera state
achievements (local)
property/company associations
Simulation-relevant player state (e.g. funds if personal) goes into the company file.
Structure:
struct PlayerData {
    uint64 player_id;
    char   name[64];

    // UI configuration
    uint32 ui_flags;
    uint32 preferred_view_mode;  // 2D/3D
    float  camera_zoom;
    int32  camera_x;
    int32  camera_y;
    int32  camera_z;

    // Associated company
    uint64 company_id;

    // Achievements & progress markers
    uint32 achievement_count;
    AchievementState achievements[achievement_count];

    // Keybindings, control scheme, etc. (not sim-critical)
};
companies/company_<id>.dat
Contains:
company finances
assets
research progress
property list
contracts and trades
worker rosters

9. ECONOMY & MARKET FILE: economy.dat
Contains:
base commodity definitions (IDs)
global and per-region prices
order books for physical trades
futures/options if enabled
random events seeds (for scenario-specific volatility)
aggregated production/consumption stats
All in integer/fixed-point units.

10. CLIMATE & WEATHER FILE: climate.dat
Contains:
per-planet climate backbone state (as defined in Vol. 4)
cached climate bands
current weather “episodes” per region
overall climate time-series indexes
Updates at low UPS (e.g. UPS=1), deterministic.

11. RNG STATE FILE: rng_state.dat
Optional central file for all RNG sequences, or included in universe.dat and per-chunk/per-property data.
Contains:
global RNG sequences
seeds for subsystem RNGs
RNG state must be restored exactly on load to preserve perfect determinism.

12. SNAPSHOTS IN SAVE FORMAT
In addition to standard saves, a universe can hold:
snapshots/snap_<tick>.dat
Each snapshot is effectively a minimized universe state:
only the data needed for rollback / replay startup
can be partial (only active properties/chunks)
Snapshot format is similar to a compressed bundle of the above files, but more compact and tuned for fast load.

13. SAVE / LOAD PIPELINE
13.1 Saving
Freeze simulation at tick N (no further ticks applied).
Compute state hash for N.
Serialize all dirty or scheduled-to-save regions:
universe core data
modified planets
modified properties
modified chunks
economy/climate/research updates
Write to temporary directory saves/<name>.tmp/.
After successful write and flush:
move previous save dir to backup/ (rolling system)
rename <name>.tmp/ to <name>/ atomically if possible
Update master list saves/index.toml.
13.2 Loading
Read save.toml.
Verify package list vs installed packages.
Load universe.dat.
Load planet & property metadata into minimal structures.
Load necessary chunks (lazy load others on demand).
Restore RNG state.
Verify state hash (if stored).
Resume simulation at tick N+1.

14. VERSIONING & MIGRATION
Each save.toml and DomFileHeader has format_version.
14.1 Engine vs Save format
Engine version may evolve faster than save format version.
Save format version increments only when incompatible layout changes occur.
14.2 Migration Strategy
When engine loads an older save:
Detect save format version.
Run migration steps in strict monotonic order:
v1 → v2, v2 → v3, …
Each migration is deterministic and pure:
defined as data transforms
no random
no world-changing semantics beyond layout and new-field defaulting
If migration path does not exist, engine refuses to load save.
14.3 Modded Saves
Mods may also have their own version markers in their data.
Engine hooks allow mod authors to:
provide migration scripts for their own data
run them during save load
If mod migrations fail or are missing → save cannot be loaded with that mod set.

15. AUTOSAVES, ROLLING SAVES, BACKUPS
15.1 Autosaves
Configurable:
[autosave]
enabled          = true
interval_ticks   = 36000   # every 10 minutes @ 60 UPS
slot_count       = 5       # rotate slots
Autosaves created as:
my_universe_autosave_01/ … 05/
15.2 Manual Saves
Player-named directories.
No implicit deletion.
15.3 Backups
On successful save:
previous non-autosave version moved to backup/ with timestamp.
optional retention count (e.g., keep last 3).
15.4 Crash Survivability
Use .tmp directory then atomic rename.
Never modify existing save directory in place.

16. COMPRESSION & PERFORMANCE
Strategically apply compression:
universe.dat, economy.dat, climate.dat — medium compression.
chunks/*.dat — lightweight compression (LZ4).
snapshots/*.dat — pick LZ4 or zstd depending on “speed vs size” setting.
Expose performance options:
[save]
compression_level = "fast"   # fast | balanced | max
chunk_save_mode   = "dirty"  # dirty | all
“dirty” = only save chunks that changed since last save.

17. INTERACTION WITH NETWORKING & REPLAYS
17.1 Networked Universes
Servers periodically:
take snapshots (snapshots/)
write long-term saves at configurable intervals (e.g. every 30 minutes)
On crash:
server can restart from last save or snapshot + replay log.
17.2 Replays
Replays (5.6g) store:
reference to universe_name and starting_save
or embed a snapshot
The savegame and replay system are complementary:
Save: snapshot of full state, possibly with partial history
Replay: pure input stream + seed + snapshot

18. OFFLINE VS ONLINE AND MODS
Saves are:
valid offline
fully functional without platform services
unchanged by Steam/GOG/Discord presence
Mod rules:
Save includes required package set.
Multiplayer servers enforce parity.
Offline clients can override and load in “unsafe” mode for experimentation, via config:
[debug]
allow_mod_mismatch_load = true
Unsafe loads are visibly labelled in UI.

19. TOOLING FOR SAVE INSPECTION
Ship official tools:
dom_save_inspect <save_path>
prints high-level summary (tick, packages, properties, planets, stats)
dom_save_list_chunks <save_path>
prints list of chunks, sizes, last touched tick
dom_save_dump_binary <file>
decodes a given *.dat into JSON for debugging
dom_save_verify <save_path>
checks internal CRC/hashes for corruption
All tools offline and cross-platform.

20. SUMMARY OF GUARANTEES
Save format is deterministic and platform-independent.
Save/load yields exact same universe state at tick N.
Packages & mods are pinned and verified.
Chunks and properties are chunked for scalability.
Backups, autosaves, snapshots protect against corruption and crashes.
Versioning + migration make saves long-lived.
All functionality remains fully offline-capable and DRM-free.
Integration with networking and replays is clean: saves as base, replays as history.

END OF VOLUME 5.7

::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
The next volume in sequence is:
VOLUME 5.8 — EXTERNAL SERVICES, INTEGRATIONS & CONTENT PORTAL
(the formalised version of the system we discussed before 5.7)
Before generating the full volume, I need one confirmation:
Do you want Volume 5.8 structured like prior volumes (dense technical spec, 15–30 sections, full MD), or further subdivided (5.8a–f) like 5.6?
Options:
A — Single unified Volume 5.8
Very long, fully integrated
Covers Steam, GOG, Discord, Twitch, YouTube, Spotify
Covers the unified portal system
Covers content sources, dpaks, achievements, screenshots, replays
Covers offline behaviour
One document
B — Split:
5.8a Content Sources (Local, Steam, GOG, Self-hosted, API)
5.8b Workshop/Portal Sync & Mod Distribution
5.8c Achievements, Presence, Rich Presence, Telemetry-less design
5.8d Screenshots, Replays, Sharing
5.8e Identity & Accounts (optional)
5.8f Offline Mode & Service Degradation
Reply:A or B.
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
We proceed with Volume 5.8a.
Below is the complete, formal, engine-spec compliant document.

# VOLUME 5.8a — CONTENT SOURCES & PLATFORM-NEUTRAL DISTRIBUTION  
Dominium Engine Spec — External Services Integration, Part A

Purpose:  
Define how Dominium discovers, catalogs, installs, updates, validates, and removes all externally-acquired content (mods, DLC, graphics packs, sound packs, replays, tools) while remaining fully offline-capable, deterministic, cross-platform, and service-agnostic.

This layer is a *non-simulation* subsystem.  
It cannot affect determinism.  
It cannot be required for offline play.  
It cannot introduce DRM.

This volume is the foundation for further volumes (5.8b–f).

---

# 0. DESIGN PRINCIPLES

1. **Offline-first**  
   The only mandatory content source is `LocalSource`.  
   All external sources (Steam, GOG, Self-hosted, etc.) are optional adapters.

2. **Platform Neutral**  
   All external platforms deliver the same internal format:  
   **dpak** (Dominium Package Format).

3. **Unified Discovery & Installation**  
   All content sources respond to the same interface, allowing the launcher and in-game UI to browse and install content identically.

4. **Determinism Firewall**  
   External content cannot modify:
   - runtime simulation ordering  
   - deterministic event loops  
   - floating point randomness  
   - networking logic  
   - tick scheduling  
   - package merge order  
   Content sources only provide packages; loading/merging is governed by internal rules.

5. **Human-Readable Metadata**  
   Outside dpak archives, all catalogs and manifests use JSON or TOML.

---

# 1. CONTENT SOURCE MODEL

A **Content Source** is a modular adapter implementing:

```pseudo
interface IContentSource {
    string id;                     # e.g. "local", "steam", "selfhosted"
    string display_name;           # shown in UI
    bool   available();            # online or reachable

    List<RemoteItem> list_catalog(Filter);
    Metadata get_metadata(ItemID);
    DownloadResult download(ItemID, dest_path);
    UpdateInfo check_update(LocalPackage);
}
This API enables:
browsing catalogs
obtaining metadata
downloading dpaks
checking for updates
Sources must be read-only:
No external source can delete or modify local data.

2. BUILT-IN CONTENT SOURCES
2.1 LocalSource (mandatory)
Always available.
Responsibilities:
Scan directories:
data/
mods/
mods_disabled/
dlc/
assets/gfx/
assets/sfx/
replays/
Return all dpaks installed locally.
Enable manual installation via “Import dpak”.
This is the only source available on Win98 or offline.

2.2 SelfHostedSource (optional, first-class)
Communicates with a simple HTTP JSON endpoint:
GET https://myportal.example/dominium/catalog.json
catalog.json contains:
{
  "version": 1,
  "items": [
    {
      "id": "mod.author.example",
      "version": "1.0.0",
      "sha256": "...",
      "title": "Example Mod",
      "description": "...",
      "download": "https://myportal.example/dominium/mods/example.dpak",
      "preview": "https://myportal.example/images/example.png"
    }
  ]
}
Advantages:
Server is trivial to host anywhere.
No dependency on platform APIs.
Works for community servers, modding hubs, LANs, private groups.
Client caching required for offline use.

2.3 Steam Workshop Source (optional)
Uses Steamworks API.
Catalog operations:
Query Workshop items tagged Dominium
Fetch metadata (title, author, version, description)
Download via Steam client
Client extracts/unpacks as dpak into:
mods/steam/<workshopid>/
Steam Workshop item → dpak transformation rules:
If Workshop item contains a dpak: use directly.
If it contains loose files: wrap into dpak on install.
Always generate a manifest if missing.
Steam remains a distribution channel, not a mod format.

2.4 GOG Source, Epic Source, Nexus Source (optional, future)
All follow same adapter logic:
Query remote catalog via API
Download dpaks
Version and hash stored in dpak manifest
Catalog cached locally
No service is privileged.

3. REMOTE ITEM REPRESENTATION
Each item listed by an external source must provide:
[meta]
id        = "mod.author.id"
version   = "1.2.0"
sha256    = "<exact package hash>"
title     = "Mod Name"
author    = "Author Name"
summary   = "Short description"
type      = "mod" | "dlc" | "gfx" | "sfx" | "music" | "tools"

[links]
download  = "https://..."
preview   = "https://..."
homepage  = "https://..."
The engine never executes remote code.
These are metadata only.

4. DOWNLOADING & INSTALLATION PIPELINE
User selects an item from a source.
Source downloads dpak to a temporary folder:
temp/mod_<id>.dpak
Engine:
verifies SHA256
extracts dpak into:
mods/<id>_<version>/
writes dpak manifest to installed_manifest.toml
Rebuild content registry.
Notify user to reload or enable mod in the launcher.
Determinism unaffected.

5. CONTENT CATALOG CACHING
Each source may maintain:
cache/sources/<source_id>/catalog.json
cache/sources/<source_id>/previews/
Failure modes:
If online and catalog fetch fails → display stale cached catalog
If offline → use cache only
No source may block UI if it fails
This ensures the entire portal works offline.

6. SOURCE PRIORITIES & MERGING
Multiple sources may list the same mod:
First party sources (local) override remote when versions equal.
The installed version always overrides remote versions.
The UI displays both:
Installed version: 1.1.0
Remote versions available: 1.2.0 (Steam), 1.3.0 (Self-hosted)
User chooses which to install.
The engine does not auto-update mods.

7. SOURCE SECURITY
All external sources must follow:
HTTPS strongly recommended (http allowed for LAN only)
Hash checking required
No executable code imported from remote sources
dpak format isolates assets and scripts
No DRM.
No platform lock-in.

8. MULTIPLAYER INTERACTION
When joining a server:
Server sends required mod list (id, version, sha256).
Launcher highlights missing mods.
User can click “Acquire missing mods”.
The launcher selects the best available source:
Local if already installed
Steam if available
Self-hosted if configured
Otherwise show “Manual import required”
After installation, user retries join.
Server does not auto-distribute mods unless operator enables “unsafe” mode.

9. UI INTEGRATION
Content Manager (launcher and in-game UI) displays:
Local packages
Available remote packages grouped by source
Installed/outdated indicators
Thumbnails, descriptions, tags
Compatibility warnings
Buttons for:
Install
Uninstall
Update
Enable/disable
User may disable any source in launcher settings:
[content_sources]
steam        = true
selfhosted   = true
local        = true   # cannot be disabled
gog          = false
If all external sources disabled → local-only.

10. OFFLINE BEHAVIOR
If external services unreachable:
No modal errors.
Content Manager switches to “Local-only mode”.
Cached catalogs remain viewable.
Install/Update from remote disabled.
The rest of the game fully functional.
All universes and mods load normally.

11. TOOLING
Provide:
dom_content_sources_list
dom_content_sources_refresh
dom_dpak_verify <file>
dom_dpak_install <file.dpak>
dom_dpak_unpack <file.dpak>
dom_dpak_pack <folder>
All offline-capable.

12. SUMMARY
Volume 5.8a establishes:
A unified way to acquire content.
Local-first, deterministic architecture.
Optional integrations for Steam, GOG, self-hosted portals, etc.
Single dpak format for all content.
Catalog caching for offline reliability.
Safe mod acquisition for multiplayer universes.
No DRM, no mandatory online dependency.
This prepares the foundation for 5.8b (Workshop/Portal Sync & Distribution).

END OF VOLUME 5.8a

---

## Confirm: proceed with **Volume 5.8b — Workshop/Portal Sync & Mod Distribution**?
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8b — WORKSHOP / PORTAL SYNC & MOD DISTRIBUTION  
Dominium Engine Spec — External Services Integration, Part B

Purpose:  
Formalize how Dominium synchronizes, distributes, updates, and publishes mods and content across:

- Steam Workshop  
- Self-hosted Dominium Portal  
- LAN/shared folders  
- Third-party mod hosts (optional)  
- Fully offline systems  

All using the **dpak** package format established in previous volumes.

This volume specifies:

- Sync pipelines  
- Upload/download semantics  
- Cross-platform security and hashing  
- Versioning, updates, rollback  
- Multi-source conflict resolution  
- Optional auto-sync  
- Privacy and offline constraints  

---

# 0. SCOPE & NON-GOALS

This subsystem does **not**:

- execute remote code  
- validate mod legality or quality  
- enforce DRM  
- rewrite dpaks  
- alter simulation determinism  
- auto-update without user approval  

It **only** manages the distribution and discovery of dpaks.

---

# 1. SYNC PHILOSOPHY

1. **dpak is the canonical mod format**  
   Workshop and portals serve dpaks; dpaks serve the engine.  
   No platform-specific packaging.

2. **No forced online updates**  
   Player must explicitly approve updates, even on Steam.

3. **Cross-platform parity**  
   A mod uploaded from Linux works on Win98/Win11/macOS without changes.

4. **Decentralized mod ecosystem**  
   Developers can:
   - publish to Steam  
   - publish to a self-hosted site  
   - distribute dpaks directly  
   - use LAN/NAS folders  
   - use USB stick (“sneakernet mode”)

5. **Deterministic versioning**  
   Multiplayer servers require identical package IDs / versions / hashes.

6. **Offline fallback**  
   Everything functions offline using cached catalogs and installed dpaks.

---

# 2. WORKSHOP SYNC PIPELINE (STEAM)

## 2.1 Overview

Dominium uses a thin SteamWorks wrapper to handle:

- Subscriptions  
- Uploads  
- Metadata sync  
- Update checks  
- Downloading Workshop items

All Workshop items for Dominium must include or be convertible to a dpak.

---

## 2.2 Download & Install from Workshop

When a user clicks “Subscribe”:

1. Steam client downloads the Workshop content to Steam’s depot directory.
2. Dominium launcher polls Steam for updated content.
3. When detected:
   - Copy the content to:
     ```
     mods/steam/<workshop_id>/
     ```
   - If the Workshop item contains dpak:
     - Use dpak as-is.
   - If it contains raw folders:
     - Wrap into a dpak with generated `package.toml`.
4. Compute SHA256.
5. Register in content registry.

This ensures deterministic package identity independent of Steam.

---

## 2.3 Workshop Updates

Steam pushes updates to subscribed items.  
Dominium handles them as:

- “Update available” indicator  
- User clicks “Update Now”  
- Engine replaces existing package after verification

Engine does **NOT** automatically migrate an active universe to new mod versions.  
Universe files store exact version required.

---

## 2.4 Uploading to Workshop

Dominium provides a tool:

dom_workshop_upload <folder_or_dpak> --title="..." --desc="..." --tags="..."

Workflow:

1. Validate dpak structure.  
2. Compute SHA256.  
3. Build Workshop metadata (title, description, preview image).  
4. Upload via SteamWorks API.  
5. Workshop item links back to the dpak.

Uploads optional.  
Offline mode unavailable, obviously.

---

# 3. SELF-HOSTED PORTAL SYNC

## 3.1 Portal Structure

A self-hosted portal requires:

/dominium/catalog.json
/dominium/mods/.dpak
/dominium/preview/.png
/dominium/tools/*.zip

Client-only requirement: **HTTP GET**.

No dynamic backend required.

---

## 3.2 Portal Catalog

Example:

```json
{
  "version": 1,
  "mods": [
    {
      "id": "mod.author.example",
      "version": "1.1.0",
      "title": "Example",
      "download": "https://example.com/mods/example-1.1.0.dpak",
      "sha256": "...",
      "tags": ["utilities", "content"]
    }
  ]
}
Portal may optionally support:
categories
ratings
comments
changelog files
Client ignores unknown fields.

3.3 Download Process
Fetch metadata
Download dpak
Verify SHA256
Install as:
mods/portal/<id>_<version>/
No platform restrictions.
No dependency on external APIs.

3.4 Portal Upload Tool
Official tool:
dom_portal_upload --server=https://example.com --dpak=foo.dpak
Uploads dpak and updates catalog.json via:
SFTP (preferred)
SSH (preferred)
HTTP WebDAV (accepted)
Manual desktop upload if no API available
This keeps portal hosting simple.

4. LAN / FOLDER SYNC
A FolderSource can point to:
a shared network folder
a local directory
removable media (USB)
CD/DVD (for collectors’ editions)
Folder must contain:
index.json
mods/*.dpak
This enables:
LAN parties
Offline groups
Air-gapped environments
Military/industrial deployments (if ever used for training sims)
No special APIs required.

5. MULTI-SOURCE RESOLUTION POLICY
A mod might exist in multiple places:
Steam
Portal
LAN share
Local old version
Dominium presents:
Installed versions:
  local       1.0.0
  steam       1.1.0
  selfhosted  1.2.0

Recommended: install 1.2.0 (newest)
But engine does NOT:
auto-select newest version
auto-update
merge versions
The user chooses the version.
The universe requires an exact version.

6. SYNC CONFLICTS
Cases:
6.1 Different dpaks share same ID but different content
Engine displays conflict warning:
Conflict: mod.author.example
Local version: 1.1.0   sha=aaa
Steam version: 1.1.0   sha=bbb
User must select one for installation/activation.
6.2 Workshop item tries to override official DLC
Prohibited.
Engine refuses installation.
6.3 Missing dependencies
UI displays required package list.
User may click “Fetch dependencies”.
6.4 Corrupt dpak
Engine rejects file and quarantines it:
quarantine/<id>-<timestamp>.dpak

7. OPTIONAL AUTO-SYNC (NEVER FORCED)
Users can enable:
[content_sync]
auto_update_steam     = false
auto_update_portal    = false
auto_update_folder    = false
If enabled:
Launcher periodically checks for updates from active sources.
Shows non-intrusive “Updates available”.
Still requires user approval.
Auto-update never affects active universes; only mod registry.

8. PRIVACY & OFFLINE REQUIREMENTS
8.1 No telemetry
Dominium does not send:
play data
hardware data
installs list
user identity
8.2 No dependency chain
Mod portal works if all other services disabled.
8.3 Download logs stored only locally
logs/content_downloads.log
8.4 No forced login
Steam login handled externally by Steam client.
Dominium does not require accounts.

9. UI PRESENTATION RULES
Content Manager (launcher / in-game):
Each content source in left sidebar:
Local
Steam Workshop
Self-Hosted
LAN Source (if configured)
Disabled sources greyed out
For each item:
Name
Version
Installed (yes/no)
Update available
Source origin icons
Preview image
Long description
Dependencies
Changelog (if provided)
Buttons:
Install / Update / Remove
Enable / Disable
“Show in Explorer”
“Open Workshop Page”

10. SYNC IN MULTIPLAYER CONTEXT
When client joins a server:
Server sends package requirements
Client checks local registry
Missing packages flagged
Client may “Get missing mods”
Engine attempts each enabled source in priority order:
Local
Steam
Self-hosted
LAN
Manual import
If package unavailable:
Universe join refused
UI shows where to obtain package
No auto-download from server unless server in “unsafe mode”
Determinism maintained.

11. PREVIEW & THUMBNAIL HANDLING
Preview images live outside dpaks:
Steam → retrieved via API
Portal → download from preview link
LAN → optional preview.png next to dpak
Thumbnails cached in:
cache/previews/<package_id>.png
Does not affect determinism.

12. CHANGELOGS & VERSIONS
dpak may include:
docs/changelog.txt
Engine parses first block of text for UI.
Services may provide:
changelog_url
homepage_url
issues_url
All optional.

13. EXPORT & PUBLISHING FOR NON-STEAM USERS
Tool:
dom_dpak_publish --out=dist/ mymod.dpak
Outputs:
.zip for mod hosting
.dpak
.json metadata
Works offline.

14. SECURITY MODEL
dpaks validated via SHA256
No platform-specific executable code allowed
Scripts run inside deterministic sandbox
No downloading arbitrary executables
No auto-execution of downloaded content
No auto-enabling installed mods for multiplayer universes
Users may manually import dpaks from unknown sources
Signature verification optional but supported
Optional signatures (PGP/age) can be used but never required.

15. FINAL SUMMARY
Volume 5.8b establishes:
A standard, platform-neutral mod distribution pipeline
Steam Workshop and self-hosted portals as optional equals
dpak as universal content format
Syncing as user-driven, never forced
Offline mode as first-class
Determinism maintained across all scenarios
Full tooling for upload/distribution
Clear UI/UX patterns for multi-source environments
Zero DRM, zero telemetry, zero mandatory online interaction
This completes the distribution-level subsystem.

END OF VOLUME 5.8b

---

Next in sequence:  
**Volume 5.8c — Achievements, Presence, Rich Presence & Telemetry-less Design**

Confirm: proceed?
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8c — ACHIEVEMENTS, PRESENCE, RICH PRESENCE & TELEMETRY-LESS DESIGN  
Dominium Engine Spec — External Services Integration, Part C

Purpose:  
Define Dominium’s internal achievement system and its optional integrations with Steam, GOG, Discord, Twitch, YouTube, and other platforms — while guaranteeing:

- Zero telemetry  
- Zero DRM  
- No online requirement  
- No simulation influence  
- Perfect determinism  
- Full offline functionality  

This volume ensures all presence/achievement features remain **cosmetic**, **local**, and **never required**.

---

# 0. DESIGN CONSTRAINTS

1. **Achievements never affect simulation.**  
   They are observers only.

2. **Presence systems are optional wrappers.**  
   When absent, nothing changes.

3. **All progress stored locally in plain TOML.**

4. **No telemetry.**  
   Dominium never uploads:
   - player actions  
   - playtime  
   - statistics  
   - mod usage  
   - hardware data  
   - achievements  
   unless explicitly pushed to Steam/GOG by the user.

5. **All external services must gracefully degrade to OFF mode.**

---

# 1. INTERNAL ACHIEVEMENT SYSTEM

Achievements are stored locally in:

config/achievements_local.toml

Example entry:

```toml
[achievements.dominium_001]
name = "First Property"
unlocked = true
timestamp = "2025-12-01T13:55:20Z"
1.1 Achievement Definition Format
Achievements defined in:
data/achievements/*.toml
Structure:
[id]
title = "First Wind Turbine"
desc = "Construct a wind turbine"
category = "infrastructure"
visibility = "always"   # or "hidden" or "delayed"
points = 10
Achievements are pure metadata.
1.2 Triggering
Triggers read state from:
simulation events (e.g., building constructed)
economy changes
research milestones
exploration or scanning events
player-level UI events (first login, first screenshot)
Triggers are defined declaratively:
triggers/power_generated > 1000
triggers/property_count >= 5
triggers/first_time_doing_X = true
No script logic in achievements.
1.3 Unlock Pipeline
Simulation event fires
Achievements subsystem evaluates conditions
If unlocked:
write to achievements_local.toml
notify external service adapters
show popup in UI (optional)

2. ACHIEVEMENT ADAPTERS (STEAM / GOG / ETC.)
Each external platform gets a thin optional adapter:
adapters/steam_achievements.so
adapters/gog_achievements.so
...
Adapter interface:
interface IAchievementAdapter {
    bool available();
    void push_unlock(achievement_id);
    void sync_from_platform();   # optional
    void flush();
}
Rules
Adapter unavailable → silently disabled.
Unlock occurs locally regardless of external state.
Sync-to-platform occurs only if:
adapter is enabled
platform client is active (e.g. Steam running)
user opted in
Steam Example
push_unlock calls SteamUserStats->SetAchievement("ACH_ID").
GOG Galaxy Example
Similar: GalaxyAPI.Stats().SetAchievement(...).
Offline case
Unlock stored locally
External sync occurs later when platforms become available

3. RICH PRESENCE (DISCORD, STEAM, ETC.)
Dominium exposes presence data through optional adapters.
3.1 Presence Data Format
Presence structure:
{
  "universe": "MyUniverse01",
  "location_type": "planet",
  "location_name": "Earth",
  "property_name": "Greenfield Base",
  "players_online": 3,
  "mode": "building",
  "view": "2D / 3D / Headless",
  "tick": 1034456,
  "mods": 12
}
Adapters consume this and turn it into:
Steam Rich Presence
Discord Rich Presence
Others as added later
Presence does not require:
network services
Discord login
Steam login
Internet
Offline → presence is simply not broadcast.
3.2 Privacy & User Control
User toggles:
[privacy]
enable_presence = false
enable_discord  = false
enable_steam    = true
show_universe_name = false
show_property_name = false
Presence can be anonymized automatically.
3.3 Presence Persistence
Presence updates on:
tick boundaries (rate-limited)
camera movement
property changes
multiplayer join
idle/AFK periods
Adapters push updates only when available.

4. STREAMER MODE & SPOILER FILTERING
Streamer mode (local-only):
hides private universe names
anonymizes worker names
hides messages from in-game chat
hides debug overlays
allows custom “broadcast overlay” UI layer
supports manual watermarking
Streamer mode is entirely client-side cosmetic.
No simulation influence.

5. TELEMETRY-LESS DESIGN
Dominium must not:
phone home
send crash reports automatically
upload usage data
collect player statistics
sync achievements to central servers
share mod lists
log remote IP addresses
create online accounts
All tracking is local-only.
If players manually upload logs or replays, that is their choice.

6. SCREENSHOTS / SCREENCAPTURE INTERFACE
Dominium exposes a simple interface:
take_screenshot(tag) -> PNG file
Screenshots saved to:
screenshots/YYYY-MM-DD/<timestamp>-<tag>.png
Integrations
Steam: adapter triggers Steam overlay screenshot if enabled
Discord: local only; no upload
Self-hosted portal: optional manual upload by player
Screenshots are never uploaded automatically.

7. IN-GAME REPLAY SHARING INTEGRATION
Replay files (*.domreplay) can be shared:
to local filesystem
to Workshop (if adapter present)
to self-hosted portal
to LAN folder
UI provides:
“Share replay”
“Export to folder”
“Upload to Workshop”
No automatic media capture.
No external posting unless explicitly requested.

8. CROSS-PLATFORM PARITY
Every integration must degrade gracefully:
Windows 98
No adapters, no presence
All achievements local
All screenshots local
Replays fully functional
Windows 2000+
Steam (if installed)
Discord optional
All local functions available
macOS 10.6+
Steam optional
Discord optional
Local-only otherwise
Linux
Steam optional
Discord optional
Everything else local
DOS / Win95 (future)
No external services
Achievements purely offline
Identical dpak format across all platforms.

9. ENGINE BOUNDARIES & SAFETY
External services cannot:
access simulation
modify mods
modify dpaks
write to the universe
change tick order
adjust simulation speed
introduce randomness
Presence/achievements operate strictly outside the deterministic core.

10. IMPLEMENTATION DETAILS
10.1 Storage
config/
  achievements_local.toml
  presence_settings.toml
  adapters/
    steam.toml
    discord.toml
    gog.toml
10.2 Event Hooks
Event types triggering presence:
universe loaded
tick update (rate-limited)
camera change
property switch
multiplayer join
mod list change
Event types triggering achievement checks:
research completed
machine built
milestone reached
economy thresholds
skill unlocks
10.3 Adapter DLL loading
Adapters are loaded dynamically:
plugins/adapter_steam.dll
plugins/adapter_discord.dll
Missing DLL → feature disabled.

11. SUMMARY
Volume 5.8c defines:
A full internal achievement system (local-first).
Thin, optional adapters for Steam/GOG/Discord.
A rich presence API safe for privacy.
Zero telemetry, zero tracking, zero DRM.
Full offline functionality.
Streamer mode and overlay filtering.
Replay and screenshot integrations without cloud dependence.
Strong boundaries preventing external services from touching simulation.
Guaranteed deterministic, cross-platform-safe architecture.

END OF VOLUME 5.8c

Next in sequence:  
**Volume 5.8d — Screenshots, Replays, Sharing & Media Integration** (more detailed than 5.6g, covering external integrations).  

Confirm: proceed?
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
Next document: Volume 5.8d will now be generated exactly in the established format.
Before I produce it, I need the branching choice for the replay system:
Replay Format Choice (affects entire volume 5.8d)
Dominium can implement deterministic replays in one of two canonical ways.

A — Input-Log Replays (Factorio-style)
Store only player inputs, UI actions, and network messages
Simulation replays deterministically from the initial seed
Ultra small file sizes
Full fidelity
Absolutely deterministic
Cannot “fast-scrub” or seek without re-simulating from start
Perfect for long games, multiplayer, huge universes
This is the correct choice if determinism is top-priority.

B — State-Snapshot + Diff Replays (Cities Skylines / RTS style)
Store periodic snapshots (every N ticks)
Store diffs between snapshots
Larger files
Allows seeking and fast-forward
Replay is not purely simulation-driven
More CPU required to encode
Far more disk I/O
Useful for cinematic tools, streaming, debugging
Determinism still maintained but more complex

C — Hybrid (A + lightweight periodic snapshots)
Input log is the canonical replay
Snapshots assist with fast-forward and jump-to-time
Snapshots are ignored for simulation correctness
Still fully deterministic because snapshots are advisory only
Good compromise for extremely long universes
Allows advanced replay viewer UI
This is the approach recommended for your game because:
Players may run multi-year simulations
Universes can be extremely large
You want first-person + 2D map replay
You want cinematic mode + export
You need full determinism
Snapshots would only be used for viewer UX, not simulation
Works on Win2000 and Linux without heavy load

Choose A, B, or C.
Your choice determines the entire structure of Volume 5.8d.
You said:
C. We should be able to store just replay inputs style, just snapshot replay, or both.
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8d — SCREENSHOTS, REPLAYS, SHARING & MEDIA INTEGRATION  
Dominium Engine Spec — External Services Integration, Part D

Scope:

- Hybrid replay model: input-log, snapshot, and combined
- Replay file formats and storage policies
- Replay viewing, scrubbing, exporting
- Screenshot capture and management
- Integration hooks for Steam / Workshop / self-hosted portal / others
- All strictly non-simulation, non-DRM, fully offline-capable

This extends 5.6g’s deterministic replay core with external-facing and UX-level details.

---

# 0. REPLAY MODEL: HYBRID (INPUT-LOG + SNAPSHOTS)

Dominium supports **three replay modes**, all using the same deterministic sim core:

1. **Input-Log Replays (canonical)**  
   - `.domreplay`  
   - Minimal: seed + package manifest + input stream  
   - Deterministic reference for correctness and desync detection  

2. **Snapshot-Only Replays (cinematic)**  
   - `.domsnap`  
   - Sequence of state snapshots, no guaranteed re-simulation  
   - Used for cinematic tools, promo, and archival where determinism is not mandatory  

3. **Hybrid Replays (combined)**  
   - `.domrplx` (container)  
   - Contains:
     - canonical `.domreplay` input-log  
     - optional embedded snapshot(s) for fast seek  
   - Simulation correctness derives **only** from the input-log; snapshots are hints for viewer UX.

---

# 1. FILE TYPES & STRUCTURE

## 1.1 Input-Log Replay: `*.domreplay`

Core canonical format:

```text
DomReplayHeader
SnapshotHeader?        # optional single base snapshot
InitialSnapshotBlob?   # or reference to external save
InputStreamBlocks...
MetadataBlock
Header fields:
struct DomReplayHeader {
    uint32 magic;          // "DORP"
    uint16 version;
    uint16 flags;
    uint64 start_tick;
    uint64 end_tick_est;
    uint64 universe_seed;

    // Pointers to sections
    uint64 offset_manifest;
    uint64 offset_snapshot;   // 0 if none
    uint64 offset_inputs;
    uint64 offset_metadata;
};
Manifest block:
Engine version
Package list (id, version, sha256)
Universe name / UUID
RNG configuration
Input stream:
Delta-encoded per tick
Varint encoding
Optional zstd/LZ4 compression
Ticks with no events omitted (implicit “no-op”)
Canonical rule:
Re-simulating from the same snapshot + input stream MUST reproduce the same state bit-identically.

1.2 Snapshot-Only Replay: *.domsnap
Used for:
Time-lapse / cinematic replays
Lightweight viewers that don’t need full deterministic sim
Machine-light “playback only” modes
Structure:
DomSnapHeader
SnapshotIndex[]
SnapshotBlob_0
SnapshotBlob_1
...
Metadata
Each SnapshotBlob is essentially a compressed subset of the normal universe save format (5.7), optimized for:
camera position(s)
chunk visual state
key stats (economy, throughput, climate)
minimal simulation-only data
No input logs. No deterministic expectations.

1.3 Hybrid Replay Container: *.domrplx
Convenience container:
Bundles:
.domreplay (input-log)
set of keyed snapshots: snap_T, snap_2T, …
Used primarily by the replay viewer.
Internal layout (logical):
DomRplxHeader
EmbeddedReplay.domreplay
Snapshots/
  snap_00000000.dat
  snap_00060000.dat
  ...
MetadataBlock
Snapshots may be:
Full universe snapshots (like 5.7 saves)
Or specialized replay snapshots (reduced state)
Important:
Hybrid container remains deterministic because simulation always replays from input-log; snapshots are used only to fast-forward to a given tick then replay the last segment.

2. CAPTURE POLICY & STORAGE
2.1 Replay Capture Modes
Config:
[replay]
mode            = "off"    # off | input | hybrid
max_disk_mb     = 4096
segment_length_ticks = 36000   # per-segment
Modes:
off : no replay recording
input : record .domreplay only
hybrid : record .domrplx with periodic snapshots
Snapshot interval for hybrid:
[replay.hybrid]
snapshot_interval_ticks = 60000   # e.g. every ~16.7 in-game minutes @ 60 UPS
2.2 Storage Layout
Replays stored in:
replays/
  <universe_name>/
    session_YYYYMMDD-HHMMSS.domreplay
    session_YYYYMMDD-HHMMSS.domrplx
    autosaves/
Viewer tools can merge or trim segments.

3. REPLAY VIEWER BEHAVIOUR
3.1 Basic Operations
Viewer must support:
Play (1×, 2×, 4×, 8×, unlimited)
Pause
Step-by-tick
Jump to time (tick N)
Jump to snapshot boundaries
Auto-seek using nearest snapshot for hybrid
load snapshot at tick T0
simulate using input-log from T0 → target tick
3.2 Deterministic vs. Non-Deterministic Playback
.domreplay and .domrplx (input-log path) must be deterministic.
.domsnap playback is approximate and non-deterministic by definition (pure state dumps).
Viewer must clearly label:
“Deterministic replay (input-log)”
“Non-deterministic cinematic replay (snapshots only)”

4. SHARING MECHANISMS
4.1 Local Sharing
User can:
Copy replay files directly (USB, LAN, etc.)
Use dom_replay_trim / dom_replay_concat to prepare curated replays
Export viewer state as video frames or PNG sequence
4.2 Steam Workshop
Optional integration:
“Share replay to Workshop”:
Wrap .domreplay or .domrplx into a dpak or Workshop item
Include metadata:
universe name
tick range
required packages
Viewer on other machines uses the same dpak+manifest semantics as mods.
Replays never require extra DRM.
4.3 Self-Hosted Portal
Replays uploaded as:
dpak with type replay
or raw .domreplay with sidecar .json metadata
Portal catalog entry:
{
  "id": "replay.author.example",
  "type": "replay",
  "universe": "MyUniverse01",
  "from_tick": 0,
  "to_tick": 360000,
  "download": "https://example.com/replays/example.domreplay",
  "sha256": "..."
}
Client uses same Content Source framework (5.8a–b).

5. SCREENSHOT SYSTEM
5.1 Capture API
Engine API:
take_screenshot(optional_tag) -> path
Behavior:
Captures current frame from active renderer (2D/3D)
Renders overlays depending on user setting:
include UI
include debug info
hide private info (streamer mode)
Saves PNG:
screenshots/YYYY-MM-DD/HHMMSS_<tag>.png
No forced JPEG. No external dependencies.
5.2 Automation
Optional time-lapse scripting:
User can configure periodic screenshots:
every N ticks
or when specific events occur
Time-lapse outputs can be used to make videos offline
5.3 External Service Hooks
Steam adapter:
calls Steam’s screenshot API in parallel (when present)
Others (if any):
may receive a callback with file path
No auto-upload anywhere.

6. MEDIA EXPORT TOOLS
6.1 Frame/Video Export
CLI tools:
dom_replay_export_frames --replay=foo.domrplx --out=frames/
dom_replay_export_video  --replay=foo.domrplx --out=foo.mp4 --fps=60
Rules:
Implementation may require ffmpeg or built-in encoder.
Export is offline and user-triggered.
No auto-upload.
6.2 Data Export (Analytics)
From replay:
dom_replay_to_csv   --replay=foo.domreplay --out=stats.csv
dom_replay_to_json  --replay=foo.domreplay --out=stats.json
Exports:
tick-by-tick stats:
power flow
throughput
population
research progress
etc.
No telemetry: user decides where to send these files.

7. IN-GAME REPLAY UX
7.1 After-action UI
On exiting a session, offer:
“Save replay for this session” (if recording was off)
“Open replay in viewer”
“Share replay…”
7.2 Replay Browser
Replays tab in launcher:
List by:
Universe
Date
Duration
Type: input-log / hybrid / snapshot-only
Filter & search.
Actions:
Play
Open folder
Export
Share (Workshop/Portal/manual)

8. INTEGRATION WITH MULTIPLAYER & SERVERS
8.1 Server-side Replays
Servers may:
Always record input-log replays of a universe
Periodically create hybrid containers with snapshots for admin review
Rotate replays based on disk limits
Config:
[server.replay]
record              = true
mode                = "input"   # or "hybrid"
max_disk_mb         = 8192
segment_ticks       = 60000
keep_last_segments  = 10
8.2 Desync Diagnosis
On desync:
Server can:
export a minimal replay segment showing the divergence
send to admin or mod author for debugging
Desync debugging relies on deterministic .domreplay segments, not .domsnap.

9. OFFLINE MODE & PRIVACY
All replay and screenshot features work fully offline.
Nothing is auto-uploaded or synced.
File formats fully documented.
Users can delete all replays/screenshots easily:
“Delete all replays”
“Delete all screenshots”
Logs:
Replay/system logs saved only locally.
No hidden network activity.

10. INTERACTION WITH DETERMINISM
Key guarantees:
Simulation determinism is determined exclusively by:
engine version
package set
seed(s)
input-log replay
Snapshots in .domrplx are advisory:
may be regenerated
do not alter correctness
may be ignored if corrupted
.domsnap is explicitly non-deterministic; not allowed as source for correctness checks.
All replay viewers using input-log path must produce identical state on all supported platforms.

11. SUMMARY
Volume 5.8d defines:
Hybrid replay system with:
canonical input-log (.domreplay)
snapshot-only cinematic (.domsnap)
combined hybrid (.domrplx)
Deterministic simulation playback from input logs
Fast seek and cinematic tooling via snapshots
Replay sharing via local, Workshop, and self-hosted portals
Screenshot capture and management
Offline media export (frames, video, analytics)
Integration hooks for Steam and other services without DRM or telemetry
Strict separation between simulation correctness and media/UX features
This volume completes the external-facing side of replays and screenshots, building directly atop deterministic core systems.

END OF VOLUME 5.8d

::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8e — IDENTITY, ACCOUNTS, SESSIONS, AND OPTIONAL CROSS-SERVICE PRESENCE  
Dominium Engine Spec — External Services Integration, Part E

Scope:

- Identity model with no mandatory accounts
- Optional linking to Steam / GOG / Discord / etc.
- Local-only identity as the canonical mode
- Session tokens for multiplayer servers
- Privacy boundaries
- Offline behaviour
- Deterministic simulation independence

---

# 0. PRINCIPLES

1. **Dominium never requires accounts.**  
2. **Identity is local-first, file-backed.**  
3. **External services are optional adapters.**  
4. **Multiplayer servers do not require global IDs.**  
5. **Account linking never affects determinism.**  
6. **No telemetry, no hidden analytics.**

---

# 1. IDENTITY MODEL

Dominium maintains two layers:

## 1.1 Local Identity (canonical)

Stored in:

identity/local_identity.json

Contents:

```json
{
  "display_name": "Player",
  "local_uuid": "uuid-v4",
  "created": "ISO8601",
  "updated": "ISO8601",
  "custom_avatar_path": "path or null",
  "prefs": {
    "color": "#cccccc",
    "badge": "none"
  }
}
This identity:
Is the authoritative identity in all offline modes.
Is the fallback identity if all services are disconnected.
Never leaves disk unless user intentionally exports it.
1.2 External Identity Links (optional)
identity/links/
  steam.json
  gog.json
  discord.json
  ...
Each adapter stores:
{
  "service": "steam",
  "linked": true,
  "account_id": "...",
  "display_name": "...",
  "avatar_url": "...",
  "last_sync": "...",
  "permissions": {
     "presence": true,
     "achievements": true,
     "content_sync": true
  }
}
The engine does not require links to exist.

2. ACCOUNT LINKING FLOW
2.1 Requirements
No Dominium global servers
No Dominium cloud ID
No login required
No online-first requirement
2.2 Linking Steps
User opens launcher → Identity → Linked Accounts
Select service (Steam / Discord / GOG / …)
Adapter attempts to read local platform API
e.g. Steamworks
no credentials handled by Dominium
On success:
populate adapter file
keep only non-sensitive fields
On failure:
continue with local identity
Services never give Dominium passwords or tokens.

3. MULTIPLAYER IDENTITY
3.1 Session Identity (transient)
When joining a multiplayer server:
{
  "display_name": "...",
  "local_uuid": "...",
  "service_ids": {
    "steam": "...",
    "gog": "...",
    "discord": "..."
  }
}
The server uses:
local_uuid as the primary key
Service IDs only for optional features
No permanent account creation
No authentication required (unless server owner forces it)
3.2 Optional Server Authentication Packs
Server owners may define:
whitelists
role packs
ban lists
based on:
local_uuid
Steam ID
Discord ID
any combination
All optional and server-side only.

4. PRESENCE & STATUS
4.1 Local Presence
Dominium tracks:
Active universe
Save name
Current mode
Replay viewer status
Stored in RAM and ephemeral.
4.2 Optional External Presence
Adapters may publish presence:
Steam Rich Presence
Discord Rich Presence
None others by default
Presence includes only:
“In Menu / In Game / In Replay Viewer”
Universe name (optional toggle)
Tick rate (optional toggle)
Presence never includes:
Location data
Private stats
Worker names
Economy details
Chat logs
Machine/cluster info
All protected by privacy preferences.

5. OFFLINE MODE
Dominium must run with:
No internet
No Steam / GOG / Discord
No external services
Damaged or missing identity files
Fallback chain:
local_identity.json
Auto-regenerate on missing/corruption
No prompts
External-linked features are disabled gracefully.

6. AVATARS
Three sources:
Local avatar file
External-linked avatar (Steam/Discord/GOG)
Default vector avatar generated via deterministic seed
Avatar pipeline:
Never auto-download external assets
External avatars cached only with user permission
External avatar cache stored in identity/cache/

7. NAMES & DISPLAY POLICY
Rules:
Local display name is always primary
External names only override if toggled on
Multiplayer servers may enforce uniqueness
Name conflicts resolved by:
<PlayerName> (#1)
<PlayerName> (#2)
...
No forced renames.

8. PRIVACY & SECURITY
8.1 No Telemetry
Dominium ships with:
No analytics
No crash uploaders
No hidden logging
No cloud sync
No tracking pixels
No unique service tokens
8.2 User-Controlled Visibility
Config options:
[privacy]
share_presence = false
share_identity_to_servers = "minimal"  # minimal | normal | extended
allow_external_avatars = false
allow_external_presence = false
When disabled:
All adapters are silenced
Identity collapses to local-only
Server sees only minimal identity

9. EXPORT & IMPORT OF IDENTITIES
Users may export:
dom_identity_export.json
Fields:
display name
avatar (optional)
prefs
No linked-account data exported unless explicitly opted in.
Servers cannot demand identity imports.

10. INTEGRATION WITH MODS
Mods may:
Query player_identity.seed for deterministic avatars
Query player_identity.display_name
Never access:
service IDs
account links
presence metadata
These fields are hidden from LUA and mod data layers.

11. DETERMINISM
Identity system must not influence simulation order, RNG, or game state.
Identity is metadata only.
Replays do not store identities beyond cosmetic info.

12. SUMMARY
Volume 5.8e defines:
A fully optional, modular identity system
Local-first identity with optional adapters
Lightweight server session identity
Optional Steam/Discord/GOG presence
Zero telemetry
Strict privacy boundaries
Deterministic simulation isolation
Offline-first behavior
Optional identity exports/imports
No DRM, no mandatory accounts
This volume finalizes the identity and account model for Dominium’s multi-platform ecosystem.
END OF VOLUME 5.8e

Proceed to **Volume 5.8f** (Offline Mode & Service Degradation) on confirmation.
You said:
Proceed 
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating Volume 5.8e, I need a single specification choice from you.
This choice determines the entire identity/account architecture and cannot be changed later without breaking all downstream volumes (5.8e, 5.8f, 6.x, 7.x, DLC integration).
Choose the Identity Model for Dominium
Dominium can operate under three fundamentally different identity frameworks.
Pick one.

A — No Online Accounts (Fully Anonymous, Fully Local)
No Dominium account system at all.
Player identity = local profile name
Multiplayer identity = client-side nickname + public key
Everything offline-capable
No central servers
No permanent identity across universes
No cross-device cloud sync
Steam/GOG/etc identity optional and non-authoritative
Extremely simple, privacy-maximal, DRM-free
Mods, DLC, replays, etc all local files
Ideal for your philosophy so far (minimal DRM, optional anti-cheat)
Cons:
No unified global friends list (unless read-only from Steam/Discord)
No persistent reputation system
No portable ownership across platforms (unless via external stores)

B — Optional Dominium Account (Local First; Online Only if Wanted)
Players may create a Dominium account but never must.
Offline play works without account
Multiplayer works without account
Account enables optional cloud sync, cross-device identity, avatar
Account server contains no mandatory telemetry
User can host their own identity server (“self-hosted identity node”)
Steam/GOG/Discord identities can be linked but are not required
Anonymous players and account users can play together
All identity features degrade safely offline
Mods / content portal work without identity, but identity enables features like:
cross-device mod subscriptions
author verification (not DRM)
Cons:
Requires designing identity APIs and secure signing
Slightly more complexity
This is usually the best modern compromise.

C — Required Dominium Account (Online identity mandatory)
This is like Minecraft / Factorio’s commercial model.
Required for online play
Required for certain content
Mandatory authentication with Dominium central server
Supports permanent identity, anti-cheat, ban lists, cloud sync
Can integrate with Steam/GOG/Discord
Cons:
Violates your requirements (minimal DRM, everything optional)
Prevents fully offline servers
Players lose control
Breaks your design philosophy
Given everything you've said so far, C is incompatible with Dominium.

Which one do you choose? (A or B)
A — No online accounts whatsoever
or
B — Optional Dominium accounts with self-hostable identity nodes
Your answer will define Volume 5.8e.
You said:
I prefer a seamless and integrated combination of all 3 tiers 
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
To integrate all three identity tiers — without violating determinism, offline support, user freedom, or minimal DRM — the identity system must be redefined as a hierarchical identity stack.
I will implement this as Model S (Stacked Identity Model), a synthesis of A, B, and C, without the downsides of any of them.
This will become the basis for Volume 5.8e.
Below is the formal identity architecture we will use.

STACKED IDENTITY MODEL (MODEL S)
A unified architecture combining:
Tier 0: No accounts, full anonymity
Tier 1: Optional Dominium local accounts
Tier 2: Optional Dominium cloud accounts
Tier 3: Optional third-party accounts (Steam / GOG / Discord)
Each tier enhances the previous one, but none are required.
This model satisfies your directive:
“A seamless and integrated combination of all 3 tiers.”

TIER 0 — ANONYMOUS LOCAL IDENTITY (ALWAYS PRESENT)
Base identity for 100% offline and DRM-free gameplay:
Local UUID
Local display name
Local avatar
Local preferences
Deterministic avatar seed
This identity is always available, always valid, and is used when:
Offline
User chooses privacy mode
Cloud/auth services unavailable
Playing on LAN
Running headless servers
Multiplayer uses signed ephemeral session tokens (local-only).
No internet required.
No global tracking.

TIER 1 — LOCAL DOMINIUM ACCOUNT (OPTIONAL)
User may optionally create a local Dominium profile:
Separate save directory and universes
Local badge / cosmetics
Offline “identity features”
Local worker/company profile
Import/export identity pack to USB or disk
This is not tied to any server.
It is simply a more structured identity state.
Useful for:
Multi-user computers
Parents/kids
LAN parties
Private servers
Local mod authorship metadata
Still zero DRM.

TIER 2 — DOMINIUM CLOUD ACCOUNT (OPTIONAL)
User may optionally connect to a Dominium cloud identity server:
Cloud-sync identity
Cloud-backed avatar
Global name uniqueness
Friends list (offline-capable local cache)
Verified authorship for mods
Cloud mod subscriptions
Cloud saves (optional, disabled by default)
Cloud achievements
Server signup (optional)
Multi-device identity
Important rules:
The account is not required to play.
Offline mode works with Tier 0 or Tier 1.
Servers may allow or disallow anonymous players at admin discretion.
Deterministic simulation does not depend on cloud identity.
Even with a cloud account, the game must run without internet.
This mirrors the best parts of Factorio’s optional account system, without the DRM aspects.

TIER 3 — THIRD-PARTY ACCOUNT LINKS (OPTIONAL)
User may optionally link:
Steam
GOG
Discord
Xbox Live
PlayStation Network
Nintendo
Twitch
YouTube
Spotify (for music pack metadata)
These links allow:
Presence
Achievements
Overlay integrations
Workshop mod sync
Friends list mapping
Replay uploads
Matchmaking assistance (optional and non-authoritative)
But:
Third-party accounts cannot override the Dominium identity stack.
Third-party logins do not bypass Tier 0 or Tier 1.
Mods and replays must remain accessible without these services.
No DRM is allowed.

UNIFIED IDENTITY STACK BEHAVIOR
Identity for any session is a merge:
Stack Resolution Order
(From highest-preference to fallback)
Tier 3: Third-party linked accounts
Tier 2: Dominium cloud account
Tier 1: Local Dominium profile
Tier 0: Anonymous identity
The game uses the highest available tier that is enabled and active.
For example:
If Steam is linked but offline → fallback to Tier 2 or Tier 1 or Tier 0
If Steam and cloud are both offline → fallback to Tier 1 or Tier 0
If all are disabled → Tier 0 only
If cloud account exists but user disables it → use Tier 1 or Tier 0
In Hardcore Privacy Mode → permanently Tier 0
In LAN-only mode → Tier 1 or Tier 0
This makes identity robust and resilient.

SERVER INTERACTION MODEL
Servers see the entire identity stack but can choose how to handle it.
Server may require any tier:
Public servers might require Tier 0 only
Verified servers may require Tier 2 (cloud account)
RP or professional servers may require Tier 3 (Discord ID)
Offline servers require no tiers
Admin servers may whitelist Tier 1 profiles
Nothing is enforced by Dominium.
This satisfies your requirement:
“Minimal DRM and anticheat enforcement; everything optional or overridable.”

REPLAY & DETERMINISM MODEL
Identity does not enter the deterministic simulation at any tier.
Simulation correctness depends only on:
Package set
Universe seed
Input logs
Snapshot sequence
Identity is metadata.
Replays include:
Local name
Avatar (optional)
Non-authoritative identity descriptors
But replay simulation does not read identity data for game logic.

MOD COMPATIBILITY
Mods may:
Display identity
Display avatar
Display species / faction / badge
Use identity seed for deterministic cosmetics
Mods may not:
Read third-party account IDs
Read cloud account tokens
Send identity to external networks
Break privacy or DRM
Enforce gated content
The engine blocks access to any sensitive identity layer.

This resolves your directive.
If this matches your vision, I will now generate:
VOLUME 5.8e — IDENTITY, ACCOUNTS, VISIBILITY & PRESENCE
using the Stacked Identity Model (Model S) as the architecture.
Confirm:
Proceed with Volume 5.8e (Model S)?
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8e — IDENTITY, ACCOUNTS, VISIBILITY & PRESENCE  
Dominium Engine Spec — External Services Integration, Part E  
Model S (Stacked Identity Model)

Scope:

- Complete identity stack for Dominium
- Tiers: Anonymous, Local Profile, Cloud Account, Third-Party Links
- Session identity for multiplayer
- Presence and visibility rules
- Privacy and offline behaviour
- Determinism isolation

No DRM. No mandatory logins. Offline-first.

---

## 0. DESIGN OBJECTIVES

1. **Stacked Identity Model (Model S)**  
   Combine three conceptual levels:
   - “No account” (purely local, anonymous)
   - “Optional Dominium account” (local and cloud)
   - “External account links” (Steam, GOG, Discord, etc.)

2. **Offline-first and DRM-free**  
   - Full game functionality with Tier 0 only  
   - No Dominium central server required  
   - No third-party platform required

3. **Deterministic Isolation**  
   - Identity never participates in simulation logic  
   - Replays remain identical regardless of identity state

4. **Server Autonomy**  
   - Servers can choose which tiers they accept or require  
   - No global enforcement from engine

---

## 1. STACKED IDENTITY MODEL OVERVIEW

Identity = stack of up to 4 tiers:

- **Tier 0: Anonymous Local Identity** (always present)
- **Tier 1: Local Dominium Profile** (optional)
- **Tier 2: Dominium Cloud Account** (optional)
- **Tier 3: Third-Party Linked Accounts** (optional, per service)

Resolution order at runtime:

1. Tier 3 (if linked, allowed, available)
2. Tier 2 (if configured, online, allowed)
3. Tier 1 (if profile exists and selected)
4. Tier 0 (fallback, always available)

The game uses the **highest active tier** that matches user privacy settings and runtime conditions.

---

## 2. TIER 0 — ANONYMOUS LOCAL IDENTITY

### 2.1 Data

Stored in:

```text
identity/local.json
Example:
{
  "schema_version": 1,
  "local_uuid": "uuid-v4",
  "display_name": "Player",
  "created": "2025-11-30T12:00:00Z",
  "last_used": "2025-11-30T12:34:56Z",
  "avatar_seed": 123456789,
  "avatar_style": "default",
  "color": "#cccccc"
}
2.2 Behaviour
Always available; regenerated if missing or corrupted.
Acts as the identity for:
pure offline play
headless servers
privacy mode
legacy platforms (Win98, DOS in future)
2.3 Determinism
The avatar_seed is allowed for purely cosmetic deterministic visuals.
Core sim must not depend on any Tier 0 data.

3. TIER 1 — LOCAL DOMINIUM PROFILE
Optional structured profiles layered on top of Tier 0.
3.1 Data
Profiles stored as:
profiles/
  <profile_id>/
    profile.json
    saves/
    config/
    mods_local/
profile.json:
{
  "profile_id": "uuid-v4",
  "profile_name": "Isaac",
  "created": "2025-11-30T13:00:00Z",
  "last_used": "2025-11-30T14:02:30Z",
  "identity": {
    "display_name": "Isaac",
    "avatar_seed": 987654321,
    "avatar_style": "engineer",
    "color": "#88ccff"
  },
  "settings": {
    "difficulty": "standard",
    "ui_theme": "dark",
    "privacy_mode": "normal"
  }
}
3.2 Behaviour
Selected at launcher start or via user switch.
Controls:
saves and universes list
local config
key bindings
mod preferences (enabled/disabled sets)
Provides a stable local persona across universes and servers.
3.3 Integration
Tier 1 identity overrides Tier 0 display_name and avatar.
Tier 0 UUID remains as base physical installation identity.
Multiple local profiles may share a machine.
3.4 Offline
Fully functional without internet or external services.

4. TIER 2 — DOMINIUM CLOUD ACCOUNT (OPTIONAL)
Tier 2 is optional and must not be required for the game to function.
4.1 Data
Local side:
identity/cloud.json
Example:
{
  "cloud_enabled": true,
  "account_id": "dom-acc-123456",
  "display_name": "IsaacDominium",
  "linked_profiles": ["profile-uuid-1","profile-uuid-2"],
  "last_sync": "2025-12-01T00:00:00Z",
  "permissions": {
    "cloud_saves": false,
    "cloud_mod_subscriptions": true,
    "friends_sync": true
  }
}
Server-side (if used) is out-of-scope here; only client-facing behaviour is defined.
4.2 Capabilities
If tier enabled and reachable:
Cloud-backed identity name and avatar
Optional:
cross-device mod subscriptions
cross-device friends list
cross-device identity consistency
cloud saves (explicitly disabled by default)
verification of mod authorship (signature, not DRM)
4.3 Constraints
Game must run without cloud account.
Game must run if cloud service is down.
Universes and saves must be accessible locally without cloud authentication.
No forced login.
Cloud account cannot lock local content.

5. TIER 3 — THIRD-PARTY ACCOUNTS
Optional integration with external services:
Steam
GOG
Discord
Xbox Live
PlayStation Network
Nintendo
Twitch / YouTube
Others (future)
5.1 Data
Stored in separate files per service:
identity/links/steam.json
identity/links/discord.json
...
Example:
{
  "service": "steam",
  "linked": true,
  "account_id": "steam64id",
  "display_name": "SteamName",
  "last_seen": "2025-12-01T01:00:00Z",
  "permissions": {
    "presence": true,
    "achievements": true,
    "workshop": true
  }
}
5.2 Behaviour
Read-only for identity integration:
presence
achievements mirroring
Workshop access (mods, replays)
Dominium never receives passwords or raw credentials.
Platform integration only works if the respective client/API is present and active.
5.3 Constraints
Third-party accounts cannot become mandatory.
Linked services can be disabled at any time.
Unlinking must not break local saves or universes.

6. IDENTITY RESOLUTION
At runtime, the active identity is assembled as:
ActiveIdentity = {
  base: Tier0,
  profile: Tier1? (if selected),
  cloud: Tier2? (if enabled + available),
  external: Tier3? (if linked + allowed)
}
Resolution order for displayed name:
If Tier3 visible → use Tier3 display_name
Else if Tier2 visible → use Tier2 display_name
Else if Tier1 visible → use Tier1 display_name
Else → use Tier0 display_name
Same pattern for avatar and colour, respecting privacy flags.

7. SESSION IDENTITY FOR MULTIPLAYER
When connecting to a server, the client constructs a SessionIdentity:
{
  "session_id": "uuid-v4",
  "stack": {
    "tier0": {
      "local_uuid": "...",
      "display_name": "...",
      "avatar_seed": 123456
    },
    "tier1": {
      "profile_id": "profile-uuid",
      "profile_name": "Isaac"
    },
    "tier2": {
      "cloud_account_id": "dom-acc-123456",
      "cloud_name": "IsaacDominium"
    },
    "tier3": {
      "steam_id": "steam64id",
      "discord_id": "discordid"
    }
  },
  "visibility": {
    "level": "minimal"  # minimal | standard | extended
  }
}
7.1 Visibility Levels
minimal:
arbitrary display_name
Tier0 UUID
standard (default):
Tier0 UUID
Tier1 profile id+name
Tier2 id if present
extended:
Tier3 IDs for whitelists / banlists
cloud identity for verification
Server can reject or downgrade based on its policy.

8. SERVER POLICIES
Server config example:
[server.identity]
allow_anonymous      = true      # allow Tier0-only
require_cloud        = false     # require Tier2
require_external     = false     # require at least one Tier3
visibility_min_level = "minimal" # minimal | standard | extended
Policy scenarios:
LAN sandbox server:
allow_anonymous = true
everything else false
Verified community server:
allow_anonymous = true
require_cloud = true (Tier2 or better)
Private RP server using Discord:
require_external = true (Discord link)
Hardcore privacy server:
only Tier0/Tier1, no Tier2/Tier3 data allowed
Engine enforces only connectivity-level rules; there is no global enforcement.

9. PRESENCE & VISIBILITY
9.1 Local Presence
Tracked per session:
Universe name
Property name (optional)
Mode (building, planning, replay viewer, menu)
Tick/time
Stored in memory, not disk, unless user logs it.
9.2 External Presence
Adapters may publish:
Steam Rich Presence
Discord Rich Presence
Data exposed:
{
  "game": "Dominium",
  "universe": "MyUniverse01",       // optional
  "location": "Earth / Greenfield", // optional
  "mode": "Building",
  "players_online": 4
}
User controls what is exposed.

10. PRIVACY SETTINGS
Stored in:
config/privacy.toml
Example:
[privacy]
enable_presence          = false
enable_cloud_account     = false
allow_third_party_links  = true
identity_visibility      = "minimal"  # minimal | standard | extended
share_universe_name      = false
share_property_name      = false
allow_external_avatars   = false
hardcore_offline_mode    = false
10.1 Hardcore Offline Mode
If hardcore_offline_mode = true:
Tier2 and Tier3 are disabled entirely
No external presence
No external adapters loaded
All identity collapses to Tier0 or Tier1
Useful for air-gapped or paranoid environments.

11. MOD ACCESS TO IDENTITY
Mods get a constrained view:
identity = {
  display_name = "PlayerName",
  avatar_seed  = 123456,
  color        = "#88ccff",
  profile_name = "LocalProfile"
}
Forbidden:
Access to cloud account IDs
Access to Steam/Discord IDs
Access to IP addresses
Access to identity visibility settings
Mods cannot exfiltrate real identity via scripting API.

12. DETERMINISM & REPLAYS
12.1 Determinism
Simulation must not read:
display names
avatar seeds
identity tiers
for any gameplay logic.
Allowed:
Identity-based cosmetic decisions (e.g. UI theme per player)
Deterministic cosmetics per avatar_seed rendered after simulation step
12.2 Replays
Replays may embed:
{
  "recorded_by": {
    "display_name": "...",
    "profile_name": "...",
    "stack_summary": "Tier2+Tier3"
  }
}
Replays must not rely on this data for sim.
Loading a replay:
Can show the recorded identity metadata
Must ignore it for all deterministic calculations

13. STORAGE LAYOUT SUMMARY
identity/
  local.json              # Tier0
  cloud.json              # Tier2 local state
  links/
    steam.json            # Tier3 link
    gog.json
    discord.json
profiles/
  <profile_id>/
    profile.json          # Tier1 data
    saves/
    config/
    mods_local/
config/
  privacy.toml
  achievements_local.toml

14. FAILURE MODES
Must degrade as:
local.json missing → regenerate anonymous Tier0
profile.json missing → profile hidden, fallback to Tier0
cloud.json corrupt → disable Tier2, notify in UI, fallback Tier1/Tier0
links/*.json missing → disable associated Tier3 services
External services down → presence and external identity disabled; game unaffected
No hard failures on identity.

15. SUMMARY
Volume 5.8e defines the Stacked Identity Model (Model S) for Dominium:
Four-layer identity stack: Anonymous, Local Profile, Cloud Account, Third-Party Links
Offline-first, DRM-free, no mandatory accounts
Server policies choose which tiers to accept
Presence and identity are strictly cosmetic and metadata-only
Strict privacy controls and hardcore offline mode
Mod-facing identity API is limited and safe
Deterministic simulation remains completely isolated from identity concerns
This volume finalises identity, visibility, and presence semantics for all future multiplayer, modding, and DLC volumes.
END OF VOLUME 5.8e
::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating Volume 5.8f — Offline Mode & Service Degradation, I need one architectural choice.
This volume must define how Dominium behaves when any or all external services fail — Steam/GOG/Discord, Dominium Cloud (Tier 2), third-party overlays, network connectivity, identity adapters, workshop services, etc.
There are two compatible design patterns, but they differ in complexity and user experience.
You must choose ONE before I generate the full volume.

CHOOSE THE OFFLINE-DEGRADATION MODEL
A — Hard Containment Mode (Strict Isolation)
Philosophy:
If a service fails, Dominium immediately isolates itself from that service and operates as if it does not exist.
Behaviour:
Steam/GOG/Discord adapter unloaded entirely
Dominium Cloud adapter disabled
Presence & achievements disabled
Mod portal switches to “local only”
Launcher hides online options
No retry loops or background reconnection
Pure offline mode until restart or manual toggle
Multiplayer available only via LAN/direct-connect
Pros:
Cleanest, simplest, safest
Zero background network operations
No UI flicker or state-changing
Perfect for offline-first systems and old platforms
Cons:
User must restart or manually re-enable network when back online
No seamless auto-recovery
Use this if you prefer predictability and fully deterministic offline-first behaviour.

B — Soft Degradation Mode (Seamless Fallback with Automatic Restoration)
Philosophy:
If a service fails, Dominium transparently downgrades to offline features, but automatically attempts to restore them in the background whenever possible.
Behaviour:
Identity stack dynamically re-resolves (Tier 3 → Tier 2 → Tier 1 → Tier 0)
If Steam disconnects mid-session, game continues using Tier 2/1/0
Periodic background re-connect attempts (configurable)
Workshop/download queues freeze and resume automatically
Cloud sync temporarily disabled and re-enabled
Presence quietly shuts off then resumes
All UI reflects the downgraded mode without interruption
Multiplayer servers are unaffected by the client’s loss of external services
Pros:
Seamless experience
No restarts needed
Natural for players with fluctuating networks
Better for long-running universes or streaming sessions
Cons:
More complex implementation
At worst, external APIs may cause slowdowns on unstable networks (can be mitigated)
Use this if you want players to experience Dominium like a modern cross-platform title while still preserving offline-first guarantees.

C — Hybrid Mode (Strict for Simulation, Soft for UI/Services)
Philosophy:
Simulation (UPS/FPS, determinism, networking) is always strictly isolated — never attempts recovery.
But UI-level services (presence, achievements, mod browsing, cloud sync) use soft automatic fallback and re-enable when possible.
Behaviour:
Simulation never retries anything
Simulation never restarts identity components
Simulation never depends on external services
External services for UI (portal browsing, workshop browsing, presence, achievements) MAY auto-reconnect
Identity stack re-resolves in background for UI-only layers
Game state (saves, replays, mods) never changes behaviour based on online status
If network fails, sim continues flawlessly; optional services quietly disappear and later return
Pros:
Maximizes determinism and stability
Maximizes user convenience
All the benefits of A for core simulation
Most benefits of B for convenience
Matches your existing design philosophy perfectly
Cons:
Slightly more engineering than A
Slightly less predictable than A if user watches UI closely (presence may flicker back on later)
This option is the best fit for a DRM-free, deterministic sim with modern convenience features.

Which one? A, B, or C?
Your answer determines the entire structure of Volume 5.8f and all following volumes.
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 5.8f — OFFLINE MODE & SERVICE DEGRADATION  
Dominium Engine Spec — External Services Integration, Part F  
Hybrid Model (C): Strict Simulation / Soft UI Services

Scope:

- Offline mode architecture
- Failure modes for identity, external services, and networking
- Strict isolation for deterministic sim
- Soft fallback + soft recovery for UI-level integrations
- Behaviour on legacy platforms and air-gapped systems
- Launcher and in-game degradation rules

This volume defines how Dominium behaves under partial or total service failure.

---

# 0. PHILOSOPHY

**Hybrid Model C**:

1. **Core Simulation = strict isolation (Tier A behaviour)**  
   - Never reconnects  
   - Never retries  
   - Never alters simulation pacing  
   - No identity tier transitions during a simulation tick  
   - External services have zero influence on determinism or UPS  

2. **External UI Services = soft fallback + auto-recovery (Tier B behaviour)**  
   - Workshop browsing recovers  
   - Presence updates return  
   - Account links re-enable  
   - Cloud mod subscriptions resume  
   - Cloud saves (if enabled) retry on safe boundaries  

This guarantees:

- **deterministic lockstep gameplay**, even in multiplayer  
- **zero DRM**  
- **total offline functionality**  
- **maximum convenience**  

---

# 1. OFFLINE MODES

Dominium supports **four** offline modes:

## 1.1 Implicit Offline Mode  
Activated when:

- Internet unreachable for 10s  
- DNS unavailable  
- All external APIs error without authentication

Effects:

- External presence disabled  
- Cloud sync and workshop browsing disabled  
- Identity falls back through Tier 3→2→1→0  
- Simulation unaffected  

Once a service becomes available again, UI-level services reactivate seamlessly.

## 1.2 Explicit Offline Mode  
User selects:  

Launcher → Settings → Network → “Offline Mode”

Effects:

- Forces Tier 0/1 identity  
- Disables Tier 2 and Tier 3  
- Blocks outgoing connections  
- Hardens privacy settings  
- UI/workshop/cloud are disabled entirely  
- No background retries  

Remains until user leaves Offline Mode manually.

## 1.3 Hardcore Offline Mode  
Defined earlier in 5.8e under privacy:

- Completely forbids Tier 2 and Tier 3  
- Prevents third-party integrations entirely  
- Disables cloud/portal services  
- Equivalent to air-gapped behaviour  
- Ideal for classified, secure, or archival deployments  

## 1.4 Legacy Offline Mode  
On legacy platforms (Win98, future DOS port, Mac OS 9):

- Third-party integrations disabled automatically  
- Steam/Discord APIs not loaded  
- Cloud disabled  
- Identity stack collapses to Tier 0 or Tier 1  
- Simulation runs normally

---

# 2. DEGRADATION MECHANICS

Understanding what fails and how:

## 2.1 Identity Tier Failures

If Tier 3 (Steam/Discord/etc) fails:

- Soft fallback to Tier 2/1/0 for UI  
- Core sim unaffected  
- Replays do not change  
- Server session identity remains valid and stable (no renegotiation)

If Tier 2 (Dominium Cloud) fails:

- Cloud sync pauses  
- Workshop metadata pauses  
- Friends list freezes  
- Mod subscription queue stalls  
- Tier 1 identity remains active  
- No forced logout  

If Tier 1 (Local Profile) fails (rare):

- Fallback to Tier 0  
- Profile hidden in UI  
- Users can still play  

Tier 0 cannot fail.

---

## 2.2 Mod Portal Failures

If Steam Workshop or self-hosted portal becomes unreachable:

- UI falls back to “local mods only”  
- Browsing/search disabled  
- Subscriptions paused  
- Updates queued until portal returns  
- No crash, no freeze  
- Servers can still load local dpaks  
- Multiplayer continues unaffected  

When service returns:

- Automatic sync if enabled  
- Subscriptions re-download new versions  
- UI shows “online” status again  

---

## 2.3 Cloud Save Failures (If Enabled)

Users must explicitly enable cloud saves in settings; default is **off**.

If cloud save upload fails:

- Save stored locally  
- Marked as “pending upload”  
- Retries only on:
  - launcher start  
  - manual retry  
  - stable connectivity for at least 5s  
- Never overwrites local save  
- Never blocks gameplay  
- No forced cloud resync  

If cloud save download fails:

- Game loads local version  
- Sync conflict dialog appears only in launcher, never in-engine  

---

# 3. MULTIPLAYER FAILURE BEHAVIOR

## 3.1 During a simulation session
If an external service fails while connected to a server:

- **Simulation continues** (lockstep is independent)  
- **Identity freeze:** server continues seeing the last resolved SessionIdentity  
- No re-identification mid-session  
- No renegotiation of tiers  
- No kick  
- No pause  
- Chat and console continue working  
- Server logs a soft warning for admins only  

Clients may see presence/portal UIs disappear temporarily.

### Why?
Mid-session identity mutation breaks determinism and complicates lockstep.

---

## 3.2 Rejoining a server

If the user leaves and tries to reconnect:

- Identity stack re-resolves (Tier 3→2→1→0)
- Server applies its identity policy
- If Tier 2/3 fail, Tier 1/0 are used instead
- If server requires Tier 2/3, connection fails gracefully

---

# 4. LAUNCHER BEHAVIOR

## 4.1 Connectivity Indicators

Launcher shows connection health:

Steam: Online / Offline / Disabled
Cloud: Online / Pending / Offline / Disabled
Portal: Online / Offline
Mods: Local Only / Online
Identity: T3/T2/T1/T0

## 4.2 Automatic Soft-Recovery Loop

Conditions:

- Not in Explicit or Hardcore Offline Mode
- Background thread at 30s interval:
  - attempt DNS
  - ping self-hosted portal
  - ping Dominium Cloud (if enabled)
  - poll Steam/Discord APIs

Recovery is silent; only the status bar updates.

---

# 5. IN-GAME UI BEHAVIOR

## 5.1 Degradation

If an external service disappears:

- Presence icon turns grey  
- Friends panel hides remote statuses  
- Mod browser switches to “local only”  
- Achievements freeze updates  
- No popups or interruptions  

UI seamlessly hides online-only elements.

## 5.2 Recovery

When services return:

- UI repopulates  
- Portal reopens  
- Workshop subscriptions resume  
- Friends list restores  
- Achievements resume syncing

No reload of universe or simulation.

---

# 6. ERROR HANDLING PRINCIPLES

## 6.1 Never Block Critical Paths

- Saves must work offline  
- Mods must load offline  
- Universe creation must work offline  
- Restart not required  
- Simulation never stops

## 6.2 Always Favor User Control

If something goes wrong:

- Provide “Retry”, “Ignore”, “Go Offline”, “Details…” buttons  
- Errors never stop gameplay
- Errors never cause reidentification mid-session

## 6.3 No Error Spam

The engine aggregates repeated failures:

Network degraded (Steam, Cloud). Switching services to offline mode.

And does not repeat it until recovery.

---

# 7. LEGACY & LOW-END PLATFORM NOTES

Platforms like:

- Windows 2000, XP, Vista  
- Mac OS X 10.6  
- Old Linux  
- Future DOS / Mac OS 9 ports  
- Win98 in Stage 2

Must:

- always default to Tier 0 + Tier 1
- never load Tier 2/3 adapters
- run in Implicit Offline Mode by definition
- show no online UI elements

This preserves determinism and compatibility.

---

# 8. DETERMINISM & REPLAYS

## 8.1 External Services Ignored

Replays ignore:

- identity tiers  
- presence state  
- cloud link state  
- portal status  
- network availability  
- online/offline mode

## 8.2 Replay Loading Under Offline Conditions

If user loads a replay while offline:

- Viewer loads fully  
- Snapshots load fully  
- Export tools work fully  
- No missing features beyond workshop uploads

---

# 9. CONFIGURATION

### `config/network.toml`:

```toml
[network]
mode = "auto"                     # auto | offline | hardcore_offline
retry_interval_sec = 30
enable_soft_recovery = true
block_external_services = false

[network.identity]
allow_tier3 = true
allow_tier2 = true
allow_tier1 = true
allow_tier0 = true

[network.portal]
enable_workshop = true
enable_selfhost = true
config/privacy.toml (linking with 5.8e):
[privacy]
visibility = "standard"           # minimal | standard | extended
hardcore_offline_mode = false
share_presence = false

10. SUMMARY
Volume 5.8f defines:
Strict simulation isolation: external services never affect UPS, ticks, RNG, or lockstep.
Soft UI fallback: non-critical services like presence, workshop, cloud mod subscriptions silently degrade.
Soft recovery: services re-enable when available.
Offline-first behaviour with Explicit and Hardcore Offline Modes.
Deterministic replay integrity regardless of service state.
Safe and quiet degradation for mod portal, cloud sync, identity tiers, and presence systems.
Server stability via frozen SessionIdentity mid-session.
Legacy platform compatibility by defaulting to Tier 0/1.
This completes the External Services Integration Layer for Dominium.
END OF VOLUME 5.8f
