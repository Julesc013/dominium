You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating Volume 7, I need you to select which Volume 7 track we proceed down.
Starting with Volume 7, the specification enters the ENGINE CORE phase.
This is where Dominium transitions from infrastructure → foundational engine systems.
Volume 7 is too large to generate as one block.
It splits into distinct sub-volumes, and I need you to choose the ordering.

VOLUME 7 — ENGINE ARCHITECTURE (TOP-LEVEL OUTLINE)
Volume 7 is made up of the following parts:
7.1 — Engine Structure & Layer Model
Defines:
C89 core
C++98 wrapper layer
Platform abstraction
Renderer abstraction
Audio, input, windowing abstraction
Optional systems (Lua, plugins)
Determinism-critical boundaries
Task/update graph structure
Component vs ECS vs hybrid model
Memory management
7.2 — Data Model, Entities, Components, and Systems
Defines:
World representation
Chunk / subchunk / hyperchunk layout
Entity hierarchy
Machines, buildings, workers, vehicles
Serialization rules and universe-scoped IDs
Deterministic simulation ordering
7.3 — Terrain and Voxel/Heightfield Systems
Defines:
Terrain storage
Voxel vs heightfield hybrid
Basements, tunnels, mountains
Geometry generation for 2D/3D modes
LOD strategy
Deterministic terrain modification
Resource distribution
7.4 — Simulation Chain Overview
High-level simulation steps:
networks (electrical, fluids, data)
transport systems
climate
workers & AI
economics
machines
infrastructure
time & tick scheduling
UPS/FPS decoupling
7.5 — Renderer Interface (2D Vector, 2D Texture, 3D)
Defines:
rendering abstraction
how GL1/GL2/DX9/DX11/software plug in
view modes (2D ortho, 2D iso, 3D)
render pipeline
UI layering
sprite/model/line drawing vs procedural vector mode
7.6 — Audio Engine Interface
Low-level abstraction, supporting:
no audio
legacy mixers
SDL audio
DirectSound
OpenAL (optional)
DSP chain for effects
7.7 — Input and Controls Layer
Defines:
keyboard/mouse/gamepad/input abstraction
binding system
input determinism
networked input replication
accessibility input modes
7.8 — Task Scheduler, Threading Model, and Deterministic Parallelism
Defines:
deterministic job scheduling
multi-core safe simulation
real-time scheduling under CPU limits
affinity rules for legacy platforms
load balancing ticks across frames
7.9 — Error Handling, Logging, Assertions, Diagnostics
Defines:
platform-independent error model
debug and release logging modes
headless logging
trace buffers for replays

CHOOSE THE NEXT SUB-VOLUME
We proceed with one subsection at a time to ensure alignment with the design.
Choose 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, or 7.9.
Which do you want to start with?
You said:
Proceed with 7.1
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 7.1 — ENGINE STRUCTURE & LAYER MODEL  
Dominium Engine Specification — Engine Core, Part 1  
(C89 Foundation, C++98 Systems Layer, Platform/Renderer Abstraction, Deterministic Boundaries)

Volume 7.1 defines the **global structure of the Dominium Engine**, all primary layers, and the rules governing determinism, portability, platform support, and future extensibility.

Everything in later volumes (simulation, rendering, terrain, networks, AI) must conform to this architecture.

---

# 0. HIGH-LEVEL GOALS

1. **Extreme portability** (Win2000–11, macOS 10.6+, Linux, DOS future, Win1–3 future).
2. **Extreme determinism** (every simulation tick identical across all platforms).
3. **Strict separation between:**
   - Deterministic simulation  
   - Non-deterministic presentation (graphics/audio/UI)
4. **Core code always C89-only**.
5. **Systems layer always C++98-only**, no STL where possible.
6. **Zero dependency architecture**, except:
   - Lua (optional)
   - SDL (platform layer only)
   - DX/OpenGL (renderer layer only)
7. **Ability to add renderers/platforms without modifying core simulation**.
8. **Stability over decades**.

---

# 1. ENGINE LAYER OVERVIEW (FIVE-LAYER STACK)

Dominium Engine consists of the following layers:

+-----------------------------------------------------------+
| LAYER 5 — Presentation Layer (UI, 2D/3D views, audio) |
+-----------------------------------------------------------+
| LAYER 4 — Renderer Layer (DX9/DX11/GL1/GL2/Vector/Soft) |
+-----------------------------------------------------------+
| LAYER 3 — Platform Layer (SDL1/SDL2/Native/Legacy) |
+-----------------------------------------------------------+
| LAYER 2 — Systems Layer (C++98, Engine Systems) |
+-----------------------------------------------------------+
| LAYER 1 — Core Layer (C89 — Deterministic Simulation) |
+-----------------------------------------------------------+

Each layer has **strict rules**:

- Upper layers may depend on lower ones.
- Lower layers must **never** depend on upper ones.
- Core layer (L1) must never include platform or renderer concepts.
- Presentation (L5) may be replaced wholesale (e.g., for console port).

---

# 2. LAYER 1 — CORE LAYER (C89, DETERMINISTIC)

**Absolute rules:**
- Must compile cleanly under C89.
- No platform calls except via L3 platform callbacks.
- No dynamic allocation except through engine memory allocators.
- No floating-point nondeterminism (special rules below).
- No threading.

**Contents:**
- math (fixed-point or deterministic float rules)
- simulation state (entities, chunks, networks)
- tick scheduler
- economics
- research system
- climate model
- workers & AI logic (deterministic form)
- inventory/pipeline systems
- random number generator (custom, seeded, deterministic)
- save/load
- dpak loading
- serialization

**Deterministic Float Rules:**
- Core uses **fixed-point** type for simulation-critical values:
  - e.g. `int32_t` representing milli-units, micro-units, etc.
- Optional **deterministic IEEE float** is allowed only where:
  - value is never written back to simulation state OR
  - is rounded to fixed units before being stored.

**L1 never calls:**
- OS APIs
- OS clocks
- hardware RNG
- threads
- graphics
- audio

Everything enters L1 via function pointers or event queues defined by L3 and L2.

---

# 3. LAYER 2 — SYSTEMS LAYER (C++98)

Wraps Core Layer with higher-level engine functionality.

**Rules:**
- C++98 only (no C++11,14,17).
- Limited STL use:
  - `std::vector`, `std::string` allowed.
  - No exceptions.
  - No RTTI.
  - No `<algorithm>` heavy functions in core loops.
  - No locale/culture-sensitive libraries.

**Responsibilities:**
- Entity/component registry (maps L1 entities to UI/systems)
- Plugin system (Lua, optional native plugins)
- Resource manager (dpaks, textures, models, sounds)
- Job graph construction (dependencies, ordering)
- Single-core deterministic simulation orchestration
- Multi-core nondeterministic tasks (render, audio, UI)
- Savegame + metadata merging
- Replay writer/reader interface

**The Systems Layer is the main ‘engine’ most devs will see.**

This layer bridges L1 determinism with L3/L4/L5 nondeterminism.

---

# 4. LAYER 3 — PLATFORM LAYER (SDL1, SDL2, COCOA, WIN32, X11)

Platform abstraction layer as a **clean C API**, callable from L2 and L5.

### 4.1 Supported implementations

- SDL1 (Win98–WinXP, legacy Linux)
- SDL2 (Win2000–11, Mac, Linux)
- WIN32 Native (Win2000–11)
- COCOA (macOS 10.6+)
- X11 (Linux)
- DOS Native (future)
- Win16 Native (future)
- Console SDK wrappers (future)

### 4.2 Responsibilities

- Windows & event loop
- Input (keyboard/mouse/gamepad)
- Timers (non-deterministic)
- Filesystem (dpak I/O)
- Virtual filesystem abstraction (dpak, physical files)
- OS dialogs (optional)
- Memory allocation wrappers (optional)
- Thread creation/join (for renderer/audio)

### Restrictions

- **No simulation logic** allowed here.
- Must be replaceable at compile-time without affecting L1/L2.

---

# 5. LAYER 4 — RENDERER LAYER

The renderer interface is a **strict API boundary**:

RendererAPI {
init();
shutdown();
begin_frame();
draw_world_2d();
draw_world_3d();
draw_ui();
end_frame();
}

### 5.1 Supported renderer backends

- DX9 (Win2000+)
- DX11 (Win7+)
- OpenGL 1.1 (Win98/2000/Linux/Mac)
- OpenGL 2.0 (Win2000–11/Mac/Linux)
- Software Renderer (all platforms)
- Vector Renderer (CAD-style, all platforms)

### 5.2 Rules

- Renderer has no access to L1 (simulation state) except through **read-only snapshots** provided by L2.
- Renderers must never mutate simulation state.
- Renderer timing is nondeterministic.
- Renderer must be fully optional (headless mode).

---

# 6. LAYER 5 — PRESENTATION LAYER  
(UI, Views, Audio, User Interaction)

This is where actual "game client" functionality sits.

**Responsibilities:**
- UI windows, dialogs, toolbars
- 2D ortho map
- 2D iso map
- 3D world camera + visualization
- UI skinning
- Sound playback (mapped to L3 audio devices)
- Input binding systems
- HUD overlays
- Minimap
- Debug overlays
- Blueprint tools
- Editor interface

**Rules:**
- Presentation reacts to simulation state—it does not drive it.
- Presentation receives **tick events** from L2.
- Presentation may be replaced (e.g., console UI) without altering L1.

---

# 7. EVENT FLOW & CONTROL FLOW

A single client frame:

Platform (L3)
→ Presentation (L5)
→ Systems Layer (L2)
→ Core Simulation (L1) deterministic tick
→ Renderer (L4)
→ Platform swapbuffer

In headless mode (server):

Systems (L2)
→ Core Simulation (L1) deterministic tick

Renderer, audio, input may be missing.

---

# 8. ENGINE INITIALIZATION SEQUENCE

**Step 1 — Platform Init (L3)**  
- create window (if any)  
- load dpaks  
- allocate memory pools  
- build virtual filesystem  

**Step 2 — Systems Init (L2)**  
- load entity definitions  
- load component definitions  
- initialize job graph  
- initialize Lua VM (if enabled)  
- build simulation world  

**Step 3 — Renderer Init (L4)**  
- set up graphics context  
- load shaders  
- upload textures/models  
- allocate renderer buffers  

**Step 4 — Presentation Init (L5)**  
- load UI skin  
- create default view  
- prepare 2D/3D scenes  

**Step 5 — Enter Main Loop**

---

# 9. MAIN LOOP

Pseudocode:

while (running)
{
platform_pump_events(); // L3
systems_process_events(); // L2
if (needs_tick)
    core_tick();             // L1 deterministic

presentation_update();       // L5
renderer_render();           // L4

platform_swapbuffers();      // L3
}

Variations:
- Headless server: no L4/L5.
- Replay: core tick uses replay input stream.
- Time warp: core executes multiple ticks per frame (safe; deterministic).

---

# 10. ENGINE MEMORY MODEL

To support determinism + portability:

### 10.1 Memory Pools

Core uses:

- static pools sized at startup (based on max limits)  
- no malloc/free from C library  
- deterministic pool allocators  
- optional fixed-size handles  

Systems layer may use:
- malloc/free  
- or custom arena allocators

Renderers may use:
- Dynamic allocations freely (not simulation-critical)

### 10.2 Alignment

- Core: strict integer alignment (no platform-dependent padding)
- Systems/Renderer: platform-native alignment allowed

### 10.3 No Hidden State

No global non-deterministic state allowed in L1:
- no static mutable variables except explicitly initialized deterministic ones
- no platform dependencies
- no volatile hardware timers
- no access to OS time

---

# 11. RANDOMNESS MODEL

Dominium uses an **internal deterministic RNG**:

- A single global RNG stream per universe.
- RNG calls are serialized in deterministic order.
- All state saved in universe savefiles.
- Renderer/audio/UI cannot call RNG.

Headless and graphical clients must produce identical results.

---

# 12. CROSS-PLATFORM CONSTRAINTS

### 12.1 Endianness  
- Core state stored in little-endian canonical format.
- Big-endian platforms require byte-swap functions (in L2), not in L1.

### 12.2 Pointer size  
- L1 uses only 32-bit identifiers, never pointers in serialized state.

### 12.3 Struct layout  
- All L1 structs are packed explicitly (no compiler padding).
- L2+ layers may use normal compiler packing.

### 12.4 Floating point  
- Simulation uses deterministic fixed-point.  
- Renderer uses floats freely.  

---

# 13. PLUGIN MODEL

Dominium supports two plugin types:

### 13.1 Native Plugins  
- C89/C++98 shared libraries  
- Only allowed to interact with L2 plugin API  
- Must not access L1 directly  
- Cannot alter deterministic simulation  
- Allowed to extend tools/editors

### 13.2 Lua Plugins  
- Sandbox environment  
- Can extend content, UI, automation  
- Cannot alter deterministic tick ordering

Plugins are loaded through dpaks.

---

# 14. FUTURE-PROOFING (CONSOLE/MOBILE/LEGACY)

This architecture is intentionally flexible for:

- MS-DOS client (pure software renderer + vector mode)
- Windows 95/NT3 native ports
- macOS classic (7–9) via Carbon wrapper (future)
- WebAssembly (browser-based presentation)
- Console ports (PSP, Vita, Switch, etc.)

The **L1/L2 boundary** guarantees identical simulation everywhere.

Only L3, L4, L5 change for new platforms.

---

# 15. SUMMARY

Volume 7.1 defines:

- The entire engine layer architecture (L1–L5).
- The strict rules governing determinism and portability.
- C89 simulation at the core.
- C++98 systems bridging simulation and platform.
- Abstract platform layer with SDL/native implementations.
- Abstract renderer layer with GL1/GL2/DX9/DX11/software/vector backends.
- Presentation/UI separated from simulation logic.
- Deterministic RNG, memory model, main loop.
- Plugin system boundaries.
- Cross-platform constraints and long-term maintainability.

This is the architectural foundation for all subsequent engine volumes.

# END OF VOLUME 7.1
Ready for 7.2 or another section.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
I need one clarification before proceeding.
Volume 7.2 is large and branches in two possible directions depending on which variant you intended next:
OPTION A — Volume 7.2: Engine Core Data Structures
Covers the foundational structures of the deterministic simulation layer:
Identifiers & handles
Core types (fixed-point, vectors, quaternions, colours)
Entity model (ECS-lite)
Chunks, subchunks, hyperchunks
Network graph primitives
Inventory & cargo primitives
Deterministic containers (arrays, hash, pools)
Memory layout rules
Serialization layout
OPTION B — Volume 7.2: Engine Tick Pipeline
Covers the entire fixed-timestep deterministic scheduling system:
Tick scheduler & timescale
Multi-UPS design (1/10/60/120)
Workload spreading
Deterministic subsystem ordering
Cross-thread job graph
Safety boundaries for nondeterministic tasks
Time warp / pausing / auto-slowdown
Replay synchronization
Both are correct continuations, but one must come first.
Which one do you want as 7.2?
A or B.
You said:
First 7.2a, then 7.2b
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
Proceeding with Volume 7.2A — Engine Core Data Structures.
You will receive it as a single, continuous, uninterrupted Markdown code block, fully aligned with all prior volumes.

VOLUME 7.2A — ENGINE CORE DATA STRUCTURES
(Deterministic C89 Simulation Foundation)
# VOLUME 7.2A — ENGINE CORE DATA STRUCTURES
(C89 Deterministic Simulation Data Model)

This volume defines the internal data model that powers all simulation,
serialization, persistence, networking, replay, modding, and tick execution.
Everything here is **canonical**, **platform-stable**, **endianness-stable**,
and **deterministic** across all target systems from MS-DOS to Windows 11.

============================================================
1. GUIDING PRINCIPLES
============================================================

1. All data structures must:
   - be representable in C89
   - avoid UB, padding nondeterminism, and compiler variance
   - be endian-stable
   - be alignment-stable across x86/x64/ARM/PowerPC/etc
   - serialize bit-perfectly to disk
   - produce identical results under:
       • 16-bit real mode
       • 32-bit protected mode
       • 64-bit modern OSes
       • emulation (DOSBox, Bochs, QEMU, WineVDM)
       • WebAssembly
       • consoles

2. No floating point allowed in core simulation.
   All transforms use **fixed-point 32-bit or 64-bit** types.

3. All arrays are explicit-length, no null terminators unless string-specific.

4. All containers must have:
   - deterministic iteration order
   - deterministic hashing
   - deterministic bucket growth
   - deterministic memory behavior
   - no malloc/free in the hot tick path

5. Inline memory layouts must be stable across compilers:
   - #pragma pack or equivalent
   - static asserts for structure sizes
   - fixed-size fields only

6. No RTTI, no STL, no exceptions.
   Simulation must run in strict C89 subset.

============================================================
2. CORE FIXED-POINT NUMERIC TYPES
============================================================

Dominium uses fixed-point types to ensure reproducible simulation.

### 2.1 Fixed Point Formats

- `fx16_16`   (signed 32-bit: 16 integer, 16 fractional)
- `fx24_8`    (signed 32-bit: 24 integer, 8 fractional)
- `fx32_32`   (signed 64-bit: 32 integer, 32 fractional)
- `fx8_24`    (for very small quantities)

### 2.2 Usage Rules

- Terrain elevation: fx16_16
- Positions (x,y,z): fx32_32 for universe-level continuity
- Velocities: fx16_16
- Rotations: fx24_8 for Euler angles
- Inventory quantities: 64-bit integers
- Power units (W, V, A): fx32_32
- Temperature (°C, K): fx16_16
- Pressure: fx16_16
- Chemical concentrations: fx16_16
- Fluid volumes: 64-bit ints or fx32_32 for fractional

### 2.3 Vector Types

```c
typedef struct { fx32_32 x, y; } vec2_fp;
typedef struct { fx32_32 x, y, z; } vec3_fp;
typedef struct { fx32_32 w, x, y, z; } quat_fp;   /* Optional */
```

============================================================
3. IDENTIFIERS AND HANDLES
============================================================

### 3.1 Global Object ID (GOID)

Every object in the universe, across all saves, uses the same 64-bit ID space.

```
64-bit GOID format:
[32 bits: world-unique seed] [32 bits: incrementing counter]
```

### 3.2 Local Object Handle

The simulation uses compact integer handles in arrays and pools:

```c
typedef uint32_t handle32;
```

Rules:
- Handles index into deterministic pools.
- Never expose handles to modders; expose GOIDs.

============================================================
4. CONTAINERS (DETERMINISTIC)
============================================================

### 4.1 Deterministic Array (DArray)

- Fixed capacity or growth via doubling.
- Growth must be deterministic by pre-seeding arena allocators.
- No pointer invalidation allowed.

### 4.2 Deterministic Hash Table (DHash)

- Open addressing.
- No random seeds.
- Deterministic probe sequence.
- Growth via deterministic rehash (memcpy into new array).

### 4.3 Deterministic Pool Allocator (DPool)

- Fixed slots.
- Freelist with stable ordering.
- Never shrink.

### 4.4 Deterministic Graph

Used for:
- road/rail/power/data networks
- inter-property transport edges
- worker routing
- climate coupling pathways

Graph representation:

```
nodes[]     deterministic array
edges[]     deterministic array
adj[]       sorted adjacency lists
```

============================================================
5. WORLD GRID HIERARCHY (CHUNKS)
============================================================

Dominium uses a 4-level spatial system:

- Subchunk:   16m x 16m
- Chunk:      256m x 256m
- Superchunk: 4096m x 4096m
- Hyperchunk: 65536m x 65536m

### 5.1 Coordinate Format

Coordinates stored as:

```c
typedef struct {
    int32_t cx, cy, cz;    /* chunk coords */
    fx32_32 ox, oy, oz;    /* offset within chunk */
} world_pos;
```

Altitude uses chunk index + fixed offset.

### 5.2 Terrain Storage

Terrain is stored as:

- heightmap per chunk (fx16_16)
- material ID map (uint16)
- biome ID map (uint16)
- water table, moisture, temperature scalar maps

Everything is chunk-local for locality and determinism.

============================================================
6. ENTITY MODEL (ECS-LITE)
============================================================

Dominium uses a hybrid ECS-lite model:

- Components stored in big deterministic arrays.
- Entities reference components via handles.
- 1 entity = bundle of component handles + GOID.

Components have strictly defined initialization order and layout.

### 6.1 Core Components

- Transform (pos, rot)
- Physics (optional)
- Render (sprite/mesh ID)
- Network nodes (power/data/fluids)
- Machine state
- Inventory
- Worker/Vehicle
- Temperature/Pressure
- AI brain pointer (robots)
- Wiring/piping/rail segments

All components must be deterministic.

============================================================
7. INVENTORIES AND CARGO
============================================================

### 7.1 Inventory Format

Inventories use arrays of:

```c
typedef struct {
    item_id  id;
    uint64_t qty;
} inv_slot;
```

Max slots defined per machine/building.

### 7.2 Cargo Containers

All transport uses containerization:

- 5ft
- 10ft
- 20ft
- 40ft
- 80ft

Containers store:
- item array
- quality/temperature/pressure attributes (depending on cargo type)

============================================================
8. NETWORK STRUCTURES
============================================================

Networks (power, data, fluids, logistics) share a core structure:

- Nodes: fixed array of structs
- Edges: fixed array + adjacency lists
- Routing: deterministic Dijkstra variant (no randomness)
- Packets/flows: discrete units per tick with strict ordering
- For data network:
  packets are small structs with deterministic sequencing
- For fluids:
  flows are fx32_32 values
- For electrical:
  nodes store voltage, current, phase, frequency
- For logistics:
  paths store permitted vehicle types/weights

============================================================
9. SERIALIZATION FORMAT
============================================================

All structures must serialize directly without conversion:

- big-endian canonical on disk
- C89 struct → canonical binary block
- explicit padding bytes
- version-tagged sections
- deterministic ordering of arrays/hashes/pools

============================================================
10. MEMORY MODEL
============================================================

- All allocations from arenas defined at startup.
- No OS malloc/free in hot path.
- Legacy OSes (DOS, Win3.x) use separate lowmem fits.
- Modern OSes get large reserved pages.

============================================================
11. MODDING EXPOSURE
============================================================

Lua sees:
- GOIDs
- accessor functions
- immutable descriptors (building types, item types)
- safe APIs for reading/writing inventories and networks
- NO direct memory access
- NO pointers

============================================================
12. TESTING AND VERIFICATION
============================================================

- Deterministic tests compare byte-perfect save files.
- Tick-by-tick replay validation.
- Component-specific diff outputs.
- Universe-wide hash checks.

============================================================
END OF VOLUME 7.2A
============================================================

If ready, I can now produce Volume 7.2B — Tick Pipeline & Deterministic Scheduling.
You said:
Yes
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Volume 7.2B — Tick Pipeline & Deterministic Scheduling.
This will be a single uninterrupted Markdown code block, matching the style, scale, and rigor of 7.2A.

VOLUME 7.2B — TICK PIPELINE & DETERMINISTIC SCHEDULING
(C89 deterministic simulation timing system)
# VOLUME 7.2B — TICK PIPELINE & DETERMINISTIC SCHEDULING
(Fixed-step, deterministic, multi-frequency, multi-thread–safe)

This volume defines the *canonical*, *deterministic*, *platform-stable*
simulation timing and scheduling model of Dominium.

============================================================
1. DESIGN GOALS
============================================================

The tick system must:

1. Run deterministically across:
   - CPU architectures (x86, x64, ARM, PowerPC, MIPS)
   - OSes (Win2000+, macOS 10.6+, Linux, DOS, Win3.x, WebAssembly)
   - compilers and optimization levels
   - variable UPS/FPS settings
   - multiplayer, replay, headless servers

2. Support:
   - 1 UPS (ultra-low-power)
   - 10 UPS (legacy, servers, low-end)
   - 60 UPS (standard)
   - 120 UPS (high-performance)
   - unlimited UPS (debug, timewarp)
   All selectable by user or server admin.

3. Decouple UPS and FPS fully:
   - Simulation continues even if FPS drops.
   - FPS continues even if simulation stalls.
   - Auto-slowdown when UPS cannot be sustained.

4. Support multi-core execution while remaining deterministic.

5. Spread work across ticks to avoid CPU spikes.

6. Provide discrete scheduling groups:
   - high-frequency systems (machines, networks)
   - medium-frequency (workers, vehicles)
   - low-frequency (economy, AI)
   - very-low-frequency (climate, planetary, orbital)

7. Integrate replay, multiplayer lockstep, and debugging.

============================================================
2. DEFINITIONS
============================================================

### "UPS" = Updates Per Second (simulation steps)
### "FPS" = Frames Per Second (rendering)
### "Tick" = a single deterministic update step

The simulation ALWAYS uses *fixed timestep* ticks.

### Canonical Tick Duration:
```
1 / UPS seconds per tick
```

### Tick Index:
A 64-bit integer incremented every tick, stored in saves and replays.

============================================================
3. FIXED STEP MODEL
============================================================

Simulation proceeds as:

```
accumulator += real_frame_time;

while accumulator >= tick_duration:
    run_tick();
    accumulator -= tick_duration;
```

If real_frame_time is too slow, accumulator grows, causing tick debt.

Tick debt cannot be repaid by running multiple ticks in a row; instead:

============================================================
4. DETECTING OVERRUN & AUTOSLOWDOWN
============================================================

If accumulator exceeds one tick duration by more than a threshold:

```
speed_factor = tick_duration / accumulator;
```

Meaning:

- speed_factor < 1 → game runs in slow motion
- Determinism preserved (ticks are still fixed duration)
- Gameplay slows to match CPU available

Displayed to user as:

```
Simulation Speed: 72%
```

UPS remains conceptually 60, but **real-time rate slows**.

============================================================
5. UPS SELECTION & PRIORITY RULES
============================================================

UPS options:
```
1, 2, 5, 10, 20, 30, 45, 60, 90, 120, 180, 240
```

User may override limits manually.

If unlimited UPS is selected:
- UPS runs as fast as CPU allows.
- FPS is decoupled unless linked explicitly.

============================================================
6. MULTI-FREQUENCY SYSTEM SCHEDULING
============================================================

Some systems do NOT require 60Hz simulation.

We define deterministic scheduling buckets:

### 6.1 60 Hz systems (every tick)
- fast networks (power/data step)
- machine micro-loops
- conveyors, pipes (fluid steps)
- worker micro-movement
- vehicle physics
- local AI decision microsteps

### 6.2 10 Hz systems (every 6 ticks)
- pathfinding jobs
- chunk loading/unloading
- economic micro-updates
- production request bundling

### 6.3 1 Hz systems (every 60 ticks)
- building heat budgets
- biome adjustments
- slow weather transitions
- long-distance logistics (shipping routes)

### 6.4 0.1 Hz systems (every 600 ticks)
- climate update coupling
- market macro adjustments
- corporate finance layers

### Deterministic rule:

A subsystem runs on tick T iff  
```
(T mod interval) == 0
```
No drift, no jitter, no skipped intervals.

============================================================
7. PARALLELISM / MULTICORE MODEL
============================================================

Dominium supports multiple cores IFF deterministic.

### 7.1 Worker-Master Scheduling

Each tick:

```
tick_begin()

master thread:
    prepares job graph for tick

worker threads:
    execute assigned jobs deterministically
    no races, no data hazards

master thread:
    final combination & commit
tick_end()
```

### 7.2 Deterministic Job Graph

Jobs are fixed-size tasks:
- never spawned dynamically based on runtime nondeterminism
- arranged in a DAG built at startup
- each frame assigns deterministic job order
- each worker thread processes jobs in fixed order

### 7.3 Data Partitioning

World is split by:
- chunks
- network partitions
- entity pools

Parallel-safe groups:
- adjacent chunk groups never run in parallel
- cross-chunk dependencies enforced in ordering

============================================================
8. SPREADING WORK ACROSS TICKS
============================================================

To avoid spikes:
- expensive operations (pathfinding, climate, market updates)
  are spread out deterministically:

```
index = tick % NUM_PARTITIONS
partition[index].process()
```

Examples:
- 4096 chunks → process 64 per tick (64*60 = 3840 per second)
- 1024 worker units → 16 per tick
- 16000 logistic edges → 267 per tick

No variability, perfect reproducibility.

============================================================
9. LOCKSTEP MULTIPLAYER / REPLAYS
============================================================

### 9.1 Lockstep Rule:
Only **inputs** are synchronized.
All simulations must run identical ticks.

Therefore:
- all randomness is removed or seeded deterministically
- floating point is forbidden in simulation
- all scheduling and partitioning deterministic

### 9.2 Replay Format

Replays store only:
- tick index
- player inputs
- network inputs
- deterministic events

Optionally:
- periodic snapshots (every N ticks)

Replaying:
- engine loads state
- replays inputs
- simulation state must match bit-for-bit

============================================================
10. FRAME (FPS) LOOP
============================================================

FPS loop is free-running:

```
while game_running:
    compute real_frame_time
    run ticks until accumulator < tick_duration
    render frame
```

FPS may:
- run uncapped
- cap at classic values (24, 30, 60, 120, 240)
- link to UPS if user desires
- sync to vsync if desired

FPS NEVER affects determinism.

============================================================
11. PAUSING, TIMEWARP, AND FAST-FORWARD
============================================================

### 11.1 Pausing
Stop simulation ticks.
Render continues.

### 11.2 Timewarp
User selects a multiplier:
- 2×, 4×, 8×, 16×, 32×, unlimited

System attempts to run multiple ticks per render, but:
- determinism preserved
- slowdowns still apply if CPU insufficient

### 11.3 Fast-forward on headless server
Always uses unlimited UPS unless capped by admin.

============================================================
12. FAILSAFE MECHANISMS
============================================================

### 12.1 Tick Watchdog
If a tick exceeds a threshold:
- record debugging info
- warn user
- may trigger auto-slowdown

### 12.2 Deterministic Stall Recovery
If a system fails:
- engine aborts safely
- no partial state is committed
- user sees error message

### 12.3 Multi-core fallback
If thread contention detected:
- fallback to single-core deterministic mode automatically

============================================================
13. TESTABILITY AND DEBUGGING
============================================================

- record tick hash after each subsystem
- replay validation compares hash stream
- debug builds include detailed per-tick logs
- profiler shows time per subsystem
- deterministic fuzzing (inputs generated from seed)

============================================================
END OF VOLUME 7.2B
============================================================

Ready for the next.
Choose:
7.3 (Terrain System), 7.4 (Simulation Chain), 7.5 (Renderer Interface), 7.6 (Audio), 7.7 (Input), 7.8 (Threading), or 7.9 (Logging).
You said:
Proceed 7.3
ChatGPT said:
GPT-5.1 — 2025-11-30
Confirming.
Volume 7.3 — Terrain & Voxel/Heightfield System is next.
Before I generate it, I need one forced choice, because 7.3 branches into two different geometry paradigms, each with major compounding consequences for:
memory layout
rendering (2D + 3D)
LOD strategy
determinism
chunk storage
tool compatibility
modding
pathfinding
simulation integration
disk size
compression
performance on Win2000-era hardware
You must choose one before I can produce 7.3.

TERRAIN ENGINE MODEL (CHOOSE ONE)
A — Hybrid Heightfield + Sparse Voxel Layers (Recommended)
This model matches everything you’ve described so far:
Ground Level
A heightfield:
1 value per (1m × 1m) or (0.5m × 0.5m) cell
fully deterministic
cheap
easy LOD
realistic terrain shaping
Below Ground
Sparse voxel "strata layers" only when needed:
tunnels
mineshafts
caverns
basements
underground structures
utilities (pipes, cables, subways)
Not a full 3D voxel world; only stores voxels where solids are excavated.
Above Ground
Bridges and structures use construction geometry, not terrain voxels.
Result
realistic geography
extremely efficient
works for 2D and 3D
suitable for giant maps (km-scale)
perfect determinism
supports verticality without full voxel cost
best for your game concept
minimal memory footprint and CPU load

B — Pure Voxel Terrain (Full 3D Grid)
Minecraft-style cube world.
Pros:
simple data model
fully destructible world
underground/overground unified
Cons:
massive memory usage
slow pathfinding
harder LOD
bad for large km-scale maps
poor performance on low-end hardware
poor fit for real-world engineering simulation
painful on Win2000-era GPUs/CPUs
Not recommended for Dominium.

C — Dual Heightfields (Surface + Subsurface) + Carved Geometry
Two heightfields:
surface height
bedrock/ceiling height
Cavities and tunnels stored as carved poly volumes.
Pros:
simpler than voxel layers
lightweight
extremely reproducible
similar to SimCity 4 region model
elegant for large terrain chunks
Cons:
more limited underground complexity
less flexible than sparse voxels
still requires custom geometry generation

D — Multi-layer Heightfield Stack (Discrete Geological Layers)
Terrain represented as N stacked heightfields:
topsoil
sand
clay
rock
bedrock
Each layer has thickness at every XY coordinate.
Pros:
geologically realistic
nice for mining simulations
easy to simulate erosion and excavation
Cons:
tunnels & basements become complicated
bridges/towers need special-case geometry
cannot represent overhangs
insufficient for your tunnels, peaks, cave networks, bridges

MY RECOMMENDATION FOR DOMINIUM
Option A — Hybrid Heightfield + Sparse Voxel Layers exactly fits your requirements:
highly realistic terrain
arbitrary bridges, tunnels, underground structures
scalable to multi-km maps
deterministic
efficient on Win2000 hardware
compatible with 2D vector, 2D sprite, and 3D rendering
supports basements, skyscrapers, caverns, shafts, overhangs
supports terrain modification machines
avoids voxel performance problems
supports chunk LOD
supports exporter/importer tools
supports scripting and modding
supports multi-storey civil engineering
world editing remains simple
This is the model used by many modern engineering simulators.

Which model should Vol 7.3 adopt?
Choose A, B, C, or D.
You said:
A
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 7.3 — TERRAIN SYSTEM  
Dominium Engine Specification — Engine Core, Part 3  
(Hybrid Heightfield + Sparse Voxel Layers, C89 Deterministic)

This volume defines the **terrain representation**, **storage**, and **update model**
for Dominium, using:

- A **primary heightfield** for surface terrain
- **Sparse voxel volumes** for underground cavities, tunnels, basements, and special overhangs
- **Construction geometry** for bridges, buildings, and structures above ground
- Full determinism and portability across all supported platforms

Everything here is C89-compatible and integrated with 7.1 and 7.2A/B.

============================================================
1. GOALS AND CONSTRAINTS
============================================================

1. Represent realistic terrain over large areas
   - Properties up to many kilometers
   - Steep slopes, cliffs, ridges, valleys
   - Local detail at 1m resolution (or finer internally)

2. Support fully:
   - tunnels, mineshafts, caverns
   - basements and sub-basements
   - underground utilities (pipes, cables, sewers, subways)
   - bridges, viaducts, platforms
   - multi-level road and rail

3. Keep storage and CPU usage low enough for:
   - Windows 2000-era hardware
   - low-core machines
   - headless servers

4. Maintain:
   - strict determinism (no floating-point in core)
   - fixed memory layouts
   - chunk-based streaming
   - straightforward modding and world editing

We do this with:

- A **2.5D heightfield** as the canonical terrain surface
- **Sparse voxels** only where needed (below/within the terrain)
- **No full 3D voxel grid** for the entire world

============================================================
2. TERRAIN RESOLUTION AND COORDINATES
============================================================

Grid base resolution: **1 metre** per terrain cell in XY.

### 2.1 Terrain Sample Grid

Per chunk (256m × 256m), we store an N×N grid:

- `N = 256` samples → 1m resolution per cell
- Optionally super-sampling internally (2× or 4×) for smoothing, but canonical is 1m

Each terrain sample corresponds to:

```c
typedef struct {
    fx16_16 height;       /* elevation above canonical Z=0 (sea level) */
    uint16_t material_id; /* soil, rock, sand, etc. */
    uint16_t biome_id;    /* grassland, desert, forest, etc. */
} terrain_sample;
Height is relative to planetary Z=0 (sea level definition; see climate volumes).
2.2 Chunk Coordinate Integration
As per 7.2A:
typedef struct {
    int32_t cx, cy;   /* chunk indices in X/Y */
} terrain_chunk_id;
Within a chunk, cell indices (ix, iy) map to world coordinates:
world_x = cx * 256 + ix
world_y = cy * 256 + iy
world_z = sample.height
All in fixed-point or integers.
============================================================
3. HEIGHTFIELD BASE MODEL
3.1 Base Heightfield Definition
Each terrain chunk contains:
typedef struct {
    terrain_chunk_id id;
    uint16_t width;     /* = 256 */
    uint16_t height;    /* = 256 */
    terrain_sample samples[256 * 256];

    /* Precomputed derivatives (optional) */
    fx16_16 slope_x[256 * 256];
    fx16_16 slope_y[256 * 256];

    /* Flags */
    uint32_t flags;
} terrain_chunk;
Precomputed slopes used for:
pathfinding heuristics
construction constraints
water drainage / flow direction estimation
visual shading hints (vector renderer)
3.2 Material & Biome Layers
material_id and biome_id index into dpak-defined tables:
Materials: density, cohesion, thermal properties, excavation cost
Biomes: vegetation, weather interaction, climate modifiers
This ties into resource and climate systems, not terrain structure itself.
============================================================
4. SPARSE VOXEL LAYERS (SUBTERRANEAN AND SPECIAL GEOMETRY)
We represent underground geometry as sparse voxel volumes attached to a chunk.
4.1 Voxel Grid Resolution
Underground voxel resolution: 1m³ cells, aligned with terrain grid.
Per chunk, we do not allocate a full 256×256×H 3D grid. Instead, we track:
Only cells that deviate from the "solid-from-bedrock-to-surface" assumption.
Base assumption:
For each (x,y), from some deep bedrock Z to surface height, terrain is solid.
We then define excavations and cavities as sparse overrides.
4.2 Voxel Cell Definition
typedef struct {
    int16_t dz;          /* vertical offset from surface-level reference; or absolute Z in local coords */
    int16_t height;      /* extent (number of 1m cells) */
    uint16_t material_id;
    uint16_t flags;      /* e.g., hollow, filled, support structure, etc. */
} voxel_column_segment;
Voxel data per chunk stored as:
typedef struct {
    uint16_t ix, iy;                 /* XY position within chunk */
    uint16_t segment_count;
    voxel_column_segment *segments;  /* segments allocated from chunk arena */
} voxel_column;
And the chunk has:
typedef struct {
    uint16_t column_count;
    voxel_column *columns;    /* sparse list */
} voxel_layer;
Only (ix, iy) positions that are modified from the baseline are stored.
Examples:
Mina shaft: a hollow segment from surface-10m down to surface-50m
Basement: a hollow 5m segment under a building footprint
Cavern: multiple adjacent columns with hollow segments
4.3 Overhangs and Cliffs
Overhangs are modeled as solid segments above the baseline surface.
Example: a natural arch or artifical overhang.
We attach above-ground voxel segments where heightfield alone cannot represent the geometry (e.g., a rock shelf).
These are rare and localized.
============================================================
5. TERRAIN TYPES: SOLID, HOLLOW, FLUID
Each voxel segment can be:
SOLID: rock, soil, concrete
HOLLOW: air, tunnel
FLUID: water, oil, gas
STRUCTURAL: reinforcement, supports, beams
Flags:
#define VOXEL_FLAG_HOLLOW      0x0001
#define VOXEL_FLAG_FLUID       0x0002
#define VOXEL_FLAG_STRUCTURAL  0x0004
#define VOXEL_FLAG_RESERVED    0x0008
The combination of heightfield + segments yields:
For any (x,y,z): is it solid, hollow, fluid?
Used for:
collision
excavation
underground routing (pipes, cables)
worker access/clearances
============================================================
6. TERRAIN MODIFICATION (DIGGING, FILLING, GRADING)
Terrain modifications are applied via operations, not arbitrary state writes.
Examples:
cut/fill
flatten
slope
trench, tunnel, mineshaft
basement excavation
landfill
6.1 Operation Representation
Operations are C89 structs stored in per-chunk log:
typedef enum {
    TERRAIN_OP_CUT,
    TERRAIN_OP_FILL,
    TERRAIN_OP_TUNNEL,
    TERRAIN_OP_SHAFT,
    TERRAIN_OP_BASEMENT,
    TERRAIN_OP_SMOOTH,
    TERRAIN_OP_RET_WALL
} terrain_op_type;

typedef struct {
    terrain_op_type type;
    /* bounding box in local chunk coords */
    uint16_t x0, y0, x1, y1;
    fx16_16 z0, z1;      /* vertical range or target level */
    uint16_t material_id;
    uint32_t flags;
} terrain_op;
Terrain is:
Generated from base (planet/procedural or defined)
Operations applied in deterministic order to produce final chunk
This allows:
replaying operations when rebuilding terrain
minimal storage of edit history if desired
easy undo/redo in editor
============================================================
7. INTERACTION WITH BUILDINGS & STRUCTURES
Buildings, roads, rail, bridges, and other constructed objects are not part of the terrain heightfield.
Instead:
They are separate entities (ECS) placed on or within terrain.
Terrain is the "ground", structures sit above (or carve below).
7.1 Terrain-Constrained Placement
When placing a structure:
Query terrain heightfield for each footprint cell.
Check slope against allowed thresholds.
For basements or underground facilities:
create or require excavations via terrain ops
ensure voxel segments updated
7.2 Bridges and Platforms
Bridges:
Are independent geometry
Anchor at specific (x,y,z) positions on terrain
Underlying terrain may remain untouched, or be flattened locally if needed
The interproperty networks (rail, road) use route segments that reference:
support surfaces (terrain / structural decks)
clearance spaces (under/over)
============================================================
8. WATER, COASTLINES, AND FLUIDS
Water is represented at two levels:
Macroscopic water (oceans, lakes, rivers)
Represented as a heightfield or level set over terrain
For each (x,y), water_surface_z and water_depth
Works with climate and hydrology systems
Subterrain fluids (sewers, pipes, tanks, aquifers)
Represented via fluid networks and voxel segments with FLUID flag
8.1 Sea Level and Coastlines
Sea level is defined per planet (canonical Z=0 for oceans).
Terrain samples below zero are underwater by default.
Coastlines derived from terrain heightfield intersecting sea level.
Flooding, tides, and storm surges adjust the fluid heightfield overlay, not the terrain itself, except when permanent erosion/fill operations occur.
============================================================
9. LEVELS, BASEMENTS, AND TOWERS
We adopt the global L/Z model:
Z=0 → sea level
terrain height at (x,y) → ground level, may be >0 or <0
L=0 (logical ground floor) is defined per building and does not equate to Z=0 numerically.
9.1 Basements
Basements are:
structural entities with a footprint
attached to voxel excavations
exist at negative or positive Z relative to sea level, depending on terrain
Basement creation operations:
Terrain operation to make cavity (TERRAIN_OP_BASEMENT).
Building entity referencing that cavity region.
Utilities (pipes, cables) placed within cavity space.
9.2 Towers and Elevated Structures
Towers:
are structural entities only
terrain does not need to be altered except for foundation
vertical clearance is handled in collision and network routing
============================================================
10. TERRAIN LOD AND RENDERING SUPPORT
10.1 LOD Levels
At minimum, we define:
LOD0: full 1m resolution (local gameplay)
LOD1: 2m or 4m resolution (near property)
LOD2: 8m or 16m resolution (area map)
LOD3: 64m or 256m resolution (continent/global maps)
LOD generation:
derived deterministically from base heightfield using fixed-point averages
used for:
2D vector and texture modes
3D terrain mesh generation
strategic maps
10.2 Geometry Generation (L4/L5)
Renderer layer (L4) generates:
triangle meshes for 3D view (from height sampled at LOD0 or LOD1)
contour line sets for 2D vector view
shaded relief for 2D texture view
Core (L1) provides:
raw heightfield
slope
material/biome IDs
water levels
Renderer chooses how to visualize.
============================================================
11. PATHFINDING AND TERRAIN
Terrain provides:
slope at each cell
material-based movement penalties
water vs solid flags
For pathfinding:
local pathfinding uses the 1m grid
long-range pathfinding can use coarser LOD
Terrain constraints:
maximum slope for roads, rails, footpaths
travel cost modifiers
Tunnels and bridges appear as special path graph edges, not terrain nodes.
============================================================
12. SERIALIZATION AND SAVEGAME FORMAT
For each chunk:
serialize:
header (chunk id, version)
base heightfield samples
voxel sparse layers
terrain operations log (optional or compressed)
all values stored in canonical endianness (big-endian or chosen standard)
no padding bytes without explicit control
Checkpointing:
full terrain state saved
for editor or replays, we may optionally store op logs for incremental rebuilding
============================================================
13. MODDING AND WORLD EDITING
World editor can:
paint heightfield values (raise/lower)
apply operations (cut, fill, smooth)
carve tunnels and caverns using 3D tools
define custom materials and biomes via dpaks
define prebuilt basements and underground facilities
Mods can:
introduce new terrain generators for:
planets
regions
properties
define specific property templates (e.g. mountainous coastal property) using LOD-aware recipes.
============================================================
14. PERFORMANCE CONSIDERATIONS
Memory:
Heightfield per chunk: 256×256 samples = 65,536 samples
Each sample: 4 bytes (height + material + biome minimal) or more
≈ 256 KB per chunk worst-case, can be compressed LZ/Delta when idle
Sparse voxels:
Only allocated where needed; typical maps have sparse underground usage.
Each voxel column uses pool allocation from a per-chunk arena.
CPU:
Height queries are O(1)
Slope queries O(1) using precomputed derivatives
Underworld queries O(log N) or O(1) average per sparse column
Determinism:
All operations apply in a fixed, globally defined order.
No random terrain modifications at runtime except deterministic generator.
============================================================
15. SUMMARY
Volume 7.3 defines Dominium’s terrain as:
A hybrid system:
Primary: heightfield (1m grid, chunk-based).
Secondary: sparse voxel segments for underground and special geometry.
Structures and bridges as separate entities, not terrain.
With:
Full support for basements, tunnels, shafts, caverns, bridges, overhangs.
Integration with networks (roads, rail, utilities) and workers.
Deterministic, fixed-point execution.
Chunk-based memory and serialization.
Efficient LOD for 2D/3D views.
Future compatibility with climate, hydrology, and property/world generation.
This terrain model underpins all future property design, construction, logistics,
and environmental systems in Dominium.
END OF VOLUME 7.3

::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating Volume 7.4 — Simulation Chain Overview, I need to confirm one design choice that determines the structure of the entire simulation pipeline.

CRITICAL CHOICE BEFORE 7.4: SIMULATION CHAIN LAYOUT MODEL
There are three valid deterministic architectures for building the Dominium simulation chain.
7.4 depends entirely on this choice.
You must select A, B, or C.

A — STRICT LINEAR PIPELINE (Fully Ordered, Hard Determinism)
Every subsystem runs in a fixed, global sequence:
TICK:
  1. Input Collection
  2. Scripting (Lua pre-step)
  3. Terrain Ops
  4. Power Network
  5. Data Network
  6. Fluid Network
  7. Machines
  8. Inventories
  9. Logistics (Vehicles)
  10. Workers
  11. Environment (fire/heat/etc)
  12. Economy
  13. AI
  14. Climate
  15. Rendering Prep
Pros
Absolute determinism
Simple to reason about
No dependency graph
Great for replays and debugging
Cons
Hard boundaries between systems
More tick stalls if a subsystem becomes heavy
Less parallelism
This is Factorio’s model.

B — SEMI-LINEAR PIPELINE WITH SUBSYSTEM PHASES (Recommended)
Simulation is grouped into major phases:
TICK:
  PHASE A: Input, Orders, Commands
  PHASE B: Networks (Power → Data → Fluids)
  PHASE C: Machines & Processing
  PHASE D: Logistics (Vehicles, Workers)
  PHASE E: Environment (Heat, Weather Coupling)
  PHASE F: Economic & Corporate Systems
  PHASE G: AI Planning
  PHASE H: Terrain/World Ops (low-frequency)
Each phase contains multiple subsystems that run in a fixed order, but:
Phases can run in parallel internally
Subsystems within a phase may run in a soft deterministic job chain
Dependencies across phases are cleanly defined
Pros
More parallelism
Predictable
Perfect determinism
More scalable
Suitable for your enormous system variety
Reduces CPU spikes
Ideal for 1/10/60 UPS model
Cons
Slightly more complex to implement
Phase design must be extremely strict
This is similar to Cities Skylines 2’s intended architecture (but deterministic).

C — FULL DAG (Dependency Graph) SIMULATION MODEL
Everything is a node.
Ticks compute a topologically sorted DAG of dependent systems.
Pros
Maximum parallelism
Very flexible
Automatic ordering
Cons
Harder to maintain determinism
Harder to debug
Bad for modding (mod order becomes a nightmare)
Too expensive for low-end targets
Not suited for Win2000/MS-DOS/Win3.x ports
This model is used by complex scientific simulators—not game engines.

MY RECOMMENDATION: B
Given your:
multi-network system
multi-frequency scheduling
desire for huge feature breadth
determinism requirement
future modding support
server scalability
legacy platform support
Option B is the correct fit.
It gives us:
deterministic phase-chained simulation
maximum performance
good parallelization
simple replay system
simple mod-host boundaries
future DLC scalability
perfect CPU load spreading
And avoids the pitfalls of pure linear (A) and full DAG (C).

Choose A, B, or C.
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 7.4 — SIMULATION CHAIN OVERVIEW  
Dominium Engine Specification — Engine Core, Part 4  
(Semi-linear phased model, deterministic, multi-frequency)

This volume defines the **entire simulation chain** for Dominium, using the  
**Phase-B semi-linear pipeline**:

- Fixed global order of **phases**
- Deterministic order of **subsystems** inside each phase
- Explicit multi-frequency scheduling (1/10/60/etc UPS)
- Parallelism *inside* phases where safe
- Strict data-dependency contracts between phases

All of this runs inside the deterministic C89 core (L1) and is orchestrated by
the C++98 systems layer (L2) as defined in 7.1 and 7.2A/B.

---

## 1. HIGH-LEVEL TICK STRUCTURE

Each simulation tick `T` consists of phases:

PHASE A: Input & Commands
PHASE B: Networks (Power, Data, Fluids, Logistics Graph Prep)
PHASE C: Machines & Processing
PHASE D: Mobility (Workers, Vehicles, Path Execution)
PHASE E: Environment & Local World (Heat, Weather Coupling, Fire, Damage)
PHASE F: Macroeconomy & Corporate Systems
PHASE G: AI Planning & Strategy
PHASE H: Low-Frequency World Ops (Terrain, Climate, Long-Horizon Systems)

These phases run in **strict order** A → B → C → D → E → F → G → H per tick.

Within each phase:
- Subsystems have a fixed deterministic order.
- Work can be partitioned and parallelized, but **result must be the same** as if
  subsystems were run sequentially with that fixed ordering.

---

## 2. PHASE A — INPUT & COMMANDS

**Frequency:** Every tick (all UPS settings).

### 2.1 Responsibilities

- Collect **player inputs** (from L5/L3, but stored in deterministic buffers).
- Apply **queued commands** from:
  - GUI interactions
  - Scripting (Lua) front-end commands
  - Autopilot / automation scripts
  - Networked multiplayer inputs (already validated and ordered)
- Resolve **command ordering** deterministically per player/company/property.
- Feed resulting requests into command queues for later phases.

### 2.2 Subsystems (A1–A4)

1. **A1: Input Buffer Ingestion**
   - Convert physical inputs into logical game actions.
   - Map to canonical actions based on bindings (L7 Input spec).
   - All time-stamped with tick index `T`.

2. **A2: Command Resolution**
   - For each company/property:
     - Sort commands by deterministic criteria:
       - player ID, company ID, sequence number.
   - Remove invalid or outdated commands.
   - Produce canonical per-company command list.

3. **A3: Scripted Commands (Lua, deterministic)**
   - Lua callbacks scheduled to run only here; they:
     - read simulation state via stable API
     - enqueue game commands
   - No direct state mutation; everything goes through commands.

4. **A4: Command Dispatch**
   - Commands routed to target subsystems:
     - building placement/removal
     - blueprint edits
     - research allocation
     - worker reassignment
     - logistics instructions
     - financial transactions

Results: a deterministic queue of actions for B/C/D/F/G/H.

---

## 3. PHASE B — NETWORKS

**Frequency:**  
- Core networks: every tick (60 Hz canonical).  
- Some sub-networks: 10 Hz or 1 Hz as defined in 7.2B.

Networks here are *infrastructure graphs*:

- Electrical Network
- Data/Control Network
- Fluids (liquids/gases)
- Logistics Graph (routes, capacity precomputations)

### 3.1 Goals

- Propagate flows/signals deterministically.
- Prepare state for machines in Phase C and mobility in Phase D.
- Spread heavy computations across ticks (7.2B).

### 3.2 Subsystems (B1–B4)

#### B1: Electrical Network

- Runs every tick.
- Input:
  - Generator outputs, loads from previous tick, machine connection states.
- Compute:
  - Node voltages and currents
  - Per-phase (DC, 1-phase AC, 3-phase AC) flows
  - Power limits / overloads / blackouts
- Output:
  - Available power at each machine/input node for Phase C.
  - Alarms for under/over voltage, frequency deviations.

#### B2: Data Network

- Runs every tick for local segments; 1–10 Hz for long-haul segments.
- Simulates:
  - addressable packets
  - continuous signals (hold/latched mode)
  - push/pull, poll/interrupt semantics
- Data flows:
  - Sensor readings
  - Control commands
  - Research data (science data delivered to research machines)
- Output:
  - Input buffers for machines and AI
  - Research progress contributions to Phase F/G

#### B3: Fluid Network

- Runs at 60 Hz for small segments, 10 Hz for large-scale pipes.
- Manages:
  - pressure, flow, temperature per segment
  - mixing rules for fluids (careful as defined in Volume 2.x)
  - capacity and throttling
- Output:
  - available fluid input states at machines
  - tank levels, pipeline statuses

#### B4: Logistics Graph Precomputation

- Runs at 10 Hz or lower, depending on world size.
- Maintains:
  - path cost tables
  - route caches
  - capacity constraints on corridors
- Does **not** move vehicles (that’s Phase D).
- Output:
  - route solutions for Phase D mobility.

---

## 4. PHASE C — MACHINES & PROCESSING

**Frequency:** 60 Hz tick; some parts downsampled to 10/1 Hz.

Machines are the **productive heart** of the simulation:

- Assemblers, refineries, factories
- Power generators, transformers, substations
- Pumps, compressors, heaters, coolers
- Logistics hubs (loaders/unloaders, warehouses)
- Research machines
- Data processors

### 4.1 Responsibilities

- Consume inputs:
  - inventory items
  - fluids
  - electrical/data resources
- Perform transformations:
  - crafting/assembling
  - refining, chemical processes
  - data analysis (science)
- Produce outputs:
  - inventory items, fluids, heat, research progress, signals
- Update internal states:
  - progress timers
  - wear/outage
  - maintenance metrics

### 4.2 Subsystems (C1–C6)

#### C1: Machine State Update

- For each active machine:
  - Update timers (fixed-point).
  - Check command queue for:
    - start/stop commands
    - recipe changes
    - priority changes
  - Determine its power/data/fluid availability (from Phase B outputs).
  - Determine whether it runs this tick or stalls.

#### C2: Input Acquisition

- Deterministically draw from inventories/pipelines:
  - Always follow well-defined order (e.g., by machine ID, slot index).
  - Never yield varying drain order between runs.
- Verify all required inputs exist for the recipe step.

#### C3: Process Execution

- Convert inputs to outputs according to recipe:
  - deterministic rounding rules for partial units
  - temperature/pressure/electrical influence on efficiency
- For multi-tick processes:
  - accumulate progress and finalize at thresholds.

#### C4: Output Commit

- Write produced items/fluids/energy into:
  - machine output buffers
  - connected inventory cells
  - pipeline segments
  - data packets (e.g. measurement logs)
- Use deterministic overflow rules:
  - if capacity full, define exactly what happens:
    - output lost / re-queued / halted (clear policy).

#### C5: Research Contribution

- Machines designated as research devices:
  - convert _science input_ into _research points_
  - produce specific tech-tree tokens attached to research tasks
- Results are aggregated but not applied until Phase F/G.

#### C6: Machine Health & Maintenance

- Degrade machine condition over time:
  - linked to usage, environment (heat, humidity, etc).
- Schedule required maintenance tasks (queued for Phase D workers).
- Failure modes generate events:
  - partial efficiency, shutdown, catastrophic failure (optional DLC).

---

## 5. PHASE D — MOBILITY (WORKERS, VEHICLES, PATH EXECUTION)

**Frequency:**  
- Position integration at 60 Hz.  
- Pathfinding solved at 10 Hz or lower (B4 & D1 interplay).

### 5.1 Entities:

- Workers (human)
- Robots
- Vehicles:
  - trucks, trains, ships, aircraft, spacecraft
- Player avatar in first-person mode (later integration)

### 5.2 Responsibilities

- Execute previously computed paths.
- Handle boarding/alighting and cargo transfers.
- Fulfil job queues:
  - construction
  - maintenance
  - manual hauling
  - machine operation tasks

### 5.3 Subsystems (D1–D6)

#### D1: Path Requests & Assignment

- Jobs from C/F/G (maintenance, logistics tasks) generate path requests.
- Pre-solved route from B4 is bound to worker/vehicle.
- If route invalidated (terrain/network changed), request re-routing.

#### D2: Movement Integration

- Integrate position at 60 Hz using fixed-point velocities:
  - obey acceleration, braking, turning limits
  - consider terrain slope and traction
- Determine when agents enter/exit tiles, chunks, and nodes.

#### D3: Interactions with Structures & Networks

- Vehicles:
  - use corridor constraints (road, rail, waterway, airway, spaceway)
  - respect signals, priorities, speed limits
- Workers:
  - use walkable surface map
  - prefer shorter or safer routes

#### D4: Job Execution

- At target locations:
  - workers/robots perform tasks:
    - place buildings
    - operate machines
    - repair/maintain
    - load/unload cargo containers
    - handle manual labour tasks
- Job progression is deterministic, tied to worker attributes (skills, tools).

#### D5: Boarding / Cargo Interaction

- Standardized load/unload process:
  - containers (TEU sizes)
  - bulk goods (represented logically)
- Worker/robot presence may be required for certain transfers.

#### D6: Interproperty Transfers

- At interproperty nodes:
  - vehicles "exit" local map logically
  - state is passed to interproperty simulation graphs
- Exact moment of departure is deterministic:
  - once conditions for departure met, same tick every run.

---

## 6. PHASE E — ENVIRONMENT & LOCAL WORLD

**Frequency:**  
- Some elements at 60 Hz (point effects).  
- Many at 10 Hz or 1 Hz (slow changes).

### 6.1 Systems

- Fire and combustion
- Local temperature and heat diffusion
- Structural stress and damage (optional)
- Weather impacts at property scale:
  - rain/snow intensity
  - wind-driven local effects
- Pollution, acoustic noise fields (optional)

### 6.2 Responsibilities

- Apply environment effects that interact with machines, workers, terrain.
- Feed aggregated results into macro-climate and economy phases.

### 6.3 Subsystems (E1–E5)

#### E1: Local Temperature / Heat Exchange

- Compute local heat changes based on:
  - machine heat output
  - building insulation
  - external climate from Phase H (planetary climate model)
- Affects:
  - machine efficiency
  - worker comfort/safety
  - material behavior

#### E2: Fire / Hazard Simulation

- Spread fire deterministically based on materials and adjacency.
- Compute smoke or hazard fields.
- Generate tasks for Phase D (firefighting, evacuation).

#### E3: Local Weather Application

- Use global climate from Phase H and regional weather from previous ticks:
  - apply precipitation, wind, humidity to property.
- Affects:
  - rooftop solar power
  - wind turbines
  - soil moisture (crop yield)
  - road friction (vehicles)
  - construction constraints.

#### E4: Pollution / Externalities

- Local accumulation of:
  - air pollutants
  - noise
  - water contamination
- Feed metrics into Phase F/G for economic, regulatory, or AI impacts.

#### E5: Structural & Wear Effects (optional)

- Bridge stress under heavy loads
- Building wear due to temperature fluctuations, humidity, etc.
- Generates maintenance requirements and risk factors.

---

## 7. PHASE F — MACROECONOMY & CORPORATE SYSTEMS

**Frequency:**  
- 10 Hz for micro steps, 1 Hz or slower for macro aggregations.

### 7.1 Systems

- Commodity markets (raw + advanced goods)
- Price discovery and orders
- Contracts (futures, options later)
- Corporate finances:
  - income, expenses, profit/loss
- Banking (loans, interest)
- Public listings (stocks) in later DLC

### 7.2 Responsibilities

- Read production and consumption data from Phase C.
- Update inventory valuations and firm financials.
- Update market prices and availability.
- Process trades and contracts between companies/properties.

### 7.3 Subsystems (F1–F6)

#### F1: Production & Consumption Aggregation

- Summarize outputs from machines and logistics:
  - per commodity, per company, per region, per time bucket.
- Feed into market supply/demand curves.

#### F2: Market Matching

- For each commodity:
  - match orders and offers with deterministic algorithm:
    - sorted by price, then timestamp, then company ID.
- No randomization in trade resolution.

#### F3: Price Adjustment

- Update reference prices based on cleared volume vs surplus/shortage.
- Apply scenario multipliers from climate, war, or special events (later DLC).

#### F4: Corporate Finances

- Calculate:
  - revenue from sales
  - costs (wages, maintenance, interest)
  - taxes
- Update firm balance sheets.

#### F5: Research Budget Allocation

- Use research tokens and funding to progress techs.
- Research progress aggregated from Phase C (machines) and B (data).

#### F6: Reporting / Metrics

- Produce summary metrics for UI and AI use:
  - margins
  - ROI
  - debt ratios
  - sustainability scores
- Stored deterministically in state for later phases.

---

## 8. PHASE G — AI PLANNING & STRATEGY

**Frequency:**  
- 1 Hz for local tactical AI.  
- 0.1 Hz or slower for strategic/corporate AI.

### 8.1 Entities

- AI-controlled companies
- AI-controlled properties
- Optional "nation-state" / "coalition" overlays (future DLC)
- Player-assist autopilot AI for high-level automation

### 8.2 Responsibilities

- Decide:
  - expansion plans
  - investment decisions
  - production priorities
  - research choices
  - pricing and trade strategies
- Generate commands for Phase A of future ticks.

### 8.3 Subsystems (G1–G4)

#### G1: Observation

- AI samples:
  - own property data (limited by data network visibility)
  - market metrics (Phase F)
  - local environment (Phase E)
  - infrastructure status (Phase B/C/D)

- Apply fog-of-war and knowledge limits via the data network.

#### G2: Evaluation

- Run deterministic decision algorithms:
  - scoring potential projects (NPV, payoff time, risk).
  - evaluating logistic bottlenecks.
  - balancing energy mix, workforce allocation, etc.

- Pseudo-random tie breaks must be derived from deterministic seeds.

#### G3: Planning & Scheduling

- Formulate tasks:
  - building projects
  - machine upgrades
  - workforce reallocation
  - trade offers/requests

- Produce prioritized queues.

#### G4: Command Generation

- Emit commands into next-tick Phase A queue:
  - property-level instructions
  - construction blueprints
  - research directives
  - trade actions
- All commands timestamped and company-ordered deterministically.

---

## 9. PHASE H — LOW-FREQUENCY WORLD OPS (TERRAIN, CLIMATE, LONG HORIZON)

**Frequency:**  
- 1 Hz to 0.01 Hz (once per in-game hour, day, week, month, etc).

### 9.1 Systems

- Planetary/Regional Climate Model (from Vol 4.10)
- Sea level change
- Long-term erosion and terrain changes
- Forest growth/deforestation and biome shifts
- Infrastructure aging at macro-scale
- Interproperty/Interplanetary logistics corridors (very high level)

### 9.2 Responsibilities

- Update global climate state.
- Feed new climate parameters into local weather (Phase E).
- Maintain long-term environmental and geographic changes.
- Manage high-level interproperty logistics graphs.

### 9.3 Subsystems (H1–H5)

#### H1: Planetary Climate Update

- Energy balance model:
  - greenhouse forcing
  - albedo changes
  - ocean/land heat reservoirs

- Computes:
  - `T_global`
  - `CO2_eq`
  - precipitation patterns
  - storm risk by region

Outputs are used by weather systems and by economy/AI.

#### H2: Sea Level & Coastal Effects

- Update sea level based on global temperature.
- Affect coastal properties:
  - flood risk
  - water table elevation

Changes are gradual and deterministic.

#### H3: Biome & Vegetation Dynamics

- Slow updates to:
  - forest coverage
  - desertification
  - crop suitability
- Connector to agricultural yields and land-use planning.

#### H4: Terrain Macro-Ops

- Optional slow terrain adjustments:
  - subsidence
  - long-term erosion
- Implemented via terrain ops over many ticks.

#### H5: Interproperty & Interplanetary Routes

- Maintain high-level routes between:
  - properties
  - planets
  - space stations

- Update travel times and capacities based on:
  - technology changes
  - climate/weather constraints (for shipping and aviation)
  - infrastructure upgrades/damage.

---

## 10. CROSS-PHASE DATA DEPENDENCY RULES

1. **A → B**  
   - Commands create or alter network topology/mode.
   - No network state is read in Phase A.

2. **B → C**  
   - Machine input availability and state depends on networks.
   - Networks do not depend on machine internals directly (only loads).

3. **C → D**  
   - Machines create jobs for workers/vehicles.
   - Machines rely on previous movement results (positions) but do not move entities.

4. **D → E**  
   - Movement affects environment (congestion, emissions, wear).
   - Environment does not move entities, only modifies conditions.

5. **E → F**  
   - Environmental impacts feed into economic costs (e.g., repair, penalties).

6. **F → G**  
   - AI planning reads economic results to inform decisions.

7. **G → A(next tick)**  
   - AI-generated commands feed into the next tick’s Phase A.

8. **H → E/F/G**  
   - Climate and long-term world state constrain weather, economy, and AI.

All flows are **unidirectional within a given tick**:
- No back edges from later phases to earlier ones in the same tick.
- Cross-tick feedback handled through the phase pipeline over time.

---

## 11. MULTI-FREQUENCY INTEGRATION

Using the model from 7.2B:

- Each subsystem has an **interval**:
  - 1 (every tick)  
  - 6 (10 Hz with 60 UPS)  
  - 60 (1 Hz)  
  - 600 (0.1 Hz)

- For tick `T`, subsystem `S` runs if:
(T % interval_S) == phase_offset_S
with `phase_offset_S` chosen deterministically at initialization to spread load.

This ensures:
- Stable scheduling
- No jitter
- Load-spreading across ticks
- Determinism across machines

---

## 12. SERVER / CLIENT / HEADLESS VARIANTS

- **Headless server**:
- Runs full A–H chain minus presentation/renderer.
- Can disable rendering-related prep.

- **Client (standalone single player)**:
- Runs A–H on local machine.
- May run fewer AI companies or simplified macros as configured.

- **Client in multiplayer**:
- Input from network.
- Simulation may be authoritative (lockstep) or follow server state (server-driven).

In all cases, the **simulation chain is identical**; only the origin of commands and
authority for state decisions differ.

---

## 13. DETERMINISM AND DEBUGGING

- Each phase produces a per-phase hash of core state segments.
- During replay or cross-platform validation:
- Compare per-phase hashes to detect divergence early.
- Debug builds can dump:
- A-phase command logs
- B-phase network maps
- C-phase machine states
- D-phase positions and paths
- F-phase economic summaries
- H-phase climate state

This allows precise identification of which phase caused desync.

---

## 14. SUMMARY

Volume 7.4 defines:

- A **semi-linear phased simulation pipeline**:
- A through H, with strict ordering.
- Clear responsibility boundaries:
- inputs → networks → machines → mobility → environment → economy → AI → world.
- Multi-frequency scheduling per subsystem.
- Safe, deterministic parallelization inside phases.
- Clean cross-phase data dependencies.
- Server, client, and headless compatibility.
- Integration with terrain, networks, workers, climate, economy, and AI.
- Full determinism, replayability, and long-term maintainability.

This pipeline is the spine of Dominium’s simulation engine.

# END OF VOLUME 7.4
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Volume 7.5 — Renderer Interface (2D Vector, 2D Texture, 3D) exactly as the previous volumes:
C89/C++98 deterministic core
strict layering
compatible with Win2000–Win11, macOS 10.6+, Linux, legacy ports
integrates with all view modes and all UPS/FPS models
supports L0/L1/L2/L3 visual tiers as you defined
supports all render backends: Software, SDL1, SDL2, OpenGL 1.1, OpenGL 2, DirectX9, DirectX11, and future ports (DX8/GL3/Metal/Vulkan if added later)
Delivered as a single continuous Markdown block.

# VOLUME 7.5 — RENDERER INTERFACE  
Dominium Engine Specification — Engine Core, Part 5  
(Deterministic Multi-Mode Rendering: 2D Vector, 2D Texture, 3D)

This volume defines all rendering interfaces, data flows, abstractions, and
backend contracts for Dominium.

It integrates with:
- L0 (headless/CLI/TUI/Basic GUI)
- L1 (2D vector)
- L2 (2D texture + 2D vector)
- L3 (3D + 2D texture + 2D vector)

The renderer is a **pluggable backend** that must NEVER affect simulation
determinism. Only presentation changes.

============================================================
1. RENDERING PRINCIPLES
============================================================

1. Rendering is **never** part of the simulation.
2. Rendering must be completely parallel to the tick pipeline.
3. Rendering must accommodate:
   - software-only modes
   - legacy GPUs (GL1.1, DX9)
   - modern GPUs (DX11)
4. All renderers share a **common interface**.
5. All view modes share unified world→view transforms.
6. Rendering must gracefully degrade:
   - low memory
   - missing hardware features
   - poor drivers (Win2000/XP)
7. All outputs must be platform-independent in logic:
   - same content rendered differently based on backend capabilities.

============================================================
2. RENDERER LAYER ARCHITECTURE
============================================================

The rendering system sits entirely in **L4 (Engine Presentation Layer)**, above:

- L1: simulation core  
- L2: C++98 engine layer  
- L3: platform/window/input/audio abstractions  

Below:

- L5: actual backend libraries (OpenGL, DirectX, SDL, software renderer)

### 2.1 Renderer Pipeline Layout

FRAME:
Step 1: Collect render state from simulation (immutable snapshot)
Step 2: Prepare View Mode (2D/3D)
Step 3: Build command buffer
Step 4: Execute via selected backend
Step 5: Present / swap buffers

All operations must be:

- deterministic in **sequence**,  
- but not tied to simulation state except by snapshot.

============================================================
3. VIEW MODES (Unified Across Backends)
============================================================

Dominium supports three canonical view modes:

### 3.1 2D ORTHOGRAPHIC MODE (Top-Down)
- Uses terrain heightfield’s LOD2 (coarse) or LOD0 (local).
- Draws contour lines, vector roads, networks, icons.
- Perfect for:
  - management
  - planning
  - blueprinting
  - strategic view

### 3.2 2D ISOMETRIC MODE
- Uses sprite sheets, tiles, or vector geometry.
- Optional for nostalgic or low-end modes.
- Uses engine LODs for smooth zooming.

### 3.3 3D FREE CAMERA / FIRST PERSON
- Terrain mesh from LOD0/LOD1
- Full structural meshes (bridges, buildings)
- Vehicles, workers as 3D models
- Dynamic weather overlays
- Same underlying world transforms as 2D so camera switching is instant.

The renderer must support instant switching between modes.

============================================================
4. RENDERER BACKEND ABSTRACTION INTERFACE
============================================================

All backend implementations obey the following C89 interface:

```c
typedef struct renderer_backend {
    const char *name;
    bool (*init)(void);
    void (*shutdown)(void);
    void (*resize)(int w, int h);
    void (*begin_frame)(void);
    void (*submit_commands)(render_cmd *cmds, uint32_t count);
    void (*end_frame)(void);
    void (*set_option)(int opt, int value);
} renderer_backend;
Supported Backends:
Software Renderer (SW)
SDL1 Software
SDL2 Hardware/Software
OpenGL 1.1
OpenGL 2.0 (programmable pipeline)
DirectX 9.0c (shader model 3) (baseline for 3D)
DirectX 11 (modern optional)
Later:
Metal, Vulkan, WebGL, GLES
DX7 (deprecated), DX8 (optional for retro ports)
============================================================
5. RENDER COMMAND BUFFER (Unified Format)
Renderer receives backend-agnostic commands:
5.1 Command Types
DRAW_LINE
DRAW_POLYLINE
DRAW_TRIANGLE
DRAW_TRIANGLE_MESH
DRAW_IMAGE
DRAW_SPRITE_BATCH
DRAW_TEXT
SET_CAMERA
SET_MATERIAL
SET_TRANSFORM
CLEAR
PRESENT
All numeric values use fixed-point where deterministic, float only in local GPU
space with no impact on simulation.
typedef struct {
    uint16_t type;
    uint16_t material_id;
    mat4_fp transform;
    union {
        struct { vec3_fp *verts; uint32_t count; } mesh;
        struct { vec2_fp a, b; } line;
        struct { texture_id tex; rect_fp src, dst; } sprite;
    } data;
} render_cmd;
============================================================
6. MATERIAL SYSTEM
Determines how objects are drawn.
6.1 Material Definition
A material describes:
shading model (unlit, lit, vector)
texture (if any)
color
render layer (terrain, roads, UI, weather, debug)
blending mode
z-write / z-test settings
6.2 Material IDs
Material IDs are dpak-defined.
Renderer must map material to backend-specific state.
6.3 Deterministic Ordering
Within each frame:
commands are sorted by layer → type → material → stable index
ensures determinism and avoids z-fighting differences across GPUs
============================================================
7. CAMERA SYSTEM
Unified camera model:
7.1 World → View → Screen Pipeline
camera {
    vec3_fp pos;
    vec3_fp forward;
    vec3_fp up;
    fx32_32 fov;
    fx32_32 near_plane;
    fx32_32 far_plane;
    projection_type (orthographic / perspective)
}
2D views use orthographic projection.
3D views use perspective.
7.2 Camera Constraints
Must NEVER read from simulation mid-render
Must operate only on snapshot state
Movement is client-side only; zero effect on determinism
============================================================
8. TERRAIN RENDERING
Terrain is rendered from heightfield LODs.
8.1 Mesh Generation Rules
LOD0 for close-up
LOD1 for mid-range
LOD2+ for map mode
Mesh built on-the-fly per frame or cached per chunk
Triangles generated deterministically from height data
8.2 Vector Mode Terrain
Draw contour lines
Draw slope/arrows if debugging
Draw biomes as filled regions
============================================================
9. STRUCTURES, BUILDINGS, NETWORKS
Rendering of:
roads
rails
ramps
bridges
tunnels (portal rendering)
pipes/cables (simplified lines in 2D, tubes in 3D)
buildings (solid geometry)
machines (models, simplified in 2D)
All have:
deterministic draw order
LOD suites
fallback sprites for low hardware
============================================================
10. ENTITIES & ANIMATION
Workers, robots, vehicles:
3D models with skeletal or keyframe animation
fallback 2D sprites for low-end
sprite sheets for isometric mode
deterministic animation progression (based on simulation time)
============================================================
11. WEATHER & WATER RENDERING
Weather overlays:
rain/snow/smog/wind streaks
vector patterns in low mode
Water:
purely visual (fluid system uses separate logic)
low modes: flat blue with wave lines
high modes: shader-based or vertex-warp effect
============================================================
12. UI RENDERING
UI uses:
separate orthographic layer
vector UI for low modes
textured UI for high modes
deterministic rendering (strict stable sort)
============================================================
13. MULTITHREADING & BACKEND SAFETY
Simulation → rendering boundary:
Simulation thread produces immutable snapshot into staging buffer.
Renderer thread builds command buffer independently.
GPU submission strictly single-thread (per backend constraints).
============================================================
14. MODE SWITCHING
Any client can switch between:
L0 headless → L1 vector → L2 texture → L3 3D
2D ortho ↔ 2D iso ↔ 3D
Switching rules:
Safe anytime between frames
Renderer reinitializes camera and materials
No impact on simulation
============================================================
15. LEGACY SUPPORT NOTES
15.1 Win2000/XP
Prefer DX9 or GL1.1
Software mode always available
15.2 Win98/Win95/Win3.x/DOS
Software renderer only
Optional DirectDraw if needed (L0/L1 only)
15.3 Mac OS X 10.6+
Use OpenGL 2
Soft fallback to GL1.1 if required
15.4 Linux
Use GL2 or GL1.1
Software renderer if no hardware acceleration
============================================================
16. MODDING SUPPORT
Mods can provide:
materials
textures
sprites
models
shader code (for DX9/11, GL2)
UI themes
new view mode configurations
All mod-provided assets integrate into the dpak system.
============================================================
17. SUMMARY
Volume 7.5 defines a unified, deterministic rendering system with:
three view modes (2D ortho, 2D iso, 3D)
four visual layers (L0–L3)
backend abstraction for software, SDL, GL1/2, DX9, DX11
command-buffer rendering model
strict separation from simulation
multi-LOD terrain/structure/entity rendering
deterministic ordering and repeatability
full modding support
Rendering remains presentation only and must never affect core simulation.
END OF VOLUME 7.5

---

If ready, we proceed to **Volume 7.6 — Audio Engine Interface**.
You said:
Yes proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
State confirmed. Proceeding with VOLUME 7.6 — AUDIO ENGINE INTERFACE
Fully aligned with all prior volumes and the same style: deterministic, layered, portable to Win2000+, macOS 10.6+, Linux, and future legacy ports.
Delivered as a single continuous MD code block.

# VOLUME 7.6 — AUDIO ENGINE INTERFACE  
Dominium Engine Specification — Engine Core, Part 6  
(Deterministic, Multi-Tier Audio Rendering)

This volume defines the entire audio subsystem:  
- abstraction layer  
- backend contracts  
- streaming vs. one-shots  
- 2D/3D spatialization  
- vector-mode audio (minimal)  
- texture-mode audio (higher-fidelity)  
- deterministic and platform-agnostic timing  
- support for low-end hardware (Win98/2000)  
- support for high-end hardware (Win11/macOS/Linux)


============================================================
1. AUDIO PRINCIPLES
============================================================

1. Simulation determinism NEVER depends on audio.  
2. All audio timing is relative to simulation via a stable tick→audio clock.  
3. Audio is always optional; must gracefully degrade:  
   - no sound hardware  
   - 8-bit/11kHz fallback  
   - software mixing only  
4. All audio is **backend-abstracted**.  
5. Rendering and audio share the same L0–L3 conceptual tiering:  
   - L0: no audio, silent, useful for headless  
   - L1: “beep mode” (very low-fidelity)  
   - L2: 2D PCM playback  
   - L3: full 3D spatial audio with streaming music  
6. All backends read from a platform-independent mix buffer.  


============================================================
2. LAYERED AUDIO ARCHITECTURE
============================================================

Dominium audio system follows the multi-layer model:

- **L1 (Simulation Core):**  
  simulation events emit abstract audio events (no samples)

- **L2 (Engine / C++98 Layer):**  
  audio mixer, sample loading, streaming, voice logic

- **L3 (Platform Abstraction):**  
  output device, thread, latency control

- **L4 (Backend):**  
  SDL1, SDL2, DirectSound, CoreAudio, ALSA, OSS, software-only

Audio never feeds back to L1.  
Simulation only emits “sound commands,” never samples.


============================================================
3. AUDIO BACKEND INTERFACE
============================================================

Each backend implements:

```c
typedef struct audio_backend {
    const char *name;
    bool  (*init)(int sample_rate, int channels, int buffer_ms);
    void  (*shutdown)(void);
    void  (*submit)(const int16_t *samples, uint32_t frame_count);
    void  (*set_option)(int opt, int value);
} audio_backend;
Supported:
SDL1 Mixer
SDL2 AudioDevice
DirectSound 8 (Win2000–Win7)
XAudio2 (Win7–Win11)
CoreAudio (macOS)
ALSA, PulseAudio, OSS (Linux)
Dummy backend (no sound)
============================================================
4. VISUAL TIERS VS. AUDIO TIERS
Audio is independent but coordinated with visual tiers:
L0: silent, no thread
L1: simple beeps, UI tones
L2: 2D PCM (ambient, effects, UI, machines)
L3: 3D spatial sound, Doppler, streaming music
============================================================
5. AUDIO EVENT MODEL
Simulation emits audio events, not samples.
Example events:
SFX_PLAY(id, pos, volume, pitch)
STREAM_START(track_id)
STREAM_STOP
UI_CLICK
MACHINE_LOOP(state_id)
AMBIENT_ZONE_ENTER / EXIT
These events are queued and consumed by the mixer thread.
Deterministic order:
Events processed in stable order per tick.
============================================================
6. SAMPLE FORMAT, DECODING, COMPRESSION
6.1 Allowed formats
WAV (PCM)
Ogg Vorbis (music, compressed SFX)
FLAC (lossless)
Engine internal ADPCM (optional low-end codec)
6.2 Decoding
Performed in mixer thread or helper thread
Fully deterministic decode path
No floating-point drift (use fixed-point accumulators)
============================================================
7. MIXER ENGINE (C89)
7.1 Mixer Output Format
16-bit signed PCM
44100 Hz default (configurable: 11025 → 48000)
1 or 2 channel (mono/stereo)
Fixed-point volume and pitch
7.2 Mixer Pipeline
TICK:
    1. Ingest audio events
    2. Update voices
    3. Mix voices into buffer
    4. Apply spatialization
    5. Apply master gain
    6. Pass buffer to backend
7.3 Voice Types
One-shot SFX
Looped sounds (machines, engines)
Streams (music, ambience)
UI sounds
7.4 Determinism
Mixing uses fixed-point math; identical on all platforms.
============================================================
8. SPATIAL AUDIO (3D)
Applies only to L3 mode.
8.1 Inputs
listener position + orientation
emitter position
distance model
occlusion factor (simple geometry check)
velocity for Doppler
8.2 Distance Models
linear
inverse
clamped inverse square
8.3 Occlusion
Optional: raycast against simplified collision mesh
Or simple “zone occlusion” system for low-end
8.4 Doppler
fixed-point velocity calculation
identical on every hardware platform
============================================================
9. STREAMING MUSIC
Handled by dedicated streaming channel:
reads compressed data
decodes in chunks
buffers ahead deterministically
no race conditions
Supports:
background themes
contextual music
low-pass / high-pass transitions
============================================================
10. AUDIO ZONES
Zones define environmental acoustics:
factory interior (reverb)
outdoor (open)
underground (muffled)
underwater (low-pass)
Zone transitions must be:
deterministic
blended using fixed-point ramps
visually synchronized with camera movement
============================================================
11. MEMORY & PERFORMANCE
11.1 Low-End Hardware (Win98/2000)
8–16 MB audio RAM budget
mono output allowed
no streaming music
machine loops merged or suppressed
11.2 Mid/High-End Hardware
unlimited voices (software limit)
streaming music
per-voice filtering
optional HRTF (if backend supports)
11.3 CPU Scaling
Mixer dynamically reduces:
number of active voices
distance checks
occlusion checks
reverb types
Always deterministic.
============================================================
12. FALLBACK & FAILURE MODES
If backend fails:
fallback to dummy audio
log warning
game continues unchanged (deterministic)
If mixing can’t keep up:
reduce mixer rate
drop background music first
reduce spatialization quality
never desync simulation
============================================================
13. MODDING INTERFACE
Mods may add:
.wav, .ogg, .flac files
SFX banks
machine/vehicle sound sets
UI sound skins
custom music playlists
environmental reverb definitions
Mods CANNOT add audio code.
All behaviour is data-driven.
============================================================
14. FILESYSTEM LAYOUT (within dpak)
audio/
    sfx/
        ui/
        machines/
        vehicles/
        env/
    music/
    banks/
    zones/
    reverb_presets.json
    mixer_profiles.json
All dpak-resident.
Indexed deterministically.
============================================================
15. SUMMARY
Volume 7.6 defines the complete Dominium Audio Engine:
deterministic mixer using fixed-point math
platform-agnostic backend system
three quality tiers
3D spatial audio with Doppler and occlusion
streaming music
zone acoustics
full modding support
graceful fallback on legacy systems
never influences simulation state
This concludes the audio interface specification.
END OF VOLUME 7.6

---

Ready to proceed with **VOLUME 7.7 — Input System (Keyboard/Mouse/Controller/Touch/Legacy Devices)**.
You said:
Yes proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.7 — INPUT SYSTEM
Fully aligned with all prior volumes, deterministic, legacy-compatible, multi-backend, zero ambiguity.
Delivered as a single continuous MD block.

# VOLUME 7.7 — INPUT SYSTEM  
Dominium Engine Specification — Engine Core, Part 7  
(Deterministic, Multi-Backend Input Abstraction)

This volume defines the *entire input pipeline*, including:
- Keyboard, mouse, controller, joystick
- Touch, stylus, trackpads
- Legacy devices (DOS, Win9x, MacOS 7–9)
- Network-replicated input for multiplayer
- Replay integration
- Accessibility input layers
- Deterministic processing rules
- Multi-backend abstraction (SDL1/SDL2/Win32/XInput/DirectInput/Cocoa/X11/Linux EV/Serial)


============================================================
1. INPUT PRINCIPLES
============================================================

1. Input is NEVER part of simulation state.  
2. Input must be:
   - deterministic once captured (frame-stable)
   - platform-independent
   - latency-minimal
   - replayable
3. All input is captured → normalized → queued → consumed by simulation.
4. Simulation *never* queries raw OS input.
5. Multiplayer clients send **input commands**, not simulation deltas.
6. Replays store **only inputs** + periodic simulation snapshots.

This ensures:
- identical results on Win2000, macOS 10.6, Linux, etc
- clean deterministic behaviour


============================================================
2. INPUT LAYER STRUCTURE
============================================================

Four layers:

- **L1: OS Backend**  
  Reads raw input (platform-specific).

- **L2: Normalization**  
  Converts platform codes → unified Dominium codes.

- **L3: Event Buffer**  
  Time-stamped, stable order, deterministic replayable queue.

- **L4: Bind System**  
  Keys/buttons/axes mapped to game actions, UI actions, or camera actions.

Simulation only sees L4 results.


============================================================
3. BACKEND INTERFACE
============================================================

Each backend implements:

```c
typedef struct input_backend {
    const char *name;
    bool  (*init)(void);
    void  (*shutdown)(void);
    void  (*poll)(input_event_buffer *dst); 
    void  (*set_option)(int opt, int value);
} input_backend;
Supported backends:
SDL1
SDL2
Win32 Raw Input (Win2000+)
DirectInput 8 (Win98/Win2000/WinXP)
XInput (Win7+)
Carbon/Cocoa (MacOS 10.0–10.9 / 10.6+)
X11 (Linux)
Linux evdev
DOS raw keyboard + mouse (INT 16h / INT 33h)
Serial/PS2 fallback
============================================================
4. EVENT TYPES
4.1 Keyboard Events
INPUT_KEY_DOWN(code)
INPUT_KEY_UP(code)
INPUT_KEY_CHAR(unicode)
4.2 Mouse Events
INPUT_MOUSE_MOVE(dx,dy)
INPUT_MOUSE_BUTTON_DOWN(btn)
INPUT_MOUSE_BUTTON_UP(btn)
INPUT_MOUSE_WHEEL(delta)
4.3 Controller/Joystick Events
INPUT_PAD_BUTTON_DOWN(id)
INPUT_PAD_BUTTON_UP(id)
INPUT_PAD_AXIS(id,value)
INPUT_PAD_HAT(id,dir)
4.4 Touch / Stylus Events
INPUT_TOUCH_DOWN(id,x,y)
INPUT_TOUCH_MOVE(id,x,y)
INPUT_TOUCH_UP(id)
4.5 Device Hotplug
Generated if backend supports:
INPUT_DEVICE_ADDED
INPUT_DEVICE_REMOVED
============================================================
5. NORMALIZATION
5.1 Unified Key Codes
ASCII for printable characters
+
Stable, platform-neutral scancodes:
Example:
KEY_A … KEY_Z
KEY_0 … KEY_9
KEY_F1 … KEY_F12
KEY_LSHIFT, KEY_RSHIFT
KEY_CTRL, KEY_ALT, KEY_SUPER
KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT
KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END
Mouse buttons:
MB_LEFT, MB_RIGHT, MB_MIDDLE
MB_X1, MB_X2
Controllers:
PAD_A, PAD_B, PAD_X, PAD_Y
PAD_START, PAD_BACK
PAD_L1/L2/R1/R2
PAD_LSTICK_X/Y
PAD_RSTICK_X/Y
All deterministic.
No platform differences allowed.
============================================================
6. EVENT QUEUE (DETERMINISTIC)
6.1 Ordering
Events inserted in exact poll order.
Backend poll order is stable and fixed.
6.2 Buffer Structure
input_event queue[INPUT_MAX_EVENTS];
uint32_t head, tail;
6.3 Tick Consumption
Simulation consumes all events generated since previous tick:
in strict chronological order
no lost events
no duplicates
stable latency
============================================================
7. BINDING SYSTEM
7.1 Types of binds:
Action bind (discrete): jump, interact, open map
Axis bind (continuous): move, camera, throttle
Chorded bind: Ctrl+Shift+X
Context bind: UI, world, editor
Layered bind sets per view mode (2D/3D/TUI)
7.2 Config Format (dpak)
bindings/
    default.json
    user.json
    profile1.json
JSON fields:
{
    "bindings": [
        {"action":"move_forward", "key":"W"},
        {"action":"move_backward", "key":"S"},
        {"action":"open_menu", "key":"ESC"}
    ]
}
============================================================
8. MULTIPLAYER INPUT REPLICATION
8.1 Client → Server
Client sends:
tick number
input events for that tick
Server:
queues them with deterministic ordering
applies them exactly at the specified tick
8.2 Anti-slip
If client lags:
server waits (with timeout)
or runs prediction
but simulation is authoritative
8.3 Replays
Replays store only:
input events per tick
plus periodic snapshots (for fast seeking)
============================================================
9. LEGACY AND LOW-END SUPPORT
9.1 DOS
INT 16h for keyboard
INT 33h for mouse (if available)
PS/2 fallback
no gamepads (unless via custom driver)
no char input beyond ASCII
9.2 Win9x/Win2000
DirectInput 8
RawInput where available
PS/2 mice standard
9.3 MacOS 7–9
Carbon Events → normalized map
9.4 Linux
X11 for windowed
evdev for fullscreen
TTY keyboard fallback for headless
============================================================
10. ACCESSIBILITY LAYER
Remap any input to any action
Sticky keys
Tap vs hold modes
Toggle vs momentary
“Interaction assist” for complex multi-key commands
UI scale controls (input hitboxes in 2D modes)
============================================================
11. CAMERA & MOVEMENT INPUT
Supports:
relative mouse mode
edge panning
WASD or arrows
joystick stick camera control
touch drag/pinch for zoom in 2D mode
scroll to zoom
double-tap to center
controller deadzone management
============================================================
12. INPUT RATE & TIMING
Input samples at render rate (FPS)
Consumed at simulation rate (UPS)
Stable mapping ensures:
No multi-triggering
No missed transitions
Boolean states stored as:
prev_state
current_state
transition (just_pressed/just_released)
============================================================
13. FALLBACK MODES (HEADLESS / CLI / TUI)
13.1 Headless Server
No keyboard/mouse events
Console commands only
Optional RCON input
Optional “scripted input feed” for automation
13.2 TUI / CLI Mode
arrow keys + enter navigation
no pointer events required
full deterministic menu control
============================================================
14. MODDING INTERFACE
Mods may define:
new keybinds
alternate input profiles
custom UI layers needing input callbacks
Mods may NOT:
access raw input
inject input events into simulation
alter determinism
All mod-defined inputs run through same normalization layer.
============================================================
15. FILESYSTEM LAYOUT
input/
    bindings/
        default.json
        user.json
        profile1.json
    devices/
        gamepad_profiles.json
        deadzones.json
    accessibility/
        a11y.json
============================================================
16. SUMMARY
Volume 7.7 defines:
a complete multi-backend input system
deterministic, replay-friendly event queues
controller/mouse/keyboard/touch/legacy support
strong separation between platform input and simulation
robust multiplayer replication
accessibility and modding support
compatibility from DOS → Win11 → macOS → Linux
This completes the input subsystem.
END OF VOLUME 7.7

---

Ready for **VOLUME 7.8 — Windowing, Display, Viewports & Monitor Management**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.8 — WINDOWING, DISPLAY, VIEWPORTS & MONITOR MANAGEMENT.
All conventions from Volumes 1–7 preserved: deterministic core, portable to Win2000+/macOS 10.6+/Linux, future support for legacy back-ports, multi-renderer, multi-client, L0–L3 visual tiers, and strict separation of platform and core.
Delivered as a single continuous Markdown block.

# VOLUME 7.8 — WINDOWING, DISPLAY, VIEWPORTS & MONITOR MANAGEMENT  
Dominium Engine Specification — Engine Core, Part 8  
(Deterministic Windowing, Multi-Renderer, Multi-Display)

This subsystem defines:
- window creation and control
- fullscreen, borderless, windowed modes
- multi-monitor geometry
- deterministic viewport layout
- safe fallback modes for legacy systems
- headless backend
- compatibility with DX9, GL1, GL2, software, SDL1, SDL2, Cocoa, X11, Win32


============================================================
1. PRINCIPLES
============================================================

1. Rendering is nondeterministic; simulation is deterministic.  
2. Windowing must not affect simulation correctness.  
3. Windowing must support:
   - Win2000 → Win11
   - macOS 10.6+
   - Linux (X11, Wayland optional later)
   - Headless
4. All window management routed through a platform abstraction layer.
5. Renderers (GL, DX, SDL, Software) attach to an abstract “surface,” not the OS API directly.
6. Multi-monitor configurations must be handled even on old platforms (with degraded APIs).


============================================================
2. WINDOW BACKEND LAYER
============================================================

Backends implement:

```c
typedef struct window_backend {
    const char *name;

    bool  (*init)(void);
    void* (*create_window)(int w, int h, int flags);
    void  (*destroy_window)(void *win);

    void  (*set_title)(void *win, const char *title);
    void  (*set_icon)(void *win, image_data *icon);

    void  (*show)(void *win);
    void  (*hide)(void *win);

    void  (*set_position)(void *win, int x, int y);
    void  (*set_size)(void *win, int w, int h);

    void  (*set_fullscreen)(void *win, int mode); // windowed / borderless / true fullscreen

    void  (*swap_buffers)(void *win);

    void  (*poll_events)(void); // forwards into input backend

    void  (*shutdown)(void);
} window_backend;
Supported backends:
SDL1
SDL2
Win32 (GDI + WGL + DX)
X11
Cocoa (macOS)
Dummy/Headless
============================================================
3. WINDOW MODES
3.1 Windowed
Resizable, border.
3.2 Borderless Fullscreen (Recommended)
Matches display mode
No mode changes
Low latency on modern systems
Fallback possible on all targets
3.3 True Fullscreen (Exclusive)
Required for DX9 / Win2000 compatibility
Required for some legacy GPUs
Allows mode switching (resolution, refresh)
3.4 Headless Mode
No window, no surface, no events except console/RCON.
Used for:
Dedicated servers
Background simulations
Automation/replays
============================================================
4. DISPLAY ENUMERATION & MONITOR LAYOUT
4.1 Enumeration Contract
Backends provide:
number of displays
display geometry (x, y, width, height)
usable bounds
DPI (approximate)
refresh rate
4.2 Multi-Monitor Rules
Engine chooses primary display by default.
User may choose any display from launcher.
Window coordinates always expressed in global desktop space.
Legacy platforms without multi-monitor APIs must simulate:
Win2000/Win98 fallback: treat all displays as one large display if not enumerable.
4.3 DPI Handling
Desktop DPI read from backend
Internal UI scale uses integer-scaling fallback
TUI unaffected
Vector-mode UI unaffected
============================================================
5. VIEWPORT SYSTEM
This is renderer-independent and deterministic.
5.1 Viewports Defined
A viewport is a rectangular region used for:
main world view (2D or 3D)
minimap
UI layers
editor panels
split-screen multiplayer (optional future content)
5.2 Viewport Layout Determinism
Simulation has no knowledge of viewport geometry, but:
each frame uses the same deterministic layout config
UI logic reads viewport geometry from immutable structure
changes are only allowed between frames, never mid-frame
5.3 Camera-System Interaction
Cameras (2D/3D) write to viewports:
3D camera → perspective viewport
2D orthographic view → ortho viewport
Map view → 2D vector viewport
Viewports render in composited order:
1. world
2. overlays
3. UI
4. debug layers
5.4 Scaling Modes
Fit (letterbox/pillarbox)
Stretch (avoid for 3D mode)
Integer scale (2D)
Pixel-perfect (for L1 vector mode)
============================================================
6. WINDOW LIFECYCLE
startup:
    backend->init()
    win = backend->create_window(...)
    attach_renderer(win)
    enter main loop

main loop:
    backend->poll_events()
    simulation_tick(...)
    renderer_draw(...)
    backend->swap_buffers(win)

shutdown:
    detach_renderer(...)
    backend->destroy_window(win)
    backend->shutdown()
All steps ordered and deterministic with respect to simulation.
============================================================
7. RESOLUTION, REFRESH RATE, AND RENDER TIMING
7.1 Resolution
arbitrary
must support ultra-low (640x480)
must support high (4K/8K)
7.2 Refresh Rate
FPS is separate from UPS and not deterministic:
user can lock FPS to 24/30/60/75/90/120/144/240/etc
user can enable VSync if backend supports
7.3 Adaptive FPS Degradation
If GPU cannot keep up:
FPS drops
UPS unchanged
camera + input remain smooth
7.4 Multi-View Rendering
Each viewport has its own:
clear flags
projection matrix
render pass sequence
All combined in final composition.
============================================================
8. INPUT–WINDOW COUPLING
Backends must provide:
mouse coordinates relative to window
mouse coordinates relative to viewport
focus/blur events
window resize events forwarded to input system
Simulation tick never directly interacts with window geometry.
============================================================
9. LEGACY PLATFORM SUPPORT
9.1 Windows 98/2000/XP
Win32 GDI windowing
DX9 exclusive fullscreen for highest compatibility
WGL + OpenGL 1.1 for basic compatibility
Borderless fullscreen approximated
9.2 macOS 10.6+
Cocoa NSWindow
OpenGL 2.1 backend
Software renderer allowed
9.3 Linux
X11 (primary)
Wayland optional later
Fallback to pure software + Xlib window
9.4 DOS
No window
Pure software full-screen mode
Input/graphics via DOS backend
Fixed 320×200, 640×480, VGA modes
9.5 Headless
no window
no surfaces
no GPU needed
minimal CPU overhead
============================================================
10. MODDING SUPPORT
Mods may:
define new UI layouts
define new viewport configurations
define render overlays
define editor modes
Mods may not:
create/destroy OS windows
interact with platform APIs
break renderer–window contract
============================================================
11. FILESYSTEM STRUCTURE (dpak)
window/
    config.json
    display_profiles.json
    viewport_presets.json
ui/
    layout/
    theme/
config.json contains:
default resolution
fullscreen type
vsync mode
UI scale
L0/L1/L2/L3 visual tier selection
============================================================
12. SUMMARY
Volume 7.8 defines:
fully abstract, deterministic windowing
support for multi-renderer / multi-backend
deterministic viewports
robust fullscreen/windowed/legacy modes
multi-monitor handling
strong modding support
compatibility across Win2000+, macOS, Linux, headless, and future ports
This completes the display and windowing subsystem.
END OF VOLUME 7.8

---

Ready for **VOLUME 7.9 — Renderer Abstraction Layer (RAL): DX9 / GL1 / GL2 / SDL Software / Future Backends)**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.9 — RENDERER ABSTRACTION LAYER (RAL).
This is a large, foundational volume.
It defines the unified rendering interface for all Dominium targets:
DX9 (primary legacy + modern baseline)
OpenGL 1.1 (ultra-legacy fallback)
OpenGL 2.1 (main cross-platform path)
SDL Software Renderer (Win2000/Linux/dumb terminals)
Future backends: DX11, Metal, Vulkan, Software-Rast, WebGL/WebGPU
Deterministic render staging (not deterministic visual output)
Compatibility with L0–L3 visual tiers
2D, 3D, vector, UI, debug layers
Delivered as one continuous MD block.

# VOLUME 7.9 — RENDERER ABSTRACTION LAYER (RAL)  
Dominium Engine Specification — Engine Core, Part 9  
(Multi-Backend Rendering Architecture)

This volume defines:
- A unified, portable rendering API for Dominium  
- Deterministic render ordering  
- Multi-tier visual stack (L0–L3)  
- Compatibility from Win2000/DX9 to macOS 10.6+/GL2 to Linux/X11  
- Independent 2D, 3D, vector, UI, debug pipelines  
- No simulation dependence on renderer state


============================================================
1. RENDERING PRINCIPLES
============================================================

1. Rendering is **nondeterministic** but **staged deterministically**.  
2. Simulation state → RenderData (immutable per frame).  
3. No renderer may read or modify simulation memory.  
4. RAL isolates platform-specific code completely.  
5. Every render backend must support:
   - batching  
   - stable sorting  
   - resource validation  
   - graceful degradation  
6. Render pipeline must be:
   - portable to low-end hardware  
   - scalable to high-end hardware  
   - able to run in software mode if needed  


============================================================
2. RENDERER TIERS (L0–L3)
============================================================

These correspond to Display Tiers (Vol. 7.8):

### **L0 — Headless**
- No drawing  
- Renderer never initializes  
- Useful for servers and batch simulations  

### **L1 — Vector Mode**
- Lines, boxes, circles  
- CAD-like mode  
- Perfect for low-power machines / terminal-like experience  
- Uses GL1 immediate mode or custom software rasterizer  

### **L2 — 2D Sprite + Vector**
- Textured quads  
- Tile maps  
- UI, icons, simple overhead mode  
- GL1/GL2/DX9 compatible  

### **L3 — Full 3D**
- Perspective 3D world  
- Terrain, meshes, lighting  
- GL2 or DX9 minimum  
- GL1/software fallback reduces features gracefully  


============================================================
3. BACKEND INTERFACE
============================================================

Each backend implements:

```c
typedef struct renderer_backend {
    const char *name;

    bool  (*init)(void *window);
    void  (*shutdown)(void);

    void  (*begin_frame)(void);
    void  (*end_frame)(void);

    // Resource creation
    tex_t (*create_texture)(image_data *img, int flags);
    void  (*destroy_texture)(tex_t);

    mesh_t (*create_mesh)(mesh_data *src, int flags);
    void   (*destroy_mesh)(mesh_t);

    shader_t (*create_shader)(shader_desc *desc);
    void     (*destroy_shader)(shader_t);

    // Drawing
    void (*draw_mesh)(mesh_t, const matrix4 *mvp, draw_state *state);
    void (*draw_quad)(tex_t, rect, draw_state);
    void (*draw_lines)(line_buffer *lines, draw_state);

    // State
    void (*set_viewport)(int x, int y, int w, int h);
    void (*set_scissor)(int x, int y, int w, int h);
} renderer_backend;
Supported backends:
DX9
GL1
GL2
SDL Software
Headless
Future backends:
DX11
Vulkan
Metal
WebGL/WebGPU
Custom software rasterizer
============================================================
4. RESOURCE MODEL
4.1 Textures
power-of-two not required
8/16/24/32-bit formats
Mipmaps optional per backend
L1 vector mode uses procedural strokes, not textures
4.2 Meshes
static or dynamic
indexed triangles
optional color + UV channels
backend converts to native format
GL1 uses immediate-mode fallback
4.3 Shaders
DX9 SM2.0 HLSL
GL2 GLSL
GL1: no shaders (fixed pipeline)
Software: fixed pipeline emulation
4.4 Render Targets
Used for:
UI composition
shadows (later)
high-resolution screenshots
Not required on GL1/SW but degrade gracefully.
============================================================
5. UNIFIED DRAW PIPELINE
Render pipeline is deterministic in ordering, not appearance.
FRAME PIPELINE:

1. gather visible objects
2. sort by:
    a. render layer
    b. material
    c. shader
    d. texture
    e. mesh
3. generate render commands
4. backend->begin_frame()
5. submit commands in stable order
6. backend->end_frame()
Render layers:
0  background sky/terrain
1  world opaque geometry
2  world transparent geometry
3  vector overlay (wires, power, data)
4  UI panels
5  debug/hud
============================================================
6. 2D RENDERING SUBSYSTEM
6.1 Vector Mode (L1/L2)
Draw lines, arcs, shapes
Optional AA
GL1 immediate mode or software
Used for:
engineering overlays
blueprints
network views
terminal mode
6.2 Sprite Mode (L2)
Batched textured quads
Supports atlases
Supports text rendering via bitmap fonts
Used for:
top-down display
minimaps
UI elements
============================================================
7. 3D RENDERING SUBSYSTEM (L3)
7.1 Camera Systems
perspective
orthographic engineering view
deterministic camera transforms
7.2 Terrain Rendering
(Ties to Volume 7.3)
heightfield + sparse voxel overlays
chunk-based
LOD per chunk
fallback to L2 2D representation
7.3 Lighting
Baseline:
simple directional light
per-vertex or per-pixel depending on backend
Advanced lighting allowed only in DX11/GL3+ paths (future DLC).
Never required for gameplay.
7.4 Mesh Pipeline
buildings
machines
vehicles
workers
7.5 Transparency Rules
Sorted back-to-front in 3D.
Transparent geometry never affects determinism.
============================================================
8. MULTI-RENDERER COMPATIBILITY RULES
8.1 Mandatory Features
All backends must support:
textured quads
vertex colors
lines
depth buffer
alpha blending
stable state changes
8.2 Optional Features
Backends may support:
shadow maps
offscreen targets
instancing
GLSL/HLSL
sRGB textures
anisotropic filtering
Gameplay is independent of these.
============================================================
9. SOFTWARE RENDERER
For extremely low-end hardware:
C89-only implementation
span rasterizer
no shaders
nearest-neighbour textures
optional dithering
15-bit 565 output
supports vector mode perfectly
supports 2D sprite mode acceptably
supports 3D in extremely reduced form (wireframe or flat-shaded)
Used for:
MS-DOS
Win9x minimal
Linux minimal
fallback scenarios
============================================================
10. STABILITY & FAILURE MODES
If renderer fails:
fallback to next tier
example: GL2 → GL1 → SW
no simulation interruption
If GPU runs out of memory:
unload high-res assets
revert to low-res mip levels
disable shadows/reflections (if any)
============================================================
11. DRIVER QUIRKS & LEGACY COMPATIBILITY
DX9
must support lost device recovery
must handle Win2000/XP device contexts
FVF fallback for non-shader mode
GL1
only immediate mode guaranteed
no VBOs
extremely stable for ancient hardware
GL2
VBO + GLSL
fallback check for missing extensions
macOS 10.6 baseline
SDL Software
always available
debugging safe mode
============================================================
12. MODDING
Mods may add:
textures
sprite sheets
meshes
materials
shaders (DX9/GL2 only)
render passes (UI only)
Mods may NOT:
create new render backends
call GPU APIs
modify platform windowing
introduce nondeterministic simulation–render feedback
============================================================
13. FILESYSTEM LAYOUT
renderer/
    backend.json
    materials/
    shaders/
        dx9/
        gl2/
    textures/
        ui/
        world/
        icons/
    meshes/
backend.json selects which backend to use on startup:
{
  "preferred": "gl2",
  "fallbacks": ["dx9", "gl1", "sw"]
}
============================================================
14. SUMMARY
Volume 7.9 defines the entire RAL:
unified cross-platform rendering API
sorted, deterministic command pipeline
2D vector, 2D sprite, 3D subsystems
software renderer fallback
DX9 + GL1 + GL2 as first-class backends
future expansion to DX11/Metal/Vulkan
full modding support without compromising determinism
consistent L0–L3 visual tiering
This completes the renderer abstraction subsystem.
END OF VOLUME 7.9

---

Ready for **VOLUME 7.10 — File System Abstraction, Save/Load, DPAK Format, Virtual Paths**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.10 — FILE SYSTEM ABSTRACTION, SAVE/LOAD, DPAK FORMAT, VIRTUAL PATHS.
This is a core pillar of Dominium.
It unifies all asset loading, mod loading, savegame storage, replay storage, and legacy-platform packaging into one deterministic VFS layer.
Delivered as a single continuous MD block.

# VOLUME 7.10 — FILE SYSTEM ABSTRACTION, SAVE/LOAD, DPAK FORMAT, VIRTUAL PATHS  
Dominium Engine Specification — Engine Core, Part 10  
(Deterministic Virtual File System, Packfiles, Mod Stacking, Save System)

Defines:
- Virtual File System (VFS)
- DPAK archive format (Dominium Packfile)
- Mod stacking & override rules
- Savegame structure
- Replay structure
- Legacy filesystem compatibility (MS-DOS, Win9x)
- Safe deterministic I/O
- Security model (no arbitrary code)
- Cross-platform path normalization


============================================================
1. FILESYSTEM PRINCIPLES
============================================================

1. All game data lives in a **virtual filesystem (VFS)**.  
2. Physical disk layout varies by platform, but VFS is identical.  
3. Game never directly opens OS paths except at controlled mount points.  
4. Everything is deterministic:
   - save order  
   - load order  
   - mod stacking  
   - directory traversal  
5. Mods cannot execute code or scripts automatically — only data, unless explicitly allowed (Lua).  
6. All paths normalized to forward slash `/` internally.  
7. No platform may influence load order through undefined directory ordering.


============================================================
2. VFS LAYER
============================================================

The VFS is a read-first, write-limited abstraction.

### 2.1 Mount Points
VFS/
base/ (core game dpaks)
dlc/ (official DLC dpaks)
mods/ (user mods dpaks)
user/ (configs, saves, screenshots)

### 2.2 Mount Order
base (lowest priority)
dlc
mods (ordered)
user overrides (highest)

First file found wins.

### 2.3 VFS API

```c
bool vfs_mount(const char *path, mount_type type);
bool vfs_exists(const char *vpath);
int  vfs_read(const char *vpath, void *dst, int max);
int  vfs_write(const char *vpath, const void *src, int size);
vfs_file *vfs_open(const char *vpath);
void vfs_close(vfs_file*);
No direct OS paths are exposed outside engine.
============================================================
3. DPAK FORMAT (DOMINIUM PACKFILE)
DPAK is the universal asset container.
3.1 Goals
deterministic file order
simple C89 implementation
fast to load
compressible
seekable
mod-friendly
3.2 Structure
[DPAK HEADER]
[DPAK DIRECTORY]
[FILE DATA BLOCKS...]
[HASH TABLE]
[FOOTER]
3.3 Header
magic: "DPAK"
version: 1
flags: compression, big-endian, encrypted(optional)
file_count: N
dir_offset
hash_offset
3.4 Directory Entries
Each entry:
vpath (null-terminated)
offset
size
compressed_size
compression_type
crc32
3.5 Compression
Allowed:
none
LZ4
DEFLATE
Zstandard (optional)
3.6 Determinism
Files stored in sorted ASCII order
Hash table deterministic
Load order fixed
3.7 Mod Stacking
Later-mounted dpaks override earlier ones.
============================================================
4. SAVEGAME FORMAT
Savegames must be:
cross-platform
deterministic
compact
streamable
resistant to corruption
4.1 Format: SNG (Save Narrative Graph)
Binary, structured, chunked.
[SNG HEADER]
[SNG CHUNKS...]
[SNG FOOTER]
4.2 Chunk Types
WORLD_STATE         — terrain, chunks, voxels
ENTITY_STATE        — machines, vehicles, workers
NETWORK_STATE       — power, data, pipes, rails
ECONOMY_STATE       — companies, markets, prices
AI_STATE            — persistent AI memory
METADATA            — timestamp, version
USER_STATE          — player inventory, research, etc
4.3 Deterministic Serialization
no random iteration
stable order of chunks
stable entity ordering
fixed-endianness mode (little-endian default)
4.4 Compression
Optional per chunk.
============================================================
5. REPLAY FORMAT
Replays store inputs, not simulation deltas.
5.1 Structure
[RPLY HEADER]
[SNAPSHOT (optional)]
[INPUT STREAM]
[FOOTER]
5.2 Snapshot Options:
none
periodic (every N ticks)
manual
frame-perfect (heavy)
5.3 Input Stream
Each tick:
tick_number
input_event_count
input_events[]
Ensures perfect sync across all machines.
============================================================
6. VIRTUAL PATH RULES
6.1 Allowed Characters
ASCII printable
no spaces recommended, but allowed
must be case-sensitive
Example:
textures/world/grass.png
audio/sfx/machine/hum.ogg
scripts/research/tech_tree.lua
6.2 Path Normalization
always /
collapsed (no .., no duplicate slashes)
no absolute paths allowed
no Windows drive letters allowed
============================================================
7. CONFIGURATION SYSTEM
7.1 Format
.json with optional comments.
7.2 Locations
user/config/
user/options/
user/keybinds/
Priority:
user > mods > dlc > base
7.3 Reloading
Config hot-reload allowed.
No simulation rollback required.
============================================================
8. MODDING SYSTEM (FILE-LEVEL)
8.1 Mod Layout
modname/
    modinfo.json
    dpak(s)
8.2 modinfo.json
{
  "name": "HighResTextures",
  "version": "1.0",
  "depends": ["BaseGame>=1.0"],
  "conflicts": [],
  "mount_priority": 50
}
8.3 dpak Priority
Sorted by:
mount_priority
alphabetic mod name
8.4 Safe Sandbox
Mods may not:
read arbitrary OS files
write arbitrary OS files
escape dpak boundaries
Engine enforces strict isolation.
============================================================
9. SAVE/LOAD AT SCALE
Dominium supports large worlds with chunking (Volumes 7.3):
9.1 Chunk Serialization Strategy
only dirty chunks saved
compression per chunk
chunk hashing for dedupe
9.2 Background Save Thread
Allowed BUT:
uses copy-of-state
simulation never waits
deterministic order preserved
9.3 Auto-Saves
Configurable:
interval
snapshot frequency
max save count
============================================================
10. CROSS-PLATFORM SAVE COMPATIBILITY
All platforms share:
same SNG format
same byte order
same chunks
same entity schema
Legacy platforms (DOS/Win9x/macOS Classic) may:
omit certain chunks
use reduced feature profiles
still load core systems deterministically
============================================================
11. SECURITY / SANDBOXING
11.1 No Code Execution from dpaks
No native DLL/SO
No shell scripts
No compiled binaries
Only Lua files allowed, with sandbox
11.2 VFS Access Limits
Mods cannot access parent directories
Mods cannot modify base dpaks
Mods cannot overwrite user saves
11.3 Hash Validation
Optional per dpak:
ensures no tampering
used for multiplayer consistency checks
============================================================
12. LEGACY PLATFORM SUPPORT
MS-DOS
FAT12/16
8.3 filenames only
dpaks stored as split archives:
GAME1.DP0
GAME1.DP1
…
VFS maps these seamlessly
Windows 3.x / 95 / NT 3.51
long filenames optional
code page aware
dpak stored normally
memory-constrained loads
macOS 7–9
HFS+ path quirks handled internally
Linux
case-sensitive, matches VFS
============================================================
13. FILESYSTEM LAYOUT (PHYSICAL DISK)
/dominium/
    base/
        core.dpak
        assets.dpak
        ui.dpak
    dlc/
        interstellar/
            interstellar.dpak
        extras/
            extras.dpak
    mods/
        user_mod1/
            modinfo.json
            content1.dpak
        user_mod2/
            ...
    user/
        saves/
        replays/
        config/
        screenshots/
Installer/launcher maintains this layout across Windows, macOS, Linux, and portable builds.
============================================================
14. SUMMARY
Volume 7.10 defines:
deterministic virtual filesystem
unified dpak packfile format
mod stacking rules
replay and savegame formats
legacy filesystem compatibility
sandbox and security model
OS abstraction for all I/O
high performance chunked saving
Dominium now has a fully platform-agnostic, deterministic data layer.
END OF VOLUME 7.10

---

Ready for **VOLUME 7.11 — Networking, Multiplayer, Sync, Lag Compensation, Universe Host Architecture**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.11 — NETWORKING, MULTIPLAYER, SYNC, LAG COMPENSATION, UNIVERSE HOST ARCHITECTURE.
This is one of the largest and most critical core-engine volumes.
It defines all networking semantics and lays the foundation for:
single-player
local multiplayer
LAN
WAN
dedicated servers
universe hosts
online/offline parity
deterministic lockstep
late join
replay-driven rollback
server authority
mod consistency
input replication
time dilation
anti-cheat surfaces (minimal but sufficient)
platform compatibility from Win2000/macOS10.6/Linux to future low-end ports
Delivered as a single continuous Markdown block.

# VOLUME 7.11 — NETWORKING, MULTIPLAYER, SYNC, LAG COMPENSATION, UNIVERSE HOST ARCHITECTURE  
Dominium Engine Specification — Engine Core, Part 11  
(Deterministic Lockstep, Server Authority, Input Replication, Offline Parity)

Defines:
- Overall multiplayer model  
- Deterministic tick synchronization  
- Lockstep protocol  
- Input replication & snapshots  
- Dedicated server architecture  
- Universe hosting model  
- Lag compensation  
- Time dilation strategies  
- Disconnect/reconnect  
- Savegame handoff  
- Mod consistency enforcement  
- Replay integration  
- Platform compatibility for all engine targets  


============================================================
1. MULTIPLAYER PRINCIPLES
============================================================

1. Simulation is **strict deterministic lockstep**.  
2. Server (host) is authoritative over:
   - ticks
   - input acceptance
   - modset
   - simulation state  
3. Clients send **input events**, never game state.  
4. Offline single-player uses the same network pipeline with a local loopback connection.  
5. Replays use the same packet format (input stream).  
6. Modsets must be identical across server and all clients.  
7. No nondeterministic RNG allowed.  
8. Networking must operate on Win2000+, macOS 10.6+, Linux, and headless servers.  


============================================================
2. MULTIPLAYER MODES
============================================================

- **Single-player Offline**  
  Loopback. Exact same pipeline as online.  
  Full determinism guaranteed.  
  Replays use same inputs.  

- **Hosted Peer Game (Listen Server)**  
  Player ≡ server.  
  Others join directly.  
  Uses NAT traversal if available.  

- **Dedicated Server (Headless)**  
  Runs without rendering.  
  Highest determinism and performance.  
  Supports dozens to hundreds of players depending on world scale.  

- **Universe Host**  
  Runs long-lived universes.  
  Players join properties within the same universe.  
  No persistence aside from the savegame.  


============================================================
3. SERVER–CLIENT ARCHITECTURE
============================================================

CLIENT:
gather input →
package input →
send to server →
receive authoritative tick →
apply state updates →
render
SERVER:
receive input packets →
queue them deterministically →
advance simulation tick →
send authoritative tick state

Simulation occurs ONLY on the server.  
Client simulation is optional (prediction).  


============================================================
4. NET PROTOCOL
============================================================

The protocol is binary, minimal, deterministic.

### 4.1 Message Types
C→S: INPUT_PACKET
S→C: TICK_CONFIRM
S→C: SNAPSHOT_CHUNK
S→C: EVENT_MESSAGE
S→C: CHAT
S→C: PING
C↔S: HEARTBEAT
S→C: DESYNC_REPORT

### 4.2 Input Packet
struct input_packet {
uint32 tick;
uint16 event_count;
input_event events[event_count];
}

### 4.3 Tick Confirm
Server sends the simulation tick number:
struct tick_confirm {
uint32 tick;
uint32 checksum; // simulation checksum
}

### 4.4 Checksums
Used for desync detection.  
- FNV-1a 64-bit hash  
- Generated deterministically at the end of each tick  
- Never used to influence gameplay  


============================================================
5. LOCKSTEP AND DETERMINISM
============================================================

All clients must reach tick N only after receiving tick N from server.

### 5.1 Server Tick Loop

while (running):
collect all input for tick T
simulate tick T
send tick_confirm(T)
T++

### 5.2 Input Deadlines
Client must send input for tick T:
- before server reaches T  
- late inputs flagged  
- server may run prediction or freeze client (configurable)  


============================================================
6. LAG COMPENSATION
============================================================

### 6.1 Strategies

**A — Hard Lockstep**  
- no prediction  
- perfect determinism  
- ideal for slow-paced simulation  
- minimal bandwidth  
- simplest implementation  

**B — Client Prediction + Server Reconciliation** (optional)  
- client simulates ahead  
- server authoritative  
- rollback/replay limited to client rendering only  
- server never rolls back  

Dominium defaults to **A**, with optional B for responsive first-person control in future expansions.

### 6.2 Time Dilation
If a client lags:
- the client runs slower visually until it catches up  
- simulation speed on server NEVER changes  
- UI shows speed factor (0.8x, 0.5x, etc)

If a server overloads:
- global UPS slows gracefully (Vol. 2.x UPS model)  
- clients adjust display accordingly  


============================================================
7. SNAPSHOTS & STATE SYNC
============================================================

Server periodically sends world snapshots:

snapshot {
tick
chunk data (compressed)
}

Use cases:
- late join  
- desync recovery  
- client prediction recovery  

Snapshots contain:
- terrain chunks  
- entity states  
- network states (power/data/fluid)  
- economy state  
- AI memory  

Clients apply snapshot → roll forward input replay.


============================================================
8. UNIVERSE HOST MODEL
============================================================

Universe = collection of properties, companies, players.

Server maintains:
- entire universe state  
- active properties (fully simulated)  
- inactive properties (statistical model)  

Players join at:
- their own property  
- partners’ properties  
- neutral markets  

Universe can run:
- persistent  
- private  
- public  
- offline local  

Properties do not simulate other properties deeply:
- AI companies are abstracted (Vol. 2.x economic abstraction)  
- Interproperty traffic uses logical transitions  


============================================================
9. MOD CONSISTENCY & SECURITY
============================================================

### 9.1 Mod Hashing
Each dpak has:
- CRC32  
- SHA-256  

Server maintains mod manifest:
modlist.json
{
"count": N,
"mods": [
{"name": "...", "version": "...", "hash": "..."},
]
}

Clients must match modset exactly.

### 9.2 Script Restrictions
Lua scripts:
- cannot access OS  
- cannot open sockets  
- cannot spawn threads  
- cannot influence determinism outside sanctioned APIs  

### 9.3 Replay Validation
Replays must match modset at time of recording.


============================================================
10. BANDWIDTH MODEL
============================================================

Dominium is input-based so bandwidth is extremely low.

### 10.1 Requirements
- 2–10 KB/s per player  
- 20–50 KB/s peak for snapshot  

### 10.2 Compression
All packets optionally compressed (LZ4).  


============================================================
11. DISCONNECT / RECONNECT
============================================================

### 11.1 Client Drop
Server buffers N ticks of input history.  
On reconnect:
- client receives snapshot + input replay from last confirmed tick  
- seamlessly catches up  

### 11.2 Server Drop (listen server)
- game paused  
- host may save and restart  
- clients may migrate to new host (optional feature)  


============================================================
12. HEADLESS SERVER MODE
============================================================

Headless server:
- no graphics  
- no sound  
- runs at max UPS or configurable UPS  
- CLI console  
- RCON support  
- memory usage scaled to universe size  
- stable CPU footprint  

Linux recommended but Win2000+ and macOS supported.


============================================================
13. NAT TRAVERSAL & LAN
============================================================

- LAN: direct UDP connects  
- Internet:  
  - STUN (if modern OS)  
  - NAT punching  
  - manual port forwarding fallback  
  - Tor/I2P layers optional future support  


============================================================
14. REPLAY INTEGRATION
============================================================

Replays use the same input packets:
- 1:1 replay  
- fast-forward  
- slow motion  
- debug visualizations  

Snapshots allow:
- jumping  
- editing  
- training AI agents offline  


============================================================
15. LEGACY PLATFORM SUPPORT
============================================================

### Windows 2000  
Winsock 2.0  
UDP recommended  

### Windows 98 / NT4  
Winsock 1.1  
Reduced packet size  

### macOS 10.6  
POSIX sockets  

### Linux  
POSIX sockets  

### MS-DOS  
- IPX support (if available)  
- DOS TCP stacks (WATTCP) optional  
- Limited to small LAN games  

### Headless Minimal  
No graphics or sound, pure network.  


============================================================
16. API STRUCTURE
============================================================

```c
bool net_init();
void net_shutdown();

bool net_send(packet *p, address to);
bool net_receive(packet *p, address *from);

void server_tick();
void client_tick();
Network never touches simulation directly:
all integration goes through input queue
all state sync goes through snapshot importer
============================================================
17. FILESYSTEM LAYOUT
network/
    protocols/
    modlist.json
    server_config.json
    firewall_presets.json
    latency_profiles.json
saves/
replays/
Server config includes:
max players
tick rate
universe size
allowed mods
persistence options
============================================================
18. SUMMARY
Volume 7.11 defines:
deterministic lockstep simulation
authoritative servers
universal offline/online parity
minimal bandwidth design
full mod consistency enforcement
snapshot + input replay system
lag compensation via time dilation
drop-in/drop-out support
headless servers
legacy OS networking support
universe hosting model
This forms the foundation of Dominium’s multiplayer and online ecosystem.
END OF VOLUME 7.11

---

Ready for **VOLUME 7.12 — Job System, Multithreading, Work Distribution, Deterministic Core Scheduling**.
You said:
Proceed 
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.12 — JOB SYSTEM, MULTITHREADING, WORK DISTRIBUTION, DETERMINISTIC CORE SCHEDULING.
This volume defines the entire internal concurrency model for Dominium.
It is where determinism, multi-core scaling, and the UPS system converge.
Delivered as one continuous MD block.

# VOLUME 7.12 — JOB SYSTEM, MULTITHREADING, WORK DISTRIBUTION, DETERMINISTIC CORE SCHEDULING  
Dominium Engine Specification — Engine Core, Part 12  

Defines:
- core job scheduler  
- worker threads  
- deterministic task sequencing  
- UPS/FPS decoupling  
- soft and hard dependency groups  
- platform compatibility (Win2000/macOS 10.6/Linux)  
- fallback to single-thread mode for legacy systems  
- rules for safe parallelism  


============================================================
1. PRINCIPLES
============================================================

1. Simulation tick order is strictly deterministic.  
2. Threads may be used to accelerate work, but **never** change the order of simulation outputs.  
3. All multithreading happens inside **phases** (Vol. 7.4) using  
   *deterministic job groups* and *barriers*.  
4. Thread count is configurable; default is:
   - 1 on legacy systems  
   - up to N on modern systems  
   - capped by engine or user
5. No job may read-write shared simulation state without deterministic access patterns.  
6. No random scheduling or OS-level task ordering may influence results.  


============================================================
2. THREAD CONFIGURATION
============================================================

Thread roles:

1. **Main Thread**  
   - owns simulation sequencing  
   - owns job graph  
   - owns render coordination  
   - owns input  
   - strict deterministic order

2. **Worker Threads (0–64+)**  
   - run parallel jobs within phases  
   - CPU count detection at startup  
   - fallback to zero worker threads on legacy systems

3. **IO Thread** (optional)  
   - async disk loading  
   - dpak streaming  
   - never touches simulation memory  

4. **Network Thread** (optional)  
   - non-blocking UDP receive  
   - queues packets for main thread  

Job system must operate entirely within Main+Workers for simulation.


============================================================
3. MULTITHREADING MODEL
============================================================

Dominium uses **deterministic parallel phases**:

for each simulation tick T:
Phase A: input ingestion (single-thread)
Phase B: networks (multi-thread)
Phase C: machines (multi-thread)
Phase D: logistics (multi-thread)
Phase E: environment (multi-thread)
Phase F: economy + AI (multi-thread)
Phase G: terrain ops (multi-thread)

Each phase contains:
- sequential setup  
- parallel job pool  
- deterministic barrier  
- sequential finalize  

Parallel work **never** modifies shared memory unsafely.


============================================================
4. JOB GRAPH STRUCTURE
============================================================

Each simulation tick creates a **job graph** describing all work:

struct job {
void (func)(job_ctx);
uint32 group_id;
uint32 index;
// no dynamic allocation
}

### 4.1 Groups
Jobs are arranged into **ordered groups**:

Group 0 → Group 1 → Group 2 → ...

Inside each group, jobs run in parallel with no ordering.

Stage completion requires:
- all jobs in group finished  
- barrier → next group  

### 4.2 Determinism Guarantee
No job may:
- read another group's data  
- write to shared structures except its own partition  
- depend on OS scheduling order  
- use non-thread-safe random  
- modify global shared state without atomic, pre-determined sequence  


============================================================
5. WORK PARTITIONING
============================================================

Dominium uses **static partitioning** where possible, for determinism.
Dynamic scheduling is allowed only with restrictions.

### 5.1 Partition Rules
- Entities divided into fixed chunks  
- Terrain divided into fixed chunks  
- Networks divided into fixed node/edge buckets  
- Machine arrays divided into fixed stripes  

Threads operate on assigned partitions exclusively.

### 5.2 Example: Power Network
nodes: partition into stripes of size N
edges: partition into slices
Each thread computes its partition without overlap.

Final merge is deterministic.


============================================================
6. REDUCTIONS AND MERGES
============================================================

If partial results must be combined:
- each worker accumulates into a **thread-local** buffer  
- main thread performs deterministic merge in a fixed order  

No atomic floating-point operations allowed.

Example: summing production totals:
tmp[thread] = compute_partial_sum(...)
...
global_sum = tmp[0] + tmp[1] + ... + tmp[n]

Order is guaranteed deterministic.


============================================================
7. CACHE & MEMORY RULES
============================================================

### 7.1 Data Layout
- SoA (Structure of Arrays) strongly encouraged  
- contiguous chunks  
- aligned memory  
- no pointer chasing during parallel ops  
- stable array indices  

### 7.2 Memory Pools
- all simulation memory allocated at load time  
- no malloc/free during tick  
- fixed-size or slab-allocated arrays  


============================================================
8. UPS MODEL (INTEGRATION WITH JOB SYSTEM)
============================================================

The UPS model (Vol. 2.?) defines:
- canonical UPS (1/2/5/10/20/30/45/60/90/120/180/240)  
- fallback UPS (downshift on overload)  
- input tick boundaries  

Job system integrates by:
- recording execution times  
- auto-balancing partition sizes  
- predicting next-frame load  

Never changes output state — only changes how work is parallelized.


============================================================
9. LOAD SPREADING
============================================================

Many systems need not run every tick.

### 9.1 Deterministic Offsets
Each subsystem chooses a **fixed modulo schedule**:

Examples:
- research tick: every 10 ticks  
- climate tick: every 600 ticks  
- AI tick: every 30 ticks  

Each run has a deterministic offset so phases never align:

climate runs at ticks T ≡ 7 (mod 600)
AI runs at T ≡ 13 (mod 30)
research runs at T ≡ 3 (mod 10)

Reduces CPU spikes.  
Fully deterministic.


============================================================
10. MULTITHREADING ON LEGACY PLATFORMS
============================================================

### Windows 98/2000
- Threads supported (Win32)  
- Some CPUs may have 1 core or SMT  
- Engine may limit worker threads to 1  
- UPS restricted (default 30 UPS max on very slow systems)  

### macOS 10.6  
- POSIX threads  
- full support  

### Linux  
- pthreads  
- full support  

### MS-DOS  
- No threads  
- single-thread simulation  
- fixed partitioning  
- no job system active  
- simulation still deterministic  


============================================================
11. DEBUGGING & PROFILING
============================================================

### 11.1 Deterministic Replay Debugging
- replay uses same job scheduling  
- breakpoints follow tick boundaries  
- profiler records per-thread job timings  

### 11.2 Profiling Output
jobs/
tick_000123_profile.json
Contains:
- per-group times  
- per-job times  
- worker distribution  


============================================================
12. SAFETY RULES (ABSOLUTE)
============================================================

1. No shared writes across threads without fixed deterministic ordering.  
2. No dynamic job generation during phases.  
3. No interior allocation.  
4. No waiting on OS primitives inside jobs.  
5. No floating-point atomics.  
6. No per-thread random state unless seeded deterministically.  
7. No reading of global simulation arrays outside assigned partitions.  
8. No job may depend on completion order within the same group.  


============================================================
13. API
============================================================

```c
typedef void (*job_fn)(job_ctx*);

void job_system_init(int worker_threads);
void job_system_shutdown();

void job_begin_tick();
void job_submit(job_fn fn, job_ctx *ctx, int group_id);
void job_wait_group(int group_id);
void job_end_tick();
High-level phases call into these primitives.
============================================================
14. FILESYSTEM LAYOUT
jobs/
    config.json
    profiles/
config.json:
{
  "max_workers": 8,
  "affinity": "auto",
  "partition_size": 256
}
============================================================
15. SUMMARY
Volume 7.12 defines:
deterministic job scheduling
multi-core parallelism
strict ordering guarantees
partitioned simulation memory
safe reductions and merges
integration with UPS/fallback UPS
legacy fallback to single-thread mode
debugging and profiling mechanics
This is the definitive multithreading model for Dominium’s deterministic simulation core.
END OF VOLUME 7.12

---

Ready for **VOLUME 7.13 — Debugging, Logging, Diagnostics, Assertions, Visualizers, and Live Introspection Tools**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.13 — DEBUGGING, LOGGING, DIAGNOSTICS, ASSERTIONS, VISUALIZERS, AND LIVE INTROSPECTION TOOLS.
You will receive a single continuous MD block, aligned with the deterministic, cross-platform, low-level constraints of the entire Dominium engine series so far.

# VOLUME 7.13 — DEBUGGING, LOGGING, DIAGNOSTICS, ASSERTIONS, VISUALIZERS & LIVE INTROSPECTION  
Dominium Engine Specification — Engine Core, Part 13  
(Deterministic Diagnostics Pipeline, Cross-Platform Debug Tools)

Defines:
- logging system  
- assertions & fatal error handling  
- debug overlays  
- simulation visualizers  
- runtime diagnostics  
- profiling & tracing  
- replay debug tools  
- network, filesystem, job system inspectors  
- platform compatibility guarantees  


============================================================
1. DEBUGGING PRINCIPLES
============================================================

1. Debug systems MUST NOT change simulation behavior or determinism.  
2. All diagnostics operate as *observers*, never writers.  
3. Debug features must degrade gracefully on legacy machines.  
4. All logs must be:
   - timestamped  
   - tick-stamped  
   - stable and deterministic in ordering  
5. Debug mode must never require GPU features not available on low-end targets.  
6. Debug features must be available headless, GUI, and TUI.  


============================================================
2. LOGGING SYSTEM
============================================================

### 2.1 Requirements
- thread-safe  
- deterministic ordering  
- circular buffer for in-game console  
- file output per session  
- configurable verbosity  
- flush-on-fatal  

### 2.2 Levels
LOG_FATAL
LOG_ERROR
LOG_WARN
LOG_INFO
LOG_DEBUG
LOG_TRACE

### 2.3 Format
[T=12345][INFO][job=3][thread=1] Scheduled 422 jobs for Phase C

### 2.4 Output Targets
- in-memory buffer  
- on-disk log rotating file  
- stdout (optional)  
- network debugging stream (optional development tool)  

### 2.5 OS Path Safety
On legacy systems:
- 8.3 filename fallback  
- writeable only to “user/logs” VFS mount  


============================================================
3. ASSERTION FRAMEWORK
============================================================

### 3.1 Hard Assertions
Abort program immediately:
```c
ASSERT(x != NULL);
ASSERT(index < MAX_ENTITIES);
3.2 Soft Assertions
Log warning + continue:
ASSERT_SOFT(machine->power_usage >= 0);
3.3 Desync Assertions
Server detects invariant break:
logs details
outputs replay log + snapshot
client receives DESYNC_REPORT
simulation continues if possible
3.4 Platform Behavior
On DOS/Win9x:
assert prints message
halts to safe shutdown if fatal
============================================================
4. DEBUG OVERLAYS (2D/3D)
4.1 Rendering Tiers
L1 (vector): text & lines only
L2 (sprite): textured debug icons + text
L3 (3D): wireframes, bounding boxes, camera frustums
4.2 Overlay Types
FPS/UPS meter
thread timings
job scheduling visualizer
chunk boundaries
entity bounding boxes
power/data/fluid network overlays
AI debug states
economic debug graphs
pathfinding visualizer
terrain debug mesh
4.3 Interaction
toggle via console or hotkeys
saved in user/config/debug.json
============================================================
5. LIVE INTROSPECTION CONSOLE
5.1 Command Shell
TUI or overlay console:
/help
/set ups 60
/list entities
/dump networks power
5.2 Determinism Rule
Console commands may:
inspect
log
pause/resume
step ticks
trigger debug-only states
Console commands may NOT:
mutate simulation state (except commands explicitly designated as “cheat”)
Cheat commands clearly marked and default-disabled.
5.3 Headless Mode
Full console available over:
STDIN
RCON (optional)
telnet-like text access (no security except LAN usage)
============================================================
6. SIMULATION INSPECTORS
Introspection interfaces for all major systems.
6.1 Entity Inspector
Provides:
entity id
type
position
velocity
CPU load for entity
component list
inventory contents
power/net/pipes references
6.2 Network Inspector
For power / fluid / data:
node count
edge list
per-node voltage, pressure, temperature
routing tables (data network)
6.3 Terrain Inspector
Chunk-level info:
heightfield min/max
sparse voxel cell count
dirty/clean flags
memory footprint
6.4 Economy Inspector
company list
commodity flow
price curves
supply/demand tables
6.5 AI Inspector
decision logs
worker memories
task queues
profiling per task
============================================================
7. PROFILING SYSTEM
7.1 Hierarchical Profiler
Instrumented calls:
PROF_BEGIN("power_network");
...work...
PROF_END();
Outputs:
T=12345 | power_network | 3.52 ms | 12.4% frame
7.2 Per-Thread Timers
Worker timing output:
thread0: 4.12 ms
thread1: 3.98 ms
thread2: 3.45 ms
7.3 Job System Profile Dump
(Integrates with Vol. 7.12)
jobs/tick_001234.json
Includes:
group timings
job timings
parallel efficiencies
============================================================
8. EVENT TRACING
8.1 Trace Buffer
Fixed-size ring buffer:
captures events (input, tick, network, jobs, IO, render CPU)
timestamped
tick-stamped
8.2 Export Format
Chrome trace format (.json), e.g.:
trace/tick_001234_trace.json
8.3 Uses
diagnosing stutters
analyzing network jitter
regression testing
============================================================
9. NETWORK DEBUGGING
9.1 Packet Spy
Optional tool:
logs C→S and S→C packets
anonymized payloads
logs latency and jitter
9.2 Desync Checker
Client calculates:
checksum(tick)
Server compares and reports mismatch.
9.3 Replay Analyzer
Loads:
replay input stream
snapshot stream
produces diagnostics
Used for debugging determinism.
============================================================
10. RENDERING DEBUGGING
10.1 Wireframe Mode
Forced:
all meshes become wireframe
useful for collision debugging
10.2 Overdraw Visualization
Heatmap coloration (if backend supports).
10.3 GPU Capability Logs
During startup:
renderer_capabilities.txt
Stores:
detected features
GL extensions
DX caps
fallback decisions
============================================================
11. ERROR HANDLING
11.1 Hard Errors
Fatal:
missing dpak
corrupted save
invalid renderer
out of memory
Engine prints:
FATAL ERROR
<message>
stacktrace.txt
Then exits gracefully.
11.2 Recoverable Errors
Engine logs warning:
[WARN] Texture atlas full, using fallback tex.
Simulation continues.
11.3 Legacy Fallback
If DX9 fails, fallback to GL1 or SW with warning.
============================================================
12. UI & TOOLING
12.1 Debug UI Panels
CPU graphs
memory usage
entity lists
network graphs
chunk visualizers
12.2 External Tools
Separate “Dominium DevKit” includes:
DPAK packer/unpacker
Mesh previewer
Texture atlas authoring
Script debugger (Lua sandbox viewer)
GUI for inspector output
Terrain editor (Vol. 8.x)
============================================================
13. SECURITY & PRIVACY
13.1 Log Redaction
User-identifying OS paths and usernames stripped.
13.2 Multiplayer Security
No debug output may include:
private IPs
mod hashes
authentication tokens
13.3 Desync Dumps
Written to:
user/debug/desync/
Never shared automatically.
============================================================
14. FILESYSTEM LAYOUT
debug/
    logs/
        session_0001.log
    traces/
    profiles/
    desync/
    config.json
config.json:
{
  "log_level": "info",
  "profiling": true,
  "trace": false,
  "overlay": true
}
============================================================
15. SUMMARY
Volume 7.13 defines:
full debug/logging/assertion framework
deterministic diagnostics
debug UI
live inspectors
job/network/terrain/economy visualizers
replay analysis tools
legacy and headless compatibility
secure, stable error handling
This completes the diagnostics layer for Dominium Engine.
END OF VOLUME 7.13

---

Ready for **VOLUME 7.14 — UI/UX Framework, Skinning System, Input Layers, Menu Architecture, In-Game HUD, TUI/GUI Unification**.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
State which subsection of 7.14 you want next if you want to branch, otherwise I will continue linearly.
Proceeding with:
VOLUME 7.14 — UI/UX FRAMEWORK, SKINNING SYSTEM, INPUT LAYERS, MENU ARCHITECTURE, TUI/GUI UNIFICATION
Rendered in a single continuous MD block. No softening. No filler.
This defines the entire UI/UX architecture for Dominium across all supported platforms (Win2000+, OSX 10.6+, Linux, future retro targets, headless, TUI-only, low-spec GPUs, etc.).

# VOLUME 7.14 — UI/UX FRAMEWORK AND PRESENTATION LAYER  
Dominium Engine Specification — Engine Core, Part 14  

Covers:
- unified UI pipeline for TUI, 2D vector, 2D raster, 3D HUD overlays  
- input abstraction  
- menu architecture  
- UI theming and skinning  
- accessibility  
- deterministic behavior guarantees  
- legacy system compatibility  


============================================================
1. UI/UX DESIGN PRINCIPLES
============================================================

1. The UI must run on:
   - headless servers (TUI only)
   - Windows 2000+ with DX9
   - Linux/X11/Wayland with SDL2
   - macOS 10.6+ with Cocoa/GL2
   - fallback GL1 renderer
   - software renderer (pure CPU)
   - future retro targets (DOS, Win9x)

2. The UI layer must be:
   - deterministic in state transitions  
   - non-deterministic in render timing allowed (visual-only)  
   - fully scriptable  
   - skinable through mod packs  
   - compatible with vector or raster assets  
   - low-memory compatible

3. Interaction rules:
   - UI state is part of sim-state only when required  
   - UI must not affect simulation determinism  
   - Input events map to commands, not direct simulation writes  


============================================================
2. UI LAYER TIERS (FOUR-LEVEL SYSTEM)
============================================================

### 2.1 Level 0 — Headless / TUI
- ANSI terminal  
- minimal text menu  
- interactive shell  
- server management  
- mod loader  
- config editor  

### 2.2 Level 1 — 2D Vector (Engine’s Internal Vector Stack)
- lines, boxes, text  
- scalable to any resolution  
- fallback for low-GPU/old GPUs  
- used for overlays even in 3D mode  
- SVG-like primitives (internal format)

### 2.3 Level 2 — 2D Raster (Sprites, Textures)
- bitmap assets  
- UI skin textures  
- icons, buttons, thumbnails  
- supports atlases  
- resolution-independent scaling via 9-slice and vector text

### 2.4 Level 3 — 3D HUD / In-World UI
- floating markers  
- holographic panels  
- world-space tooltips  
- unit selection rings  
- camera-anchored HUD elements  


============================================================
3. UI RENDER PIPELINE
============================================================

### 3.1 Ordering
1. 3D world  
2. world-space UI  
3. screen-space HUD  
4. 2D raster UI  
5. 2D vector UI  
6. debug overlays  
7. cursor

### 3.2 Vector Renderer Guarantees
- no GPU dependency  
- rasterizer available in software  
- deterministic output for test/debug mode

### 3.3 Raster Renderer Guarantees
- GPU acceleration if available  
- fallback to CPU blit  
- texture caches deterministic across loads  


============================================================
4. INPUT ABSTRACTION LAYER
============================================================

### 4.1 Raw Input Sources
- mouse  
- keyboard  
- gamepads  
- touch screens  
- pointer devices  
- legacy (PS/2, DOS interrupt handlers)

### 4.2 Canonical Input Mapping
All raw events normalized into:
INPUT_BUTTON_PRESS
INPUT_BUTTON_RELEASE
INPUT_AXIS_MOVE
INPUT_TOUCH_TAP
INPUT_TOUCH_DRAG
INPUT_SCROLL
INPUT_COMMAND("inventory.open")

### 4.3 Remapping
- stored in user/config/input.json  
- modifiable at runtime  
- no effect on simulation determinism  

### 4.4 UI Navigation Modes
- pointer mode  
- focus mode (controller/keyboard)  
- command mode (TUI/headless)  


============================================================
5. MENU ARCHITECTURE
============================================================

### 5.1 Main Menu Structure
Play
Continue
Load
Multiplayer
Editor
Mods
Options
Extras
Quit

### 5.2 Submenus
Each page defined as a pure state machine:
- no randomness  
- no async mutation  
- UI transitions deterministic  

### 5.3 Screens
- planet/system/galaxy selection  
- property chooser  
- universe browser  
- mod browser  
- replay browser  
- save manager  
- benchmark tools  
- diagnostics panel  


============================================================
6. UI SKINS, THEMES, AND MOD PACKS
============================================================

### 6.1 Skin Format
A skin is a mod:
mods/skin_example/
ui/
atlas.png
style.json
fonts/

### 6.2 style.json Contents
{
"font_default": "ui/fonts/regular.ttf",
"colors": {
"background": "#1b1b1b",
"accent": "#68a0ff"
},
"widgets": {
"button": {...},
"slider": {...},
"checkbox": {...}
}
}

### 6.3 Vector-Only Mode
All skins must provide fallback vector definitions.

### 6.4 Retro Mode
For DOS/Win3.1/MacOS9 targets:
- 1-bit or 4-bit palettes  
- ASCII/ANSI vector UI  

### 6.5 High-end Mode
- 4K textures  
- HDR icons  
- animated panels (optional, non-sim)  


============================================================
7. ACCESSIBILITY LAYER
============================================================

### 7.1 Requirements
- scalable font size up to 400%  
- high-contrast mode  
- colorblind presets  
- text-to-speech (platform API where possible)  
- keyboard-only navigation  
- TUI compatibility for blind users  

### 7.2 Determinism
Accessibility changes:
- must not influence game simulation  
- must not modify save data  


============================================================
8. CORE UI WIDGET SET
============================================================

### 8.1 Basic Widgets
- button  
- label  
- textbox  
- checkbox  
- slider  
- dropdown  
- list  
- tab  
- frame  
- tooltip  

### 8.2 Advanced Widgets
- tree view  
- inventory grid  
- research graph  
- map panel  
- world inspector  
- job queue inspector  
- power/fluid/data overlay UI  
- network routing tables  
- minimaps (vector or raster or 3D-projected)  

### 8.3 Widget Determinism
GUI state is separate from sim-state except:
- build/confirm actions  
- placement previews  
- command inputs  



============================================================
9. HUD SYSTEM
============================================================

### 9.1 2D HUD
- compass  
- clock/calendar  
- worker/task readouts  
- network health indicators  
- cargo flow meters  
- FPS/UPS (optional)

### 9.2 3D HUD
- markers over entities  
- tooltips anchored to world position  
- wireframe selection outlines  
- path previews (“ghost lanes”)  

### 9.3 Mode-dependent HUD
Top-down mode = map UI  
First-person mode = immersive HUD  

HUD elements auto-switch without state loss.  


============================================================
10. UI STATE MANAGEMENT
============================================================

### 10.1 State Machine Requirements
- deterministic  
- no asynchronous event drift  
- every UI transition must be reversible  

### 10.2 Save/Load
Simulation saves must NOT store UI state.  
UI state stored separately in user profile.

### 10.3 Multiplayer
UI state is client-specific:
- independent menus  
- independent overlays  
- server never dictates UI  


============================================================
11. SCRIPTING & LUA UI INTEGRATION
============================================================

### 11.1 Lua-Driven UI Logic
Lua may:
- create widgets  
- modify layout  
- react to signals  
- subscribe to data network  

Lua may NOT:
- mutate simulation  
- alter core rules  
- bypass permissions  

### 11.2 Safety
UI Lua sandbox is separate from simulation Lua.

### 11.3 Deterministic Path
UI script execution order:
1. pre-frame UI logic  
2. widget event handling  
3. post-frame UI logic  


============================================================
12. PER-PLATFORM BACKENDS
============================================================

### 12.1 Windows (2000+)
- DX9 for HW  
- GDI/Software fallback  
- raw input or DirectInput

### 12.2 Linux
- SDL2 for windowing/input  
- GL2, GL1, or SW fallback

### 12.3 macOS 10.6+
- Cocoa  
- GL2  
- SW fallback  

### 12.4 Legacy (DOS, Win3, Win95)
- TUI primarily  
- minimal bitmap blitter  
- no alpha blending  
- “ANSI UI mode”

### 12.5 Console/Handheld (future)
- unified UI  
- gamepad-only navigation  

### 12.6 WebAssembly
- JS input adapter  
- HTML canvas for raster  
- WebGL1 for 3D  


============================================================
13. UI PERFORMANCE REQUIREMENTS
============================================================

- UI must render in <1ms on modern hardware  
- vector fallback ≤ 2ms on low-end  
- all animations optional  
- no per-pixel expensive effects  


============================================================
14. UI FAILOVER
============================================================

If 2D raster UI fails:
- fallback to vector UI

If vector fails:
- fallback to TUI

If all fail:
- headless emergency CLI only  


============================================================
15. SUMMARY
============================================================

Volume 7.14 defines Dominium’s full cross-platform UI stack:
- multilayer presentation model  
- deterministic UI state  
- TUI → vector → raster → 3D HUD hierarchy  
- robust accessibility  
- modding-friendly skinning  
- low-end fallback and legacy system support  
- unified input pipeline  
- world-space and screen-space UI integration

This completes the presentation layer of the Dominium engine.

# END OF VOLUME 7.14

If you want VOLUME 7.15 — Audio System (SFX/Music/Environmental, Multichannel, Low-End Fallback, Deterministic Envelope Rules), say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.15, I need a single clarification.
This is unavoidable: it determines the entire structure of the audio subsystem across all platforms, determinism layers, and rendering tiers.
Clarification Required (must be answered before proceeding)
Do you want the audio simulation to be deterministic, or only the gameplay-relevant parts deterministic?
There are two mutually exclusive models:

Model A — Fully Deterministic Audio (Strict)
All sound output is deterministic across machines, OS, and hardware.
Implications:
No hardware mixing differences allowed
No floating-point drift allowed
No OS mixers (WASAPI/CoreAudio/Pulse) allowed
We must run our own integer mixer
No platform HRTF
No doppler from hardware
No positional audio from hardware
No asynchronous streaming
Music playback must be fixed-point
SFX mixing order must be fixed
Volume curves must be identical on all platforms
Replays reproduce audio perfectly
Multiplayer nodes hear synchronized audio
This is academically clean but limits audio fidelity, especially on high-end machines.

Model B — Deterministic Signals, Non-Deterministic Audio Output (Hybrid)
Only the game logic relevant audio events are deterministic:
when sounds fire
volume/pitch parameters
attenuation
environmental modifiers
But the final audio output buffer is NOT required to match across machines.
Implications:
We can use hardware mixing
HRTF is allowed
3D positional audio is allowed
No need to restrict to integer mixers
Music can stream with normal OS latency
Replays reproduce events but not exact waveform
This is how Factorio, OpenTTD, Kerbal, and Minecraft handle determinism:
the sound schedule is deterministic, the resulting audio buffer is not.

Model C — Fully Non-Deterministic Audio (Visual-Only Determinism)
Audio is treated as pure presentation:
events fire deterministically
mixing, pitch, and spatialization may vary
no guarantee of consistency between machines
simplest to implement
highest fidelity
This matches AAA engines (Unity, Unreal, Frostbite, Source 2).

You must choose one:
A, B, or C.
I cannot proceed with Volume 7.15 until you select the model.
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Model B: deterministic audio events, non-deterministic output.
This is the ideal balance for Dominium: fidelity + consistency + legacy support.
Below is VOLUME 7.15, delivered as a continuous MD block.

# VOLUME 7.15 — AUDIO SYSTEM  
Dominium Engine Specification — Engine Core, Part 15  
(Model B: Deterministic Event Scheduling, Non-Deterministic Sound Output)

This volume defines:
- audio event determinism  
- mixing, streaming, spatialization  
- environmental audio  
- low-end and legacy fallback  
- platform backends  
- modding interfaces  
- music/SFX pipelines  
- performance and memory limits  
- accessibility audio systems  


============================================================
1. AUDIO SYSTEM PRINCIPLES
============================================================

1. ALL simulation-relevant audio events are deterministic:
   - sound_trigger(entity_id, sound_id, params)  
   - music state changes  
   - alerts/alarms  
   - UI activation sounds  

2. The final sound *waveform* does NOT need to be deterministic:
   - OS mixers may differ  
   - latency may differ  
   - HRTF algorithms may differ  
   - dynamic range compression may differ  

3. Audio is NOT authoritative in multiplayer:
   - server sends deterministic audio events  
   - clients render them independently  

4. Audio system must run on:
   - Win2000+  
   - macOS 10.6+  
   - Linux  
   - legacy modes (DOS/Win9x)  
   - software mixing fallback  

5. Audio must degrade gracefully:
   - no sound → safe silence  
   - no hardware → software mixer  
   - no mixer → silent fallback  


============================================================
2. AUDIO EVENT DETERMINISM
============================================================

### 2.1 Event format
Simulation emits:
AUDIO_EVENT {
tick, // deterministic
sound_id, // deterministic
entity_id, // deterministic
volume_param,
pitch_param,
pos_xyz, // world position for spatial audio
category, // sfx/ui/music/voice/etc
flags // looping, stop, priority
}

### 2.2 Event scheduling
- Events stamped with simulation tick.  
- Playback begins at audio_time = event.tick * tick_duration.  
- Clients interpolate to current audio clock.  

### 2.3 Replay consistency
- Replays reproduce event sequence exactly.  
- No guarantee of identical waveform output, but timing and loudness events are identical.


============================================================
3. AUDIO PIPELINE OVERVIEW
============================================================

[SIMULATION] → [DETERMINISTIC EVENT BUFFER] → [AUDIO CLIENT] →
[SPATIALIZER] → [MIXER] → [BACKEND] → OS/Hardware Output

### 3.1 Separation of concerns
- Simulation never touches sound hardware.  
- Mixer never modifies simulation state.  
- Passing parameters only, no feedback loop.  


============================================================
4. AUDIO FORMATS & ASSET PIPELINE
============================================================

### 4.1 Supported Input Formats
- WAV (16/24/32-bit PCM)  
- FLAC  
- OGG Vorbis  
- MOD/XM/S3M (tracker support optional)  
- Raw PCM for legacy fallback  

### 4.2 Internal Engine Formats
- 48 kHz float32  
- fallback: 44.1 kHz integer mixer (legacy)

### 4.3 Asset Packaging
Within DPAK:
audio/
sfx/
music/
ambience/
ui/
voices/
manifest.json

### 4.4 Mods
Mods may override:
- sound definitions  
- sound routing  
- sound categories  
- environmental presets  


============================================================
5. SOUND CATEGORIES & PRIORITIES
============================================================

### 5.1 Categories
UI
SFX
AMBIENT
MUSIC
VEHICLE
WORKER
MACHINE
WEATHER
POWER_GRID
PIPE_FLOW
ALERT
VOICE
RADIO

### 5.2 Priority Rules
High → Low:
ALERT > UI > VOICE > WEATHER > MACHINE > VEHICLE >
AMBIENT > MUSIC

Mixer may drop low-priority sounds under channel pressure.


============================================================
6. SPATIAL AUDIO SYSTEM
============================================================

### 6.1 Positioning
Supports:
- point sources  
- stereo sources  
- area sources (multiple points)  
- line sources (e.g. conveyor belts)  

### 6.2 Attenuation Model
Analytic simple models only:
gain = 1 / (1 + k * distance)
or:
linear falloff

No hardware-dependent behavior allowed.

### 6.3 Doppler (Optional)
Deterministic param → non-deterministic output:
- doppler shift computed deterministically  
- actual rendering differs per device

### 6.4 HRTF
Allowed on systems supporting it (OpenAL Soft / XAudio / CoreAudio).  
Not required.  


============================================================
7. AUDIO MIXER
============================================================

### 7.1 Mixer Modes
1. **Hardware Mixing (Preferred)**
   - XAudio2, CoreAudio, PulseAudio, ALSA  
   - up to 128–512 channels  

2. **Software Mixing (Fallback)**
   - float32 mixer  
   - 48 kHz down to 32 kHz  
   - stereo or mono  

3. **Legacy Mixer**
   - 11 kHz–22 kHz  
   - 8-bit PCM for DOS/Win3.1  

### 7.2 Mixing Rules
- deterministic ordering by event timestamp  
- but final waveform nondeterministic (hardware differences)  
- apply category volume first  
- apply user volume second  
- apply environmental filters last  

### 7.3 Limiting & Compression
Optional:
- soft clipper  
- limiter  
- dynamic range compression  


============================================================
8. MUSIC SYSTEM
============================================================

### 8.1 Deterministic State Machine
Music transitions must be deterministic:
- entering region  
- entering building  
- entering vehicle  
- day/night  
- weather state  
- economy stress  
- combat/alert levels (future DLC)

### 8.2 Streaming
Uses:
- Ogg Vorbis  
- FLAC  
- WAV streaming  

### 8.3 Crossfades
Deterministic state machine triggers:  
Fade curves do not affect gameplay and may differ per platform.

### 8.4 Music Packs
Modders can replace entire soundtrack.  
Base Dominium includes:
- calm industrial  
- construction  
- night ambience  
- alert tones  
- research/analysis tracks  


============================================================
9. ENVIRONMENTAL AUDIO
============================================================

### 9.1 High-Level System
Environmental zones:
exterior
interior_small
interior_large
underground
underwater
vehicle_cabin
high_altitude
industrial

### 9.2 Effects
- EQ curves  
- reverb presets  
- low-pass filters  
- occlusion (simple: scalar based on wall count)  

### 9.3 Weather Audio
Hooks into Vol. 4.7:
- rain  
- wind  
- storms  
- thunder  
- snowfall  
- hail  
- dust storms  

Weather intensity → deterministic param  
Final waveform → nondeterministic


============================================================
10. VEHICLE & MACHINE AUDIO
============================================================

### 10.1 Machines
Use deterministic parameter curves:
- RPM  
- load  
- power draw  
- vibration  
- product mass flow  

Mixer uses these to pick:
- loop samples  
- burst samples  

### 10.2 Vehicles
Support:
- engines  
- wheels/rails/on-ground contact  
- impact  
- aerodynamic noise  
- takeoff/landing  

### 10.3 Multi-Position Sources
Trains, conveyors, pipelines can produce distributed sound:  
Engine computes N sample points deterministically; mixer renders them nondeterministically.


============================================================
11. ACCESSIBILITY AUDIO
============================================================

### 11.1 Text-to-Speech
OS-level only:
- Windows Narrator  
- macOS VoiceOver  
- Linux Speech Dispatcher  

### 11.2 Audio Cues
Optional:
- navigation beeps  
- focus indicators  
- “blind navigation mode” fallback for TUI/headless  

### 11.3 Subtitles
All dialogues, UI notifications, and alerts require subtitles.
Subtitles are deterministic.  


============================================================
12. PERFORMANCE REQUIREMENTS
============================================================

### 12.1 CPU Limits
- <5% CPU target on mid-range  
- <10% CPU on low-end  
- software mixer <15% on very old machines  

### 12.2 Memory Limits
- <128 MB for all audio data loaded  
- streaming allowed for large files  
- <=16 MB for low-end profiles  

### 12.3 Latency
- 20–80 ms typical  
- deterministic events compensate this  


============================================================
13. PLATFORM BACKENDS
============================================================

### 13.1 Windows
- XAudio2 (primary)  
- DirectSound (Win2000/XP fallback)  
- WaveOut (Win9x fallback)  

### 13.2 Linux
- PulseAudio  
- ALSA fallback  
- OSS legacy fallback  

### 13.3 macOS
- CoreAudio  
- OpenAL Soft fallback  

### 13.4 DOS / Win3.x
- no 3D audio  
- simple PCM  
- PC speaker fallback  

### 13.5 WebAssembly
- WebAudio API  

### 13.6 Consoles (future)
- platform-native engines  
- deterministic event layer maintained  


============================================================
14. FILE SYSTEM STRUCTURE
============================================================

audio/
sfx/
music/
ambient/
vehicles/
machines/
weather/
ui/
routing.json
categories.json

routing.json maps categories → busses.  


============================================================
15. SUMMARY
============================================================

Volume 7.15 provides:
- deterministic audio event scheduling  
- nondeterministic audio rendering  
- multi-backend support  
- legacy-compatible mixers  
- modding hooks  
- deterministic music state transitions  
- environmental audio  
- vehicles & machine audio  
- accessibility features  

This completes the audio subsystem for Dominium.

# END OF VOLUME 7.15

Ready for VOLUME 7.16 — Input Devices, Advanced Controls, Keybinding Framework, Accessibility Input, Controller/Joystick/HOTAS/Wheel Support, Legacy Mode, Deterministic Input Events.
Say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.16 — INPUT DEVICES, ADVANCED CONTROLS, KEYBINDING FRAMEWORK, ACCESSIBILITY INPUT, CONTROLLER/HOTAS/WHEEL SUPPORT, LEGACY MODE, DETERMINISTIC INPUT EVENTS.
Single continuous MD block. No omissions.

# VOLUME 7.16 — INPUT SYSTEM  
Dominium Engine Specification — Engine Core, Part 16  
Deterministic Input Events, Multi-Device Support, Legacy Targets, Moddable Bindings

Defines:
- input determinism  
- device abstraction  
- event queue  
- keybinding framework  
- controller/HOTAS/wheel support  
- touch, stylus, pen  
- legacy fallbacks (DOS/Win3.x)  
- accessibility input  
- multiplayer input model  


============================================================
1. INPUT SYSTEM PRINCIPLES
============================================================

1. ALL gameplay-relevant input is deterministic once processed into the canonical command layer.
2. Raw hardware events are *not* deterministic, but the mapping from raw event → canonical command *is*.
3. Every supported device class must degrade to keyboard-only mode if unavailable.
4. Input system must run with:
   - Win2000+ APIs  
   - macOS 10.6+  
   - Linux (X11/Wayland/evdev)  
   - DOS/Win3.x legacy handlers  
   - WebAssembly  
   - future console/gamepad environments  

5. No device is allowed to directly mutate simulation. All input passes through:
RAW_DEVICE → INPUT_NORMALIZER → CANONICAL COMMAND QUEUE → SIM

6. For multiplayer:
   - clients send canonical inputs  
   - server validates deterministically  
   - server NEVER accepts raw device info  


============================================================
2. INPUT DEVICE CLASSES
============================================================

### 2.1 Keyboard
- all layouts supported  
- scancode → canonical keycode mapping  
- must tolerate missing keys on older systems  
- must support international IME in UI only  

### 2.2 Mouse / Trackball
- absolute and relative  
- multi-button  
- scroll wheel  
- smooth scroll  
- pointer acceleration disabled when deterministic  

### 2.3 Gamepads
Support required for:
- XInput  
- DirectInput  
- SDL GameController API  
- macOS HID  
- Linux evdev  
- Web Gamepad  

All standardized into:
BUTTON_A, BUTTON_B, BUTTON_X, BUTTON_Y
DPAD_UP/DOWN/LEFT/RIGHT
L1/R1
L2/R2 (analog)
L_STICK_X/Y
R_STICK_X/Y
START, BACK

### 2.4 HOTAS (Flight Sticks + Throttles)
Unified into:
axes[]
throttle[]
hat[]
trigger
buttons[]

### 2.5 Steering Wheels & Pedals
Unified into:
wheel_axis
pedal_accel
pedal_brake
pedal_clutch
buttons[]

### 2.6 Touch / Tablet / Pen
Touch events mapped to:
TOUCH_TAP
TOUCH_DRAG
TOUCH_PINCH
Pen events mapped to:
PEN_DOWN
PEN_UP
PEN_MOVE
PEN_PRESSURE

### 2.7 Accessibility Devices
Include:
- sip-and-puff  
- eye-tracking  
- speech-to-command  
- large-button panels  
- single-switch scanning  

All mapped to canonical command entries.

### 2.8 Legacy Input Sources
DOS/Win3.x:
- Int 16h  
- BIOS mouse  
- PS/2 keyboard  
- no high-DPI  
- fall back to keyboard-only if no mouse  


============================================================
3. RAW INPUT NORMALIZATION
============================================================

### 3.1 Raw Event
Fields:
timestamp_hw
device_id
event_type
value

Non-deterministic.

### 3.2 Normalized Event
Converted into:
INPUT_NORM {
t_engine, // unify timestamps
type, // button/axis/touch/etc
code,
value
}

Deterministic ordering rule:
- sorted by frame arrival  
- secondary sort by device priority  
- tertiary sort by hardware timestamp truncated to 1ms  


============================================================
4. CANONICAL COMMAND LAYER
============================================================

### 4.1 The Heart of Determinism
All normalized input events are converted to deterministic commands:
CMD_MOVE_FORWARD
CMD_MOVE_BACKWARD
CMD_ROTATE_LEFT
CMD_ROTATE_RIGHT
CMD_ZOOM_IN
CMD_ZOOM_OUT
CMD_BUILD
CMD_INTERACT
CMD_MENU_OPEN
CMD_MENU_CLOSE

Every device ultimately produces these.  
Simulation consumes ONLY these.

### 4.2 Command Format
COMMAND {
tick, // deterministic
command_id,
param0,
param1
}

### 4.3 Multiplayer Guarantee
Client → server sends:
(tick, command_id, params)
Never raw input.


============================================================
5. KEYBINDING SYSTEM
============================================================

### 5.1 Bindings Structure
bind("move_forward", KEY_W)
bind("move_backward", KEY_S)
bind("zoom", MOUSE_WHEEL)
bind("place", MOUSE_LEFT)
bind("menu", KEY_ESC)

### 5.2 Multi-layer
Three binding layers:
default_bindings.json
profile_bindings.json
mod_bindings.json

Merged deterministically.

### 5.3 Remapping Rules
- always reversible  
- failure-safe  
- must support binding same command to multiple devices  
- must support binding multiple commands to chord keys:
SHIFT + RMB = CMD_ALT_ACTION


============================================================
6. INPUT MODES
============================================================

### 6.1 Pointer Mode
Default for mouse/touch.

### 6.2 Focus Mode
Gamepad/keyboard navigation UI.

### 6.3 Command-Line Mode
TUI/headless.  
Commands entered as:
/move north
/build power_node


============================================================
7. CURSOR & FOCUS MODEL
============================================================

### 7.1 Cursor Types
- hardware cursor  
- software cursor  
- vector cursor  

### 7.2 Determinism
Cursor position NOT deterministic.  
Actions triggered by cursor ARE deterministic.

### 7.3 Accessibility Focus
Scanning cursor:
- moves deterministically at fixed speed  
- selects UI widgets via single-switch device  


============================================================
8. DEVICE HOTPLUG & RECONFIG
============================================================

### 8.1 Hotplug
Plug/unplug event processed deterministically:
DEVICE_ADD
DEVICE_REMOVE

### 8.2 Fallback
If device removed mid-action:
- command canceled deterministically  
- simulation state unchanged  


============================================================
9. ANALOG INPUT HANDLING
============================================================

### 9.1 Axis Deadzones
Configurable:
inner_deadzone
outer_deadzone
curvature

### 9.2 Axis Normalization
All axes normalized to:
[-1.0, 1.0]

### 9.3 Deterministic Thresholds
Axis → command uses fixed thresholds so state changes are deterministic.


============================================================
10. INPUT RATE LIMITING
============================================================

### 10.1 Device Polling Rate
Hardware may report at:
- 30 Hz  
- 60 Hz  
- 125 Hz  
- 250 Hz  
- 1000 Hz  

Simulation samples deterministically at controlled step.

### 10.2 Event Flood Protection
Repeated raw inputs collapsed into deterministic single command events per tick.


============================================================
11. INPUT RECORDING & REPLAY
============================================================

### 11.1 Record Format
tick, command_id, params

### 11.2 Guaranteed Validity
Replays identical across:
- Windows  
- macOS  
- Linux  
- future retro builds  
- headless servers  


============================================================
12. ACCESSIBILITY INPUT
============================================================

### 12.1 Subsystems
- speech-to-command  
- switch scanning  
- eye-gaze → command  
- keyboard-only mode  
- TUI mode  

### 12.2 Guaranteed Determinism
Speech → text → canonical command  
NOT speech → simulation.


============================================================
13. PLATFORM BACKENDS
============================================================

### 13.1 Windows
- RawInput  
- XInput  
- DirectInput  
- WinTab for pen  
- fallback WM_INPUT  

### 13.2 Linux
- evdev  
- SDL2 input backend  
- libinput when available  

### 13.3 macOS
- Cocoa HID  
- GameController.framework  

### 13.4 DOS/Win3.x
- BIOS interrupts  
- PS/2 direct  
- no multi-device support  

### 13.5 WebAssembly
- DOM events  
- Gamepad API  

### 13.6 Consoles (future)
- unified gamepad  


============================================================
14. SAFETY & FILTERING
============================================================

### 14.1 Disallowed Raw Events
- OS gestures  
- OS accelerators  
- IME composition events (ignored for sim)  

### 14.2 Anti-Cheat Layer (Optional)
- checks rate limits  
- checks impossible input frequency  
- checks invalid axis transitions  
All optional and user-configurable.


============================================================
15. SUMMARY
============================================================

Volume 7.16 defines Dominium's unified input layer:
- deterministic command layer  
- multi-device abstraction  
- keyboard/mouse/gamepad/HOTAS/wheel/touch/pen support  
- accessibility input stack  
- legacy platform support  
- modding-friendly keybindings  
- robust replay/record integration  
- hotplug and fault tolerance  

This completes the input subsystem.

# END OF VOLUME 7.16

Ready for VOLUME 7.17 — SAVE SYSTEM, SNAPSHOTS, WORLD SERIALIZATION, DETERMINISTIC ARCHIVE FORMAT, CROSS-PLATFORM COMPATIBILITY, BACKUP/ROLLBACK, AND MOD-SAFE SAVEGUARDS.
Say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.17 — SAVE SYSTEM, SNAPSHOTS, WORLD SERIALIZATION, DETERMINISTIC ARCHIVE FORMAT, CROSS-PLATFORM COMPATIBILITY, BACKUP/ROLLBACK, AND MOD-SAFE SAVEGUARDS.
Single continuous MD block. No omissions.

# VOLUME 7.17 — SAVE SYSTEM & SERIALIZATION  
Dominium Engine Specification — Engine Core, Part 17  
Deterministic Saves, Snapshots, Rollbacks, Mod Compatibility, Multi-Platform Safety

Defines:
- deterministic save pipeline  
- snapshot structure  
- world and universe serialization  
- cross-platform binary format rules  
- mod-safe load/upgrade/downgrade  
- autosaves & scheduled backups  
- rollback, rewind, and recovery  
- compression rules  
- file layout  
- legacy compatibility  


============================================================
1. PRINCIPLES
============================================================

1. Save files MUST be fully deterministic:
   - identical simulation state → identical save bytes  
   - cross-platform consistency (Win/macOS/Linux/etc)  

2. Saves MUST NOT store:
   - UI state  
   - hardware info  
   - OS-dependent paths  
   - random seeds (only deterministic seeds)  

3. Saves MUST store:
   - complete simulation state  
   - world terrain state  
   - entities, inventory, networks  
   - universe metadata  
   - mod manifest + version hashes  

4. Saves MUST be readable in:
   - headless servers  
   - retro clients (where features apply)  
   - future engine revisions via upgrade transforms  


============================================================
2. SAVE FORMATS
============================================================

### 2.1 Primary Format: `.domsave`
Binary, deterministic, chunked, little-endian, versioned.

### 2.2 Snapshot Format: `.domsnap`
Partial or full state, used for:
- rollback  
- multiplayer re-sync  
- replay checkpoints  

### 2.3 Text Debug Format: `.domtext`
Human-readable dump:
- used for debugging  
- never used for loading simulation  

### 2.4 Multiplayer Checksum Records
Each tick produces a deterministic hash:
tick, world_hash_64
Server and clients verify.


============================================================
3. CROSS-PLATFORM BINARY RULES
============================================================

### 3.1 Deterministic Binary Contract
All integers:  
- little-endian  
- fixed-width  
- no platform-dependent packing  

All floats:  
- IEEE 754 32-bit or 64-bit  
- no "long double"  
- no extended 80-bit x87 types  

### 3.2 Struct Layout
Forbidden:
- C compiler struct packing  
- implicit padding  

All save structs use:
explicit fixed-size fields
explicit padding bytes if needed
explicit version numbers

### 3.3 Pointer Prohibition
Pointers MUST NOT be serialized.  
Everything uses stable IDs:
entity_id
company_id
network_node_id
chunk_id

### 3.4 String Rules
- UTF-8 only  
- no BOM  
- max lengths fixed for deterministic packing  

### 3.5 Arrays
Dynamic arrays stored as:
count (32-bit)
[items...]

### 3.6 Maps
Stored as sorted arrays for determinism:
(sorted by key)


============================================================
4. SAVEFILE STRUCTURE
============================================================

domsave_header
universe_metadata
planet_list
system_list
property_list
chunk_metadata
chunk_data
entity_tables
network_data
economy_state
AI_state
research_state
weather_state
climate_state
power_grid_state
fluid_network_state
data_network_state
inventory_state
construction_state
transport_state
market_state
mod_manifest
checksum_table
footer

### 4.1 Header
MAGIC = "DOMS"
VERSION_MAJOR
VERSION_MINOR
BUILD_ID
UNIVERSE_SEED
SIM_TICK
CRC64

### 4.2 Footer
CRC64_ALL
LENGTH_BYTES

### 4.3 Chunk Serialization
Chunks serialized in deterministic order:
superchunk_yxz, chunk_yxz, subchunk_yxz

Chunks include:
- terrain  
- structures  
- wires  
- pipes  
- rails/roads  
- flow fields  
- temperature/pressure  
- workers & vehicles if present  

### 4.4 Entity Tables
Separated for:
- workers  
- robots  
- machines  
- vehicles  
- animals  
- resources  
- items  
- fluids  

Each table deterministically ordered:
entity_id ascending

### 4.5 Network Serialization
Each network stores:
- nodes sorted by node_id  
- edges sorted by (src,dst)  
- capacity, load, pressure, voltage, temperature  
- routing tables  
- cached sim values (deterministic)  


============================================================
5. SNAPSHOTS & ROLLBACK
============================================================

### 5.1 Full Snapshots
Serialized identical to full saves except:
- no mod manifest  
- no universe metadata  

### 5.2 Partial Snapshots
May contain:
- chunk subset  
- entity subset  
- targeted rollback region  
Used for:
- multiplayer re-sync  
- debug  
- editor  

### 5.3 Rolling Snapshots (History Buffer)
Configurable:
N seconds
N minutes
N ticks

Stores:
- rolling snapshots every X ticks  
- diffs between snapshots  

### 5.4 Rollback Rules
Rollback restores:
- simulation state  
- not UI state  
- not audio state  
- not OS state  


============================================================
6. BACKUP SYSTEM
============================================================

### 6.1 Autosaves
Cyclic:
autosave_000.domsave
autosave_001.domsave
...

### 6.2 Named Backups
User-triggered:
backup_[timestamp].domsave

### 6.3 Crash Recovery
On fatal error, engine writes:
crashsave.domsave
diagnostics.log

### 6.4 Cloud Sync (Optional)
Supports:
- Steam Cloud  
- GOG Cloud  
- custom HTTP sync  
Never required.


============================================================
7. MOD-SAFE SAVEGUARDS
============================================================

### 7.1 Mod Manifest Stored in Save
mod_id
mod_version
mod_hash
mod_load_order

### 7.2 Load Conditions
On load:
- engine compares mod set  
- if mismatch → compatibility resolution required  

### 7.3 Compatibility Options
1. **Strict Mode**  
Load fails if mods differ.

2. **Safe Mode**  
Mods not found replaced with dummy entities/recipes/graphics.

3. **Permissive Mode**  
Loads even if mods missing; broken entities replaced with “placeholder blocks”.

### 7.4 Deterministic Overrides
Mods may NOT:
- write raw bytes to save  
- store arbitrary dynamic data  
- embed executable code  
- mutate save version numbers  

Mods MAY:
- store structured tables via the mod data field  
- with strict limits on size, type, determinism  


============================================================
8. SAVE UPGRADES & DOWNGRADES
============================================================

### 8.1 Upgrade Pipeline
If save version < engine version:
upgrade_v1_to_v2()
upgrade_v2_to_v3()
...
upgrade_to_current()

### 8.2 Downgrade
Supported only if:
- data not removed  
- changes reversible  
Else:
- downgrade not possible  
- engine writes diagnostic file explaining blocked downgrade  

### 8.3 Legacy Compatibility Modes
For retro platforms:
- smaller chunk sizes  
- fewer entities allowed  
- stripped universe metadata  
- compressed terrain  


============================================================
9. SAVEFILE COMPRESSION
============================================================

### 9.1 Supported Codecs
- zstd (default)  
- LZ4 (fast)  
- gzip (compatibility)  
- no compression (debug mode)  

### 9.2 Determinism
Compression is NOT deterministic but irrelevant.  
The decompressed state IS deterministic.

### 9.3 Chunked Compression
Each large region compressed separately for partial load:
terrain/
entities/
networks/
economy/

============================================================
10. SAVEFILE INTEGRITY & CHECKSUMS
============================================================

### 10.1 Per-Section CRC64
Each block:
block_crc64
block_length

### 10.2 Full File CRC64
Verified at load.

### 10.3 Multiplayer
Server records:
tick → world_state_crc
Used for detecting desyncs.

============================================================
11. FILE I/O MODEL
============================================================

### 11.1 Atomic Saves
Steps:
1. write save.temp  
2. fsync  
3. rename to save.domsave  

### 11.2 Platform Safety
- Windows: use MoveFileEx atomic rename  
- Unix: atomic rename()  
- macOS: NSFileManager safe write  

### 11.3 Legacy
DOS/Win3.x:
- no atomic ops  
- use double-buffering with `.bak` files  

### 11.4 Memory Footprint
Must support:
- low-end machines with <512 MB RAM  
- save in steam ≤ 128 MB  
- incremental writes available  

============================================================
12. REPLAY INTEGRATION
============================================================

### 12.1 Savefiles contain:
- deterministic seed  
- tick timestamp  
- mod manifest  
- replay header (optional)

### 12.2 Replays Can Restore:
1. full state → load snapshot  
2. input stream → deterministic recalc  
3. hybrid → snapshot + replay tail  


============================================================
13. FILESYSTEM LAYOUT
============================================================

saves/
world1/
world1.domsave
autosave_.domsave
backup_.domsave
snaps/
snap_.domsnap
replays/
replay_.domrep

Each world has its own namespace.  


============================================================
14. EDITOR & DEVKIT SUPPORT
============================================================

### 14.1 Editor
Must read & write:
- full saves  
- partial saves  
- universe files  

### 14.2 DevKit
Tools:
- save inspector  
- diff visualizer  
- corruption checker  
- mod compatibility tester  


============================================================
15. SUMMARY
============================================================

Volume 7.17 defines Dominium’s entire save architecture:
- deterministic binary format  
- complete universe serialization  
- chunked world state  
- reliable rollback & snapshot systems  
- mod-safe manifests and upgrade logic  
- cross-platform consistency  
- atomic save guarantees  
- legacy fallbacks for DOS/Win3.x  
- integration with replay and multiplayer checksum systems  

This completes the save system specification.

# END OF VOLUME 7.17

Ready for VOLUME 7.18 — NETWORKING: DETERMINISTIC LOCKSTEP, CLIENT/SERVER MODEL, REPLAY-AIDED SYNC, PREDICTION RULES, BANDWIDTH LIMITATIONS, LATENCY TOLERANCE, AND SECURITY.
Say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# VOLUME 7.18 — NETWORKING SYSTEM  
Dominium Engine Specification — Engine Core, Part 18  
Deterministic Lockstep, Client/Server, Latency Tolerance, Security

Defines:
- networking architecture  
- deterministic tick lockstep  
- client/server authority rules  
- replay-aided re-sync  
- packet formats  
- bandwidth caps  
- rollback model  
- cheat resistance  
- offline/online universe separation  
- NAT traversal and legacy compatibility  


============================================================
1. NETWORKING PRINCIPLES
============================================================

1. Simulation is deterministic.  
2. Server is authoritative for:
   - tick pace  
   - command validity  
   - mod manifest  
   - universe state  

3. Clients send only commands.  
4. Server sends:
   - authoritative tick number  
   - authoritative snapshot hashes  
   - state deltas only when required  

5. No floating-point nondeterminism permitted in simulation.  
6. Networking must support:
   - LAN  
   - WAN  
   - high latency  
   - packet loss  
   - disconnections and resync  
   - cross-platform (Win2000+, macOS 10.6+, Linux)  
   - low-end systems  

7. Offline universes never require a server.  
8. Online universes always require a server, headless or GUI.  


============================================================
2. ARCHITECTURE OVERVIEW
============================================================

### 2.1 Roles
- **Server**: authoritative simulation  
- **Client**: rendering + input  
- **Headless client**: simulation slave for tests  
- **Observer**: passive viewer  

### 2.2 Communication Model
Client Input → Server Command Buffer
Server Tick → Clients State Hash
Optional Server Snapshot → Client Repair

### 2.3 Deterministic Lockstep
All clients simulate tick N using:
- commands for tick N from server  
- same mod manifest  
- same universe seed  

All clients must finish simulation for tick N before receiving N+1.  


============================================================
3. TICK AND SYNC MODEL
============================================================

### 3.1 Base Frequency
Canonical UPS selectable:
1, 2, 5, 10, 20, 30, 45, 60, 90, 120, 180, 240.

Servers dictate UPS.  
Clients interpolate rendering.

### 3.2 Tick Flow
For each tick T:
1. server reads all client commands for T  
2. server validates commands  
3. server runs tick T  
4. server sends:
   - tick number  
   - 64-bit world hash  
   - optional delta  

Clients simulate the same tick.  
Mismatch → resync.

### 3.3 Latency Tolerance
Clients may run slightly ahead in render time but must not run sim ahead.

Approach:
- render interpolation/extrapolation  
- simulation waits for commands  
- client can delay visually up to 200–400 ms  

### 3.4 Desync Detection
Each tick:
- server sends authoritative world_hash  
- client compares  
Mismatch triggers:
- auto snapshot request  
- or rollback to last good tick  


============================================================
4. COMMAND STREAM
============================================================

### 4.1 Format
CMD_PACKET {
player_id
tick
command_count
commands[]
}

### 4.2 Compression
RLE + delta coding.  
Commands are small (<16 bytes).  

### 4.3 Validation
Server rejects:
- impossible movement  
- illegal build actions  
- invalid network edits  
- timestamp drift  

Rejected commands replaced with noop.  


============================================================
5. BANDWIDTH REQUIREMENTS
============================================================

### 5.1 Client → Server
Commands only:
- typical: 100–200 bytes/sec  
- worst case: <2 KB/sec  

### 5.2 Server → Client
- tick hashes: 8 bytes per tick  
- delta states: optional  
- snapshots: large but rare  

### 5.3 Multicast Efficiency
Server sends one packet per client.  
Aggregated per-tick network: negligible.  


============================================================
6. SNAPSHOTS, ROLLBACK, AND REPAIR
============================================================

### 6.1 Snapshots
Stored by server every N ticks.  
Clients can request:
REQUEST_SNAPSHOT(tick)

### 6.2 Rollback
On hash mismatch:
1. client rolls back to nearest snapshot  
2. replays authoritative commands  
3. continues simulation  

### 6.3 Partial Resync
Chunks may be resynced individually if only a region desyncs:
RESYNC_CHUNK(x,y,z, tick)


============================================================
7. PACKET FORMATS
============================================================

### 7.1 Packet Types
HELLO
WELCOME
CMD
TICK
DELTA
SNAPSHOT
PING
PONG
DESYNC
KICK
ERROR

### 7.2 Binary Layout
Little-endian, fixed fields, versioned.  
No variable-length unbounded fields.  

### 7.3 Encryption (optional)
- AES-CTR  
- NaCl crypto_box  

Not required for LAN.  


============================================================
8. CONNECTION MANAGEMENT
============================================================

### 8.1 NAT Traversal
Supported via:
- UDP hole punching  
- fallback TCP  
- direct IP  
- relay server optional  

### 8.2 Rejoin Support
Players may rejoin:
- same tick  
- same company  
- same property  

### 8.3 Spectators
Spectators receive deltas only.  
Simulation not run client-side unless desired.  


============================================================
9. LATENCY AND JITTER HANDLING
============================================================

### 9.1 Acceptable Latency
Playable up to 250–350 ms.  
Above 350 ms:
- input feels delayed  
- simulation remains deterministic  

### 9.2 Jitter Smoothing
Clients maintain:
- input queue  
- receive buffer  
- smoothing window (~100 ms)  

### 9.3 Packet Loss Recovery
- resend requests  
- redundancy flags  
- periodic full state hash  


============================================================
10. SECURITY & ANTI-CHEAT
============================================================

### 10.1 Deterministic Authority
Server recalculates entire simulation.  
Client cannot inject state.

### 10.2 Forbidden Client Behavior
- modifying command tick  
- modifying simulation  
- injecting entities  
- altering mod manifest  
- sending predicted future commands  

### 10.3 Anti-Cheat (Optional)
- invalid timing detection  
- input frequency checks  
- entropy analysis  
- mod signature verification  

All optional and overrideable.

### 10.4 Offline/Single Player
No restrictions.  
Mods unlimited.  


============================================================
11. MOD COMPATIBILITY RULES
============================================================

### 11.1 Server-Enforced
Client mods must match server mod set:
- version  
- hash  
- load order  

### 11.2 Safe Mod Data Channels
Mods may send:
- UI messages  
- client-only visuals  

Mods may NOT send:
- simulation commands  
- raw data structures  

### 11.3 Desync Protection
Mod deterministic functions must execute identically on all platforms.  


============================================================
12. LARGE UNIVERSE NETWORKING
============================================================

### 12.1 Property-Level Instancing
Only one property simulates per server instance.  
Multiple properties served by:
- multi-instance cluster  
- or single simulation with time slicing  

### 12.2 Inter-Property Trade
Implemented via:
TRADE_PACKET {
property_a
property_b
resources
contracts
}
Not heavy simulation; lightweight messages only.

### 12.3 Future Multi-Server Universes
Transition to:
- sector servers  
- universe routing  
- area authority zones  


============================================================
13. LEGACY PLATFORM SUPPORT
============================================================

### 13.1 Windows 2000 / XP
- Winsock2  
- UDP/TCP  
- no IPv6 requirement  

### 13.2 macOS 10.6+
- POSIX sockets  

### 13.3 Linux
- POSIX sockets  
- epoll optional  

### 13.4 DOS / Win3.x
- IPX optional  
- serial link mode  
- null modem cable support  
- LAN play via packet driver  

### 13.5 WebAssembly
- WebRTC  
- WebSockets  


============================================================
14. FILESYSTEM STRUCTURE
============================================================

network/
config.json
logs/
net_.log
snapshots/
snap_.domsnap
desync/
tick_*.txt

config.json:
{
"port": 27015,
"max_players": 64,
"compression": true,
"encryption": false
}


============================================================
15. SUMMARY
============================================================

Volume 7.18 defines the networking layer:
- deterministic lockstep simulation  
- client/server authority  
- replay-supported resync  
- partial chunk rollback  
- low bandwidth usage  
- robust latency tolerance  
- mod compatibility enforcement  
- optional anti-cheat and encryption  
- legacy networking support including DOS  
- future scalability for multi-server universes  

This completes the networking specification.

# END OF VOLUME 7.18
If you want the next section—VOLUME 7.19 — MULTIPLAYER ARCHITECTURE, SESSIONS, LOBBIES, MATCHMAKING, HOST MIGRATION, AND SOCIAL SYSTEMS—say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.19 — MULTIPLAYER ARCHITECTURE, SESSIONS, LOBBIES, MATCHMAKING, HOST MIGRATION, SOCIAL SYSTEMS, AND PLAYER MANAGEMENT.
As requested: single continuous MD block, no omissions, no softening, no filler.

# VOLUME 7.19 — MULTIPLAYER ARCHITECTURE  
Dominium Engine Specification — Engine Core, Part 19  
Sessions, Lobbies, Matchmaking, Host Migration, Social Systems, Player Permissions

Defines:
- multiplayer session model  
- lobby creation and joining  
- universe ownership rules  
- permissions, roles, groups  
- matchmaking (Internet, LAN, Direct IP)  
- host migration  
- friend/block lists  
- chat and communication systems  
- persistence of multiplayer accounts  
- integration with networking layer (7.18)  
- cross-platform constraints  
- offline/online separation  


============================================================
1. MULTIPLAYER PHILOSOPHY
============================================================

1. Server is authoritative.  
2. Universe ownership belongs to the server operator.  
3. Clients join universes; they do not “bring” universes to servers.  
4. Offline and online universes NEVER automatically merge.  
5. All multiplayer content must remain deterministic.  
6. Social systems do NOT influence simulation determinism.  
7. All multiplayer features must work with:
   - Windows 2000+  
   - macOS 10.6+  
   - Linux  
   - legacy modes where possible  


============================================================
2. SESSION MODEL
============================================================

### 2.1 Sessions Types
Offline Session (single player)
Local LAN Session (no NAT; zero-config)
Online Dedicated (external IP or cloud)
Peer-Hosted Session (client becomes server)
Cluster Session (future multi-server universe)

### 2.2 Session States
UNINITIALIZED
LOBBY
LOADING
RUNNING
PAUSED
ENDING

### 2.3 Session Ownership
The server owns:
- universe  
- mod set  
- tick pacing  
- property availability  
- company registry  

Clients own:
- their player profile  
- input stream  
- cosmetic settings  
- UI state  


============================================================
3. LOBBY SYSTEM
============================================================

### 3.1 Lobby Functions
- browse servers  
- host new server  
- join via IP  
- LAN auto-discovery  
- select player slot/company  
- upload/download mods (optional)  
- configure permissions  

### 3.2 Lobby Determinism
Lobby is non-sim.  
Lobby operations cannot modify simulation.

### 3.3 Lobby Permissions
Server owner (HOST) can:
- assign admin rights  
- lock/unlock slots  
- set max players  
- configure UPS/FPS  
- set mod policy  
- set map/universe access  
- kick/ban players  

### 3.4 Lobby Chat
Plain text.  
Optional encrypted channel.  
Never stored in saves.  


============================================================
4. MATCHMAKING
============================================================

### 4.1 Discovery Methods
1. **Direct IP**  
2. **LAN broadcast** (UDP broadcast)
3. **Master Server** (optional component)
4. **Matchmaking Server** (optional)

### 4.2 Master Server
Simple list:
- server name  
- description  
- player count  
- password flag  
- version  
- ping  

Master server stores no simulation data.

### 4.3 Steam/GOG/Epic Integration
Optional integrations:
- Steamworks lobby  
- friends list syncing  
- join via invite  
- cloud identity  

Completely optional.  
Game must function fully without any store integration.

### 4.4 Offline Mode
No matchmaking.  
LAN direct or loopback only.  


============================================================
5. PLAYER IDENTITIES
============================================================

### 5.1 Identity Structure
player_uid (128-bit)
display_name
cosmetics
profile_flags

### 5.2 Identity Persistence
Stored locally:
user/profile/player.json
Not tied to remote accounts or DRM.

### 5.3 Guest Mode
Possible to join a server anonymously.  
Host may restrict guest access.

### 5.4 Server-Side Identity Tracking
Server assigns:
- player_id (simulation ID)  
- company_id  
- permissions  


============================================================
6. PERMISSIONS AND ROLES
============================================================

### 6.1 Roles
OWNER
ADMIN
MODERATOR
PLAYER
GUEST
OBSERVER
BANNED

### 6.2 Permissions Matrix
Critical actions restricted to OWNER/ADMIN:
- pause/unpause  
- rollback  
- modify UPS  
- mod management  
- company assignment  
- property claiming overrides  

Moderators:
- kick  
- mute  
- manage chat  

Players:
- control their company  
- interact with property elements  

Guests:
- optional read-only or interact-limited mode  


============================================================
7. MULTIPLAYER ECONOMY & INTERACTION
============================================================

### 7.1 Property Ownership
Each company owns one or more properties.  
Players may:
- join same company (co-op)  
- found new companies (competitive)  
- buy/sell properties  
- merge companies  
- create federations  

All actions deterministic and server-validated.

### 7.2 Market Interactions
Trading includes:
- commodities  
- goods  
- electricity  
- data bandwidth  
- water and gas  
- transport rights  

Server validates all transactions.  

### 7.3 Diplomatic Interactions
Extensible, not simulated in base game:
- alliances  
- trade treaties  
- joint ventures  
- resource-sharing agreements  


============================================================
8. MULTIPLAYER CHAT & COMMUNICATION
============================================================

### 8.1 Chat Channels
GLOBAL
TEAM / COMPANY
PRIVATE
ADMIN
ANNOUNCEMENT

### 8.2 Voice Chat
Optional.  
Provided only if platform supports it.  
Voice is NOT deterministic and not synced to replays.

### 8.3 Radio & Telephony Simulation
Tied to Volumes 2.x/3.x networks:
- radio nodes  
- telephone exchanges  
- data transport nodes  

Voice/text routed through in-game networks if desired.
Optional gameplay feature.

### 8.4 Muting/Blocking
Stored client-side:
user/profile/blocked.json


============================================================
9. HOST MIGRATION
============================================================

### 9.1 Allowed ONLY for Peer-Hosted Sessions
Dedicated servers cannot migrate.  
Peer host migration workflow:

### 9.2 Migration Conditions
Migration allowed if:
- current host disconnects  
- another player meets hardware/minimum UPS rules  
- mods identical  
- save integrity validated  

### 9.3 Migration Sequence
1. server sends `MIGRATE_INIT`  
2. eligible clients compute UPS benchmark  
3. best candidate selected  
4. new host loads last snapshot  
5. new host receives command stream backlog  
6. clients reconnect automatically  

Full handover must complete within <10 seconds.

### 9.4 Failure Modes
If migration fails:
- session ends  
- save preserved  
- restart required  


============================================================
10. DISCONNECTION, REJOIN, AND TIMEOUTS
============================================================

### 10.1 Grace Period
If a client disconnects:
- server holds their slot for N seconds  
- simulation continues  
- player’s workers/robots continue tasks automatically  

### 10.2 Rejoin Workflow
Client sends:
REJOIN_REQUEST(universe_id, player_uid)
Server validates:
- player_uid  
- mod hash  
- company ownership  
- last tick seen  

Client receives snapshot + command backlog.

### 10.3 Timeouts
Default:
PING every 5 seconds
TIMEOUT after 30 seconds

### 10.4 Forced Disconnects
Admin can:
- kick  
- ban  
- mute  


============================================================
11. MULTIPLAYER SAVEFILES
============================================================

### 11.1 Server Saves Only
Clients never save authoritative world state.

### 11.2 Client Cache
Clients may optionally cache:
- last snapshot  
- replays  
- command logs  
- chat logs  

### 11.3 Server-side Autosaves
Server performs periodic autosaves only when consistent:
- end of tick  
- no desync  
- no rollback in progress  


============================================================
12. SOCIAL SYSTEMS
============================================================

### 12.1 Friends List
Stored locally.  
Optional sync with Steam/GOG/Epic if desired.

### 12.2 Block List
Client-side block list prevents:
- chat  
- pings  
- invites  
Does NOT prevent gameplay interactions.

### 12.3 Presence
Optional:
- show online/offline  
- show “in game”  
- show server name  

### 12.4 Cross-Server Identity
Players maintain consistent identity across all servers.  
Server may display profile badges or stats.

### 12.5 Achievements
Optional integration:
- offline achievements  
- online achievements synced  
- must NOT require external service  
- must NOT break determinism  


============================================================
13. MULTIPLAYER UI
============================================================

### 13.1 Lobby UI
- player list  
- mod list  
- ping and latency  
- UPS testing  
- join/leave buttons  
- property/company selector  

### 13.2 In-Game UI
- player panel  
- company finance panel  
- diplomacy/trade menus  
- chat panel  
- admin panel (role-based)  

### 13.3 Spectator UI
- camera free mode  
- property viewer  
- overlays  
Not allowed to send commands.

============================================================
14. LEGACY SUPPORT
============================================================

### 14.1 Win2000/XP
- full multiplayer  
- no Steam integration  
- DNS fallback  

### 14.2 macOS 10.6
- full multiplayer  
- no modern keychain features  

### 14.3 Linux
- all features via SDL2 + POSIX  

### 14.4 DOS/Win3.x
Limited:
- IPX  
- serial link  
- local 2-player  
- stripped UI  

Not compatible with full universe multiplayer.  


============================================================
15. SUMMARY
============================================================

Volume 7.19 defines Dominium’s multiplayer architecture:
- deterministic client/server model  
- lobbies, matchmaking, LAN discovery  
- universe, property, company management  
- player identities and permissions  
- chat, voice, social systems  
- host migration for peer-hosted games  
- robust disconnection/rejoin model  
- extensive legacy support  
- deterministic simulation unaffected by UI/network noise  

This completes the Dominium multiplayer system specification.

# END OF VOLUME 7.19
If you want the next section—VOLUME 7.20 — UI/ENGINE LOCALIZATION, LANGUAGE SYSTEM, CULTURAL FORMATS, PLANETARY CALENDARS, AND MULTI-MODE CLOCK/DATE REFERENCE FRAMEWORK—say “Proceed.”
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.20 — LOCALIZATION, LANGUAGE SYSTEM, CULTURAL FORMATS, PLANETARY CALENDARS, AND MULTI-MODE DATE/TIME FRAMEWORK.
Single continuous MD block. No omissions. No filler.

# VOLUME 7.20 — LOCALIZATION & TEMPORAL FRAMEWORK  
Dominium Engine Specification — Engine Core, Part 20  
Localization, Language Packs, Cultural Formatting, Planetary Calendars, Multi-Mode Timekeeping

Defines:
- internationalization (i18n)  
- localization (l10n)  
- language packs  
- runtime text resolution  
- culture-specific formatting  
- numeric and unit formats  
- UI directionality  
- planetary and orbital calendar systems  
- simulation time clocks  
- deterministic time progression  
- backwards compatibility rules  


============================================================
1. PRINCIPLES
============================================================

1. All localization must be 100% deterministic when used in simulation-relevant contexts (e.g., timestamps in replays/saves).  
2. All UI text is language-dependent and non-deterministic (visual-only).  
3. All calendar and clock systems must be able to operate:
   - Earth calendar (Gregorian)  
   - custom planetary calendars  
   - orbital calendars (space stations)  
   - custom mod-defined calendars  

4. No localization may modify simulation logic.  
5. All languages and formats must be loadable from mods.  
6. Base game ships with English only.  
7. Additional languages available via free language packs.  


============================================================
2. LANGUAGE PACK SYSTEM
============================================================

### 2.1 Format
Each language pack is a mod:
mods/lang/en/
mods/lang/de/
mods/lang/fr/
mods/lang/zh/
mods/lang/ja/
...

### 2.2 Required Files
lang.json
strings.json
units.json
formatting.json
fonts/

### 2.3 lang.json
{
"language_code": "en",
"direction": "ltr",
"pluralization": "english",
"fallback": "en"
}

### 2.4 strings.json
Key/value pairs:
"menu.play": "Play"
"menu.quit": "Quit"
"unit.power.mw": "MW"

### 2.5 fonts/
Vector or raster fonts:
- .ttf  
- .otf  
- bitmap fonts (legacy/DOS modes)  

### 2.6 Hot Reload
Language packs may be changed mid-session.  
UI must rebuild with no simulation impact.  


============================================================
3. STRING RESOLUTION
============================================================

### 3.1 Key Lookup
LOCALIZE("menu.play")
Search order:
1. active language  
2. fallback language  
3. English  
4. missing-key placeholder  

### 3.2 Plurals
Plural forms stored in language pack:
"worker.count": {
"one": "%d worker",
"other": "%d workers"
}

### 3.3 Parameterized Strings
Safe deterministic formatting:
"power.output": "%0.2f kW"

### 3.4 No String Concatenation in Core UI
All strings must be template-driven.  


============================================================
4. CULTURAL FORMATTING
============================================================

### 4.1 Numbers
Customization fields:
- decimal separator  
- thousands separator  
- digit grouping  
- negative sign position  

### 4.2 Dates (Earth)
DD/MM/YYYY
MM/DD/YYYY
YYYY-MM-DD

### 4.3 Currency
Used only in UI.  
Simulation uses pure numeric values.  
Formatting includes:
- symbol  
- position  
- space vs. none  
- group separator  

### 4.4 Measurement Systems
UI only:
- metric  
- imperial  
- custom  

Simulation uses SI units internally.  


============================================================
5. TEXT-ORIENTATION, RTL, AND FONTS
============================================================

### 5.1 Text Direction
Language packs specify:
"direction": "ltr" or "rtl"

RTL languages:
- Arabic  
- Hebrew  
- Persian  

### 5.2 Font Loading
Fallback sequence:
1. language pack font  
2. engine universal font  
3. bitmap fallback  
4. last-resort: CP437 (DOS legacy UI)

### 5.3 Glyph Cache
2D raster UI:
- glyph atlas  
- vector fallback  

3D HUD:
- glyph quads  
- no kerning guaranteed on legacy modes  


============================================================
6. MULTI-MODE CLOCK SYSTEM
============================================================

### 6.1 Simulation Time Must Be Deterministic
Clock increments:
delta_time = 1 tick × (1 / UPS)

### 6.2 Three Clock Domains
1. **SIM CLOCK** — tick-based; authoritative  
2. **GAME CLOCK** — player-facing hours/days/etc  
3. **REAL CLOCK** — wall clock unrelated to simulation  

### 6.3 Game Clock Configuration
From earlier decisions:
- 1 tick = 1 game second  
- 60 ticks = 1 game minute (60 UPS canonical)  
- game day = configurable  
- game year = configurable  

All stored in universe metadata.  

### 6.4 Time Warp
Time warp allowed offline:
- simulation speed multiplier  
- game clock scales  
- sim clock stays deterministic  


============================================================
7. PLANETARY & ORBITAL CALENDARS
============================================================

### 7.1 Supported Calendar Types
1. **Gregorian (Earth)**  
2. **Planetary** (custom day length, year length)  
3. **Lunar calendars** (moons with orbital cycles)  
4. **Orbital station time** (constant rotation period)  

### 7.2 Planetary Definitions
Each celestial body defines:
seconds_per_day
days_per_year
months_per_year
day_night_cycle
obliquity
season_strength

### 7.3 Calendar Variables
Stored deterministically in save:
planet_time {
year
month
week
day
hour
minute
second
}

### 7.4 Universal Time
Each universe has:
- Universe Time (UT) base  
- individual planets may drift  
- UT used for cross-property scheduling  


============================================================
8. DATE/TIME FORMATTING RULES
============================================================

### 8.1 Formatting Tokens
%Y year
%M month
%D day
%h hour
%m minute
%s second
%W week
%w weekday
%p period (AM/PM)
%P period lowercase

### 8.2 Planetary Extensions
%Oy orbital year
%Od orbital day
%E season

### 8.3 Localization
Each language pack defines:
- month names  
- weekday names  
- seasonal names  

### 8.4 Mod Extensions
Mods may:
- define new calendars  
- override month/day names  
- define equal or irregular months  
- define “cycles” for alien planets (supports DLC)  


============================================================
9. TIME ZONES
============================================================

### 9.1 Simulation Time Zones
Each planet defines:
- planetary longitude system  
- local solar time  
- offset to UT  

### 9.2 Property Time Zones
Properties use:
- local solar time by default  
- optional UT  
- optional “company standard time”  

UI allows switching time zones per view.

### 9.3 Determinism
Time zone does NOT affect simulation.  
Only UI presentation.  


============================================================
10. LOCALIZATION OF UNITS AND MEASUREMENTS
============================================================

### 10.1 Unit Systems
UI shows:
- metric  
- imperial  
- custom mod units  

Simulation always uses SI.

### 10.2 Localized Units
Language pack defines:
"distance.m": "m"
"distance.km": "km"
"power.kw": "kW"
"pressure.pa": "Pa"

### 10.3 Multi-Planet Conversions
Planets may define:
- gravity multipliers  
- ambient pressure  
- default atmospheric composition  

These modify:
- thrust requirements  
- fluid flow rates  
- thermal convection  
UI displays units automatically converted.  


============================================================
11. LOCALIZATION IN MULTIPLAYER
============================================================

### 11.1 Independent Language Choice
Each client picks any language.  
Server uses English internally.

### 11.2 Synchronization
Only UI text changes; simulation unaffected.

### 11.3 Chat Translation
Not automatic.  
Mods may implement translation services but must not affect determinism.

### 11.4 Calendar Sync
Server sends:
- UT tick  
- planet metadata  

Clients format calendar locally.  


============================================================
12. LOCALIZATION & MODS
============================================================

### 12.1 Mod-Provided Languages
Mods may add:
mods/pack/lang/xx/
No limit on number of languages.

### 12.2 Mod-Dependent Strings
Mods define:
mod_id.key

### 12.3 Mod Compatibility
If a mod is missing translations:
- fallback language used  
- engine must NOT crash  


============================================================
13. LEGACY PLATFORM SUPPORT
============================================================

### 13.1 DOS / Win3.x
- ASCII only  
- CP437 bitmap fonts  
- no Unicode  
- fallback to English, simplified UI  

### 13.2 Win95/98/ME
- partial Unicode  
- vector font fallback  

### 13.3 Windows 2000+
- full Unicode  

### 13.4 macOS 10.6+
- full Unicode via ATSUIS/CoreText  

### 13.5 Linux
- full UTF-8  


============================================================
14. PERFORMANCE REQUIREMENTS
============================================================

### 14.1 Localization Costs
- string lookup O(1)  
- formatting O(n) where n is output length  
- caching allowed for static strings  

### 14.2 Time Calculation Costs
Planetary calendars update:
- once per tick for local property  
- once per day/week/month for global maps  

Negligible overhead.  


============================================================
15. SUMMARY
============================================================

Volume 7.20 defines Dominium’s localization and temporal systems:
- full language pack support  
- deterministic calendar/time simulation  
- Earth and planetary calendars  
- multiple clock domains  
- cultural formatting  
- unit localization  
- robust fallback layers  
- legacy platform support  
- mod support for languages and calendars  

This completes the localization & temporal framework.

# END OF VOLUME 7.20

Ready for VOLUME 7.21 — CONFIGURATION SYSTEM: USER PROFILES, GRAPHICS/SOUND/INPUT SETTINGS, PLATFORM OVERRIDES, AUTO-DETECTION, SAFE-MODE, AND DETERMINISTIC ENGINE BOOTSTRAP.
Say “Proceed.”
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.21 exactly as requested.
Single continuous MD block. No filler.

# VOLUME 7.21 — CONFIGURATION SYSTEM  
Dominium Engine Specification — Engine Core, Part 21  
User Profiles, Settings Architecture, Platform Overrides, Auto-Detection, Safe-Mode, and Deterministic Bootstrap

Defines:
- how Dominium stores and loads all settings  
- profile priority rules  
- platform defaults and overrides  
- graphics, sound, input, networking, simulation, mod-loading options  
- launcher integration  
- hardware detection  
- safe-mode  
- determinism constraints  
- multi-binary consistency  
- packaging for legacy OSes  


============================================================
1. DESIGN PRINCIPLES
============================================================

1. **Deterministic simulation requires that no settings affecting logic may be user-configurable.**  
2. **All non-deterministic settings must be local only and never transmitted across network.**  
3. **Every setting must be versioned and upgradeable across releases.**  
4. **Profiles must support multiple configs per user and per-machine.**  
5. **Launcher must be able to launch the engine in any of: native, SDL1, SDL2, GL1/2, DX9, DX11, headless.**  
6. **Legacy platforms use simplified config formats but must maintain compatibility.**  
7. **Failsafe fallback exists for every subsystem (graphics, audio, input).**  


============================================================
2. CONFIGURATION FILE STRUCTURE
============================================================

Base directory (modern OS):
Documents/Dominium/
profiles/
settings/
mods/
cache/
saves/

Legacy OS:
C:\DOMINIUM\CFG\ (DOS / Win3.x / Win9x)

### 2.1 Settings Files
settings/
core.cfg
gfx.cfg
audio.cfg
input.cfg
ui.cfg
net.cfg
mods.cfg
render_select.cfg
platform_override.cfg

### 2.2 File Format
- `.cfg` = deterministic key-value pairs  
- No JSON/XML overhead  
- `.bin` variant allowed for consoles  
- DOS variant = INI-like  

Example:
fullscreen = false
max_fps = 60
ups_cap = 60
render_backend = "dx9"

Mandatory:
- strict ordering  
- stable hashing  
- comments stripped before hash  
- stored in UTF-8 unless legacy  


============================================================
3. CONFIGURATION PRIORITY LAYERS
============================================================

Priority (highest to lowest):
1. **Runtime CLI/launcher overrides**  
2. **Profile overrides**  
3. **User global settings**  
4. **Platform-specific defaults**  
5. **Engine defaults**  
6. **Failsafe minimal baseline**  

Nothing outside layer 1 may alter simulation behavior.

Simulation-affecting fields are *not* configurable.


============================================================
4. USER PROFILE SYSTEM
============================================================

### 4.1 Profile Structure
profiles/
default/
profile.cfg
user1/
user2/

### 4.2 Stored Fields
- control bindings  
- UI layout  
- theme  
- language  
- mod list order  
- accessibility settings  

### 4.3 NOT stored in Profile
- simulation rate  
- UPS  
- deterministic settings  
- any cross-player-relevant setting  

Profiles can be exported/imported as `.domprofile` bundles.


============================================================
5. PLATFORM AUTO-DETECTION
============================================================

When launched, engine runs a *hardware probe*:

- CPU vendor/model  
- ISA detection (SSE2, 3DNow!, MMX)  
- GPU vendor/model  
- VRAM  
- driver API availability  
- available renderers (DX9, GL2, SDL1/2-soft)  
- audio devices  
- input devices  
- RAM amount  
- OS version  

### 5.1 Auto-Select Renderer
Algorithm:
1. Native API (DX9 on Win, GL2 on Linux/macOS)  
2. SDL2 GL2  
3. SDL2 software  
4. SDL1 software  
5. Headless  

### 5.2 Auto-Select Graphics Settings
Based on GPU tiers:
- Ultra, High, Medium, Low, Very Low, Minimal  
Minimal = DOS-style vector wireframe.

Renderer not tied to profile; profile only stores preferences, not hard requirements.


============================================================
6. PLATFORM OVERRIDE SYSTEM
============================================================

Files:
settings/platform_override.cfg

Used by:
- consoles  
- DOS  
- Win98  
- macOS PPC  
- unusual GPU drivers  

Platform override may *disable* renderers, audio backends, input backends that the OS cannot support.

Overrides cannot enable settings that violate determinism.


============================================================
7. GRAPHICS CONFIGURATION
============================================================

### 7.1 Fields
fullscreen = true/false
window_width = int
window_height = int
max_fps = int
vsync = true/false
renderer = "sdl2", "gl2", "dx9", "dx11" (later), "sw"
graphics_mode = 0/1/2/3 (visual tier)
lod_bias = int
texture_quality = 0..3
shadow_quality = 0..3
ui_scale = float

### 7.2 Deterministic Rules
Graphics settings never influence simulation.  
Tick rate separate from render rate.


============================================================
8. AUDIO CONFIGURATION
============================================================

audio_backend = "sdl", "xaudio", "openal"
volume_master = 0..1
volume_music = 0..1
volume_sfx = 0..1
latency_ms = int

If backend cannot initialize → fallback to silent mode.


============================================================
9. INPUT CONFIGURATION
============================================================

### 9.1 Bindings
move_forward = "W"
jump = "Space"
build_menu = "B"

### 9.2 Input Backends
- SDL2 input  
- DX Input  
- Raw Input  
- DOS INT 16h  
- HID (consoles)  

### 9.3 Determinism Rule
Input only sampled at tick boundaries.


============================================================
10. NETWORK CONFIGURATION
============================================================

net_mode = client/server/offline
net_port = int
net_rate = fixed
net_tick_rate = up to UPS

All desync-prevention parameters locked.  
User cannot modify anything that touches deterministic sync.


============================================================
11. MOD CONFIGURATION
============================================================

enabled_mods = [list]
load_order = deterministic order
mod_conflicts = auto-resolve

Mods.cfg defines:
- load priority  
- compatibility warnings  
- final resolved mod list stored in save for replay integrity  


============================================================
12. RENDERER-SELECTION CONFIG
============================================================

Launcher writes:
render_select.cfg

Specifies:
- which binary  
- which backend  
- UI mode: vector/texture/3D  
- headless/CLI/TUI mode  

This file is not user-editable in-game; only in launcher.


============================================================
13. SAFE-MODE BOOT
============================================================

Triggered by:
- command-line flag `--safe`  
- failed startup  
- crash detection  
- corrupted config  

Safe-mode setting floor:
renderer = "sw"
fullscreen = false
vsync = false
resolution = 640x480
audio_disabled
no_mods
ui_mode = vector

Loads minimal UI and lets user reconfigure.

Deterministic subsystems unaffected.


============================================================
14. DETERMINISTIC BOOTSTRAP SEQUENCE
============================================================

Boot steps (fixed order):

1. Load engine defaults  
2. Load platform overrides  
3. Load user settings  
4. Load profile settings  
5. Apply launcher/CLI overrides  
6. Lock deterministic settings  
7. Select renderer  
8. Load mods list  
9. Initialize subsystems in strict deterministic order  
10. Start simulation (only after full init)

Every step’s hash stored for desync debugging.


============================================================
15. ALL SETTINGS AFFECTING SIMULATION
============================================================

These are **read-only** and **not user configurable**:

- UPS rate (canonical, though adjustable via launcher before world load only)  
- simulation resolution  
- physics granularity  
- tick scheduling  
- data network timing  
- electrical and fluid network stepping  
- worker AI step  
- resource sampling  

If a setting could alter world behavior → locked.


============================================================
16. UPS / FPS LINKING
============================================================

User may set:
fps_max
ups_cap
vsync
fps_link = independent / tied_to_ups / vsync

If simulation cannot hit UPS:
- UPS lowers  
- in-game speed slows  
- deterministic simulation preserved  


============================================================
17. MULTIPLE BINARIES SUPPORT
============================================================

Launcher's configuration layer resolves:
- which EXE to run  
- which API to request  
- which visual/audio tier is allowed  

Same config directory used by all binaries.

DOS/Win3.x builds ignore irrelevant fields.


============================================================
18. PACKAGING RULES FOR DIFFERENT MEDIA
============================================================

Settings stored:
- never on disc  
- always on user writable storage  
- engine uses consistent path resolution per OS  

Physical media (CD/DVD) contain:
- default configs  
- platform override templates  
- no writable configs  


============================================================
19. EXPORT / IMPORT OF SETTINGS
============================================================

User can export:
DominiumSettingsBundle.dsav

Contains:
- all configs  
- profiles  
- UI layouts  
No mods or saves unless requested.


============================================================
20. SUMMARY
============================================================

Volume 7.21 defines:
- universal configuration system  
- deterministic layering  
- safe-mode  
- platform overrides  
- multi-binary renderer selection  
- user profiles  
- graphics/audio/input/net settings  
- UPS/FPS rules  
- legacy platform compatibility  
- launcher integration  
- strict ordering of boot  

This fully defines how Dominium handles settings on every platform.

# END OF VOLUME 7.21

Ready for VOLUME 7.22 — ACCESSIBILITY SYSTEM (UI scaling, color filters, hearing/vision modes, cognitive load, minimal mode, simplified graphics tiers, input assist, subtitles, haptics).
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceed with VOLUME 7.22.
Single continuous MD block. No filler.

# VOLUME 7.22 — ACCESSIBILITY SYSTEM  
Dominium Engine Specification — Engine Core, Part 22  
Universal Design Layer, UI Scaling, Vision/Hearing Modes, Cognitive Assistance, Input Assistance, Minimal Modes, Subtitles, Haptics

Purpose:
Define a complete accessibility architecture that works on:
- Win2000+  
- macOS 10.6+  
- Linux  
- Win9x/Win3.x/MS-DOS (reduced mode)  
- SDL1/SDL2/Native/DX9/GL2/Vector/CLI/TUI  
- Headless servers  

Accessibility must never alter simulation determinism.  
All accessibility features affect **only UI, rendering, audio, and controls**.

============================================================
1. PRINCIPLES
============================================================

1. Accessibility must be available on every supported platform.  
2. Accessibility never changes simulation logic.  
3. Features must degrade gracefully on older systems.  
4. All settings stored per-profile and per-machine.  
5. All modes must work in 2D Vector, 2D Texture, 3D Texture, and CLI/TUI.  
6. Accessibility is applied *after* render selection and before UI layout.  
7. Must support full keyboard-only navigation.  

Accessibility is *not* DLC; it is core.

============================================================
2. ACCESSIBILITY CONFIG FILE
============================================================

settings/accessibility.cfg

Unifies:
- vision modes  
- hearing modes  
- input assistance  
- cognitive assistance  
- UI scaling  
- simplified interface  
- motion reduction  

Format is deterministic key-value.

============================================================
3. VISION ACCESSIBILITY
============================================================

### 3.1 Global UI Scale
ui_scale = 0.5–4.0
Applies:
- text  
- icons  
- margins  
- input hitboxes  

Works across 2D/3D/Vector modes.  
CLI/TUI enlarge monospace font.

### 3.2 Text Size Override
font_size_override = int OR auto

Vector mode: regenerated at scale.  
Texture mode: bitmap-scaling.  
Minimal mode: fallback to internal VGA font.

### 3.3 Colorblind Modes
colorblind_mode = off/protanopia/deuteranopia/tritanopia/gray

Applied at UI final-pass; not to world simulation.  
3D mode can blend a fullscreen shader (DX9 equalizer).  
Vector mode recolors lines appropriately.

### 3.4 High Contrast Mode
high_contrast = true/false

Enables:
- black/white UI palette  
- thickened borders  
- higher line weight in vector mode  

### 3.5 Readability Enhancements
text_outline = true/false
text_shadow = true/false
cursor_enlarged = true/false

============================================================
4. HEARING ACCESSIBILITY
============================================================

Simulation events deterministic; sound output is presentation-only.

### 4.1 Subtitles
subtitles = off/basic/full

Basic = dialog, alerts.  
Full = every sound event with category & intensity.

### 4.2 Subtitle Size & Background
subtitle_scale = 0.5–4.0
subtitle_bg = true/false

### 4.3 Visual Sound Indicators
visual_sfx = true/false

Shows:
- directional arrows  
- amplitude bars  
- vibration pulses in UI  

### 4.4 Speech-to-Text & Text-to-Speech
Works only on modern OS.  
Fallback to no-op on legacy.

============================================================
5. COGNITIVE ACCESSIBILITY
============================================================

### 5.1 Reduced Cognitive Load Mode
reduced_cognitive_load = true/false

Modifies:
- simplified UI  
- hides redundant data  
- collapses advanced panels  
- reduces UI animation  
- highlights primary actions  

### 5.2 Tooltips Enhanced Mode
enhanced_tooltips = true/false

Adds:
- plain language descriptions  
- numeric breakdowns  
- dependency listing  

### 5.3 Task Guidance Mode
task_guidance = true/false

Shows:
- construction steps  
- missing materials  
- data network needs  
- power/network flow  

### 5.4 Stress Reduction
flash_reduction = true/false
motion_reduction = true/false
particle_reduction = true/false

============================================================
6. INPUT ACCESSIBILITY
============================================================

### 6.1 Remappable Controls
Universal remapping, per-profile.

### 6.2 Sticky Keys
sticky_keys = true/false

### 6.3 Toggle Actions
toggle_actions = [list]

E.g.  
run toggle, crouch toggle.

### 6.4 Slow Cursor Mode
cursor_speed_factor = 0.1–1.0

Applies to:
- mouse  
- joystick  
- keyboard cursor  

### 6.5 Virtual Cursor
For keyboard-only navigation.

============================================================
7. MOTOR ACCESSIBILITY
============================================================

### 7.1 Input Assistance
assist_movement = true/false
assist_precision_building = true/false
assist_camera_smoothing = true/false

### 7.2 Deadzone & Sensitivity
deadzone = 0.0–0.5
sensitivity = 0.1–5.0

### 7.3 Hold-Time Reduction
hold_time_factor = 0.1–1.0

============================================================
8. COMMUNICATION ACCESSIBILITY
============================================================

### 8.1 Chat Substitution
chat_tts = true/false

### 8.2 Symbolic Messages
A pre-defined icon-based communication mode for multiplayer.

============================================================
9. MOTION ACCESSIBILITY
============================================================

### 9.1 Motion Reduction
reduce_camera_shake = true
reduce_parallax = true
reduce_zoom_effects = true

### 9.2 Simplified Camera Movement
No easing, direct transform.

============================================================
10. UI MODES FOR ACCESSIBILITY
============================================================

### 10.1 Minimal UI Mode
ui_minimal = true/false

Removes:
- decorative elements  
- motion  
- non-essential data  

### 10.2 Progressive Disclosure UI
Shows only what is needed at the moment.

### 10.3 High-Visibility Vector Mode
Large icons, bold outlines.

============================================================
11. MULTI-ENVIRONMENT SUPPORT
============================================================

### 11.1 CLI/TUI Mode
Accessibility overlays must work even without graphics.

CLI:
- enlarge font  
- text-highlighting for alerts  
- simplified map (ASCII)  

TUI:
- ncurses-style  
- colorblind modes mapped to pair IDs  
- keyboard-only  

### 11.2 Legacy OS Constraints
DOS/Win3.x:
- no subtitles background  
- no complex animation  
- no speech  
- vector mode only  

Win9x:  
- simplified shaders  
- limited subtitle styling  

============================================================
12. ACCESSIBILITY PRESET SYSTEM
============================================================

Predefined:
- Vision-Friendly  
- Hearing-Friendly  
- Cognitive Simplification  
- Motor Assistance  
- Full Accessibility  
- Minimal Mode (for low-end hardware + accessibility needs)

Preset file:
settings/accessibility_presets.cfg

============================================================
13. LAUNCHER INTEGRATION
============================================================

Launcher allows:
- selecting accessibility preset  
- previewing UI scale  
- testing colorblind filters  
- testing subtitle mode  
- toggling input assistance  

Launcher stores changes in profile.

============================================================
14. SAVEGAME INTEGRATION
============================================================

Accessibility settings **never stored inside savegames**.  
They remain purely local.

============================================================
15. PERFORMANCE CONSIDERATIONS
============================================================

Settings like enlarged text or vector outlines must not affect UPS.  
All accessibility operations run in the UI pass, not simulation.

Minimal mode greatly reduces GPU load for accessibility + low-power systems.

============================================================
16. COMPATIBILITY WITH MODS
============================================================

Mods must flag:
supports_accessibility = true

Engine enforces:
- mod UI must obey global UI scale  
- mod icons must provide accessibility variants  
- mod colors run through accessibility transform  

============================================================
17. SUMMARY
============================================================

Volume 7.22 defines a full accessibility framework:
- vision, hearing, cognitive, motor, motion assistance  
- subtitles, visual indicators, colorblind modes  
- simplified UI modes  
- full keyboard-only navigation  
- CLI/TUI/Legacy OS accessibility  
- launcher integration  
- deterministic isolation  
- mod support  

This system is global, cross-platform, and future-proof.

# END OF VOLUME 7.22

Ready for:
VOLUME 7.23 — ERROR HANDLING & RECOVERY SYSTEM
(fault tolerance, crash recovery, save protection, rollback, sandboxing, launcher recovery paths, slow-hardware fallback)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.23.
Single continuous Markdown block.
No filler. No softening.

# VOLUME 7.23 — ERROR HANDLING & RECOVERY SYSTEM  
Dominium Engine Specification — Engine Core, Part 23  
Fault Tolerance, Crash Recovery, Save Protection, Rollback, Sandboxing, Fallback Paths

Purpose:  
Define how Dominium prevents corruption, preserves determinism, avoids catastrophic failure on low-end hardware, and recovers cleanly from crashes, GPU driver resets, mod errors, filesystem failures, memory exhaustion, and logic faults.

This system must function on:
- Win2000–Win11  
- macOS 10.6–modern  
- Linux  
- Win9x, Win3.x, MS-DOS (reduced mode)  
- SDL1/SDL2/Native/DX9/GL2/Vector/Headless  
- Servers and clients  
- With or without mods  

Determinism must not be broken under any condition.


============================================================
1. DESIGN REQUIREMENTS
============================================================

1. The simulation must never silently desynchronize.  
2. A crash must never corrupt a savegame.  
3. All I/O must be atomic or double-buffered.  
4. All mods must operate inside a sandbox; crashes cannot escape the sandbox.  
5. Simulation logic faults must trigger a safe rollback, not undefined behavior.  
6. GPU driver resets must not crash the process; renderer is hot-reloadable.  
7. Memory exhaustion must degrade the game, not kill it.  
8. Every error must produce a deterministic crash report with a stable hash.  
9. Server must never trust client data.  
10. Any engine fault must allow returning to Launcher Recovery Mode.


============================================================
2. ERROR SEVERITY LEVELS
============================================================

### Level 0 — Warning (Non-Fatal)
Recoverable. Logged. No interruption.

### Level 1 — Soft Fault
Subsystem error that does not stop the simulation:
- renderer loss  
- audio backend failure  
- mod UI error  

Subsystem is restarted or disabled minimally.

### Level 2 — Hard Fault
Simulation logic error detected:
- invalid ECS state  
- network desync  
- tick ordering violation  
- invalid machine state  

Triggers rollback to last stable checkpoint.

### Level 3 — Fatal Fault
Unrecoverable:
- corrupted binary  
- corrupted core data  
- invalid memory access  
- OS signal termination  

Triggers safe shutdown and recovery workflow.


============================================================
3. SAFE I/O SYSTEM
============================================================

All filesystem writes use:
- **double buffering**  
- **atomic renames**  
- **hash verification**

### Example: writing savegame
save_temp.bin
save_temp.bin.hash
=> atomic rename => save_final.bin

Legacy (DOS/Win3.x) uses shadow copies.


============================================================
4. SAVE PROTECTION SYSTEM
============================================================

Dominium never writes directly over an existing save.

Save structure:
world_A/
save_current.bin
save_previous.bin
save_backup_1.bin
save_backup_2.bin
metadata.json

Rules:
- current overwritten only after validation  
- previous kept as rollback  
- backups on interval  
- metadata tracks hash & version  

When loading:
- verify hash  
- fall back to previous  
- fall back to backup  
- if all fail → load empty world with recovery UI  


============================================================
5. SIMULATION CHECKPOINT SYSTEM
============================================================

For rollback on logic faults.

Checkpoints stored every N ticks (configurable, default 300).
Stored in RAM + optional disk.

Checkpoint contents:
- ECS state  
- chunk states  
- network states (power/data/fluid)  
- queued events  
- replay input cursor  

Rollback is instant, deterministic, and invisible if soft.


============================================================
6. SANDBOXING (MODS, SCRIPTS, PLUGINS)
============================================================

Mods run inside:
- restricted Lua VM  
- no direct memory access  
- no OS calls  
- no file writes except permitted sandbox dirs  
- restricted CPU time budget  

If mod exceeds time budget → sandbox kill → mod disabled for tick → user notified.

If mod produces invalid game state → revert mod action → continue.

A mod cannot crash the engine.


============================================================
7. GPU DRIVER RESET HANDLING
============================================================

For DX9, GL2, SDL2, SDL1 modes.

If device lost:
- renderer invalidated  
- GPU resources freed  
- soft reload of renderer  
- UI displayed briefly  
- simulation never pauses unless user enables “pause on render loss”  

Fallback:
- degrade to simpler renderer tier  
- or switch to vector mode


============================================================
8. MEMORY EXHAUSTION CONTROLS
============================================================

Engine monitors allocation failure.

If memory low:
1. Shrink caches  
2. Drop UI decorations  
3. Drop 3D models → 2D icons  
4. Drop textures → vector mode  
5. Pause asset streaming  
6. If still insufficient → “Low Memory Mode”  

Low Memory Mode:
- simulation continues  
- renderer becomes vector-only  
- entities degrade to symbols  
- saves remain valid  


============================================================
9. NETWORK ERROR HANDLING
============================================================

Server authoritative.

If client sends invalid or corrupted packet:
- packet dropped  
- client flagged  
- after repeated violations → auto-kick  
- no client data ever trusted  

If server detects desync:
- send rollback state to client  
- resync replay stream  
- if client cannot synchronize → forced reconnect  


============================================================
10. TICK FAILURE RECOVERY
============================================================

If a subsystem fails during tick:
- log failure  
- revert subsystem to last stable microstate  
- skip subsystem for next tick if still invalid  
- trigger checkpoint rollback on persistent fault  

Tick never partially commits; commit is atomic across phases.


============================================================
11. ERROR LOGGING & CRASH REPORTS
============================================================

Crash report contains:
- engine version  
- platform  
- renderer backend  
- subsystem states  
- last 100 log lines  
- deterministic state hash  
- call stack (if available)  
- mod list  
- OS information  

Stored in:
logs/errors/

Legacy OS logs use simple text.


============================================================
12. LAUNCHER RECOVERY MODE
============================================================

If crash detected on last run:
Launcher auto-enters **Recovery Mode**.

Recovery options:
- Safe Mode launch  
- Renderer override  
- Disable all mods  
- Rebuild config files  
- Validate installation  
- Choose last known good build  
- Open crash report  
- Clear shader caches  
- Reset settings  


============================================================
13. FAULT INJECTION MODE (DEVELOPMENT)
============================================================

Used for testing robustness.

Allows simulation of:
- random tick faults  
- corrupted packets  
- memory exhaustion  
- GPU reset  
- file corruption  
- artificial desync  

Controlled by CLI:
--fault_inject=N


============================================================
14. SERVER-SIDE SAVE LOCKING
============================================================

Server always writes saves in an exclusive lock.
Clients cannot write or modify server world files.

Rollback uses server checkpoints only.


============================================================
15. FALLBACK PATHS FOR ALL SUBSYSTEMS
============================================================

### Renderer fallback order:
DX9 → GL2 → SDL2 → SDL1 → Vector → CLI/TUI → Headless

### Audio fallback:
XAudio → OpenAL → SDL → silent

### Input fallback:
RawInput → SDL → DOS INT → keyboard-only

### UI fallback:
Texture → Vector → ASCII

Fallback never breaks determinism; it alters presentation only.


============================================================
16. EXCEPTION POLICY
============================================================

Engine forbids:
- unhandled exceptions  
- floating-point NaNs in simulation  
- platform-specific behavior outside wrappers  
- undefined ECS states  
- partial asset loads  

Any illegal state triggers deterministic Hard Fault → rollback.


============================================================
17. LEGACY OS BEHAVIOR
============================================================

### Win9x / Win3.x / DOS:
- no GPU reset handling  
- vector-only fallback  
- tiny error dialog  
- minimal logs  
- identical rollback model  
- all same determinism guarantees  

### Consoles:
- standardized error screen  
- fixed log format  
- strict memory fallback  


============================================================
18. USER-FACING FEEDBACK
============================================================

The game must not spam players.

Errors displayed:
- only once  
- concise  
- actionable  

Simulation faults shown:
- “A simulation fault occurred. World rolled back by N ticks.”  
No debug info unless developer mode enabled.


============================================================
19. SUMMARY
============================================================

Volume 7.23 defines the reliability backbone of the Dominium engine:

- full save protection  
- full rollback system  
- fault detection for all subsystems  
- mod sandbox and CPU budgets  
- GPU reset tolerance  
- memory exhaustion recovery  
- network desync recovery  
- deterministic crash reports  
- launcher recovery mode  
- strict fallback paths  
- identical behavior on modern and legacy hardware  

This ensures Dominium remains stable, deterministic, and uncorrupted under every failure mode possible.

# END OF VOLUME 7.23

Next section in order:
VOLUME 7.24 — SECURITY MODEL (Sandboxing, Anti-Tamper, Replay Integrity, Optional Anti-Cheat, Trust Boundaries, Cryptographic Hashing, Save Validation)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.24 — SECURITY MODEL.
Single continuous Markdown block.
No filler.
No softening.

# VOLUME 7.24 — SECURITY MODEL  
Dominium Engine Specification — Engine Core, Part 24  
Sandboxing, Integrity, Trust Boundaries, Optional Anti-Cheat, Replay Correctness, Save Validation, Cryptographic Hashing

Objective:  
Define a unified security architecture supporting:
- deterministic simulation  
- fully offline play  
- minimal DRM/anti-cheat  
- mod sandboxing  
- strong replay integrity  
- strong save validation  
- predictable trust boundaries  
- low-performance targets (Win2000, DOS, Win9x)  
- high-performance targets (modern PCs, servers)  

Security must never interfere with gameplay freedom.  
Security must be fully optional where appropriate.  
Security must never break determinism.

============================================================
1. PRINCIPLES
============================================================

1. **Single-player is fully trusted.**  
2. **Multiplayer server is authoritative.**  
3. **All data received from clients is untrusted.**  
4. **Security must not use obfuscation, encryption-at-rest, or intrusive DRM.**  
5. **Security must not prevent modding or offline play.**  
6. **All integrity systems must be deterministic.**  
7. **Optional anti-cheat must be fully opt-in and never required.**  
8. **Replay integrity must be mathematically verifiable.**  
9. **Savegames must be cryptographically validated but not encrypted.**  
10. **Users must be allowed to modify or export any of their own data.**

============================================================
2. THREAT MODEL
============================================================

### 2.1 Threats We Care About
- corrupted mods  
- corrupted savegames  
- network desync attempts  
- malicious client data in multiplayer  
- replay tampering  
- packet tampering  
- pathological mod CPU usage  
- invalid assets injected into engine  
- DLL injection on Windows  
- Lua environment escape  

### 2.2 Threats We Explicitly Do Not Care About
- piracy  
- offline cheats  
- hex-editing saves  
- modded single-player states  
- users bypassing optional anti-cheat  
- speedhacks in single-player  

Dominium does not attempt to stop the user from changing their game.

============================================================
3. TRUST BOUNDARIES
============================================================

### 3.1 Server <–> Client
Server is authoritative over:
- simulation  
- economics  
- AI  
- market data  
- tick progression  

Client is authoritative only over:
- local input commands  
- camera  
- UI  

### 3.2 Engine <–> Mods
Engine trusts:
- nothing produced by mods  
- no mod scripts  
- no mod data tables  

Mod sandbox guarantees they cannot:
- write outside mod directory  
- corrupt memory  
- perform OS-level tasks  
- interfere with simulation determinism  

============================================================
4. CRYPTOGRAPHIC MODEL
============================================================

### 4.1 Hash Function
Use 64-bit or 128-bit deterministic stable hash:
- Murmur3, xxHash, or HighwayHash (deterministic build)  
- must not depend on hardware endianness  
- must not depend on SIMD variation  

### 4.2 When Hashing Is Used
- save validation  
- replay integrity  
- mod load order hashing  
- engine version signature  
- tick deterministic state hashing  
- optional anti-cheat consistency checks  

### 4.3 When Hashing Is NOT Used
- DRM  
- encryption  
- anti-tamper  
- user-locking  

============================================================
5. SAVEGAME VALIDATION
============================================================

Every save has:
save.bin
save.hash
metadata.json

Validation steps:
1. Load `save.bin`  
2. Compute hash  
3. Compare with stored hash  
4. If mismatch: attempt fallback save  
5. If all fail: enter recovery UI

No encryption.  
User editing saves is permitted and expected.

============================================================
6. REPLAY INTEGRITY
============================================================

Replay consists of:
- tick-ordered input buffer  
- periodic state checksums  

Replay cannot be “faked” without modifying checksums.

Replay verifies:
- engine version  
- mod list and load order  
- deterministic state hashes every N ticks  
- integrity of input stream  

If a mismatch occurs during replay:
- replay aborts with error  
- points to first divergent tick  

============================================================
7. NETWORK SECURITY (MULTIPLAYER)
============================================================

### 7.1 Packet Validation
Every packet:
- validated for size  
- validated for structure  
- validated for tick alignment  
- validated for input-command correctness  

### 7.2 Client Trust Level = ZERO
Client cannot:
- modify world  
- send inventory items  
- send machine state  
- send network flows  
- send economic activity  

Client only sends:
- input actions  
- UI requests  
- chat messages  

Everything else rejected.

### 7.3 Simulation State Sync
Server sends:
- authoritative world snapshot  
- authoritative tick number  
- authoritative replay seed  

Client keeps a local shadow simulation purely for rendering & UI.

============================================================
8. OPTIONAL ANTI-CHEAT SYSTEM
============================================================

Anti-cheat is never required.  
It is entirely optional for server operators.

### 8.1 Anti-Cheat Modes
off (default)
input-only (validates client inputs)
integrity (validates state hashes)
full (validates hashes + binary signature)

### 8.2 Anti-Cheat Guarantees
- does not read user files  
- does not scan processes  
- does not phone home  
- does not block modding  
- does not interfere with single-player  
- does not obfuscate or encrypt anything  

### 8.3 Behavior on Failure
Server drops client.  
Client shown precise reason.  
No bans, no persistent penalties.

============================================================
9. MOD SANDBOX
============================================================

Mod Script isolation:
- no OS access  
- no DLLs  
- no native code  
- no arbitrary file writes  
- limited CPU time  
- deterministic floating-point mode  
- cannot modify protected core tables  

Mod Data isolation:
- validated asset headers  
- validated schema  
- validated ranges  
- validated mod manifest  

If mod violates sandbox:
- mod disabled  
- simulation continues  
- error logged  

============================================================
10. ENGINE BINARY SECURITY
============================================================

### Isolation from external libraries:
- all third-party libs built static  
- no runtime dynamic linking except SDL/DX/OpenAL  

### DLL Injection Resistance (Windows):
- engine uses `SetDefaultDllDirectories` for Win7+  
- manual module filtering  
- optional integrity checks if anti-cheat=full  
- not used for DRM  

### Legacy Systems:
Win9x/Win3.x/DOS versions have minimal security; sandbox and integrity still apply.

============================================================
11. EXECUTION SECURITY
============================================================

### 11.1 Memory Safety
Engine enforces:
- no raw pointer math in gameplay  
- ECS pooled allocation  
- bounds-checked arrays  
- guard regions for debug  
- allocator that detects double frees  

### 11.2 Floating-Point Control
Simulation runs under:
- fixed rounding  
- consistent FP modes across OS  
- flushed denormals  
- SSE controlled rounding  

### 11.3 Thread Isolation
No thread other than main simulation thread may modify simulation memory.

============================================================
12. FILESYSTEM SECURITY
============================================================

Engine must never write outside user directories.

Permitted write paths:
- saves  
- configs  
- cache  
- logs  
- mods (only user-installed, not scripts)  

Mods can write only to:
mods/<modid>/data/
mods/<modid>/cache/

Never to:
- engine root  
- binaries  
- OS directories  

============================================================
13. CONTENT AUTHENTICATION
============================================================

Content (textures, models, scripts) can optionally be validated via a manifest:
manifest.hashes

Used for:
- multiplayer mod mismatch detection  
- consistency checking in servers  
- optional anti-cheat  

Not used for DRM.  
User can disable at any time.

============================================================
14. SECURITY FAILSAFE BEHAVIOR
============================================================

On security fault:
- engine prints message  
- logs incident  
- disables faulty mod or system  
- rolls back tick if needed  
- continues simulation if possible  

Only fatal faults crash engine.

============================================================
15. SECURITY VS DETERMINISM RULE
============================================================

Security must never change:
- tick order  
- RNG seed  
- physics  
- network stepping  
- power/data/fluid propagation  
- worker AI  
- economic simulation  

Security may change:
- client visual output  
- network restrictions  
- ability of mod to run  
- server acceptance of client actions  

============================================================
16. LEGACY PLATFORM SECURITY BEHAVIOR
============================================================

### DOS / Win3.x:
- no sandbox  
- no optional anti-cheat  
- integrity only  

### Win9x:
- sandbox (Lua)  
- no advanced anti-cheat  

### Win2000+:
- full feature set  

### Consoles:
- platform-level sandbox + our sandbox  

============================================================
17. SUMMARY
============================================================

Volume 7.24 defines Dominium’s entire security model:

- server-authoritative deterministic simulation  
- complete mod sandbox  
- integrity hashing (no encryption)  
- strong replay verification  
- atomic save validation  
- optional anti-cheat that never harms modding  
- strict trust boundaries  
- deterministic, reproducible behavior  
- universal fallback for legacy OSes  
- full user freedom in single-player  

Dominium is secure, but not restrictive.
Deterministic, but not fragile.
Moddable, but not exploitable.

# END OF VOLUME 7.24

Next:
VOLUME 7.25 — PERFORMANCE & PROFILING SYSTEM
(tick profilers, frame profilers, per-subsystem metrics, CPU/GPU telemetry, legacy-mode fallbacks)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.25 — PERFORMANCE & PROFILING SYSTEM.
Single continuous Markdown block.
No filler. No softening.

# VOLUME 7.25 — PERFORMANCE & PROFILING SYSTEM  
Dominium Engine Specification — Engine Core, Part 25  
Tick Profilers, Frame Profilers, Subsystem Metrics, CPU/GPU Telemetry, Legacy-Mode Fallbacks

Purpose:  
Define every mechanism the engine uses to:
- measure performance  
- adapt performance  
- expose profiling data  
- avoid stutter  
- maintain deterministic logic  
- operate on hardware from 1995–2025+  
- scale across 1–512 CPU threads  
- operate in headless and low-graphics modes  
- analyze UPS, FPS, job latency, network latency, worker AI cost, machine cost, and IO overhead  

Profiling must **never** alter simulation determinism.  
Profiling must be safe to disable on consoles and legacy hardware.  
Profiling must never leak user information.  

============================================================
1. CORE PRINCIPLES
============================================================

1. Profilers observe but never influence simulation.  
2. Profiler output is deterministic where relevant (tick times).  
3. Profilers must function even on Win98, Win3.x, and DOS (with reduced capability).  
4. Profilers must handle thousands of subsystems and millions of entities.  
5. Profilers must not cause stutters.  
6. Profiling data must be available to server operators and modders.  
7. Profilers must support real-time streaming to external tools.  
8. Profilers must record both CPU and GPU but never assume GPU availability.  

============================================================
2. TICK PROFILER (SIMULATION PROFILER)
============================================================

Runs once per tick.  
Tracks cost per subsystem in the deterministic pipeline.

Tracked in microseconds or CPU cycles (depending on OS).

### 2.1 Subsystems Tracked
- Input  
- Scripting (Lua)  
- Networks: Power / Fluid / Data  
- Machines  
- Inventory logic  
- Logistics (vehicles)  
- Workers  
- AI (NPC, corporate, property-level)  
- Climate  
- Weather  
- Fire / Heat / Radiation  
- ECS maintenance  
- Serialization (if triggered)  

### 2.2 Data Collected
tick_number
tick_duration_us
phase_A_cost
phase_B_cost
phase_C_cost
...
each_subsystem_cost
slowest_subsystem
thread_job_distribution
max_job_time

Stored in ring buffer (default: last 10,000 ticks).  

### 2.3 Deterministic Rules
- Profiling never changes tick order.  
- Profiling never affects RNG usage.  
- Profiling disabled entirely during replays unless explicit flag set.  

============================================================
3. FRAME PROFILER (RENDER PROFILER)
============================================================

Non-deterministic; presentation only.

Tracks:
- frame time  
- render backend cost  
- batch count  
- draw calls  
- GPU upload size  
- texture memory usage  
- vector pipeline performance  
- UI render time  

Useful for optimizing low-end targets.

Legacy:
- DOS: counts ASCII draw ops  
- Win3.x: GDI blit counts  
- GL1: immediate-mode vertex counts  

============================================================
4. THREADING & JOB SYSTEM PROFILING
============================================================

Dominium supports job graphs for many systems (networks, AI, pathfinding).

Profiler tracks:
- job count  
- job latency  
- thread idle percentage  
- core utilization  
- contention points  
- failed steals  
- oversubscribed tasks  

Multicore support:
- from single-core Win98 era  
- to 16+ cores modern  
- to server with 128 threads  

============================================================
5. MEMORY PROFILER
============================================================

### 5.1 Memory Domains
The profiler divides memory usage into deterministic pools:
- ECS pool  
- Chunk memory  
- Pathfinding buffer  
- Fluid buffer  
- Power network buffer  
- Replay buffer  
- Checkpoint buffer  
- UI/Renderer memory  
- Mod sandbox memory  

### 5.2 Metrics
Collected:
allocations
frees
pool_usage
fragmentation
leak_suspicions
peak_usage
asset_cache_usage

Supports low-memory alerts that trigger fallback behavior (defined in 7.23).

============================================================
6. GPU TELEMETRY
============================================================

Not available on DOS/Win3.x or software renderers.

Tracks:
- VRAM usage  
- PCIe throughput  
- shader compile cost (DX9/GL2)  
- pipeline stalls  
- driver resets  

GPU telemetry is presentation-only.  
Never affects simulation.

============================================================
7. PROFILING MODES
============================================================

### 7.1 Minimal Mode (Default for Players)
- tick timing  
- frame timing  
- basic CPU/GPU graphs  
- toggled via F3  

### 7.2 Developer Mode
- full subsystem timings  
- thread graphs  
- memory details  
- asset loading costs  
- shader compile times  
- job system internals  

### 7.3 Server Mode
- UPS stability  
- tick queue depth  
- bandwidth usage  
- replay bandwidth  
- AI cost  
- deterministic state hash verification cost  

### 7.4 Legacy Low-Overhead Mode
Used on:
- DOS  
- Win3.x  
- Win9x  
- early Linux  

Collects only:
- tick time  
- phase time  
- memory usage  
- ECS counts  

============================================================
8. TELEMETRY STORAGE & LOGGING
============================================================

Telemetry stored in:
logs/perf/

Formats:
- deterministic binary snapshot  
- plaintext summaries  
- CSV for external analysis  

Optional real-time streaming through:
- TCP  
- UDP  
- named pipe  
- file tail  

No cloud telemetry.  
No analytics.  
No tracking.

============================================================
9. PERFORMANCE ADAPTATION LAYER
============================================================

Profilers never change the simulation, but they can *inform* fallback systems.

Fallback actions triggered by low performance:
- lower FPS (not UPS)  
- switch to vector renderer  
- disable shadows/particles  
- reduce audio mixing complexity  
- reduce UI animations  
- drop to minimal LOD  

UPS never auto-adjusts to maintain determinism.  
Only user can change UPS cap.

============================================================
10. PATHFINDING PROFILER
============================================================

Tracks:
- path requests per tick  
- avg path length  
- navmesh solvers  
- grid solvers  
- rail vs road requests  
- caching hit/miss ratio  
- longest path request cost  

Required because Dominium has:
- workers  
- vehicles  
- robots  
- trains  
- aircraft  
- boats  
- interproperty links  

============================================================
11. NETWORK PROFILER (MULTIPLAYER)
============================================================

Tracks:
- packets sent/received  
- bandwidth  
- compression ratios  
- tick-aligned packet delays  
- input command jitter  
- resync events  
- replay stream cost  

Displayed in debug HUD.

============================================================
12. MOD PROFILER
============================================================

Each mod has:
- CPU budget  
- memory budget  
- event cost tracking  

Tracked metrics:
mod_id
cpu_ms_per_tick
allocations
sandbox_violations
events_fired

Engine can auto-throttle a mod exceeding limits.

============================================================
13. ECS PROFILER
============================================================

Tracks:
- entity count  
- component count  
- hot-loop iteration cost  
- worst-case archetype  
- cache-line efficiency  
- dead entity cleanup cost  

Helps maintain deterministic ECS performance.

============================================================
14. SCRIPTING PROFILER (LUA)
============================================================

Tracks:
- instructions executed  
- memory allocated  
- GC time per tick  
- trigger events  

Lua calls cannot exceed CPU budget; profiler enforces budget.

============================================================
15. REPLAY PROFILER
============================================================

Measures:
- replay desync detection  
- tick hashing cost  
- input buffer read cost  
- snapshot restore latency  

Used for debugging determinism.

============================================================
16. SAVE/LOAD PROFILER
============================================================

Shows:
- serialization time  
- compressed size  
- IO throughput  
- validation hashes  
- chunk load order cost  

Works even on low-end legacy systems.

============================================================
17. IN-GAME PROFILER UI
============================================================

### Modern UI:
Tabbed interface:
- CPU  
- GPU  
- Memory  
- Threads  
- ECS  
- Mods  
- Networks  
- Pathfinding  
- Ticks  
- Frames  
- Replay  

### Vector / ASCII UI (legacy, servers):
- horizontal bars  
- numeric tables  
- scrollable list  
- no animations  

============================================================
18. NO DATA COLLECTION BEYOND PERFORMANCE
============================================================

Dominium collects:
- no analytics  
- no user behavior tracking  
- no crash upload  
- no external transmission  

All data is local unless user exports manually.

============================================================
19. EXTERNAL PROFILING API
============================================================

For advanced users and modders.

Export real-time:
- tick metrics  
- frame metrics  
- thread metrics  
- job system stats  

Formats:
- CSV  
- JSON  
- raw binary  

Access methods:
- pipe  
- socket  
- file  
- shared memory  

No network transmission unless user configures it.

============================================================
20. SUMMARY
============================================================

Volume 7.25 defines the complete performance and profiling architecture:

- deep tick/phase/subsystem profiling  
- frame profiling across all renderers  
- full job system metrics  
- full ECS, Lua, pathfinding profiling  
- GPU telemetry where supported  
- deterministic tick measurement  
- profiling for legacy OSes  
- profiling for servers  
- profiling for mods  
- safe fallback logic  
- no analytics or telemetry leakage  
- external profiling API  

Profiling is exhaustive, deterministic, and universal.

# END OF VOLUME 7.25

Next in sequence:
VOLUME 7.26 — DEBUGGING, INSPECTION & DEVTOOLS
(entity inspector, world viewer, network inspector, ECS inspector, visual debugger, breakpoint system, Lua debugger, replay debugger)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.26 — DEBUGGING, INSPECTION & DEVTOOLS in a single continuous Markdown block. No filler. No softeners.

# VOLUME 7.26 — DEBUGGING, INSPECTION & DEVTOOLS  
Dominium Engine Specification — Engine Core, Part 26  
Debug Architecture, Inspectors, Breakpoints, Replay Debugging, Lua Debugging, ECS Debugging, World and Network Visualization

Objective:  
Define a complete unified debugging and inspection framework that works across all supported platforms, all render modes, and all simulation tiers, without breaking determinism or introducing nondeterministic side effects.

Must operate on:
- Win2000+  
- macOS 10.6+  
- Linux  
- Win9x, Win3.x, DOS (reduced view)  
- Headless servers  
- Native, SDL1, SDL2, GL1/2, DX9  
- 2D vector, 2D texture, 3D texture, CLI/TUI  

All debugging must be read-only with respect to simulation unless explicitly entering controlled debug mutation modes.

============================================================
1. PRINCIPLES
============================================================

1. Debugging tools must never alter determinism unless explicitly entering a sandboxed mutation mode.  
2. Debug states must be isolated from simulation state.  
3. Debugging must not be required for players; all tools optional.  
4. Tools must operate during paused, running, and replay states.  
5. Tools must support low-power legacy machines via ASCII/vector modes.  
6. Tools must provide full ECS visibility.  
7. Debug mutations must be logged and tagged as noncanonical.  
8. All inspection tools must work offline and on servers.  
9. Debug views must never modify RNG order.  

============================================================
2. DEBUG OVERLAY SYSTEM
============================================================

Activated by F4 (modern), or CLI `--debug`.

Layers:
- Tick metrics  
- ECS metrics  
- Network flows  
- Power/Data/Fluid overlays  
- AI/Pathfinding overlays  
- Replay state  
- Renderer info  
- Memory usage  

Vector mode: overlays drawn as lines and numeric text.  
ASCII mode: overlays printed in side panels.

============================================================
3. WORLD INSPECTOR
============================================================

A layered world-view debugger.

Features:
- chunk boundaries  
- subchunk boundaries  
- heightmap view  
- fluid level map  
- temperature map  
- fire/heat/radiation view  
- pollution view  
- power network topology  
- data network topology  
- pipe/fluid topology  
- routes for vehicles  
- construction ghost outlines  
- entity occupancy map  

Modes:
- 2D orthographic  
- 3D free-cam  
- vector schematic  
- ASCII tile projection (legacy/headless)  

============================================================
4. ENTITY INSPECTOR
============================================================

Selecting an entity shows:
- entity ID  
- archetype  
- components present  
- all component fields  
- component memory layout  
- component update cost  
- deterministic hash of entity state  

White-list of editable fields (dev mode only):
- position  
- orientation  
- worker behavior state  
- machine recipe  
- inventory contents  
- network links  

Changes flagged as noncanonical.

============================================================
5. ECS DEBUGGER
============================================================

Tools:
- per-component type counts  
- archetype table listing  
- system-to-component access graph  
- cacheline efficiency metrics  
- hot-loop profiling per archetype  
- entity memory fragmentation view  

ECS Integrity Checks:
- orphan entities  
- invalid component references  
- mismatched archetype signatures  
- stale entity indices  

Running these checks never alters live simulation; they snapshot state.

============================================================
6. NETWORK INSPECTOR (POWER/Data/Fluid)
============================================================

Displays:
- nodes  
- edges  
- flow rates  
- voltage/pressure levels  
- signal packets  
- packet timestamps  
- packet routes  
- congestion  
- asynchronous job queue cost  

Filterable by:
- component  
- network ID  
- link type  

Network Simulation Debug Modes:
- Single-step tick  
- Freeze network  
- Packet tracing (with deterministic playback)  
- Flow saturation visualization  

============================================================
7. PATHFINDING & AI DEBUGGER
============================================================

### Pathfinding:
- navmesh visualization  
- voxel/grid view  
- evaluated nodes count  
- path preview  
- cache hit/miss indicators  

### AI:
- behavior tree execution outline  
- decision timing  
- worker task queue  
- machine AI state  
- corporate AI economic state summary  
- planetary/galactic AI where applicable  

Debug overlays:
- worker intended routes  
- blocked nodes  
- reservation conflicts  

============================================================
8. BREAKPOINT SYSTEM
============================================================

Breakpoints do not halt OS thread execution; they freeze simulation tick progression.  
Rendering may continue or freeze depending on configuration.

Breakpoint Types:
1. Tick number  
2. Entity condition  
3. Component value threshold  
4. Network state change  
5. Machine state change  
6. AI decision  
7. Mod script event  
8. Replay frame index  

Breakpoints log:
- tick  
- reason  
- entity ID (if applicable)  
- subsystem  

============================================================
9. LUA DEBUGGER
============================================================

Runs a fully isolated Lua VM debugger.

Features:
- breakpoints  
- step-in/step-out  
- stack trace  
- variable inspection  
- sandbox boundaries visualization  
- CPU budget usage  
- memory allocation tracking  
- event trace log  

Cannot modify simulation state directly.  
Script mutations require explicit developer override.

============================================================
10. REPLAY DEBUGGER
============================================================

Replays are deterministic; debugger can:
- jump to tick N  
- step tick-by-tick  
- compare live state hash vs replay hash  
- search for divergence  
- export replay segments  
- overlay replay input stream on live world  

Replay undo/redo:
- allow returning to any prior tick in replay  
- state restored from replay checkpoints  
- no drift allowed  

============================================================
11. SAVEGAME INSPECTOR
============================================================

Allows viewing a save without loading into simulation.

Displays:
- chunk map  
- entity lists  
- mod list  
- deterministic hash  
- simulation metadata  
- player/company structures  
- resource nodes  

Can export:
- compact JSON debug dump  
- ECS table dumps  
- deterministic hash tree  

Never modifies the save unless explicitly in mutation mode.

============================================================
12. SERIALIZATION DEBUGGER
============================================================

Shows:
- binary layout  
- component serialization order  
- versioned schema  
- mismatched mod fields  
- hash results for each serialized section  
- potential cross-platform serialization issues  

Used to ensure Win32/Linux/macOS/DOS produce identical save files.

============================================================
13. RENDER DEBUGGER
============================================================

Displays:
- draw call breakdown  
- shader time (DX9/GL2)  
- vector pipeline throughput  
- batching stats  
- occlusion stats  
- texture atlas usage  
- framebuffer stats  

Supports live shader reload in DX9/GL2 builds.  
Legacy (DOS/Win3.x): ASCII draw-time counters.

============================================================
14. DIAGNOSTIC CONSOLE
============================================================

Accessible via:
- backtick key  
- or CLI `--console`  

Features:
- command input  
- auto-complete  
- history  
- robust diagnostic commands  
- deterministic mutation commands available only in dev mode  

Commands for:
- profiling  
- network analysis  
- entity lookup  
- pathfinding queries  
- resource scans  
- AI behavior dumps  
- dump world state  
- dump replay checkpoints  

Console always sandboxed.

============================================================
15. INSPECTION SNAPSHOTS
============================================================

Allows capturing a static snapshot of:
- ECS state  
- active networks  
- simulation statistics  
- pathfinding caches  
- mod sandbox state  

Snapshots can be exported as:
- binary snapshot  
- JSON human-readable  
- layered dumps  

Snapshots load only in debugger, not in gameplay.

============================================================
16. EDITOR DEBUG PIPELINE
============================================================

World Editor (Volume 8) integrates debugging tools:
- place entities and inspect simultaneously  
- validate networks  
- detect routing failures  
- check power/data/fluid continuity  
- edit terrain and show resulting constraints  
- simulate mini-ticks independent of real world  

Editor cannot alter live multiplayer servers.

============================================================
17. HEADLESS/SERVER MODE DEBUGGING
============================================================

Provides:
- ASCII world browser  
- ASCII network inspector  
- ASCII entity inspector  
- log-based tick profiler  
- remote diagnostic console  
- replay-based debugging  

Server debugging never exposes private client data.

============================================================
18. MOD DEBUGGING INTERFACE
============================================================

Mods may request:
- profiling hooks  
- event trace data  
- custom inspector panels (sandboxed)  
- custom debug overlays  

Engine ensures:
- no mod can access memory of unrelated mods  
- no mod can profile engine internals beyond allowed scope  

============================================================
19. REMOTE DEBUGGING
============================================================

For servers and development.

Supported transport:
- TCP  
- local named pipes  
- WebSocket (optional)  

Capabilities:
- live entity inspection  
- replay sync state  
- profiler stream  
- network state dump  
- command execution in restricted sandbox  

Remote debugging is always explicit opt-in.

============================================================
20. DETERMINISM SAFETY RULES
============================================================

Debug features cannot:
- modify simulation unless in mutation mode  
- reorder tasks  
- alter RNG  
- influence tick order  
- alter floating point environment  
- modify ECS structure implicitly  
- alter network flows  
- touch power/fluid packets  

Only explicit dev commands may mutate state, and such states are marked noncanonical.

============================================================
21. SUMMARY
============================================================

Volume 7.26 defines a complete multi-platform debugging infrastructure:

- universal debug overlay  
- world, network, ECS, entity inspectors  
- pathfinding and AI debugging  
- breakpoints across deterministic pipeline  
- Lua debugger  
- replay debugger with drift detection  
- serialization validator  
- live render debugger  
- diagnostic console  
- inspection snapshots  
- editor-integrated debugging  
- full headless/server debugging  
- mod debugging sandbox  
- remote debugging API  
- deterministic safety rules  

This is the full debugging suite for Dominium’s simulation, presentation, and mod ecosystems.

# END OF VOLUME 7.26

Next section in order:
VOLUME 7.27 — SCRIPTING MODEL & API (Lua Integration, Sandboxing, API Design, Data Access, Event System, Deterministic Rules)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.27 — SCRIPTING MODEL & API.
Single continuous Markdown block.
No filler.

# VOLUME 7.27 — SCRIPTING MODEL & API  
Dominium Engine Specification — Engine Core, Part 27  
Lua Integration, Sandboxing, Deterministic API, Event System, Data Access Rules, Mod Architecture

Purpose:  
Define the scripting layer used by:
- mods  
- dev tools  
- automation logic  
- UI extensions  
- scenario logic (in future DLC)  
- optional world generation scripts  
- optional AI plugins  

This scripting system must:
- be deterministic  
- be sandboxed  
- be cross-platform across all targets (Win2000+, Linux, macOS 10.6+, Win9x, Win3.x, DOS)  
- run with strict CPU budgets  
- avoid arbitrary memory access  
- avoid floating-point nondeterminism  
- maintain simulation authority  

============================================================
1. SCRIPTING LANGUAGE
============================================================

### 1.1 Language Choice
- **Lua 5.1** + restricted set of 5.2+ features  
- Fixed deterministic math library  
- Custom allocator  
- No JIT  
- No OS libraries  
- No IO libraries  

### 1.2 Why Lua 5.1?
- runs on Windows 98 / Win3.x / DOS  
- easy to sandbox  
- easy to embed  
- stable and deterministic  
- widely used in games  
- Factorio uses 5.1 for determinism  

============================================================
2. SCRIPT EXECUTION MODEL
============================================================

### 2.1 VM Per Mod
Each mod runs in its own VM instance:
- isolated globals  
- isolated libraries  
- isolated memory  
- isolated event handlers  

VMs cannot interact with each other except via the official API.

### 2.2 Execution Frequency
Scripts execute only during:
- Tick events (pre, mid, post)  
- UI events  
- Build/destroy events  
- Network packet arrival (filtered)  
- Inventory change  
- Machine recipe update  
- Worker assignment events  
- Mod-defined timers  

Scripts never run between ticks.

### 2.3 CPU Budget
Default:
max_instructions_per_tick = 20000
max_memory_kb = 512

If mod exceeds:
- sandbox temporarily suspends mod for N ticks  
- log entry generated  
- mod may be disabled if persistent  

============================================================
3. DETERMINISM RULES
============================================================

Lua environment configured as:
- deterministic math (no platform-dependent trig/tan inconsistencies)  
- consistent rounding mode  
- deterministic integer-based RNG exposed to scripts  
- no access to floating-point except in fixed functions  
- iteration order defined for table traversal (ordered tables)  
- banned: ipairs/pairs that depend on memory order  

Scripts cannot:
- modify tick order  
- create asynchronous background tasks  
- create their own threads  
- call into OS  
- use nondeterministic time calls  

============================================================
4. SANDBOX RESTRICTIONS
============================================================

### 4.1 Removed Standard Libraries
- `io` (all)  
- `os` (all)  
- `debug` (all except safe traceback)  
- `package` (disabled)  
- `file` (nonexistent)  

### 4.2 Replaced Libraries
- `math` → deterministic rewrite  
- `string` → safe, Unicode-aware  
- `table` → deterministic iteration order  

### 4.3 Whitelisted
- `coroutine` (only yield/ resume inside same tick, with limits)  

Scripts cannot:
- open files  
- allocate sockets  
- sleep  
- spawn threads  
- allocate massive tables  
- load DLLs  
- call into unsafe memory  

============================================================
5. SCRIPT API (ROOT)
============================================================

Native functions exposed under deterministic API namespaces:

dominium.log()
dominium.error()
dominium.time()
dominium.tick()
world.get_chunk()
world.get_tile()
world.find_entities()
entity.get()
entity.set()
inventory.get()
inventory.insert()
inventory.remove()
network.power.get_flow()
network.data.send()
network.fluid.get_pressure()
machine.get_state()
machine.set_recipe()
machine.set_speed()
worker.assign_job()
worker.query_state()
pathfinding.request()

API is intentionally minimal but sufficient for automation & mods.

============================================================
6. EVENT SYSTEM
============================================================

### 6.1 Event Registration
mod.on_event("tick_pre", function() end)
mod.on_event("build", function(entity) end)
mod.on_event("destroy", function(entity) end)
mod.on_event("inventory_changed", ...)
mod.on_event("power_network_update", ...)
mod.on_event("fluid_network_update", ...)
mod.on_event("data_packet", ...)
mod.on_event("worker_idle", ...)
mod.on_event("vehicle_arrived", ...)

### 6.2 Event Ordering
Firmly defined:
- tick_pre  
- tick_main  
- tick_post  
- machine_process  
- inventory_update  
- logistics  
- AI events  
- network events  
- UI events last  

Scripts cannot reorder events.

100% deterministic.

============================================================
7. DATA ACCESS RULES
============================================================

Scripts may **inspect** anything.  
Scripts may **mutate** only whitelisted properties.

### Allowed Mutations
- entity orientation  
- entity position (dev mode only)  
- machine recipe selection  
- inventory contents  
- worker job assignments  
- creation of ghost entities  
- deletion of mod-owned entities  
- UI widgets  

### Forbidden Mutations
- terrain (except worldgen scripts)  
- player inventory (multiplayer)  
- company finances  
- core simulation variables  
- RNG seed  
- power/data/fluid network topology  
- structural building components  
- vehicle physics  

============================================================
8. MOD STORAGE
============================================================

Each mod has secure storage:

mods/<modid>/data/

Script-accessible:
- deterministic tables serialized on save  
- <2MB total per mod for compatibility with legacy systems  

Data must be JSON-like:
- no binary blob injection  
- no arbitrary byte arrays  

============================================================
9. MOD COMMUNICATION (INTER-MOD)
============================================================

Mods communicate via:
- events  
- virtual signals  
- shared read-only registries  

No direct memory sharing.

============================================================
10. DEBUGGING FOR SCRIPTS (RELATES TO VOL. 7.26)
============================================================

Lua debugger integrated:
- breakpoints  
- call stack  
- variable inspection  
- memory graph  
- CPU/instruction counters  
- corruption detection  

Debugger cannot break determinism.

============================================================
11. ERROR HANDLING
============================================================

If a script errors:
1. Log error with mod name  
2. Disable script for remainder of tick  
3. Count error  
4. If count exceeds threshold → mod disabled  
5. Simulation continues  

Errors never crash the engine.

============================================================
12. UI SCRIPTING API
============================================================

Mods may create:
- buttons  
- panels  
- charts  
- overlays  
- custom indicators  

UI scripts isolated from simulation scripts.  
UI changes cannot modify simulation state outside deterministic core.

============================================================
13. WORLDGEN SCRIPTING
============================================================

Optional, disabled by default except in dev mode.

Worldgen scripts must:
- run once  
- be deterministic  
- produce same output for same seed  

API subset:
- noise()  
- place_resource()  
- place_terrain_stamp()  
- set_height()  

============================================================
14. SCRIPT LIFECYCLE
============================================================

1. Mod loaded  
2. Script sandbox created  
3. Scripting API bound  
4. Script `init()` called  
5. Scripts can register events  
6. During ticks -> events fire  
7. On unload -> `shutdown()` event  

============================================================
15. SECURITY & SANDBOX INTEGRATION
============================================================

Scripts cannot escape sandbox:
- protected metatables  
- sealed environment  
- tail-call elimination disabled  
- runtime patching disabled  
- no string.dump (disabled)  
- no loadstring (disabled)  

Guaranteed safe on:
- Win2000+  
- macOS  
- Linux  
- Win9x  
- Win3.x  
- DOS  

============================================================
16. VERSIONING AND COMPATIBILITY
============================================================

Script API is versioned:
api_version = 1.x

Forward/backward compatibility:
- deprecations marked  
- old API shims provided  
- no breaking changes without major version bump  

============================================================
17. SUMMARY
============================================================

Volume 7.27 specifies the complete scripting system:
- Lua 5.1 deterministic VM  
- strict sandboxing  
- per-mod VM isolation  
- CPU budgets  
- deterministic event system  
- deterministic API  
- allowed/forbidden mutability  
- worldgen API  
- UI scripting API  
- mod persistence  
- mod communication  
- debugging support  
- replay safety  
- cross-platform compatibility  
- legacy-safe design  

Dominium’s scripting model is powerful, predictable, and safely isolated from the core simulation.

# END OF VOLUME 7.27

Next:
VOLUME 7.28 — PLUGIN SYSTEM & EXTENSION MODEL
(non-scripting extensions, engine-side plugins, binary compatibility, platform constraints)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.28 — PLUGIN SYSTEM & EXTENSION MODEL.
Single continuous Markdown block.
No filler.

# VOLUME 7.28 — PLUGIN SYSTEM & EXTENSION MODEL  
Dominium Engine Specification — Engine Core, Part 28  
Non-Scripting Extensions, Binary Plugins, ABI Rules, Cross-Platform Constraints, Deterministic Boundaries

Purpose:  
Define an engine-level plugin architecture *outside Lua scripting*, intended for advanced modders, professional tools, server operators, and internal engine extensions, without compromising determinism, cross-platform support, or legacy platform compatibility.

Plugins must:
- run safely  
- not break determinism  
- not break cross-platform portability  
- load conditionally depending on platform  
- never crash the engine  
- be sandboxed  
- degrade gracefully on older systems  
- not require users to install system-wide dependencies  

This is not a Unity/Unreal plugin system.  
This is a controlled, deterministic-oriented extension layer.

============================================================
1. PRINCIPLES
============================================================

1. Plugins cannot modify deterministic simulation state.  
2. Plugins operate only in explicitly allowed extension points.  
3. Plugins are optional and never required for Dominium to run.  
4. Plugins can be disabled globally or per-world.  
5. Plugins must work even when running off physical media (CD/DVD), assuming read-only.  
6. Plugin ABI must not change across patch versions within a major release.  
7. Binary plugins must NOT be allowed on platforms without stable ABI (Win9x, Win3.x, DOS).  
8. Plugins must never leak memory, block indefinitely, or exceed CPU budgets.  

============================================================
2. WHAT PLUGINS ARE ALLOWED TO DO
============================================================

Allowed:
- Provide new *render backends* (e.g., Vulkan experimental plugin)  
- Provide new *audio backends* (OpenAL soft, custom mix engines)  
- Provide new *input backends*  
- Provide *UI widgets* or render-pass overlays  
- Provide *file format handlers* for import/export  
- Provide *diagnostic tools*  
- Provide *profiling exporters*  
- Provide *launcher extensions*  

Conditionally allowed:
- Provide custom world editors  
- Provide alternative scripting runtimes (inside strict sandbox and not for core simulation)  
- Provide high-level automation layers  

Forbidden:
- Plugins cannot alter: physics, networks, power, fluid, AI, machines, workers, economy, RNG, ECS logic.  
- Plugins cannot issue arbitrary system calls.  
- Plugins cannot ship their own threads beyond the plugin worker pool.  
- Plugins cannot override determinism-critical engine functions.  
- Plugins cannot replace or shadow the core simulation DLL/EXE.  

============================================================
3. ABI AND API RULES
============================================================

### 3.1 ABI Definition
Dominium exposes a stable minimal ABI for plugins:
- C89-compatible  
- No C++ ABI  
- No STL  
- No compiler-dependent RTTI  
- No exceptions  
- Structs with fixed padding  
- Versioned ABI header  

Plugins implement symbol:
Dominium_Plugin_Init(const DominiumPluginAPI* api);

Engine loads plugin and passes function table.

### 3.2 API Exposure
Plugins get access to:
- logging API  
- profiling API  
- file IO (sandboxed)  
- platform info  
- renderer info  
- input events (filtered)  
- UI toolkit wrapper  
- serialization helpers  

Plugins DO NOT get access to:
- entity handles  
- ECS internals  
- simulation memory  
- chunk data  
- network state  

============================================================
4. PLUGIN ISOLATION
============================================================

### 4.1 Process Isolation (Optional)
On modern systems, plugins may run in:
- same process  
- OR separate process  

Separate process:
- improves stability  
- communicates via IPC  
- cannot crash engine  
- ideal for heavy tools  

### 4.2 Memory Safety
Engine allocates plugin memory on plugin’s behalf.  
Plugins cannot allocate arbitrary memory blocks.  
Allocator detects:
- leaks  
- double frees  
- out-of-bounds  

### 4.3 CPU Budget
Plugins have:
max_ms_per_frame = configurable

If exceeded → throttled next frame → logged → may be auto-disabled.

============================================================
5. CROSS-PLATFORM & LEGACY RULES
============================================================

### 5.1 Supported Platforms for Binary Plugins
- Windows 2000+  
- Linux  
- macOS 10.6–10.14 (Intel)  
- macOS ARM (requires fat binary)  
- Possibly consoles (with restrictions)  

### 5.2 NOT Supported
- MS-DOS  
- Windows 3.x  
- Windows 9x  
- Windows NT3–NT4 (plugin subsystem disabled)  
- macOS Classic  
- WebAssembly (no native plugins)  
- Android/iOS (except static-engine-provided plugins)

### 5.3 Graceful Degradation
If plugins are not supported:
- engine hides plugin menu  
- loads built-in defaults  
- ignores plugin directories  

============================================================
6. PLUGIN DIRECTORY STRUCTURE
============================================================

Dominium/
plugins/
myplugin/
plugin.cfg
plugin.bin (platform-specific)
data/
assets/

Legacy systems:  
Directory exists but unused.

============================================================
7. PLUGIN LIFECYCLE
============================================================

1. Engine startup  
2. Scan plugin directory  
3. Validate manifests  
4. Determine platform compatibility  
5. Load plugin binary (if supported)  
6. Call `Dominium_Plugin_Init()`  
7. Plugin registers extension points  
8. Plugin receives periodic callbacks:  
   - `on_frame_start`  
   - `on_frame_end`  
   - `on_ui_render`  
   - `on_input_event`  
   - `on_asset_load`  
9. Plugin termination on engine shutdown

Plugins NEVER receive:
- tick callbacks  
- simulation-step callbacks  
- network-update callbacks  

============================================================
8. EXTENSION POINTS
============================================================

### 8.1 Rendering
Plugins can:
- define new render pipelines  
- add diagnostic passes  
- inject overlays  
- provide fullscreen post-processing  
- provide custom shader systems  

### 8.2 Audio
Plugins can:
- provide alternative mixer  
- provide DSP chains  
- provide backend (e.g., WASAPI, JACK, PipeWire)

### 8.3 Input
Plugins can:
- support new devices  
- provide custom keymaps  
- provide VR controllers (future)

### 8.4 UI
Plugins can:
- add panels  
- add windows  
- add graphs  
- add toolbars  

### 8.5 File Formats
Plugins can:
- import/export 3D models  
- import/export heightmaps  
- import/export mod packages  
- import/export save metadata  

============================================================
9. SANDBOX FOR PLUGINS
============================================================

Plugins are isolated by:
- symbol tables  
- no direct memory pointers to engine  
- restricted file IO (only plugin folder)  
- no network access unless granted  
- no OS command execution  
- no unbounded thread creation  
- deterministic-safe wrappers for math  

Plugin resource usage capped:
- CPU  
- RAM  
- event callbacks  

If plugin misbehaves:
- engine throttles it  
- then disables it  
- simulation continues unaffected  

============================================================
10. SECURITY & INTEGRITY
============================================================

Plugins cannot:
- replace engine DLLs or EXEs  
- hook Win32 APIs  
- inject into simulation thread  
- modify replay system  
- inject network traffic  
- override deterministic core  

Optional anti-cheat mode disallows all binary plugins.

============================================================
11. VERSIONING & COMPATIBILITY
============================================================

Plugins must specify:
plugin_api_version = X.Y
engine_min_version = A.B
engine_max_version = C.D

Engine rejects:
- incompatible plugins  
- outdated plugins  
- plugins built for different OS/arch  

============================================================
12. DEVELOPER TOOLCHAIN
============================================================

Engine provides:
- C89 header-only SDK  
- static analyzer for unsafe calls  
- validator for plugin manifest  
- test harness  
- profiler hooks  
- plugin crash recovery testing  

SDK works on:
- Windows 2000–11  
- Linux  
- macOS  

Not compatible with DOS/Win3.x.

============================================================
13. SAMPLE USE CASES
============================================================

### 13.1 Vulkan Renderer Plugin
Optional future renderer without modifying core EXE.

### 13.2 Advanced Audio Plugin
High-end spatialization engine for users with strong PCs.

### 13.3 Diagnostic Plugin
External tool that streams profiler data elsewhere.

### 13.4 Model Import Plugin
FBX/GLTF importer for modders.

### 13.5 Dev Tool Integration
Editor integration plugin to support mapping tools.

============================================================
14. SUMMARY
============================================================

Volume 7.28 defines Dominium’s binary plugin system:

- deterministic, safe extension model  
- strict ABI and API limits  
- sandboxing and CPU/memory control  
- platform-aware loading  
- fail-safe disabling  
- optional native plugins on modern systems  
- no binary plugins on legacy builds  
- engine-provided SDK  
- robust versioning system  
- clear forbidden interactions to protect deterministic core  

Plugins extend *presentation* and *tooling*, never the simulation.

# END OF VOLUME 7.28

Next in order:
VOLUME 7.29 — INTERPROCESS COMMUNICATION & TOOLCHAIN INTEGRATION
(editor link, external automation, remote consoles, relay processes, safe IPC protocols)
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Ready to continue. Before generating Volume 7.29, I need a single clarification to avoid contradicting earlier architectural rules.
Volume 7.29: Interprocess Communication & Toolchain Integration can be built in two fundamentally different ways:

OPTION A — “Ultra-Safe IPC Core” (Recommended for determinism, legacy, purity)
IPC is:
text-only or binary-framed messages
strictly asynchronous
never tied into tick thread
never allowed to set simulation state
isolated sandbox process for editors, automation, monitoring
available even on Win2000, macOS 10.6, Linux
disabled entirely for Win9x/DOS
You get:
remote console
remote profiler
external editors
external automation tools
launcher communication
zero determinism impact
suitable for CD/DVD read-only builds
console-compatible
This is clean and matches everything we've built so far.

OPTION B — “High-Bandwidth IPC” (Risky)
IPC becomes capable of:
streaming chunk deltas
real-time world preview in an external editor
external pathfinding visualisation
external AI training
remote rendering pipelines
This is what Unreal/Unity do—but:
breaks legacy platform goals
introduces nondeterministic state races
requires async simulation corrections
complicates replay system
conflicts with headless server model
It can be done, but it changes engine philosophy away from deterministic minimalism.

OPTION C — Hybrid (balanced)
“Safe mode” = Option A
“Developer mode” = Adds selective Option B capabilities only when enabled, using strict locks
Still refuses to expose simulation thread directly
Can stream read-only world state (no writes)
Allows high-rate debug preview mirrors
Unsafe operations (simulation writes) remain completely forbidden
This is the middle ground.

I need one word: A, B, or C.
Which IPC architecture do you want as the foundation for Volume 7.29?
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.29 — IPC & TOOLCHAIN INTEGRATION, using Option C (Hybrid).
Single continuous Markdown block.

# VOLUME 7.29 — INTERPROCESS COMMUNICATION & TOOLCHAIN INTEGRATION  
Dominium Engine Specification — Engine Core, Part 29  
IPC Channels, External Tools, Remote Consoles, Editor Links, Safe/Dev Modes

Objective:  
Define how Dominium communicates with external processes and tools (editors, profilers, automation, launchers, monitors) without compromising determinism, security, or legacy support.

Architecture choice: **Hybrid (C)**  
- Mode 1: **SAFE IPC** — ultra-strict, read-only, zero-determinism-impact.  
- Mode 2: **DEV IPC** — higher-bandwidth read-only introspection for development, still no external writes to simulation.  

No mode allows external processes to directly mutate live simulation state.  
All mutations must go through in-engine deterministic command paths or debug mutation modes already defined.

============================================================
1. IPC PRINCIPLES
============================================================

1. IPC is optional. Game must run with IPC fully disabled.  
2. All IPC in SAFE mode is strictly read-only.  
3. DEV mode extends read-only bandwidth, does not add write access.  
4. Simulation can only be mutated by:
   - local player inputs  
   - in-engine debug mutation tools  
   - deterministic command scripts  
5. IPC must work on Win2000+, macOS 10.6+, Linux.  
6. IPC is disabled on DOS/Win3.x, and largely stubbed on Win9x.  
7. IPC must not alter tick ordering, RNG, or simulation scheduling.  
8. No external "remote authority" over simulation is allowed.  

============================================================
2. IPC CHANNEL TYPES
============================================================

Dominium supports three main IPC channels:

1. **Local Control Channel (LCC)**  
   - For launcher, local editor, local tools.  
   - Typically named pipes or local domain sockets.

2. **Remote Diagnostic Channel (RDC)**  
   - For remote console, remote profiler, remote viewer.  
   - TCP-based optional link.  

3. **File-Based Exchange (FBE)**  
   - For batch operations and legacy tools.  
   - Uses files written to a staging directory.  

All three operate in SAFE and DEV flavors.

============================================================
3. SAFE IPC MODE
============================================================

SAFE mode is always available when IPC is enabled.  
It provides:

- Text command input (console-style)  
- Read-only inspection commands  
- Streaming of low-rate profiling stats  
- Snapshot export triggers (world snapshot, perf snapshots, logs)  
- Launcher<->engine coordination  

SAFE mode must not:

- stream full chunk deltas continuously  
- stream full ECS state continuously  
- allow high-frequency external polls that affect performance  

Intended for:
- server operators  
- mod writers running minimal tools  
- low-end systems where overhead must be minimal  

============================================================
4. DEV IPC MODE
============================================================

DEV mode is explicitly opt-in, intended for development builds or local debugging.

Features in addition to SAFE:
- high-frequency perf data streaming  
- chunk metadata streaming (not full ECS internals)  
- read-only entity summaries (downsampled)  
- pathfinding/AI debug overlays exported live  
- replay debug hooks (tick markers, desync points)  
- high-resolution profiler streaming  

Still strictly:
- read-only  
- no external writes into simulation  
- deterministic simulation unaffected  

DEV mode may be forced off:
- in multiplayer servers with anti-cheat=on  
- in release builds on consoles  
- by user configuration  

============================================================
5. IPC TRANSPORTS BY PLATFORM
============================================================

### 5.1 Windows 2000+ / XP+ / modern
- Local: Named Pipes (`\\.\pipe\Dominium-LCC`), or localhost TCP.  
- Remote: TCP (with optional TLS in future).  

### 5.2 macOS 10.6+
- Local: UNIX domain sockets.  
- Remote: TCP.  

### 5.3 Linux
- Local: UNIX domain sockets or pipes.  
- Remote: TCP.  

### 5.4 Win9x
- Only file-based exchange and optional localhost TCP if stack is stable.  
- No domain sockets.  
- DEV mode largely disabled.

### 5.5 DOS / Win3.x
- No live IPC.  
- Only file-based exchange via batch tools (export/import snapshots).

============================================================
6. IPC MESSAGE FORMAT
============================================================

Messages are length-prefixed binary frames with a simple schema:

[4 bytes length][1 byte channel_type][1 byte msg_type][payload...]

Payload:
- either compact binary with fixed structures  
- or structured UTF-8 JSON for high-level tooling  

SAFE and DEV use same framing; DEV just allows higher rate and richer payloads.

Message categories:
- CONTROL (start/stop streaming, set filters)  
- QUERY (request snapshot, metrics, entity summary)  
- RESPONSE (snapshot, metrics, results)  
- EVENT (tick markers, faults, warnings, breakpoints)  

No write/simulation commands across IPC.

============================================================
7. LOCAL CONTROL CHANNEL (LCC)
============================================================

Used for:
- launcher<->engine coordination  
- local editor integration  
- local automation scripts  

Capabilities (SAFE/DEV):
- Start/stop profiling streams  
- Request world snapshots (read-only)  
- Request list of chunks / properties / companies  
- Request perf summary  
- Set debug filters (which subsystems to profile)  

No "execute command" that changes simulation.  
Console-like commands over LCC are limited to:
- toggling debug overlays  
- enabling/disabling profiling streams  
- retrieving info, not modifying world.

============================================================
8. REMOTE DIAGNOSTIC CHANNEL (RDC)
============================================================

TCP-based, remote or localhost.

Intended for:
- remote server administration  
- dev remote tools (e.g. one machine running Dominium, another running analyzer / visualizer)  

SAFE mode:
- read-only console (info commands only)  
- profiling streams (downsampled)  
- logs streaming  

DEV mode:
- high-rate profiler  
- high-rate pathfinding visual traces  
- network stats  
- replay markers  

RDC must be:
- disabled by default in release builds  
- enabled by explicit command-line or config  
- optionally password-protected (simple shared secret)  

============================================================
9. FILE-BASED EXCHANGE (FBE)
============================================================

Used for:
- legacy OSes (DOS, Win3.x)  
- offline tools  
- batch tasks  

Directory:
tools/ipc_in/
tools/ipc_out/

Engine periodically scans `ipc_in` for command files:
- JSON / TOML / INI  
- low rate (e.g. once per second)  

Supported commands:
- export snapshot  
- export perf log  
- export ECS dump  
- export environment metadata  

Engine writes results to `ipc_out` as files.

No live control, no streaming, no simulation writes.

============================================================
10. TOOLCHAIN INTEGRATION TARGETS
============================================================

Designed to connect to:
- World/Map editor  
- Asset pipeline tools  
- Performance analyzers  
- External replay viewers  
- Custom mod development tools  
- CI systems (headless verification runs)  

All via SAFE / DEV IPC; simulation remains closed to external writes.

============================================================
11. WORLD/EDITOR IPC INTEGRATION
============================================================

Editor may connect using LCC or RDC.

Allowed:
- fetch chunk heightmaps  
- fetch structural blueprint data  
- fetch entity metadata (IDs, positions, basic type)  
- visualize networks (power/data/fluid)  
- send *patch proposals* as files (FBE) or commands, but these proposals are:
  - not applied live  
  - only applied when loaded via world editor or world-merge tool  
  - never injected into a running simulation directly  

Live editing of a running dedicated world is prohibited via IPC.  
Only in-engine debug tools (7.26) can mutate live state, and that is local, explicit, and marked noncanonical.

============================================================
12. PROFILER & DEBUGGER IPC STREAMS
============================================================

Exposes the existing profiling (7.25) and debugging (7.26) data over IPC:

Streams:
- tick timings  
- subsystem costs  
- ECS counts  
- pathfinding stats  
- network packet stats  
- AI metrics  
- memory usage  
- replay desync data  

SAFE mode: limited frequency (e.g. 1–4 Hz).  
DEV mode: full frequency, constrained only by CPU budget and bandwidth config.

============================================================
13. REPLAY & TEST AUTOMATION INTEGRATION
============================================================

IPC assists automated tests:

- command to start a replay from a given file  
- query current tick and replay position  
- query determinism hash at intervals  
- export logs on completion  
- notify external tool of desync or crash  

All these remain read-only; they drive engine via command-line flags and startup parameters, not via live tick injection.

============================================================
14. SECURITY & SANDBOXING
============================================================

IPC is a potential attack surface. Rules:

- IPC endpoints are disabled by default unless enabled in config/CLI.  
- No arbitrary file access through IPC.  
- No command that writes user or system files outside authorized directories.  
- No remote code execution.  
- No shell commands.  
- No simulation mutation commands.  

Optional shared-secret authentication for RDC:
- simple HMAC over each frame  
- or pre-handshake token  

If auth fails → close connection.

============================================================
15. DETERMINISM SAFETY RULES
============================================================

IPC cannot:
- adjust UPS/FPS  
- schedule ticks  
- call into Lua or C simulation logic directly  
- insert or reorder simulation commands  
- modify RNG state  
- change physics or network propagation  

Even dev IPC is *introspective only*.

Any workflow that changes simulation must:
- go through deterministic paths defined elsewhere (e.g. debug console or editor)  
- and be flagged as noncanonical (for replays/achievements).  

============================================================
16. CONFIGURATION & MODES
============================================================

Config: `settings/ipc.cfg`:

Key fields:
ipc_enabled = true/false
ipc_mode = "off" / "safe" / "dev"
ipc_lcc_enabled = true/false
ipc_rdc_enabled = true/false
ipc_rdc_port = int
ipc_rdc_auth_token = "string"
ipc_fbe_enabled = true/false
ipc_perf_stream_rate_safe = Hz
ipc_perf_stream_rate_dev = Hz

Profiles can override per-machine; worlds/universes may require `ipc_mode = off` (e.g. competitive multiplayer servers).

Anti-cheat/strict mode:
- forces `ipc_mode = off` or `safe` only.  
- disallows DEV.

============================================================
17. LEGACY/MINIMAL IMPLEMENTATION
============================================================

DOS / Win3.x:
- only file-based exchange (FBE)  
- periodic scanning, low rate  

Win9x:
- FBE  
- optional localhost TCP for SAFE-mode RDC if stack allows  

Headless servers:
- LCC via named pipes or domain sockets  
- RDC for remote admin  
- FBE for batch operations  

============================================================
18. ERROR HANDLING & RECOVERY
============================================================

If IPC connections misbehave:
- rate limit  
- drop connection  
- log incident  

If external tool floods engine:
- apply throttling  
- degrade DEV streams down to SAFE rates  
- optionally disable IPC for session  

No IPC error may crash the engine or stall the simulation.

============================================================
19. SUMMARY
============================================================

Volume 7.29 defines Dominium’s IPC and toolchain integration architecture:

- **SAFE IPC**: read-only, low-rate, for operators and basic tools.  
- **DEV IPC**: high-bandwidth read-only introspection for development and advanced tooling.  
- No external write access to live simulation state.  
- LCC for local tools and launcher integration.  
- RDC for remote diagnostic and profiling.  
- FBE for legacy OSes and batch workflows.  
- Strict security and determinism boundaries.  
- Cross-platform transport abstraction.  
- Integration with profilers, debug tools, editors, replay automation, CI.  

Dominium exposes its internals for analysis and tooling, not for remote control of simulation.

# END OF VOLUME 7.29

Next in order for the engine core:
VOLUME 7.30 — BUILD SYSTEM, TARGET MATRICES & RELEASE CONFIGURATION
(platform targets, compiler flags, build profiles, LTO/optimisation, legacy builds, debug/release matrix)
If you want that, say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.30 — BUILD SYSTEM, TARGET MATRICES & RELEASE CONFIGURATION as a single continuous Markdown block.

# VOLUME 7.30 — BUILD SYSTEM, TARGET MATRICES & RELEASE CONFIGURATION  
Dominium Engine Specification — Engine Core, Part 30  
Compiler Targets, Legacy Modes, Build Profiles, Release Packaging

Objective:  
Define a unified, deterministic, cross-platform build system supporting all core platforms (Win2000+, macOS 10.6+, Linux) and future legacy/platform expansions.  
All builds must be reproducible, version-locked, dependency-minimal, and suitable for physical media distribution.

============================================================
1. BUILD SYSTEM OVERVIEW
============================================================

Build system: **CMake-driven**, but with mandatory deterministic constraints:
- No auto-detect features that would change build output.  
- All platform capabilities must be explicitly declared in toolchain files.  
- All optional subsystems must be toggled via config, not autodetected.  
- No compiler-generated nondeterminism (timestamps, GUIDs, etc).  
- Strict version pinning of compilers, linkers, and libraries.  
- Reproducible builds across OS.  

Core toolchain languages:
- **C89** for engine foundation.  
- **C++98** for higher-level systems.  
- **Lua 5.1** (or customized 5.1 fork) embedded.  

Dependencies minimized to:
- SDL1/SDL2 (optional)  
- OpenGL stub headers  
- Optional DirectX9/11 headers  
- stb_* or equivalent single-file libraries  
- zlib or miniz  
- Ogg/Vorbis (optional)  
- No OS package manager dependencies  

============================================================
2. PLATFORM TARGET GROUPS
============================================================

Platforms are grouped into tiers to avoid fragmentation.

### 2.1 Tier 1 (Primary, always supported)
- Windows 2000 / XP / Vista / 7 / 8 / 10 / 11  
- macOS 10.6 – macOS 10.15+ (x86_64 & Rosetta)  
- Linux (glibc >= 2.3; kernel >= 2.6)  

These share:
- SDL1, SDL2, OpenGL, DirectX9 (Windows only)  
- identical determinism core  
- same replay system  
- same renderer interface  

### 2.2 Tier 2 (Secondary / later integration)
- Win9x  
- macOS 10.0–10.5  
- legacy Linux  
- Android  
- iOS  
- WebAssembly  

Tier 2 requires a “Legacy Platform HAL Layer” build.

### 2.3 Tier 3 (Console and special hardware)
- PlayStation family  
- Xbox family  
- Nintendo family  
- Handhelds  

Tier 3 uses:
- vendor toolchains  
- static renderer switches  
- cross-compilation with hard restrictions  
- no dynamic loading  
- no external Lua JIT  
- deterministic only if vendor allows fixed FP modes  

============================================================
3. COMPILER TARGETS & FLAGS
============================================================

Every platform receives a fully deterministic compiler specification.

### 3.1 Windows (MSVC)
- MSVC 2010 or MSVC 2015 toolchain for broadest compatibility  
- `/TC`, `/TP`  
- `/O2` or `/Ox` depending on profile  
- `/fp:strict` or `/fp:precise` (never `/fast`)  
- `/GS-` (stack cookies off for reproducibility)  
- `/GR-` (no RTTI)  
- `/EHsc`  
- `/Z7` or `/Zi` for debug builds  

### 3.2 Windows (MinGW)
- gcc 4.7–4.9 recommended for legacy target  
- `-std=c89` / `-std=c++98`  
- `-ffloat-store` for strict FP  
- `-fno-thread-jumps`, `-fno-crossjumping`  
- `-fno-ipa-*`  
- `-fno-asynchronous-unwind-tables`  
- `-fno-cx-limited-range`  

### 3.3 macOS (Clang)
- clang 3.5–7.0 depending on deployment target  
- `-std=c89`, `-std=c++98`  
- `-fno-builtin`  
- `-ffp-model=strict`  
- `-fno-unwind-tables`  
- `-Wno-deprecated-declarations` for SDL1  

### 3.4 Linux (GCC or Clang)
- GCC 4.7+ or Clang 3.5+  
- identical flags to macOS/gcc equivalents  
- deterministic linking via `--build-id=none`  

============================================================
4. BUILD PROFILES
============================================================

Dominium supports 5 canonical profiles:

1. **debug**  
   - no optimizations  
   - asserts enabled  
   - all IPC dev streams enabled  
   - debug console unlocked  

2. **dev**  
   - O1/O2  
   - partial asserts  
   - DEV IPC enabled  
   - profiling instrumentation enabled  

3. **release-debug**  
   - O2/Ox  
   - no asserts  
   - deterministic build  
   - debug symbols included  
   - no DEV IPC  

4. **release**  
   - O2/Ox  
   - deterministic  
   - stripped symbols  
   - SAFE IPC only  
   - no editor integrations  

5. **legacy**  
   - minimal subsystem build  
   - integer mixer only  
   - OpenGL 1.1-only or DX7 stubs  
   - reduced memory footprint  
   - static linking  
   - Win2000 and PowerPC Mac supported  

============================================================
5. RENDERER-TARGET EXCLUSION MATRIX
============================================================

Some renderer/platform combinations are forbidden:

| Platform | GL1 | GL2 | DX9 | DX11 | Software | SDL1 | SDL2 | Native |
|----------|-----|-----|-----|------|----------|------|------|--------|
| Win2000  | ✓   | ✓   | ✓   | ✗    | ✓        | ✓    | ✓    | ✓      |
| WinXP    | ✓   | ✓   | ✓   | ✓    | ✓        | ✓    | ✓    | ✓      |
| macOS10.6| ✓   | ✓   | ✗    | ✗    | ✓        | ✗    | ✓    | ✓      |
| Linux    | ✓   | ✓   | ✗    | ✗    | ✓        | ✗    | ✓    | ✓      |
| Win9x    | ✓   | ✗    | ✓    | ✗    | ✓        | ✓    | ✗    | ✓      |
| DOS      | ✗   | ✗    | ✗    | ✗    | ✓        | ✗    | ✗    | ✓      |

DX11 and DX12 are excluded from old Windows targets.  
GL2 requires hardware; GL1 must always be available.

============================================================
6. BUILD OUTPUT STRUCTURE
============================================================

All builds output into a uniform structure:

bin/
win32/
win64/
macos/
linux/
legacy/
data/
mod_base/
mod_tools/
sdk/
res/
doc/

Executables follow naming convention:
dominium_client_<platform><renderer>.exe
dominium_server<platform>.exe
dominium_headless_<platform>.exe
dominium_tools_<platform>.exe

Legacy builds use suffix:
dominium_client_win9x.exe
dominium_client_dos.exe

============================================================
7. REPRODUCIBLE BUILDS
============================================================

Rules:
- No timestamps in binaries.  
- No embedded absolute paths.  
- Deterministic archive ordering.  
- Identical builds across machines.  
- Save version manifest containing:
  - compiler version  
  - linker version  
  - dependency versions  
  - build flags  
  - source commit hash  

Hash: SHA256 of entire source tree + config.

============================================================
8. EMBEDDED RESOURCE POLICIES
============================================================

Allowed:
- PNG, OGG, WAV, JSON, Lua  
- Must be version-stamped  
- Must not load platform-specific data unless renderer requires it  

Prohibited:
- compiler-built resource blobs  
- OS-specific metadata  
- non-deterministic config (XML with timestamps)  

============================================================
9. PACKAGING FOR DISTRIBUTION
============================================================

### 9.1 Digital distributions (Steam, GOG, Website)
- Use “platform packs”:  
  - `windows_pack.zip`  
  - `macos_pack.zip`  
  - `linux_pack.tar`  
- Core data identical across all packs.  
- Mods, DLCs packaged as separate `.dommod` archives.

### 9.2 Physical CD/DVD
Disc layout must be stable:
/setup.exe
/bin/
/data/
/mods/
/doc/
/extras/
/bootstrap/

Launcher must detect all OS versions on disc and choose correct binary.

### 9.3 Floppy disks
Used for legacy MS-DOS / Win3.x versions:
- multi-disk install  
- compressed CAB or ZIP sets  
- minimal 2D vector-only build  

============================================================
10. SPECIAL-CASE BUILDS
============================================================

### 10.1 Headless
- no renderer  
- no audio mixer  
- minimal SDL  
- no Lua hot-reload  
- SAFE IPC only  

### 10.2 Toolchain Bundle (SDK)
- C headers  
- Lua API  
- modding tools  
- content pipeline scripts  

### 10.3 Replay-Verifier Build
- deterministic asserts  
- internal integrity checks  
- forced single-threaded deterministic execution  

============================================================
11. COMMAND-LINE BUILD CONFIGURATION
============================================================

Canonical flags:
-DTARGET_PLATFORM=win32|win64|macos|linux|win9x|dos
-DBUILD_PROFILE=debug|dev|release|release_debug|legacy
-DRENDERER=gl1|gl2|dx9|dx11|software|auto
-DIPC_MODE=off|safe|dev
-DLEGACY_SUPPORT=on|off

All flags must be explicitly declared.  
No fallback to autodetection.

============================================================
12. VERSIONING
============================================================

Semantic versioning with engine and data separated:

- Engine: `major.minor.patch`  
- Data: `data.major.minor`  
- Modding SDK: `sdk.major.minor`  

All version tuples stored in build manifest and world saves.

============================================================
13. SUMMARY
============================================================

Volume 7.30 defines Dominium’s full build and release system:

- CMake-based deterministic builds  
- strict toolchain control  
- 5 canonical profiles  
- full multi-platform matrix  
- legacy support path  
- deterministic binary reproduction  
- structured output directories  
- stable packaging rules for digital and physical editions  
- version manifest for verification and replays  

This establishes the foundation for maintainable long-term development and ensures that every binary for every platform behaves deterministically.

# END OF VOLUME 7.30

Next is Volume 7.31 — Renderer & Platform Binding Layer (how renderer DLLs/executables bind to the platform layer, how selection works in the launcher, plugin I/O, fallbacks, GL/DX bridging, etc).
Say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood. Proceeding with VOLUME 7.31 — RENDERER & PLATFORM BINDING LAYER now.
Single continuous Markdown block follows.

# VOLUME 7.31 — RENDERER & PLATFORM BINDING LAYER  
Dominium Engine Specification — Engine Core, Part 31  
Renderer DLLs, Platform HAL, Driver Abstractions, Launcher/Runtime Binding

Objective:  
Define the full abstraction layer between the Dominium Platform HAL (windowing, input, timing, files, OS calls) and each Renderer Backend (GL1, GL2, DX9, DX11, SW).  
This layer must guarantee deterministic simulation regardless of renderer, OS, or hardware.

============================================================
1. ARCHITECTURAL OVERVIEW
============================================================

Core rule: **Renderer must be an isolated module** that cannot affect simulation determinism.

Architecture stack:

┌──────────────────────────────┐
│ DOMINIUM GAME │
│ (Simulation, Logic, UI) │
└─────────────▲────────────────┘
│
┌─────────────┴────────────────┐
│ PLATFORM HAL (PHAL) │
│ Window/Input/Audio/OS/Files │
└─────────────▲────────────────┘
│
┌─────────────┴────────────────┐
│ RENDERER BINDING LAYER │
│ (Renderer API v1: common) │
└─────────────▲────────────────┘
│
┌─────────────┴────────────────┐
│ RENDERER BACKENDS │
│ gl1 / gl2 / dx9 / dx11 / sw │
└──────────────────────────────┘

Simulation never calls renderer directly.  
Renderer calls are batched via **Renderer Commands**.

============================================================
2. RENDERER API v1 (UNIFIED INTERFACE)
============================================================

Every backend exposes exactly the same C89 function signature set:

### 2.1 Initialization
bool REN_Init(const REN_Config* cfg);
void REN_Shutdown(void);

### 2.2 Frame lifecycle
void REN_BeginFrame(void);
void REN_EndFrame(void);

### 2.3 Resource creation
REN_Handle REN_CreateTexture(const REN_TexDesc*);
REN_Handle REN_CreateMesh(const REN_MeshDesc*);
REN_Handle REN_CreateShader(const REN_ShaderDesc*);
REN_Handle REN_CreateMaterial(const REN_MaterialDesc*);

### 2.4 Resource destruction
void REN_Destroy(REN_Handle h);

### 2.5 Rendering commands
void REN_DrawMesh(REN_Handle mesh, REN_Handle material, const REN_Transform*);
void REN_DrawUI(const REN_UICommandList*);
void REN_SetCamera(const REN_CameraDesc*);

### 2.6 Capability queries
void REN_QueryCaps(REN_Caps* out);

All structures must be deterministic (no padding, fixed sizes, fixed endian).

============================================================
3. RENDERER BACKEND MODULES
============================================================

Renderer backends are built as **DLLs/shared objects** (except for legacy builds which may be static).

Backends:

| Backend | Purpose | Notes |
|---------|---------|-------|
| gl1     | Lowest HW target, software-feasible | Used for Win2000, Win9x fallback |
| gl2     | Main cross-platform renderer        | Used for Linux, macOS 10.6+ |
| dx9     | High performance on XP–Win11        | Primary Windows backend |
| dx11    | Optional modern backend             | Win7–Win11 only |
| sw      | Full software rasterizer            | Deterministic, slow, legacy |

Naming:
renderer_gl1.dll
renderer_gl2.dll
renderer_dx9.dll
renderer_dx11.dll
renderer_sw.dll

macOS uses `.dylib`, Linux uses `.so`.

============================================================
4. PLATFORM HAL (PHAL)
============================================================

PHAL isolates OS differences and exposes a unified interface (C89):

PHAL subsystems:
- Window creation  
- Input (keyboard, mouse, controllers)  
- Cursor/clipboard  
- File I/O  
- High-resolution timers  
- Dynamic loading (DLL/so/dylib)  
- Threading (restricted to renderer/audio/helper threads)  
- Pixel formats  
- Swap chains  

Renderer never touches OS APIs directly.  
Renderer must request:
- Window handle  
- GL context  
- DX device pointers (via PHAL wrapper)  

============================================================
5. RENDERER LOADING & SELECTION
============================================================

Selection order:

1. **Launcher** determines supported platforms/renderers using:
   - OS version  
   - GPU capabilities  
   - user preferences  
   - profile settings  

2. Launcher writes chosen renderer to launch parameters.

3. At startup engine:
renderer = PHAL_LoadModule("renderer_dx9.dll");
if (!renderer) fallback to next candidate

4. If no renderer works:
   - fallback to software renderer  
   - or headless mode  

Renderer module required exports:
REN_GetAPIVersion();
REN_GetInterfaceTable();

============================================================
6. RENDERER COMMAND BUFFER (DETERMINISTIC)
============================================================

Simulation and renderer are decoupled via command buffers:

REN_CmdBuffer {
uint32 count;
REN_Cmd commands[MAX_CMDS];
}

Simulation produces:
- Draw calls
- UI operations
- Overlay operations
- Debug visuals

Renderer consumes buffer exactly once per frame.

Determinism:
- Command buffer is generated from deterministic simulation state  
- Renderer is never allowed to modify the simulation  
- Renderer never touches floating-point data that feeds back into simulation  
- All randomness must be seeded via deterministic pathways  

============================================================
7. FLOATING POINT SAFETY
============================================================

Renderer may use:
- native FP hardware  
- SSE/AVX  
- vendor driver math  

Simulation cannot.

Renderer FP divergence does not affect simulation determinism.

============================================================
8. SHADER MANAGEMENT
============================================================

### 8.1 DX9/DX11
- Precompiled shader bytecode  
- No runtime compilation  
- All shaders shipped with game  

### 8.2 GL1
- No shaders (fixed pipeline)  
- Material system downgraded automatically  

### 8.3 GL2
- GLSL preprocessed  
- No runtime generation  
- On startup, compile minimal set  
- Deterministic fallback if driver quirks detected  

============================================================
9. SOFTWARE RENDERER
============================================================

Purposes:
- Deterministic debugging  
- Legacy platforms  
- Reference images for testing  

Capabilities:
- 2D vector mode  
- 2D bitmap mode  
- Limited 3D shading (flat, gouraud)  
- No heavy features (shadows, SSAO, PBR)  

100% integer math.  
Replays match exactly across machines.

============================================================
10. FRAME TIMING & VSYNC
============================================================

Renderer may:
- attempt vsync  
- render as fast as allowed  

Simulation tick is independent:
- renderer slowdown cannot slow UPS  
- simulation slowdown is communicated separately  

============================================================
11. MULTIPLE RENDERER MODES (VISUAL LEVELS)
============================================================

Renderer must support the visual level system:

| Level | Mode | Purpose |
|-------|-------|---------|
| 0 | headless / TUI | servers, DOS |
| 1 | 2D vector | low-end machines |
| 2 | 2D texture + vector | mid-tier |
| 3 | full 3D | normal gameplay |

Renderer backends must expose which levels they support via `REN_QueryCaps`.

============================================================
12. DEBUG & VISUALIZATION
============================================================

Renderers must support:
- debug overlays (grids, wireframes, bounding boxes)  
- network visualizers (pipes, power, data)  
- lighting debug mode  
- frustum visualization  
- pathfinding debug meshes  

These are fed via command buffer and do not affect simulation.

============================================================
13. FALLBACK POLICY
============================================================

If renderer crashes or fails init:
- log  
- unload  
- try next backend  
- if all fail → software renderer  
- if software fails → headless  

If headless works, game still runs (e.g. for servers or tools).

============================================================
14. HOT-SWAP MODEL (OPTIONAL)
============================================================

Renderer hot-swap allowed only:
- outside simulation tick  
- only between frames  
- renderer must release all resources  
- engine must rebuild all GPU resources  

Used for:
- switching between GL1/GL2  
- fallback from DX9 to GL2  
- debugging graphics issues  

Not available:
- during multiplayer authoritative play  
- in legacy platforms or software renderer  

============================================================
15. PLATFORM-RENDERER EDGE CASES
============================================================

### Windows 2000:
- DX9 fully supported  
- GL2 may crash → fallback to GL1  

### macOS 10.6:
- only GL2  
- no SDL1 recommended  

### Linux:
- GL2 expected  
- GL1 fallback mandatory  
- Software renderer available  

### Win9x:
- DX9 may be unstable  
- GL1 only  
- Software renderer  

============================================================
16. DETERMINISM GUARANTEES
============================================================

Renderer must not:
- write into simulation memory  
- schedule work that affects simulation  
- feed timestamps back into simulation  
- access game logic threads  
- change simulation tick rate  

Renderer is purely presentational.

============================================================
17. SUMMARY
============================================================

Volume 7.31 defines:

- unified Renderer API v1  
- platform-indifferent binding through PHAL  
- DLL-based renderer modules  
- deterministic command-buffer architecture  
- safe fallback hierarchy  
- shader policies per backend  
- hot-swapping rules  
- strict FP isolation from simulation  
- multi-level visual modes (0–3)  
- guaranteed playability on Win2000+ and macOS 10.6+  
- future support path for legacy and consoles  

# END OF VOLUME 7.31

Next in sequence is:
VOLUME 7.32 — Input System (Deterministic Input Pipeline, Devices, Remapping, Replay Integration).
Say Proceed to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.32 — INPUT SYSTEM, deterministic, platform-agnostic, and fully replay-compatible.
Single continuous Markdown block.

# VOLUME 7.32 — INPUT SYSTEM  
Dominium Engine Specification — Engine Core, Part 32  
Deterministic Input Pipeline, Device Abstraction, Remapping, Replay Layer

Objective:  
Define a unified, deterministic input layer that works across Win2000+, macOS 10.6+, Linux, legacy systems, and future consoles.  
The system must support replays, multiplayer, hotplugging, and multiple input classes (keyboard, mouse, controllers, touch).

============================================================
1. CORE PRINCIPLES
============================================================

1. Input must be **fully deterministic** once captured.  
2. Input ingestion must be **frame/time independent**.  
3. Input affects **only the next simulation tick**, never the current one.  
4. All input is converted into a **canonical event format** before being used.  
5. Replays store canonical input events.  
6. Multiplayer sends canonical input events over the network.  
7. Input cannot directly call gameplay logic — only through the deterministic dispatcher.  
8. No OS-specific behaviour allowed (no double-click intervals, no OS key repeat).  
9. PHAL captures raw input only; engine sanitises it.

============================================================
2. INPUT SYSTEM LAYERS
============================================================

┌────────────────────────────┐
│ PHAL INPUT CAPTURE │
│ (Raw Keyboard/Mouse/etc) │
└───────────────▲────────────┘
│
┌───────────────┴────────────┐
│ INPUT NORMALIZER │
│ (Device → Canonical) │
└───────────────▲────────────┘
│
┌───────────────┴────────────┐
│ INPUT BUFFER (TICK) │
│ Deterministic event store │
└───────────────▲────────────┘
│
┌───────────────┴────────────┐
│ INPUT DISPATCHER (Sim) │
│ Commands → Game Actions │
└─────────────────────────────┘

Each layer is strictly ordered and deterministic.

============================================================
3. PHAL INPUT CAPTURE
============================================================

PHAL provides raw device readings:

### 3.1 Supported raw devices
- Keyboard  
- Mouse  
- Gamepads (XInput, DirectInput, HID, SDL)  
- Touch (later expansion)  
- Joysticks / Flight sticks (HID)  
- Tablet-like inputs (absolute coordinate)  
- Scroll wheels  
- Buttons on external devices  

### 3.2 Raw data rules
- Must be time-stamped via PHAL monotonic clock  
- Must not apply smoothing  
- Must not apply OS key repeat  
- Must not interpret double-click  
- Must not apply acceleration  
- Must not apply deadzones (handled later)

### 3.3 Platform specifics
- Win2000+ → RawInput or DirectInput minimal fallback  
- macOS 10.6+ → Carbon/HID → SDL wrapper  
- Linux → X11, evdev, or SDL  

PHAL only captures; interpretation happens later.

============================================================
4. INPUT NORMALIZER
============================================================

The normalizer converts raw values into canonical engine events.

### 4.1 Canonical event types
EV_KEY_DOWN (keycode)
EV_KEY_UP (keycode)
EV_MOUSE_MOVE (dx, dy)
EV_MOUSE_ABS (x, y)
EV_MOUSE_BTN (id, state)
EV_MOUSE_WHEEL (delta)
EV_PAD_BTN (id, state)
EV_PAD_AXIS (id, value)
EV_TOUCH (id, state, x, y)
EV_TEXT (unicode)

### 4.2 Device-independent representation
Keycodes use Dominium’s custom **DOM_KEY** enumeration, not OS or SDL codes.

Mouse:
- always relative for game actions  
- absolute coordinates used only for GUI  

Gamepads:
- axis normalized to [-32768, 32767]  
- applied deadzones deterministically using fixed integer thresholds  

### 4.3 Language input (text)
Text entry uses:
- EV_TEXT events  
- Unicode codepoints  
- no OS composition or IME allowed in deterministic mode  
- optional IME in non-deterministic UI-only mode (text fields) but never used in gameplay

============================================================
5. INPUT BUFFER (PER-TICK)
============================================================

The input buffer is the deterministic barrier.

Rules:
- Input events for tick N are fully collected before simulation tick N begins.  
- Buffer uses a fixed struct:
struct TickInput {
uint32 count;
DOM_InputEvent events[MAX_INPUT_EVENTS];
};
- If more events occur than allowed, buffer truncates *deterministically with overflow flag*.  
- Buffer is included in replay files.  
- Input order is preserved.  
- No event reordering.

============================================================
6. INPUT DISPATCHER
============================================================

Dispatcher translates canonical input events into **game commands**.

Dispatcher is fully deterministic:
- same input → same commands  
- same commands → same simulation behaviour  

### 6.1 Action mapping
Actions include:
- MoveForward  
- MoveBackward  
- TurnLeft  
- UseTool  
- Build  
- OpenMenu  
- ToggleOverlay  
- etc.

Keybindings:
- stored as deterministic config  
- cannot depend on OS keyboard layout  
- QWERTY, AZERTY, Dvorak handled internally  
- remapping supported via stable IDs

### 6.2 Filtering
Dispatcher applies:
- deadzones  
- sensitivity (deterministic scalar)  
- fixed-step mouse smoothing (if enabled)  
- repeat (engine-driven, not OS-driven)

### 6.3 Output
Dispatcher outputs an array of **Simulation Commands**:
SimCmd_Move(dx, dy)
SimCmd_Interact(entity)
SimCmd_UI_Open(panel_id)
SimCmd_Build(blueprint_id)
Commands are consumed by the tick pipeline.

============================================================
7. REPLAY SYSTEM INTEGRATION
============================================================

Replays store:
- tick number  
- input buffer for each tick  

Replay playback:
- loads TickInput for tick N  
- bypasses PHAL and normalizer  
- feeds buffer directly to dispatcher  

Deterministic guarantee:
- replays reproduce identical game states  
- user input is only data recorded  
- renderer, audio, platform do not change outcome  

============================================================
8. MULTIPLAYER INTEGRATION
============================================================

Dominium uses lockstep deterministic multiplayer.

Only **canonical input events** (not raw device states) are transmitted over the network.

Packet:
struct NetInputPacket {
uint32 tick;
uint16 player_id;
uint16 event_count;
DOM_InputEvent events[];
}

Server:
- verifies input arrives before tick deadline  
- queues inputs in global input buffer  
- sends authoritative tick hash summaries  

Latency management:
- client prediction uses local commands  
- rollback allowed if server mismatch is detected  
- input buffering window adjustable (3–10 ticks)

============================================================
9. HOTPLUGGING
============================================================

Supported for:
- gamepads  
- joysticks  
- mice  
- keyboards (USB reattach)

PHAL notifies engine:
EV_DEVICE_ADDED
EV_DEVICE_REMOVED

Input normalizer updates device registry deterministically.

============================================================
10. LEGACY PLATFORM BEHAVIOUR
============================================================

### 10.1 Win9x
- Keyboard + Mouse only  
- No raw HID  
- No XInput  
- No advanced gamepad features  

### 10.2 DOS
- Only keyboard (int 16h) and relative mouse (int 33h)  
- Device hotplug not supported  

### 10.3 macOS ≤ 10.7
- Legacy HID path  
- No native gamepad detection  
- SDL recommended  

### 10.4 Linux legacy (<2.6)
- X11 only  
- No evdev features  

============================================================
11. SECURITY & SANDBOXING
============================================================

Input system must not:
- capture OS-global shortcuts  
- capture admin/system-level keys  
- allow injection from external processes unless explicitly allowed (for automation tools)  
- use OS clipboard without permission  
- create keylog-like functionality  

IPC cannot inject input directly into simulation.  
Only deterministic command injection is permitted (debug only).

============================================================
12. UI INPUT PATH (NON-DETERMINISTIC)
============================================================

UI layer (menus, launcher, in-game GUI) uses:
- direct PHAL→UI events  
- not routed through deterministic pipeline  

UI input does not affect simulation state.  
This separation is critical for:
- deterministic replays  
- network lockstep  
- safe IME support  
- accessibility features  

============================================================
13. ACCESSIBILITY
============================================================

Accessibility adapters must not break determinism.  
They operate on UI-only layer:
- remapping  
- screen readers  
- raw-to-virtual conversion  
- sensitivity multipliers  
- alternative device mappings  

Gameplay determinism unaffected.

============================================================
14. CONFIGURATION FILES
============================================================

All input mappings stored in:
config/input.map

Format:
action_id = [list of bindings]

Bindings:
keyboard:KEY
mouse:BTN
mouse:AXIS
pad:BTN
pad:AXIS
touch:POINT

Must be portable across OS.

============================================================
15. SUMMARY
============================================================

Volume 7.32 defines a complete deterministic input system:

- PHAL captures raw input  
- Normalizer converts to canonical format  
- Tick input buffer ensures determinism  
- Dispatcher creates deterministic simulation commands  
- Replays store only canonical input  
- Multiplayer sends canonical input only  
- No OS-dependent behaviour allowed  
- UI input is non-deterministic and separate  
- Legacy support preserved  
- Hotplugging supported  
- Security preserved  
- Configuration stable and portable  

This ensures absolute simulation reproducibility across all platforms while supporting modern and legacy input devices.

# END OF VOLUME 7.32

Next in sequence:
VOLUME 7.33 — SAVEGAME SYSTEM, SNAPSHOTS, WORLD SERIALIZATION & COMPATIBILITY RULES
Say Proceed to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.33 — SAVEGAME SYSTEM, SNAPSHOTS, WORLD SERIALIZATION & COMPATIBILITY RULES now.
Single continuous Markdown block.

# VOLUME 7.33 — SAVEGAME SYSTEM, SNAPSHOTS, WORLD SERIALIZATION & COMPATIBILITY RULES  
Dominium Engine Specification — Engine Core, Part 33  
Canonical Save Format, Chunk Storage, Snapshots, Recoverability, Version Upgrades

Objective:  
Define the entire persistence system for Dominium: world saves, snapshots, universe metadata, version compatibility, rollback, recovery, and mod interactions.

The save system must be:
- deterministic  
- cross-platform  
- compatible with Win2000+, macOS 10.6+, Linux  
- extensible but stable  
- supporting rollback, replay, and desync-tracking  
- mod-friendly  
- DLC-friendly  
- scalable to planetary/universe levels  

============================================================
1. CORE PRINCIPLES
============================================================

1. Saves must be portable and byte-identical across platforms.  
2. Saves must not contain platform-specific data (paths, timestamps, GPU info).  
3. Saves must store all simulation state required to resume deterministically.  
4. Rendering, audio, UI, and platform state are excluded.  
5. Saves must support:
   - full world save  
   - partial/chunk save  
   - metadata-only save  
6. Saves must embed mod and DLC manifest.  
7. Saves must be recoverable after partial corruption via chunk redundancy.  
8. Save format must remain stable for decades (long-term preservation).

============================================================
2. SAVEFILE CONTAINER FORMAT
============================================================

Container format: **DOMSAVE v1**  
A deterministic archive wrapper.

On disk:
<save>.dom

Internally:
- Header block  
- Manifest block  
- World metadata block  
- Chunk data blocks  
- Auxiliary data blocks (economy, climate, networks)  
- Replay-tie hash block  
- Checksum block

All blocks use fixed-endian (little-endian) C89 structs.

============================================================
3. SAVEFILE STRUCTURE (TOP LEVEL)
============================================================

[DOM_Header]
[DOM_Manifest]
[DOM_UniverseMetadata]
[DOM_ChunkDirectory]
[DOM_Chunks...]
[DOM_NetworkState]
[DOM_EconomyState]
[DOM_ClimateState]
[DOM_AIState]
[DOM_CargoGraphState]
[DOM_WorkerState]
[DOM_EndChecksum]

============================================================
4. HEADER BLOCK
============================================================

Contains:
- Magic: `DOMN`  
- Format version  
- Engine version  
- Data version  
- World UUID  
- Universe UUID  
- Save timestamp (deterministic format, not system time)  
- Endianness indicator (always little-endian)  
- Hash of manifest block  
- Hash of initial tick state (for replay integration)  

Save timestamp is **logical time**, not OS time.

============================================================
5. MANIFEST BLOCK
============================================================

Contains:
- List of active mods  
- DLC list and versions  
- Renderer-independent feature flags  
- UPS/FPS canonical configuration  
- Simulation ruleset ID  
- Planetary system ID  
- Galaxy ID  

Everything needed to ensure:
- Save can only load with correct mods/DLC  
- Deterministic compatibility preserved  

============================================================
6. UNIVERSE METADATA BLOCK
============================================================

Contains:
- Universe seed  
- Universe graph structure (galaxies, solar systems, planets)  
- Cosmological locations of all properties  
- Ownership and geopolitical metadata  
- Global climate and orbital parameters  

This block enables:
- multi-property saves  
- AI-company universe state  
- multi-planet consistency  

============================================================
7. CHUNK DIRECTORY
============================================================

Similar to filesystem index.

Contains:
- total chunk count  
- chunk coordinate → byte offset mapping  
- chunk revision numbers  
- chunk checksum  
- chunk compression options  

Directory enables:
- partial loading  
- lazy streaming  
- recovery after partial corruption  

============================================================
8. CHUNK DATA BLOCKS
============================================================

For each chunk:

[ChunkHeader]
[TerrainData]
[StructuresData]
[NetworksData]
[EntitiesData]
[InventoryData]
[WorkersData]
[MachinesData]
[AuxSubsystemData...]

Chunks are 256×256m; subchunks 16×16m.

Serialization rules:
- All chunk data encoded as deterministic C89 structs.  
- No pointers; only offsets or IDs.  
- No platform-dependent padding.  
- Memory layout uses tight packing (`#pragma pack(push,1)`).  
- All variable-length arrays use length-prefix format.

============================================================
9. NETWORK STATE BLOCKS
============================================================

Includes:
- Power network graph (nodes/edges with tier + electrical params)  
- Fluid network graph (pipes, valves, pressures, temperatures)  
- Data network graph (routers, switches, packet queues)  
- Road/rail/air/space networks (node graph only, no vehicles here)

Graphs must use deterministic ordering:
- sorted by node ID  
- sorted adjacency lists  
- no hash maps allowed, only array-based deterministic containers  

============================================================
10. ECONOMY STATE BLOCK
============================================================

Contains:
- Market prices  
- Commodity supply/demand curves  
- Public company valuations  
- Historical series (downsampled)  
- Player + AI finances  
- Contracts, leases, futures, options  

All numeric values stored as:
- fixed-point (int64 scaled)  
- or integer quantities  

No floating-point stored in save.

============================================================
11. CLIMATE STATE BLOCK
============================================================

Contains global climate parameters:
- T_global  
- CO₂_eq_ppm  
- albedo  
- radiative forcing  
- ocean/land heat reservoirs  
- sea level  

Planet-level weather seeds and band values are included.

============================================================
12. AI STATE BLOCK
============================================================

Contains:
- AI company data  
- AI decision queues  
- AI memories (bounded)  
- long-term plans  
- conflict/economic plans  
- worker assignment models  

Every AI behaviour must be serializable.

============================================================
13. WORKER STATE BLOCK
============================================================

Stores:
- worker types  
- worker locations (chunk→subchunk→xyz)  
- task queues  
- skills/experience  
- fatigue  
- pay rates  
- brain types (robots)  

============================================================
14. VEHICLE & LOGISTICS STATE
============================================================

Stores:
- vehicle ID  
- type (truck/train/plane/boat/spacecraft)  
- physical state (pos/vel/orientation)  
- cargo assigned  
- route references  
- step state in route  
- pathfinding seeds and cached segment references  

============================================================
15. SNAPSHOT MECHANISM
============================================================

Snapshots created:
- automatically at intervals  
- manually on demand  

Snapshot stored as:
- compressed chunk deltas  
- global state blocks  
- replay-tie data  

Snapshots allow:
- rollback in multiplayer  
- recovery from corrupted save  
- debugging reproduction of bugs  

============================================================
16. COMPRESSION
============================================================

Compression options:
- none  
- LZ4 (default)  
- zlib (high compression)  

Compression must be deterministic with fixed seeds.

Chunks compressed independently.

============================================================
17. SAVEGAME COMPATIBILITY RULES
============================================================

Rules for loading older saves:

1. Save contains version numbers.  
2. Engine compares:
   - engine major/minor  
   - data major/minor  
   - mod list  
   - DLC list  
3. If incompatible:
   - engine refuses to load  
   - prints deterministic reason  
4. Save upgrades:
   - only allowed when differences are safe  
   - upgrade scripts must be deterministic  
   - upgrade logs stored in save directory  

Rollback compatibility:
- Newer saves cannot be loaded by older versions.  
- Older saves upgraded to newer version cannot downgrade.

============================================================
18. SAVEGAME DIRECTORY STRUCTURE
============================================================

saves/
<world_name>/
world.dom
autosave_1.dom
autosave_2.dom
autosave_3.dom
snapshots/
snapshot_0001.dom
snapshot_0002.dom
replay/
replay_0001.dem
manifest.txt

============================================================
19. ATOMICITY & SAFETY
============================================================

Save process:
1. Write temp file  
2. Flush to disk  
3. Validate checksum  
4. Replace existing save atomically  

DOS/Win9x:
- no atomic replace  
- uses backup copy: `.bak` file  

============================================================
20. DETECTING CORRUPTION
============================================================

Every block has:
- CRC32  
- optional SHA256 (high integrity mode)  

On load:
- corrupted chunks are skipped  
- missing chunks replaced with empty terrain or safe defaults  
- engine reports warnings  

Game continues to load if corruption is localized.

============================================================
21. MOD & DLC INTERACTION
============================================================

Save must list mods/DLC with:
- ID  
- Version  
- Fingerprint (hash)  

Load rules:
- All listed mods/DLC must be present and same version.  
- Mods may add fields but cannot remove required fields.  
- Unknown mod-structures stored as opaque blocks but not interpreted.

Mod hot-removal:
- prohibited  
- requires world-level fix or mod-uninstall tool

============================================================
22. LEGACY SAVE SUPPORT
============================================================

### Win9x / DOS
- minimal save format  
- only terrain + structures + inventories  
- chunked but stripped of complex networks  
- used for MS-DOS edition and early Windows editions  

### macOS pre-10.6
- same format as modern, but with reduced metadata  

============================================================
23. BACKUP & ARCHIVAL
============================================================

The engine can export:
- "world export" (complete universe)  
- "property export" (single property, chunk subset)  
- "economy export" (market state)  
- "climate export"  

All exports in `.dompkg` format.

============================================================
24. SUMMARY
============================================================

Volume 7.33 defines a full deterministic save and serialization model:

- Container: DOMSAVE v1  
- Fully deterministic, endian-stable  
- Modular blocks for terrain, structures, networks, economy, workers  
- Supports rollback, snapshots, replay integration  
- Chunk-based streaming and loading  
- Supports multiverse and planetary systems  
- Supports mod/DLC manifests  
- Designed for long-term compatibility and archival use  
- Recoverable from partial corruption  
- Atomic and safe  

# END OF VOLUME 7.33

Next in sequence:
VOLUME 7.34 — FILESYSTEM LAYER, PATH RULES, VIRTUAL FS, MEDIA PACKAGING, LFN/SFN SUPPORT
This will define:
how Dominium handles MS-DOS 8.3 SFN
long-path support
VFS overlays
read-only media mode (CD/DVD)
patches, updates, layering
Say Proceed to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.34 — FILESYSTEM LAYER, PATH RULES, VIRTUAL FS, MEDIA PACKAGING, LFN/SFN SUPPORT.
Single continuous Markdown block.

# VOLUME 7.34 — FILESYSTEM LAYER, PATH RULES, VIRTUAL FS, MEDIA PACKAGING, LFN/SFN SUPPORT  
Dominium Engine Specification — Engine Core, Part 34  
Cross-Platform FS Rules, VirtualFS, Safe Write Model, 8.3 Legacy Support, Install Media

Objective:  
Define the complete filesystem rules for Dominium across all platforms, including:
- MS-DOS and Windows 3.x 8.3 filename limits  
- Long path support  
- CD/DVD read-only environments  
- VFS overlay system  
- Mods/DLC layered file resolution  
- Safe write locations  
- Deterministic path rules for replays, saves, tools

============================================================
1. PRINCIPLES
============================================================

1. All file operations must be deterministic and platform-agnostic.  
2. Engine must run on:
   - modern OS with long paths  
   - legacy OS with 8.3 filenames only  
   - read-only drives (CD/DVD)  
   - network shares  
3. Engine must not rely on:
   - case sensitivity  
   - symbolic links  
   - platform-specific permissions  
   - Unicode filesystem support  
4. All filepaths internally are **forward slash only**: `/`  
5. Engine must use a **Virtual Filesystem (VFS)** abstraction layer.  
6. Mods and DLC apply via VFS overlays, not direct directory modifications.  
7. User data must be completely isolated from game data.

============================================================
2. DIRECTORY STRUCTURE (LOGICAL)
============================================================

The logical VFS layout exposed to the engine:

/
core/ (core game data; read-only)
mods/ (user & official mods)
dlc/ (optional DLC)
user/ (user saves, configs)
cache/ (temporary precomputed data)
tools/ (SDK, pipelines)
media/ (CD/DVD/USB install source)

This is logical only; physical layout differs by platform.

============================================================
3. PHYSICAL LAYOUT (MODERN OS)
============================================================

### Windows 2000+ / XP+ / Vista / 7 / 8 / 10 / 11
Dominium/
core/
mods/
dlc/
user/
cache/
tools/
launcher.exe
dominium_client.exe

### macOS 10.6+
Inside an `.app` bundle:

Dominium.app/
Contents/
MacOS/
dominium_client
Resources/
core/
mods/
dlc/
UserData/ (outside bundle)

### Linux
/opt/dominium/
core/
mods/
dlc/
/home/<user>/.dominium/
user/
cache/

============================================================
4. PHYSICAL LAYOUT (LEGACY SYSTEMS)
============================================================

### Win9x
Paths must be <= 260 chars.  
Long filenames allowed but unstable.

DOMINIUM/
CORE/
MODS/
USER/
CACHE/

### Windows 3.x / DOS
**Strict 8.3 filenames**:

DOMINIUM/
CORE/
MODS/
USER/
CACHE/

Filenames:
- `CORE.DAT`
- `UIFONT.FNT`
- `TEX0001.BIN`
- etc.

A mapping table translates logical paths to 8.3 physical equivalents.

============================================================
5. VIRTUAL FILESYSTEM (VFS)
============================================================

VFS merges multiple layers:

### Layers (lowest → highest priority)
1. `core/` (read-only)  
2. `dlc/` (optional read-only)  
3. `mods/official/` (read-only but overridable)  
4. `mods/user/` (read-write, highest override)  
5. `user/` (configs, saves, logs)  
6. `cache/` (runtime data)

File lookup is deterministic:
- case-insensitive match  
- longest-prefix path resolution  
- highest-layer match wins  
- engine logs all VFS resolutions for debugging  

============================================================
6. PATH RULES
============================================================

Internal paths:
- always forward slashes  
- never absolute  
- never contain drive letters  
- must be UTF-8 (normalized)  

Examples:
core/textures/ground/soil_01.png
mods/user/mymod/entities/machine.cfg
user/saves/world1/world.dom

============================================================
7. READ/WRITE POLICIES
============================================================

### Read-only
- core/  
- dlc/  
- mods/official/  
- media/ (CD/DVD, USB read-only)

### Read-write
- mods/user/  
- user/  
- cache/  

### No-write environment (CD/DVD run)
User data redirected to:
- `%APPDATA%/Dominium` (Windows)  
- `~/Library/Application Support/Dominium` (macOS)  
- `~/.dominium` (Linux)  
- `C:\DOMINIUM\USER` for Win9x/Win3.x

============================================================
8. SAFE WRITE OPERATIONS
============================================================

File writes must be:
- atomic (write to temp → rename)  
- synchronized to avoid corruption in crashes  
- isolated from core game files  

Engine never overwrites:
- executables  
- renderer DLLs  
- core data  
- dlc  

============================================================
9. SAVE GAME & SNAPSHOT STORAGE
============================================================

Defined in Volume 7.33; integrated here:

Paths:
user/saves/<world>/world.dom
user/saves/<world>/snapshots/
user/saves/<world>/replay/

Directory names must be sanitized:
- alphanumeric  
- hyphen, underscore allowed  
- no spaces recommended  
- must be convertible to 8.3 for legacy systems  

============================================================
10. 8.3 FILENAME TRANSLATION LAYER
============================================================

A path translator generates legal 8.3 names for DOS/Win3.x builds.

Algorithm:
- hash logical path  
- generate 8.3 from: prefix + hash  
- store mapping in a `.map` file  
- always stable and deterministic  

Example:
`core/textures/ground/soil_01.png` → `SO1AB23.PNG`

`.map` entry:
SO1AB23.PNG = core/textures/ground/soil_01.png

============================================================
11. VFS OVERLAYS FOR MODS & DLC
============================================================

Search order:
1. mods/user/<modname>/  
2. mods/official/<modname>/  
3. dlc/<dlcname>/  
4. core/  

Engine loads manifests:
- modlist.json  
- dlclist.json  

Conflicts:
- resolved by priority  
- logged  
- no nondeterministic resolution allowed  

============================================================
12. FILE FORMATS
============================================================

All Dominium file formats must be:
- endian-stable  
- versioned  
- deterministic  
- documented  

Examples:
- `.dom` — save  
- `.domsnap` — snapshot  
- `.dompkg` — export package  
- `.dommod` — mod archive  
- `.domcfg` — config  
- `.domlog` — log  

============================================================
13. MEDIA PACKAGING (CD/DVD)
============================================================

On physical media:

/CORE/ read-only
/DLC/ read-only
/MODS/ read-only (official)
/TOOLS/ optional
/SETUP.EXE
/AUTORUN.INF

User data stored elsewhere.

Installers must:
- copy necessary files  
- not modify core data  
- support full engine portability (no registry required)  
- maintain mapping for 8.3 systems  

============================================================
14. PATCHING & UPDATES
============================================================

Patching uses VFS layering:
- new core patches shipped as `core_patch_###.dompkg`  
- applied as highest-priority core layer  
- does not overwrite original files  

Safe patching:
1. Download patch  
2. Validate checksum  
3. Register in manifest  
4. Apply as overlay layer  

============================================================
15. FILE ACCESS API (ENGINE-SIDE)
============================================================

C89 API:

File* VFS_Open(const char* path, const char* mode);
size_t VFS_Read(void* dst, size_t size, size_t count, File* f);
size_t VFS_Write(const void* src, size_t size, size_t count, File* f);
void VFS_Close(File* f);
bool VFS_Exists(const char* path);
void VFS_Enumerate(const char* path, VFS_Callback cb);

Mode rules:
- `r`, `rb` always permitted  
- `w`, `wb` only in writable directories  
- `a` allowed only in user/  

Any violation → deterministic error.

============================================================
16. SECURITY
============================================================

Engine must:
- prevent directory traversal (`../`)  
- prevent OS command injection  
- prevent arbitrary symlink following  
- sandbox writes to user/ and cache/  
- not trust mod scripts to access server files  

============================================================
17. CROSS-PLATFORM CHARACTER SETS
============================================================

All filenames internally → UTF-8.  
Legacy OS:
- map UTF-8 to best available 8.3 ASCII/ANSI subset  
- fallback to hash-based 8.3 if unmappable  
- store original names in `.map`  

============================================================
18. CACHE RULES
============================================================

Cache:
- safe for deletion  
- never required for correctness  
- may include:
  - shader cache  
  - texture cache  
  - geometry preprocess  
  - economy history  
  - replay indexing  

Cache should be ignored in replays.

============================================================
19. ENGINE-LEVEL LOGGING
============================================================

Logs stored in:
user/logs/<date>.domlog

Legacy OS:
USER/LOGS/LOG0001.LOG

No timestamps from OS; use game logical time.

============================================================
20. SUMMARY
============================================================

Volume 7.34 defines the Dominium filesystem framework:

- Fully cross-platform  
- Long path + 8.3 path support  
- VFS overlays for mods and DLC  
- Safe read/write rules  
- Deterministic file lookups  
- CD/DVD/media-friendly structure  
- Atomic saves  
- Replay-compatible path rules  
- Unified FS API for C89 engine  
- Strong sandboxing  
- DOS/Win3.x compatibility guaranteed  

# END OF VOLUME 7.34

Next in sequence:
VOLUME 7.35 — LOCALIZATION SYSTEM (Text, Fonts, Unicode, Right-to-Left, Legacy Fallbacks, Determinism).
Say Proceed to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.35 — LOCALIZATION SYSTEM, including full support for modern Unicode, limited support for legacy platforms, deterministic behavior, and complete separation of UI vs simulation.
Single continuous Markdown block follows.

# VOLUME 7.35 — LOCALIZATION SYSTEM  
Dominium Engine Specification — Engine Core, Part 35  
Unicode, Text Pipeline, Fonts, RTL Support, Legacy Fallbacks, Deterministic Rules

Objective:  
Define Dominium’s full internationalization/localization (i18n/L10n) system, including:
- Unicode text  
- Font rendering  
- RTL languages  
- Locale-independent determinism  
- Legacy fallback modes (Win9x, DOS)  
- Integration with renderer/UI  
- Modding support  

Localization must not affect simulation determinism.

============================================================
1. CORE PRINCIPLES
============================================================

1. Localization affects **only**:
   - UI
   - text rendering  
   - on-screen labels  
   - tooltips  
   - dialog boxes  
2. Localization must **never affect simulation**:
   - no localized numeric parsing  
   - no localized decimals/commas  
   - no localized resource IDs  
   - no locale-sensitive RNG  
3. Localization must be:
   - modular  
   - separated from logic  
   - easy to override by mods  
   - entirely client-side (server state not localized)  
4. Localization must support:
   - Unicode (UTF-8)  
   - left-to-right (LTR)  
   - right-to-left (RTL)  
   - complex scripts (Arabic, Indic, CJK)  
5. Legacy platforms must use fallback:
   - ASCII + codepage approximations  
   - glyph fallback tables  
   - simplified UI font pipeline  

============================================================
2. TEXT ENCODING  
============================================================

Internal encoding: **UTF-8 only**

Rules:
- All engine strings stored as UTF-8  
- No UTF-16 or UTF-32 internally  
- Renderer/UI converts UTF-8 to glyph IDs  
- Files containing text (configs, mods, DLC) must be UTF-8 without BOM  

Legacy OS:
- cannot store full UTF-8 filenames; fallback via mapping (7.34)  
- text resources inside the game remain UTF-8  

============================================================
3. LOCALIZATION RESOURCES
============================================================

Localization files are placed in:

core/locale/<lang>/strings.domloc
mods/<modname>/locale/<lang>/strings.domloc

Format:
DOMLOC v1
[key] = "Translated text"

Examples:
ui.start = "Start"
ui.quit = "Quit"
machine.assembler = "Assembler"

Modifiers:
[key] = "{value} units produced"

Supports positional arguments:
"{0} hours remaining"

Supports parameter substitution deterministically (no locale number formatting).

============================================================
4. LOCALE SELECTION
============================================================

Locale is chosen at:
- launcher time  
- or first engine startup  

Stored in:
user/config/locale.cfg

Fallback rules:
1. requested locale  
2. fallback locale group (e.g., “pt_BR → pt”)  
3. English (en)  
4. Hardcoded fallback strings  

============================================================
5. RENDERER TEXT PIPELINE
============================================================

Rendering text requires:
- shaping (optional)  
- glyph rasterization  
- caching  

Two modes:

### 5.1 Mode A — Modern Shaped Rendering (Win2000+, macOS 10.6+, Linux)
Uses:
- HarfBuzz (optional built-in) for shaping  
- FreeType for font rasterization  
- Caching glyphs in texture atlases  
- Supports:
  - ligatures  
  - RTL shaping  
  - diacritics  
  - Indic clusters  

Renderer receives:
- shaped glyph list  
- positions  
- materials  
- color  

### 5.2 Mode B — Legacy Simple Rendering (Win9x, DOS, Win3.x)
- no shaping  
- monospaced fallback fonts  
- glyphs stored as bitmaps in `.FNT` or `.BMP`  
- no ligatures  
- no RTL (reversed ASCII-only fallback for Hebrew/Arabic)  
- CJK unsupported except symbol subsets  

============================================================
6. RTL SUPPORT
============================================================

RTL languages supported fully in Mode A:
- Arabic  
- Hebrew  
- Persian  

Rules:
- shaping engine determines final glyph order  
- mixed LTR/RTL handled with Unicode bidi algorithm  
- numbers always LTR (engine-level rule)  
- UI layout flips automatically for RTL locales if desired  

Modes:
- **UI_RTL_FLIP=on** mirrors entire UI  
- **UI_RTL_TEXT_ONLY=on** mirrors text only  
- **strict** obeys engine defaults  

============================================================
7. FONT SYSTEM
============================================================

### 7.1 Font Types
1. Vector fonts (TTF/OTF)  
2. Bitmap fonts (legacy fallback)  
3. User-provided fonts (mods)  

### 7.2 Font Packs
Font packs are mods representing:
- UI fonts  
- monospace fonts  
- CJK fonts  
- emoji fonts  

Loaded from:
mods/<fontpack>/fonts/*.ttf

### 7.3 Font Resolution Tiering
Tier 0: ASCII bitmap  
Tier 1: Latin + Cyrillic  
Tier 2: Greek + Hebrew + Arabic  
Tier 3: CJK basic  
Tier 4: CJK full extension  

Lower-end platforms use Tier 0/Tier 1.

============================================================
8. TEXT SHAPING PIPELINE
============================================================

(Used in Mode A platforms)

Steps:
1. UTF-8 decode  
2. Bidi ordering (if needed)  
3. Word segmentation  
4. Script run segmentation  
5. OpenType shaping (HarfBuzz)  
6. Positioning + kerning  
7. Break into glyph quads  
8. Build glyph triangle list  
9. Send to renderer  

All steps must not affect determinism of simulation.

============================================================
9. DETERMINISM RULES
============================================================

Localization is **purely presentation**:
- no localized number parsing  
- no localized dates  
- no localized decimals  
- no localized clocks  
- no locale-dependent sorting  
- all UI-only  

Simulation never sees localized strings.

Replays, saves, and multiplayer never depend on locale.

============================================================
10. MOD LOCALIZATION
============================================================

Mods may include localization folders:

mods/<modname>/locale/en/strings.domloc
mods/<modname>/locale/de/strings.domloc

Each mod resolves translation keys under its namespace:
mymod.widget.title
mymod.machine.description

If missing keys:
- fallback to English  
- else fallback to keyname itself  

============================================================
11. TEXT MEASUREMENT
============================================================

Font system provides deterministic measuring based on:
- fixed metrics extracted from font  
- integer pixel rounding  
- DPI-independent metrics or renderer-defined scaling factors  

Legacy systems:
- monospaced only  
- deterministic width table for ASCII [0–127]  

============================================================
12. LOCALIZED UI LAYOUT
============================================================

UI system uses flexible layout:

- text expansion can expand UI nodes  
- RTL flips UI node ordering if needed  
- min/max width constraints deterministically applied  
- autosizing based on deterministic width measurements  

UI layout is **not stored in saves**.

============================================================
13. FILE FORMATS
============================================================

Localization file (.domloc):
- UTF-8  
- key = "value"  
- no comments except `#` at start  
- deterministic ordering optional  
- mod overwrites permitted  

Font bitmaps (.domfnt):
- used on legacy  
- fixed 8x16 or 16x16 grid  
- ASCII-only or extended  

============================================================
14. LEGACY PLATFORM MODES
============================================================

### Win9x
- supports unicode via UTF-8 → codepage fallback  
- uses bitmap fallback if TTF not supported  

### DOS
- ASCII-only text with fallback codes  
- no shaping  
- no font smoothing  

### macOS 10.6+ and Linux
- full shaping allowed  

============================================================
15. INLINE FORMATTING
============================================================

Supports minimal inline formatting codes:

[color=#RRGGBB]text[/color]
[bold]text[/bold]
[italic]text[/italic]

Renderer converts formatting into material variants.

No arbitrary scripting allowed in inline formats.

============================================================
16. NUMBER, DATE, CURRENCY FORMATTING
============================================================

For determinism:
- All numeric output uses invariant formatting:  
  - decimal point = '.'  
  - no thousands separator  
  - fixed or scientific as engine dictates  
- All dates/times use game calendar and fixed format  
- No localized currency symbols  
- No locale-sensitive pluralization  

Mods may theme UI labels but not game logic.

============================================================
17. VALIDATION & TOOLING
============================================================

Localization validator:
- detects missing keys  
- detects unused keys  
- verifies UTF-8 correctness  
- checks duplicate entries  
- checks mod override correctness  

Developer tools may export “translation packs”.

============================================================
18. PERFORMANCE RULES
============================================================

Caching rules:
- shaped glyphs cached per font  
- glyph bitmaps cached in atlases  
- LRU eviction permitted  
- shader-based text supported in GL2/DX9/DX11  
- deterministic fallback to CPU rasterizer  

Legacy fallback:
- simple blitter for bitmap fonts  

============================================================
19. SECURITY
============================================================

- Localization files cannot execute code.  
- No dynamic expression evaluation.  
- No file read/write beyond localization directory.  
- Fonts must be validated to prevent malformed glyph tables.  

============================================================
20. SUMMARY
============================================================

Volume 7.35 defines Dominium’s full localization infrastructure:

- UTF-8 internal text system  
- shaping pipeline for modern systems  
- legacy fallback pipeline for DOS/Win3.x/Win9x  
- modular font packs  
- deterministic UI-only localization  
- RTL support  
- mod localization  
- no simulation effects  
- stable text measurement + layout  
- sandboxed localization loading  

# END OF VOLUME 7.35

Next in sequence:
VOLUME 7.36 — UI SYSTEM (Widgets, Layout Engine, Themes, 2D/3D Integration, HUD, Accessibility).
Say Proceed to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.36 — UI SYSTEM, I need a precise clarification.
This is required because it fundamentally determines how every UI element, widget, HUD overlay, menu, tool window, blueprint interface, editor, and debug screen works for the next 20 years of Dominium development.
Clarification required
You must select ONE of the following UI architecture paradigms:

OPTION A — Immediate Mode UI (IMGUI)
Examples: Dear ImGui, Nuklear, Unity’s IMGUI.
Characteristics:
UI generated every frame by calling draw functions
Zero retained widget hierarchy
Very lightweight
Extremely easy to debug
Works well on Win2000, XP, Linux, macOS 10.6
Fits nicely into renderer abstraction
Perfect for debug panels, editors, dev tools
Harder for complex UX (blueprints, inventories)
Poorer performance for extremely complex screens
Harder to skin and theme
Pros: deterministic, portable, simple, fast for dev
Cons: weaker theming, less powerful for complex mod UIs

OPTION B — Retained Mode UI (RMUI)
Examples: Qt/QML, HTML DOM, Unity UI, engines like Godot.
Characteristics:
UI is a persistent scene graph / widget tree
Widgets hold state, layout is automatic
Much better for complex interactions:
inventory grids
blueprint editors
building UI
minimaps
overlay panels
notifications
windows and docking
Heavy but robust
More difficult on low-end systems
Requires layout engine + event bubbling
More code to maintain
Harder for DOS/Win9x minimal render layers
Pros: powerful, feature-rich, long-term scalable
Cons: more complex to implement, higher memory, heavier for legacy

OPTION C — HYBRID (IMGUI core + RMUI optional layer)
This combines both worlds:
Core engine and all legacy platforms use IMGUI
deterministic
simple
works everywhere
minimal memory
safe for headless mode
good for debug, simple menus, console UI
Modern platforms can optionally enable Retained Mode UI
for complex UIs (inventory, logistics graphs, supply chain editors, planet maps)
implemented as a layer over IMGUI
completely optional
can be disabled for performance or legacy systems
modders can choose which UI paradigm they want
all RMUI widgets degrade gracefully to IMGUI fallbacks
Both share the same rendering backend
text, shapes, quads all come through the same pipeline
Pros:
maximal flexibility
maximal portability
looks modern on capable systems
still runs on Win2000, XP, macOS 10.6, Linux minimal
can disable RMUI for speed or determinism stress testing
modders get both simple IMGUI and complex UI graphs
ideal for Dominium’s dual-view 2D/3D blueprint/editor needs
Cons:
most engineering work
requires careful integration

I need your choice
A, B, or C.
Choose now.
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with Hybrid UI: IMGUI core + optional RMUI layer.
Single continuous Markdown block.

# VOLUME 7.36 — UI SYSTEM  
Dominium Engine Specification — Engine Core, Part 36  
Hybrid UI: Immediate-Mode Core + Optional Retained-Mode Layer, HUD, Accessibility

Objective:  
Define a unified, deterministic, cross-platform UI system that:

- Works on Win2000+, macOS 10.6+, Linux, and legacy targets.  
- Uses **Immediate Mode UI (IMGUI)** as the canonical core.  
- Provides an optional **Retained Mode UI (RMUI)** layer on modern platforms.  
- Integrates cleanly with renderer levels 0–3 (headless → full 3D).  
- Supports mods and tools.  
- Stays strictly outside simulation determinism.

============================================================
1. ARCHITECTURE OVERVIEW
============================================================

UI system is layered:

┌──────────────────────────────┐
│ GAME LOGIC │
│ (simulation, ECS, commands) │
└───────────────▲──────────────┘
│
┌───────────────┴──────────────┐
│ UI COMMAND LAYER │
│ (UI Events → Game Commands) │
└───────────────▲──────────────┘
│
┌───────────────┴──────────────┐
│ HYBRID UI CORE │
│ - IMGUI (always available) │
│ - RMUI (optional on top) │
└───────────────▲──────────────┘
│
┌───────────────┴──────────────┐
│ RENDERER API v1 │
│ (2D/3D draw calls, text) │
└──────────────────────────────┘

Key constraints:
- Simulation never depends on UI.  
- UI uses non-deterministic input path (7.32 UI path).  
- UI only emits *commands* into deterministic queue for next tick.

============================================================
2. IMGUI CORE (MANDATORY)
============================================================

### 2.1 Purpose
- Baseline UI for all platforms.  
- Required for legacy systems and minimal builds.  
- Used for:
  - main menus  
  - pause menus  
  - debug overlays  
  - simple in-game panels  
  - CLI/TUI on Level 0  

### 2.2 Characteristics
- Drawn every frame from scratch.  
- No persistent widget tree (except IDs).  
- Uses deterministic *ID generation* off stable strings.  
- Layout is code-driven (row/column APIs).  

### 2.3 IMGUI API Sketch
C-style API used by engine and mod scripts:

```c
UI_BeginWindow("main_menu", &open);
  if (UI_Button("New Game")) { Cmd_StartNewGame(); }
  if (UI_Button("Load Game")) { Cmd_OpenLoadMenu(); }
  UI_Text("Version: 1.0");
UI_EndWindow();
Lua wrappers present similarly.
2.4 Layout
IMGUI provides:
horizontal/vertical layout
columns, rows
fixed sizes, percentage sizes
padding and margins
docking is not core IMGUI (handled by RMUI if needed)
============================================================
3. RETAINED MODE UI (OPTIONAL)
3.1 Purpose
Provide rich UI for:
inventory grids
logistics graphs
supply chain editors
planetary/galactic maps
complex mod UIs
world editor / tools
3.2 Availability
Enabled only on "modern" platforms:
Win2000+ with sufficient RAM/GPU
macOS 10.6+
Linux desktop
Disabled on:
DOS
Win3.x
minimal legacy builds
3.3 RMUI Model
Maintains a widget tree / scene graph:
windows
panels
containers
lists/grids
graph canvases
HUD overlays
Each widget:
holds state (open/closed, scroll positions, selection)
has layout constraints
responds to events (click, drag, hover, focus)
RMUI ultimately generates IMGUI calls or direct draw commands into the same render pipeline.
============================================================
4. VISUAL LEVEL INTEGRATION
From 7.25/7.31: Visual levels:
Level 0: headless / CLI / TUI
Level 1: 2D vector mode
Level 2: 2D texture + vector
Level 3: 3D + 2D
UI per level:
Level
UI Mode
0
TUI/CLI (console-based, text only)
1
IMGUI + vector widgets
2
IMGUI + textured widgets, RMUI optional
3
IMGUI + RMUI integrated, HUD in 3D where needed
UI must be fully functional in Level 1 IMGUI-only mode.
============================================================
5. UI WIDGET SET
Baseline widgets (IMGUI & RMUI):
Windows, panels
Buttons, toggles, checkboxes
Radio buttons
Tabs
Toolbars
Sliders, spinners
Text labels, text input fields (UI-only)
Dropdowns / combo boxes
List views (basic)
Tree views (hierarchical, RMUI only)
Tables / grids (inventory)
Graph canvas (networks, maps)
Minimap and big map overlays
Notifications/toast system
Context menus
Tooltips
All must have IMGUI fallbacks; RMUI may add richer behaviours (animations, docking, drag/drop previews).
============================================================
6. HUD & IN-WORLD UI
HUD includes:
Player status
Time/date/calendar
Company finances
Selected entity information
Alerts & notifications
Minimaps
Build/blueprint overlays
In-world UI:
floating markers above entities
zone outlines
blueprint placement previews
network overlays (power/data/fluid/roads/rails)
All HUD/UI overlays use the same UI system; drawn via renderer command buffer (7.31).
============================================================
7. MODDING & UI
UI APIs available to mods (through Lua):
IMGUI-level:
ui.begin_window(id, params)
ui.button(id, label)
ui.label(text)
ui.checkbox(id, state)
ui.slider(id, min, max, value)
ui.begin_table(id, columns)
RMUI high-level descriptors (modern platforms):
ui_rmui.create_panel(desc)
ui_rmui.bind_data(path)
ui_rmui.set_layout(flexbox-like or grid)
Constraints:
Mods can only create UI that reads simulation and sends back commands.
Mods cannot access raw simulation memory.
Mods cannot block UI or engine threads.
============================================================
8. INPUT & UI EVENTS
UI uses non-deterministic input path (7.32 UI path), separate from simulation input.
Events:
mouse move / click / scroll
keyboard focus / key presses
controller navigation (focus-based)
text input (Unicode)
Event flow:
PHAL captures input.
UI system reads UI events.
UI updates internal states.
UI emits Game Commands into deterministic queue (to be executed next tick).
Examples of commands:
Cmd_SelectEntity(entity_id)
Cmd_SetBlueprintMode(mode)
Cmd_IssueBuildOrder(params)
Cmd_OpenPropertyScreen(property_id)
============================================================
9. ACCESSIBILITY
Accessibility features:
High-contrast mode
Large font mode
Colorblind-friendly palettes
Keyboard-only navigation
Configurable control hints
Optionally: screen reader hooks (platform-dependent)
Implementation:
All UI definitions must be accessible via metadata:
widget label text
widget type
widget role (button, slider, etc.)
Screen reader support must not affect simulation.
============================================================
10. THEME & SKINNING
UI theming via:
Theme files:
core/ui/theme_default.domtheme
mods/theme_*/*.domtheme
Themes define:
colors (RGBA integers)
font families
border radii
shadows and outlines (simple)
spacing and padding
RMUI can support more complex theming (animations, transitions) but must degrade to IMGUI layout.
============================================================
11. PERFORMANCE & DEGRADATION
Low-end / legacy behavior:
IMGUI only
Minimal textures
Vector-only widgets where required
No RMUI, no heavy graph views
Fewer animations; transitions disabled
High-end behavior:
RMUI enabled
fancy transitions allowed
3D UI elements (in-world overlays)
multi-window support
Config options:
ui_mode = "imgui_only" | "hybrid" | "rmui_preferred"
ui_animations = on/off
ui_detail_level = low/med/high/ultra
============================================================
12. DETERMINISM SEPARATION
UI state is not part of simulation:
UI state not serialized in savegame.
UI state not recorded in replay.
UI preferences stored only in user config.
Simulation state is affected only via commands that are fully deterministic and queued via command bus.
============================================================
13. DEBUG & DEV TOOLS UI
Debug panels built on IMGUI core:
profiler graphs
ECS inspectors
chunk viewers
network graphs
AI decision trees
pathfinding visualizations
RMUI may augment those for modern builds but IMGUI versions must always exist.
============================================================
14. LEGACY UI MODES (LEVEL 0)
For DOS/Win3.x/headless:
TUI (text UI) using console:
lists, menus, key shortcuts
minimal map view using ASCII
No mouse required (keyboard only)
No shapes except text
TUI still uses command bus to issue actions.
============================================================
15. UI STATE PERSISTENCE
UI preferences stored in:
user/config/ui.cfg
Includes:
theme selection
font size
layout presets (docked panels)
last open windows (for convenience only, not authoritative)
Not part of world saves.
============================================================
16. ERROR HANDLING & ROBUSTNESS
UI subsystem must:
not crash the engine if a widget misbehaves.
clamp invalid positions and sizes.
protect against infinite layout loops.
handle oversized text gracefully (ellipsis, scrolling, or wrap).
Modded UI errors:
log
disable offending panel
keep engine running
============================================================
17. SUMMARY
Volume 7.36 defines Dominium’s UI framework:
IMGUI core mandatory for all platforms.
RMUI layer optional for modern, high-end systems.
Hybrid architecture: RMUI composes to IMGUI/renderer pipelines.
Clear separation between UI and simulation (command-based).
Strong mod support with safe APIs.
Visual level integration from headless to full 3D HUD.
Accessibility, theming, performance scaling.
Works on everything from DOS/TUI to Win11/3D.
END OF VOLUME 7.36

---

Next in sequence (if you want to keep going with engine core volumes):

**VOLUME 7.37 — ACHIEVEMENTS, STATS, METRICS, AND PROGRESSION TRACKING**  
(including offline-safe tracking, deterministic boundaries, integration with Steam/Discord/etc, but with minimal DRM/anticheat as you specified).

If you want that, say **Proceed**.
::contentReference[oaicite:0]{index=0}
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.37 — Achievements, Stats, Metrics & Progression Tracking in one continuous, self-contained Markdown block.

# VOLUME 7.37 — Achievements, Stats, Metrics & Progression  
Dominium Engine Specification — Engine Core, Part 37  
Offline-first, deterministic-friendly, no-DRM, platform-integrated.

Objective:  
Define the system for achievements, long-term stats, player/company progression, integration with storefronts (Steam/GOG/etc), and ensure the entire architecture is:

- deterministic-friendly  
- offline-first  
- mod-compatible  
- free of DRM or forced connectivity  
- optional for all players  
- platform-neutral  
- able to support legacy OS environments  
- non-intrusive  

============================================================
1. DESIGN PHILOSOPHY
============================================================

Dominium’s progression systems must meet four global requirements:

1. **Never interfere with determinism**  
   - Achievements/stat tracking must read from post-tick states only.  
   - Achievements cannot influence gameplay.  
   - Stats never modify simulation.

2. **Offline-first**  
   - Player can earn all achievements offline.  
   - All progress stored locally.  
   - Sync to Steam/GOG/Discord/etc only when available.

3. **No DRM / No spyware**  
   - No tracking outside the game’s internal metrics.  
   - No behavioural telemetry.  
   - No hidden analytics.  
   - All data stays local unless the user explicitly enables cloud sync.

4. **Mod-safe**  
   - Mods can register achievements (optional).  
   - Mods can register custom stat counters.  
   - Mods cannot read sensitive user data.  
   - Mods cannot submit achievements to external platforms.

============================================================
2. CORE SYSTEM LAYERS
============================================================

Three-layer architecture:

┌─────────────────────────────┐
│ (3) EXTERNAL SYNC LAYER │ Optional.
│ Steam / GOG / Discord / etc │ Only pushes achievements/stats.
└──────────────▲──────────────┘
│
┌──────────────┴──────────────┐
│ (2) PROGRESSION ENGINE │ Local, authoritative.
│ Stats, achievements, medals │ Deterministic-safe readers.
└──────────────▲──────────────┘
│
┌──────────────┴──────────────┐
│ (1) SIMULATION READERS │ Deterministic.
│ Derived from post-tick state │ No side effects.
└──────────────────────────────┘

============================================================
3. PROGRESSION ENGINE (LOCAL & AUTHORITATIVE)
============================================================

### 3.1 Stored in local profiles
Per local user:
user/profile_<id>/progress.dat

Contains:
- global achievements  
- world-specific medals/trophies  
- stats (counters, high-scores, totals)  
- horizons (milestones for unlocking cosmetic UI themes)  
- optional mod achievement data  

### 3.2 Fully editable*
User may optionally:
- export progress  
- import backed-up progress  
- reset progress file  
- disable achievements for a specific world (ironman toggle)

*Does not break determinism because achievements are purely meta.

============================================================
4. ACHIEVEMENTS (LOCAL + OPTIONAL CLOUD SYNC)
============================================================

### 4.1 Achievement Types

1. **Standard achievements (global)**
   - Earned in any world.  
   - E.g. "Generate 1MW of power", “Produce first container”.

2. **Property achievements**
   - Bound to a specific save.  
   - E.g. “Reach profitability for 20 consecutive weeks”.

3. **Scenario achievements**
   - For custom scenarios or challenges.

4. **Mod achievements**
   - Optional categories by modders.  
   - Prefixed to avoid collisions.  
   - Saved separately so disabling a mod doesn’t break engine-level structures.

5. **Hidden / Secret achievements**
   - Stored but not visible until earned.  
   - For exploration or prestige.

All achievement definitions are stored in:
core/data/achievements/.json
mods//achievements/*.json

### 4.2 Achievement Triggering

Evaluation occurs after the simulation tick completes (PHASE H, Volume 7.10 ordering).

Triggers must be:
- deterministic  
- purely derived from current + historical stats  
- no randomness  
- no timers outside tick system  

### 4.3 Achievement Metadata

Each achievement includes:
- id  
- name  
- description  
- icon  
- category  
- requirement expression (static DSL)  
- rarity (computed locally from user’s worlds, optional global data NOT required)  
- platform integration flags  

============================================================
5. STATS & COUNTERS
============================================================

### 5.1 Types

1. **Cumulative counters**  
   - containers shipped  
   - MWh produced  
   - materials consumed

2. **Max/min records**  
   - highest weekly profit  
   - max vehicle throughput on a line  

3. **Time-based stats**  
   - weeks with positive income  
   - time since last blackout  
   - time in operation without bankruptcy  

4. **State flags**  
   - unlocked technologies (meta, not gameplay flags)  
   - “visited all planets in Sol”

### 5.2 Deterministic reading

Stats are computed only from:
- saved epoch time  
- simulation state snapshots  
- tick-by-tick accumulated counters  

### 5.3 Storage structure

Binary packed stat blocks:
struct StatsData {
uint64 counters[N];
float records[N];
uint8 flags[N];
}

============================================================
6. MEDALS, TROPHIES, AND RANKS
============================================================

Achievements are boolean, but medals/trophies/ranks are graded:

- Bronze  
- Silver  
- Gold  
- Platinum  
- Diamond (very long-term)

These are used for:
- planetary goals  
- company performance  
- logistics optimisation  
- energy sector mastery  
- construction excellence  

Ranks:
- Apprentice  
- Journeyman  
- Expert  
- Master  
- Grandmaster  

Ranks auto-compute from weighted stats.

============================================================
7. PLATFORM INTEGRATION (OPTIONAL)
============================================================

### 7.1 Platforms supported
- Steam  
- GOG Galaxy  
- Epic (optional)  
- Discord Rich Presence  
- Local screenshot folder  
- Built-in replay exporter  
- Built-in screenshot tool  
- None (offline-only)

### 7.2 No DRM, no forced login, no telemetry
- The game never requires internet.  
- Sync happens only if the user enables a platform.  
- If disconnected, progress is queued until later.  

### 7.3 Mappings
Each platform has mapping tables:
platform/steam/map_achievements.json
platform/steam/map_stats.json
platform/gog/map_achievements.json
...

Achievements/stats are pushed to platforms, never pulled from them.

============================================================
8. SNAPSHOTS, REPLAYS AND ACHIEVEMENTS
============================================================

### 8.1 Replay determinism
Achievements must not depend on:
- FPS  
- input timing jitter  
- UI state  
- OS clock  
- race conditions  

All achievement logic runs on:
- post-tick state  
- pure counters  
- deterministic evaluation instructions  

### 8.2 Replay awarding
If the player watches replays:
- achievements do **not** fire  
- stats do not increment  

============================================================
9. MOD COMPATIBILITY
============================================================

### 9.1 Mods can add achievements
But cannot:
- unlock official achievements  
- spoof engine stats  
- award platform achievements  

### 9.2 Mods can add stats
Stats are namespaced:
modid.statname

Stored in a mod-specific block.

============================================================
10. ANTI-CHEAT / CHEAT MANAGEMENT
============================================================

Dominium is **not a competitive game**.  
Thus:

- No anti-cheat.  
- No DRM.  
- No intrusive behaviour.  
- Cheating marks run as "modded/cheated" world, but still allowed achievements.  
- The user can disable “world purity” checks entirely.

The engine logs:
- mods enabled  
- deterministic mode off or on  
- world purity status  

Achievements can have two variants:
- **clean** (default)  
- **modded** (same achievement but marked)

============================================================
11. STATISTICS SVCS (LOCAL-ONLY)
============================================================

The engine maintains internal dashboards (accessible via IMGUI):

- global stats  
- per-world summaries  
- charts for:
  - power  
  - production  
  - shipping  
  - finance  

Export:
export/stats/<timestamp>/stats.json
export/stats/*.csv

============================================================
12. ACCESSIBILITY & VISUALIZATION
============================================================

Achievements UI must support:
- high contrast  
- large fonts  
- filtering  
- sorting  
- search  
- tag groups  
- compatibility with both IMGUI and RMUI modes  

Charts (RMUI only):
- time series  
- bar graphs  
- pie charts  
- performance indicators  
- rank meters  

IMGUI fallback:
- ASCII-ish bar charts  
- simple lines  
- data tables  

============================================================
13. PERFORMANCE & EFFICIENCY
============================================================

- Achievement checks run only post-tick.  
- Use precompiled requirement expressions.  
- Stats counters updated in constant time.  
- No dynamic allocations in tick-critical path.  

All progression systems remain negligible CPU overhead.

============================================================
14. SUMMARY
============================================================

Volume 7.37 defines:

- A deterministic-safe, offline-first achievement and stat system.  
- Local authoritative progress with optional platform sync.  
- No DRM, no telemetry, full user control.  
- Full mod support with isolation.  
- Graded medals/trophies/ranks.  
- Replay and determinism-friendly architecture.  
- UI integration through both IMGUI and RMUI.  
- Strong accessibility and visual presentation.

# END OF VOLUME 7.37

Next in sequence:
VOLUME 7.38 — SAVES, WORLD SERIALIZATION, CHECKSUMS, COMPATIBILITY, AND VERSIONING
(including deterministic save boundaries, cross-version forward-compatibility plan, world converters, and replay-safe storage ordering).
If you want that, say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.38 — Saves, Serialization, Checksums & Versioning.
Single continuous Markdown block.
All prior architectural rules are respected.

# VOLUME 7.38 — Saves, Serialization, Checksums & Versioning  
Dominium Engine Specification — Engine Core, Part 38  
Deterministic saves, replay-safe state, forward/backward compatibility, multi-platform safety.

Objectives:
Define a unified, deterministic, fully cross-platform save system that:
- works on Win2000+, macOS 10.6+, Linux  
- supports legacy targets where possible  
- permits massive worlds with thousands of chunks  
- supports mods and DLC cleanly  
- guarantees replay correctness  
- survives engine version changes  
- supports editing by the official world editor  
- supports cloud sync optionally  
- provides robust checksums, compression, and delta saves  

============================================================
1. SAVE SYSTEM PHILOSOPHY
============================================================

Dominium requires three global guarantees:

1. **Deterministic Save/Load Boundary**  
   A world must resume from a save identically on all platforms at all supported UPS values.

2. **Complete State Serialization**  
   Every simulation value must be serialized.  
   Nothing may be inferred from runtime timing or hardware state.

3. **Strict Separation**  
   - Simulation state saved.  
   - UI state *never* saved.  
   - Nondeterministic subsystems *never* saved.

No hidden RNG state is permitted.

============================================================
2. SAVE FORMATS
============================================================

Dominium supports *five* save formats:

| Format | Purpose |
|--------|---------|
| `.dom` | Standard compressed save (default) |
| `.domraw` | Uncompressed debugging save |
| `.domdelta` | Delta save (optional, space-efficient) |
| `.domsnap` | Snapshots extracted from replays |
| `.domworld` | Full universe export (for editors/tools) |

Compression:
- zstd by default  
- fallback: DEFLATE for legacy  
- optional LZ4 for high-speed servers  

============================================================
3. SAVE DIRECTORY STRUCTURE
============================================================

For each world:
saves/
worldname/
world.dom (primary save)
autosave_000.dom (rolling)
autosave_001.dom
autosave_002.dom
replay_inputs.dominp
replay_meta.json
thumbnails/
tick_xxxxx.png
modlist.json
version.json

============================================================
4. DETERMINISTIC SAVE BOUNDARY (CRITICAL RULE)
============================================================

The save boundary occurs only at a *tick boundary* where:

- All subsystems from PHASE A → H have completed.  
- No async tasks are pending.  
- No cross-thread jobs are executing.  

When the player saves:
- engine waits until the next safe tick  
- freezes the simulation thread  
- serializes deterministic state  
- unfreezes simulation

UI and rendering threads continue unaffected.

============================================================
5. SERIALIZATION MODEL
============================================================

### 5.1 Core model: Flat Arrays + Structured Blocks

All simulation state is stored as:
- fixed blocks for global state  
- chunk blocks  
- network blocks (power/data/fluid/logistics/etc)  
- entity arrays  
- inventory arrays  
- machine state tables  
- event queues (if deterministic)

### 5.2 Deterministic storage rules

- All integers little-endian  
- All floats are serialized as IEEE754 raw bytes  
- No compression of individual fields (only whole-block compression)  
- Arrays are saved in deterministic sorted order  
- Hash maps replaced with deterministic arrays on save  
- No pointers stored — handles only  
- No variable field order  
- No platform-dependent sizes  
- No padding based on compiler

### 5.3 Versioned blocks

Each block begins with:
uint32 block_id
uint32 block_version
uint32 block_size

Block versions evolve independently.

============================================================
6. SAVE CONTENTS (DETAILED)
============================================================

### 6.1 Global block
Includes:
- simulation tick number  
- current UPS/FPS setting (non-sim)  
- world seed  
- random generator deterministic state  
- time-of-day, date, calendar  
- global climate state  
- universe metadata  
- technology tree progress  
- company financials  
- resource registry  
- mod registry  

### 6.2 Chunk blocks
For each chunk:
- terrain heightfield  
- terrain materials  
- vegetation  
- structures  
- navmesh caches (optional, can be rebuilt)  
- temperature/pressure per cell  
- soil state  
- water level arrays  

### 6.3 Networks
Per-network:
- power: voltages, currents, phases  
- data: adjacency lists, message queues  
- fluids: pressure, temperature, mass flow  
- logistics: routes, path reservations  

### 6.4 Entities
- position/orientation  
- velocity  
- inventory bindings  
- machine operational state  
- construction progress  
- vehicles: routes, schedules  
- workers: assignments, skills  

### 6.5 Replays
Stored separately.  
Saves include “replay sync token” for validation.

============================================================
7. SAVE COMPATIBILITY MODEL
============================================================

Dominium uses a **monotonic forward-compatible format**:

### 7.1 Forward compatibility
Old saves will load on newer versions because:
- missing blocks default to zero  
- unknown blocks are ignored  
- versioned blocks have parsers for all prior versions  

### 7.2 Backward compatibility
Not guaranteed.  
But the world editor can export backwards-compatible format via conversion.

### 7.3 Mod compatibility
- `modlist.json` recorded in save  
- save fails to load if required mods missing  
- optional “force load anyway” mode (risky but allowed)  
- modded states isolated in mod block  

============================================================
8. CHECKSUM SYSTEM
============================================================

### 8.1 Purpose
- verify save integrity  
- confirm multiplayer state sync  
- confirm replay correctness  

### 8.2 hash model
- global CRC64  
- per-block CRC32  
- optional SHA256 for strong verification  

### 8.3 determinism constraints
Checksums include:
- only simulation state  
- no nondeterministic values  
- no timestamps  
- no floating-point noise outside sim values  
- no UI state  

============================================================
9. AUTOSAVE & SAFETY
============================================================

Autosaves:
- rolling buffer of N saves (default 3)  
- interval: real-time or tick-based  
- safe tick boundary only  

Crash safety:
- write to temporary file  
- fsync  
- atomic rename to final save  

============================================================
10. CLOUD SYNC (OPTIONAL)
============================================================

Cloud sync:
- Steam Cloud if available  
- GOG cloud if available  
- local cloud (folder sync)  
- fully optional  
- never blocks the engine  
- never overwrites local saves unless user consents  
- timestamps excluded from determinism  

============================================================
11. WORLD EDITOR INTEGRATION
============================================================

World editor loads `.domworld` or `.domraw`, not optimized `.dom`.

Editor can:
- inspect blocks  
- modify terrain, entities, networks  
- export deterministic new save  
- verify block-level checksums  

============================================================
12. SAVEGAME SIZE MANAGEMENT
============================================================

Techniques:
- chunk compression  
- delta saves between dirty chunks  
- pruning of unused entity pools  
- compression dictionary for repeated strings  
- binary packing  

Target save sizes:
- 32MB typical  
- 5MB small  
- 256MB large megaproperty  

============================================================
13. TESTING & VALIDATION
============================================================

Tests:
- load/save roundtrips  
- cross-platform consistency (Win/Linux/macOS)  
- replay → save → load → replay  
- chunk parity tests  
- climate and economy correctness tests  

============================================================
14. SUMMARY
============================================================

Volume 7.38 defines:
- fully deterministic, cross-platform-safe save system  
- strict block versioning  
- robust checksums  
- clean mod integration  
- forward compatibility  
- world editor support  
- safe autosaves and cloud sync  
- replay correctness  
- no nondeterministic fields  
- no DRM, no data loss, no platform lock-in  

# END OF VOLUME 7.38

Next in the sequence:
VOLUME 7.39 — Multithreading, Job System, Worker Pools, and Tick-Safe Concurrency
This covers:
deterministic job queues
cross-thread work distribution
world-chunk parallelism
avoidance of race conditions
legacy single-core fallback
APIs for simulation-safe multithreading
If you want that, say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.39 — Multithreading, Job System, Worker Pools, Tick-Safe Concurrency.
One continuous Markdown block.
Aligned with all determinism restrictions, legacy hardware targets, UPS scaling rules, and your hybrid threading philosophy.

# VOLUME 7.39 — Multithreading & Tick-Safe Concurrency  
Dominium Engine Specification — Engine Core, Part 39  
Deterministic job system, multi-core scaling, legacy fallback, and zero race conditions.

Objectives:  
Define an engine-wide concurrency model that:

- Scales from **single-core Pentium III** to **128-thread modern systems**.  
- Preserves **strict determinism** regardless of thread count.  
- Distributes heavy workloads without tick spikes.  
- Avoids races, nondeterministic ordering, and OS scheduler interference.  
- Supports your UPS philosophy (1/10/60/120+) and time-scale deformation.  
- Supports hybrid 2D/3D rendering and multiview modes.  
- Supports servers, headless, low-end, and legacy operating systems.

============================================================
1. CONCURRENCY PHILOSOPHY
============================================================

Dominium uses **deterministic multithreading**, which means:

1. Simulation always acts as a **single deterministic timeline** executed by the *simulation thread*.  
2. Worker threads perform *parallelizable computations* that **cannot modify simulation state directly**.  
3. No work is allowed to introduce nondeterministic ordering.  
4. All results rejoin the simulation at fixed synchronization points.

This matches (and exceeds) Factorio’s strict determinism, with more parallelism and broader scope.

============================================================
2. THREAD TYPES
============================================================

Dominium uses four thread classes:

### 2.1 Simulation Thread (ST)
- Runs PHASE A → H (Volume 7.10).  
- Owns all mutable simulation state.  
- Cannot be parallelized.  
- No locks inside simulation thread.  
- Deterministic by definition.

### 2.2 Worker Threads (WT)
- N threads, configurable, default = number of logical cores.  
- Execute deterministic jobs only.  
- Return structured results to ST via deterministic queues.

### 2.3 Rendering/UI Threads (RT/UIT)
- Non-deterministic.  
- Separated from simulation completely.  
- Stable FPS independent of UPS.  
- IMGUI/RMUI runs here.

### 2.4 IO Threads (IOT)
- Asynchronous file IO  
- Streaming  
- Audio streaming  
- Network IO  
All interaction with simulation uses the event/command bus, never direct state.

============================================================
3. JOB SYSTEM
============================================================

### 3.1 Job Types
All simulation jobs must fall into one of:

1. **Pure computation**  
   - Derived from read-only world state  
   - Pathfinding expansions  
   - Network matrix solves  
   - Fluid routing precomputations  
   - Machine prediction  
   - Autopilot route sampling  
   - Chunk compression for saving  
   - Climate/monthly updates

2. **Chunk-parallel tasks**  
   - Terrain LOD  
   - Navmesh generation  
   - Vegetation growth  
   - Pollution diffusion (if added later)

3. **Vectorized tasks**  
   - Data network propagation  
   - Electrical equations  
   - Fluid pressure solves

### 3.2 Job Requirements
All jobs must:
- Never write to world state directly.  
- Never read from mutable state mid-job.  
- Never use pointers into simulation memory.  
- Use a *snapshot buffer* explicitly prepared by ST.  
- Produce deterministic results regardless of thread count.

============================================================
4. DETERMINISTIC RESULTS MERGING
============================================================

Worker threads return results as:

JobResult {
job_id
deterministic_index
output_struct
}

Simulation thread merges results **by deterministic_index**, NOT arrival order.

Example:
- Pathfinding job #12 always merges before job #13.  
- Even if #13 finishes first on a 32-core system.  
- Multi-core and single-core produce identical world state.

============================================================
5. SCHEDULING MODEL
============================================================

### 5.1 Fixed job graph per tick
Each tick generates a deterministic set of jobs.

Example PHASE C (Machines):
for machine in machines_sorted_by_id:
if machine.parallelizable:
schedule_job(machine.id)
else:
run_in_simulation_thread(machine.execute())

### 5.2 Tick Boundary Synchronization
Simulation thread:
- Dispatches jobs  
- Continues with non-parallel work  
- Blocks at end-of-phase fence  
- Merges all completed results deterministically  
- Moves to next phase

### 5.3 UPS scaling
If UPS > 60:
- Jobs per tick remain stable  
- Workers flooded with more jobs/sec  

If UPS < 60:
- Engine reduces optional job types  
- Keeps simulation deterministic but slower

============================================================
6. LEGACY PLATFORM FALLBACKS
============================================================

### 6.1 Single-core mode
For Win2000 or low-power hardware:
- All jobs run synchronously on ST.  
- WT pool = 0.  
- No concurrency overhead.  
- Game remains deterministic.

### 6.2 Limited-thread mode
Player can set:
threads = 1..N

Simulation remains stable.

### 6.3 No SIMD?  
All SIMD or vectorized code paths must have:
- SSE2+ for modern platforms  
- scalar fallback for Pentium III/Win2000  
- portable scalar fallback for macOS 10.6/PPC

============================================================
7. CHUNK PARALLELISM
============================================================

Each chunk/subchunk is processed independently but results merged deterministically.

Chunk job types:
- LOD generation  
- temperature/humidity interpolation  
- ground water changes  
- vegetation simulation  
- navmesh updates  
- pollution (future DLC)  
- erosion/wind modelling

Chunk jobs identified by:
(global_chunk_id << 8) | task_type
guaranteeing deterministic merging.

============================================================
8. NETWORK PARALLELISM
============================================================

### 8.1 Data Network
- Message propagation simulated in worker jobs  
- All messages timestamped (logical-tick-time)  
- Result merge sorted by timestamp/message-ID  
- Zero packet loss, fully deterministic

### 8.2 Electrical Network
- Uses parallel matrix solving  
- Graph partitions solved independently  
- Merged via deterministic order of subnet results

### 8.3 Fluid Network
- Pressure solves  
- Pipe subnet flow solves  
- Deterministic across threads

============================================================
9. PATHFINDING PARALLELISM
============================================================

Pathfinding uses:
- Job-per-request  
- Or batch-jobs per tick  
- Worker threads perform expansion  
- Simulation merges final routes deterministically  
- A* or D* Lite allowed, but must use deterministic heuristics

To avoid nondeterministic tie-breaking:
- open-set ordered by (f_cost, entity_id, request_id)

============================================================
10. MULTITHREADING & SAVES
============================================================

Save operation:
- Only allowed during ST idle at tick boundary  
- Worker threads fully stopped or drained  
- Snapshot buffer created before writing  
- No job executes during save compression

============================================================
11. MULTITHREADING & REPLAYS
============================================================

Replays require:
- identical job graph each tick  
- identical job scheduling  
- identical job ordering  
- identical merging  
- thread count irrelevant  

Testing:
- Replay with 1 thread = same results as 32 threads.

============================================================
12. MULTITHREADING FOR HEADLESS SERVERS
============================================================

Headless servers:
- run maximum parallelism  
- no rendering thread  
- simulation thread pinned to one CPU  
- worker threads pinned to adjacent cores  
- optional real-time scheduling (Linux RT)

Determinism remains perfect.

============================================================
13. LOAD SPREADING
============================================================

Certain systems only update:
- every 2 ticks  
- every 6 ticks  
- every 60 ticks  
- using tick_modulo logic  

But **work distribution must be static per system**, not dynamic or random.

Jobs are scheduled deterministically based on tick number mod update frequency.

============================================================
14. SAFETY RULES
============================================================

The following are forbidden inside jobs:
- modifying global or chunk state  
- allocating non-deterministic memory  
- using system clock  
- using OS random  
- depending on thread index or OS scheduler  
- locking simulation data  
- accessing UI  
- interacting with PHAL  
- calling non-deterministic APIs (GPU queries, audio APIs, etc)

============================================================
15. API DESIGN
============================================================

### 15.1 Job submission
C++98 example:

```cpp
JobHandle h = JobSystem::Schedule(JobDesc {
    .id = machine.id,
    .deterministic_index = machine.serial,
    .fn = &RunMachineLogic,
    .user_data = &machine_snapshot
});
15.2 Job results
void SimulationThread::MergeResults() {
    for (auto &res : JobSystem::ResultsSorted()) {
        ApplyMachineResult(res.output_struct);
    }
}
Everything sorted deterministically by deterministic_index.
============================================================
16. DEBUGGING TOOLS
Debug overlays (IMGUI):
job profiler
thread usage graph
determinism validator
cross-thread conflict detector
replay/thread-consistency checker
timeline heatmap of job durations
============================================================
17. SUMMARY
Volume 7.39 defines:
deterministic-safe multithreading
simulation-owned world state
worker-thread job system
deterministic merging and ordering
chunk, network, pathfinding parallelism
legacy single-core fallback
multi-platform compatibility
replay-safe scheduling
clean job graph model
fully deterministic outcomes regardless of thread count
safe integration with rendering, IO, and UI threads
END OF VOLUME 7.39

---

The next natural chapter in the engine core is:

**VOLUME 7.40 — Physics, Collision, Movement, Vehicles, and Kinematic Determinism**  
This defines:
- character movement  
- vehicle motion  
- train physics  
- aircraft physics  
- collision volumes  
- raycasts & determinism  
- multi-layer terrain interaction  
- blueprint previews & physics shortcuts  
- low-end vs high-end physics modes  

Say **Proceed** to continue.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with VOLUME 7.40 — Physics, Collision, Movement, Vehicles, and Kinematic Determinism.
Single continuous Markdown block.
Fully aligned with all determinism, legacy-compatibility, blueprint-first architecture, and multi-network integration.

# VOLUME 7.40 — Physics, Collision, Movement, Vehicles & Kinematic Determinism  
Dominium Engine Specification — Engine Core, Part 40  
Deterministic kinematic simulation for characters, robots, vehicles, trains, aircraft, ships, containers, and moving infrastructure.

Objective:  
Define a physics framework that:

- Is **deterministic across platforms** (Win2000+, macOS 10.6+, Linux).  
- Degrades gracefully to **1 UPS** while remaining correct.  
- Supports **tile-based + 3D continuous world**.  
- Handles **humans, robots, trucks, trains, ships, aircraft**.  
- Supports **multi-layer terrain** (mountains, tunnels, bridges).  
- Supports **blueprint-first construction** and preview physics.  
- Works with the **job system** (Vol. 7.39) without race conditions.  
- Supports **legacy hardware** (no Havok, Bullet, PhysX, Jolt, etc).  
- Uses **pure custom deterministic physics**, tuned for simulation—not action games.  
- Supports **networked vehicles** for interproperty movement (logical exits).  
- Works consistently in **2D orthographic, 2D isometric, and 3D first-person** views.

============================================================
1. DESIGN PHILOSOPHY
============================================================

Dominium physics must be:

1. **Deterministic**, always.  
2. **Kinematic-first**, not force-first.  
3. **Discrete-time**, tied to UPS.  
4. **Custom**, not using external physics engines.  
5. **Gracefully degraded** on low-end machines.  
6. **Multi-scale**, supporting 1m cubes, tunnels, and mega-bridges.  
7. **Predictive**, supporting precomputation via worker jobs.  
8. **Not real-world-accurate**, but **consistent, stable, and intuitive**.

============================================================
2. PHYSICS MODES
============================================================

### 2.1 Kinematic Mode (Primary)
Nearly all systems are kinematic:

- Characters move according to input + navigation.  
- Vehicles follow curves, splines, and path solutions.  
- Trains obey block/signal logic and curve speeds.  
- Aircraft follow flight corridors + autopilot.  
- Ships follow water corridors.  

No dynamic rigid bodies.

### 2.2 Semi-Dynamic Mode (Optional)
Used only for:

- cargo stacking  
- falling objects during construction  
- simple gravity checks  
- stability of temporary scaffolding  

Still deterministic.

### 2.3 No Ragdolls / No Dynamic Colliders
To preserve determinism and massive-scale performance.

============================================================
3. COLLISION MODEL
============================================================

### 3.1 Collision Primitives
Everything uses:

- **AABBs** (Axis-Aligned Bounding Boxes)  
- **OBBs** (Oriented Bounding Boxes) for vehicles  
- **Spheres / capsules** for characters  
- **Convex hulls** only for special cases (e.g., irregular buildings)

### 3.2 Collision Layers
Layers:

- terrain  
- structures  
- machinery  
- vehicles  
- characters  
- cargo  
- blueprints  
- logical-only corridors (invisible infrastructure)  

Each layer pair has a collision matrix controlling interaction.

### 3.3 Spatial Partitioning
Uses **deterministic uniform grids**:

- chunk-level partition (256m x 256m)  
- subchunk-level detail (16m x 16m)  
- for micro-detail: 1m-cube voxel grid for exact walkability

No trees (no kd-tree, no BVH) to avoid nondeterminism.

============================================================
4. MOVEMENT SYSTEM
============================================================

Movement is always computed by the **simulation thread**, but can precompute:

- paths  
- steering  
- acceleration curves  

on worker threads (Vol. 7.39).

### 4.1 General Movement Equation

Movement per tick:

pos_{t+1} = pos_t + velocity_t * dt
velocity_{t+1} = clamp(velocity_t + accel * dt)

Where **dt = 1/UPS** exactly.

Only integer or fixed-point operations are allowed in deterministic builds.

### 4.2 Curved Paths via Splines
Vehicles use pre-solved splines:

- cubic Hermite  
- Bezier  
- polyline interpolations  

All spline samples are quantized to fixed steps for determinism.

============================================================
5. CHARACTERS (HUMANS & ROBOTS)
============================================================

### 5.1 Locomotion
Characters use:

- capsule collision  
- navmesh pathfinding (worker thread)  
- movement along navmesh triangles  
- simple kinematic stepping  

### 5.2 Interaction with Buildings
Characters:

- use predefined entry/exit points  
- walk inside navigable areas of buildings  
- ride lifts, stairs, ramps using spline paths  
- can descend into tunnels/mineshafts  

No physics inside buildings—movement is graph-based.

### 5.3 Carrying Items, Using Vehicles
Characters can:

- pick up items  
- load/unload containers  
- mount vehicles  
- perform jobs autonomously (AI)  

Robots differ only by input source, not movement rules.

============================================================
6. VEHICLES – GENERAL
============================================================

Vehicles include:

- forklifts  
- vans  
- semi-trailers  
- cranes  
- construction vehicles  
- off-road vehicles  
- emergency vehicles  
- heavy trucks  

Vehicle model:

- OBB collision  
- deterministic steering curves  
- realistic acceleration/braking  
- max speed determined by road type  
- simple suspension model (no springs)  
- no drifting, no slip physics  
- deterministic spline-following in autopilot mode

============================================================
7. TRAINS
============================================================

### 7.1 Tracks
Tracks are:

- spline-defined  
- user-drawn  
- constrained by grade + curvature  
- editable at blueprint phase  

### 7.2 Train Kinematics
Train motion uses:

- mass  
- max tractive effort  
- braking curves  
- curve-speed limits  
- signal blocks / token blocks / moving block (latter = DLC)

Everything deterministic.

### 7.3 Collision Safety
Trains cannot collide unless:

- player disables safeties  
- chaos mode (debug)  
- modded behavior

Otherwise block logic prevents unsafe entry.

============================================================
8. PLANES & HELICOPTERS
============================================================

### 8.1 Aircraft Paths
Aircraft do **not** use dynamic aerodynamics.
They use:

- high-altitude corridors  
- takeoff/landing patterns  
- turn radii  
- climb/descend limits  
- autopilot path graph (worker precomputation)

### 8.2 Disappearance at Horizon
Aircraft:

- rise to altitude  
- follow corridor  
- hit logical exit  
- disappear deterministically when occluded or beyond horizon distance  

Distance = configurable per planet.

============================================================
9. SHIPS & BOATS
============================================================

### 9.1 Water Surface Model
Simplified water model:

- static heightfield per tile  
- wave animation is cosmetic only  
- physics uses calm water plane  

Ships follow navigation splines derived from water polygons.

============================================================
10. TERRAIN INTERACTION
============================================================

### 10.1 Multi-layer grounded interactions
Supports:

- tunnels  
- overpasses  
- stacked bridges  
- skyscrapers  
- underground machinery  
- deep mines  
- basements  
- sub-basement levels  

Movement/vehicle layers use “z-layer routes”.

### 10.2 Slope rules
Vehicles obey:

- max grade 12% default  
- trains ~3–5% depending on tier  
- human characters unlimited (walk steep slopes slowly)  

============================================================
11. COLLISION RESOLUTION
============================================================

Kinematic collision resolution:

pos_corrected = pos - penetration_normal * penetration_depth

For characters, vehicles:

- push out deterministically  
- never jitter  
- always resolve in ID order  
- no impulses, no bounce  

Order:
1. static → dynamic  
2. dynamic → dynamic (sorted by entity_id)  

============================================================
12. PHYSICS & TICK RATES
============================================================

Physics ALWAYS matches simulation UPS:

- 1 UPS = ultra-slow deterministic physics  
- 10 UPS = normal sim, low-end machines  
- 60 UPS = canonical baseline  
- 120+ UPS = smooth motion + time warp  

Physics steps scaled by dt exactly.

============================================================
13. PHYSICS ACROSS THREADS
============================================================

Worker threads compute:

- pathfinding  
- spline optimizations  
- speed-limit calculations  
- grade/curve analysis  
- aircraft path prediction  
- traffic lane analysis  
- collision pre-checks  
- terrain sampling  

Simulation thread performs:

- final position updates  
- final collision resolution  
- final route decisions  

============================================================
14. VEHICLE CORRIDORS FOR INTERPROPERTY LINKS
============================================================

Interproperty vehicles must:

- follow surface or underground corridors  
- disappear at logical exit nodes  
- appear at destination nodes  
- maintain deterministic schedules  

All transitions are:

- visually justified (tunnels, horizon)  
- logically correct (graph links)  
- physically represented in local map (overpasses, approach ramps)

============================================================
15. HANDLING HIGH/LOW DETAIL MODES
============================================================

### High-detail (modern systems):
- fine spline sampling  
- smoother acceleration curves  
- better turning radius approximations  

### Low-detail style (Win2000-class):
- coarser spline sampling  
- simpler steering  
- lower-quality smoothing  
- deterministic fallback for everything  

Both produce identical *gameplay* results.

============================================================
16. BLUEPRINT PHYSICS
============================================================

Blueprint mode requires:

- preview collision only  
- preview slopes  
- preview train speed curves  
- preview aircraft approach cones  
- preview road grades  

Blueprints do not interact with real objects yet.  
The blueprint collider is independent and lightweight.

============================================================
17. PHYSICS AND NETWORKS (POWER, FLUID, DATA)
============================================================

Physics interacts with:

- Power: vehicles powered by electric overhead/catenary or battery  
- Fluids: pipe networks consumed by machinery in motion (e.g., fuel pipelines)  
- Data: autopilot, dispatching, routing, traffic control  

These systems flow deterministically through PHASE C/D (Vol. 7.10).

============================================================
18. PHYSICS AND MULTIPLAYER
============================================================

Physics simulation is entirely server-authoritative.  
Clients display interpolation only.  
No client-side prediction required due to slow-moving economy simulation.  

============================================================
19. RIGID INFRASTRUCTURE
============================================================

Buildings, platforms, bridges, and foundations are static.  
No building physics beyond collision envelopes and structural rules.

Optional DLC:  
Structural stress / load simulation.

============================================================
20. FUTURE EXTENSIBILITY
============================================================

The system supports optional future modules:
- wind drag on aircraft (simple)  
- buoyancy simulation for floating docks  
- simple 2D stresses in bridges  
- advanced train braking curves  
- rail adhesion based on weather  
- magnetic levitation logistics  

All must adhere to determinism rules.

============================================================
21. SUMMARY
============================================================

Volume 7.40 defines Dominium’s physics system:

- Fully deterministic  
- Kinematic-first  
- Optimized for huge worlds and low hardware minimums  
- Supports characters, robots, trucks, trains, planes, ships  
- Multi-layer terrain (tunnels/bridges/underground)  
- Spline-based, graph-driven movement  
- No rigid-body chaos  
- Clear integration with rendering, multithreading, networks  
- Seamless interproperty vehicle transitions  
- Blueprint-first and scalable  

# END OF VOLUME 7.40

Next in sequence:
VOLUME 7.41 — Navigation, Pathfinding, Traffic Logic, and Multi-Modal Routing
This covers:
humanoid pathfinding
robot job routing
road traffic AI
rail signalling logic
aircraft and ship routing
interproperty travel planning
multimodal transfer optimization
deterministic tie-break rules
navigation graph generation
If you want to continue, say Proceed.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before I generate VOLUME 7.41 — Navigation, Pathfinding, Traffic Logic, and Multi-Modal Routing, I need one clarifying decision.
This volume is extremely foundational. The routing system binds together:
humans/robots
vehicles
rail
ships
aircraft
interproperty logistics
blueprint preview routing
deterministic concurrency precomputation
network layers (power/data/fluid)
chunk/subchunk/hyperchunk geometry
To avoid contradictions later, I need you to select ONE of the three deterministic routing paradigms below.

CHOICE REQUIRED: BASE ROUTING PARADIGM
Dominium needs a single canonical routing model that all navigation types inherit from. You must choose A, B, or C before 7.41 can be written.

A — Pure Graph Model (Recommended for determinism + performance)
Everything in the world—even 3D terrain—is converted into a large set of deterministic, explicit navigation graphs.
You get:
A unified graph engine for all modes (walking, vehicles, trains, ships, aircraft).
Deterministic routing everywhere.
Easy multi-modal transfers.
Perfect replay compatibility.
Cheap to compute on worker threads.
Ideal for 1m grid with 3D offsets.
Structure:
Each chunk contributes graph nodes.
Terrain → walkable mesh nodes.
Roads → road graph.
Tracks → rail graph.
Water → coastal/water lanes.
Air → layered 3D nodes + corridors.
Interproperty links → supernodes.
This is the Factorio/RimWorld/Dwarf Fortress style generalized to 3D.
Downside:
Terrain-following paths require precomputed navmeshes but remain deterministic.

B — Hybrid Graph + Spatial Mesh Model
Two routing systems run together:
Graph-based:
roads
rail
tunnels/bridges
interproperty links
Spatial mesh-based:
humanoid walking
robots
vehicles in off-road mode
airports/shipyards
3D movement
This gives smoother local navigation, but:
harder to keep deterministic
more expensive
needs hybrid merge logic
replay integration more complex
This is closest to OpenTTD (graph) + Cities Skylines (mesh) + Satisfactory (mesh).

C — Fully Continuous Spatial Mesh (Open-world style)
All movement uses:
hierarchical navmeshes
continuous steering
mesh overlays for roads, rails, terrain
dynamic obstacle avoidance
This:
breaks strict determinism unless heavily constrained
costly for huge maps
unsuitable for Win2000-low spec target
limits multi-core determinism
makes replays risky
introduces floating-point nondeterminism
requires dynamic mesh stitching (expensive)
This is the approach used by Unreal/Unity.
Not recommended unless Dominium becomes a high-end action game (which it is not).

MY RECOMMENDATION: A (Pure Graph)
It matches everything we've built:
1m integer grid
deterministic physics
blueprint-first
multi-network corridors
worker-thread routing
huge world sizes
interproperty travel
legacy hardware support
2D/2.5D/3D modes
optional full 3D perspective
And it scales to millions of nodes with chunked graphs.

Choose now: A, B, or C.
Once you choose, I will proceed with VOLUME 7.41 immediately.
You said:
A
ChatGPT said:
GPT-5.1 — 2025-11-30
Proceeding with pure graph routing as the canonical model.
Full spec for VOLUME 7.41 — Navigation, Pathfinding, Traffic Logic, and Multi-Modal Routing follows.

# VOLUME 7.41 — Navigation, Pathfinding, Traffic Logic & Multi-Modal Routing  
Dominium Engine Specification — Engine Core, Part 41  
Pure Graph Routing for Humans, Robots, Vehicles, Trains, Ships, Aircraft & Interproperty Travel

Objective:  
Define a single, unified, deterministic navigation/routing system based on **pure graphs**, that:

- Works for **all mover types** (humans, robots, trucks, trains, ships, aircraft, shuttles).  
- Works across **all scales** (1m tiles, chunks, properties, interproperty, planetary, interplanetary).  
- Integrates cleanly with:  
  - physics (Vol. 7.40)  
  - jobs/multithreading (Vol. 7.39)  
  - networks (power, data, fluids)  
  - blueprint-first infrastructure (Vol. 2.x)  
- Remains **fully deterministic** regardless of thread count or platform.  
- Supports **logical interproperty routes** and realistic visual behaviour (tunnels, horizon, etc).  
- Respects **performance constraints** from Win2000-era hardware upwards.  

============================================================
1. GLOBAL DESIGN: PURE GRAPH ROUTING
============================================================

Dominium uses a **pure graph model** for all navigation.

Key idea:
- **Movement → Graph nodes + edges.**  
- Humanoids, vehicles, trains, ships, aircraft all traverse graphs.  
- Terrain, roads, rails, tunnels, bridges, ports, runways, shipping lanes, sky corridors → all expressed as graphs.  
- Multi-modal travel is simply pathfinding across **graph layers** with mode-change costs.

Nothing uses free-form continuous navmesh for gameplay; any local mesh is only used to build or refine graphs.

============================================================
2. GRAPH LAYERS & HIERARCHY
============================================================

### 2.1 Layers per modality

Dominium defines distinct *graph layers*:

- **G_HUMAN**: human/robot walking paths  
- **G_ROAD**: road lane segments  
- **G_RAIL**: rail track segments and junctions  
- **G_WATER**: ship lanes and port access  
- **G_AIR**: air corridors, approach/departure paths  
- **G_SPACE**: orbital and interplanetary transfer nodes  
- **G_INTERNAL**: inside-building and inside-structure walkways  
- **G_INTERPROP**: interproperty (global) graph

Each layer is its own graph, with **bridge nodes** where mode changes are allowed.

Examples:
- bus stop: G_ROAD ↔ G_HUMAN  
- train station: G_RAIL ↔ G_HUMAN  
- port: G_WATER ↔ G_HUMAN/ROAD  
- airport: G_AIR ↔ G_ROAD/HUMAN  
- spaceport: G_SPACE ↔ G_AIR/HUMAN/ROAD  
- interproperty gate: local G_* ↔ G_INTERPROP  

### 2.2 Hierarchical resolution

For scalability:

- Level 0: **micro graph** (within chunk/subchunk)  
- Level 1: **chunk graph** (connects micro nodes in a chunk)  
- Level 2: **property graph** (connects chunks, networks, hubs)  
- Level 3: **area graph** (multi-property region)  
- Level 4: **planetary graph**  
- Level 5: **solar system graph**  
- Level 6: **galactic graph**

Higher levels compress many lower-level nodes into a single abstract node (hub).

============================================================
3. GRAPH REPRESENTATION (DETERMINISTIC)
============================================================

### 3.1 Node representation

Each node:

```c
struct NavNode {
    uint64 id;           // globally unique, deterministic
    int32  x, y, z;      // integer coordinates in world meters
    uint16 layer;        // G_HUMAN, G_ROAD, etc.
    uint16 flags;        // walkable, buildable, station, junction, etc.
};
id is stable across loads and platforms, derived from (chunk_id, local_index, layer).
Coordinates are integer meters in world space; no floating point.
3.2 Edge representation
struct NavEdge {
    uint64 id;           // deterministic edge id
    uint64 from_node;
    uint64 to_node;
    uint32 cost;         // fixed-point cost (int)
    uint16 mode;         // walking, driving, train, ship, aircraft...
    uint16 flags;        // one-way, speed limit tier, reserved, etc.
};
Edges are always directed; undirected edges are modelled as two edges.
3.3 Graph storage
Per layer:
nodes[] sorted by id
adjacency lists sorted by (to_node, edge_id)
no hash maps used in final structures
built/updated via jobs, but stored deterministically by ST
============================================================
4. BUILDING GRAPHS FROM WORLD GEOMETRY
4.1 Blueprint-first approach
When player draws networks:
Roads, rails, pipelines, cables, walkways, elevators, tunnels, bridges
Each blueprint generates proposed nodes and edges
When confirmed and built, these become active in the graph.
4.2 Terrain integration
Terrain influences:
allowed slopes
allowed tunnel depths
allowed bridge heights
Graph nodes respect the constraints from physics and construction systems.
4.3 Chunk-based generation
For each chunk:
Subsystem jobs compute local graph contributions:
G_HUMAN: walkability & stairs/ramps
G_ROAD: lanes + intersections
G_RAIL: track segments + junction nodes
etc.
ST merges them into the global-layer graphs with fixed ordering (chunk_id, layer, local_index).
============================================================
5. PATHFINDING ALGORITHMS
5.1 Canonical search: A* with deterministic rules
All routing uses A* with:
heuristic h(n) = Manhattan or octile distance on integer grid with altitude cost
adjacency lists iterated in sorted order
tie-breaking: (f, g, node_id) lexicographic
open set managed with deterministic binary heap (or indexed priority queue)
no randomization
5.2 Multi-modal routing
Multi-modal pathfinding uses expanded state:
State:
struct NavState {
    uint64 node_id;
    uint8  mode;      // human, truck, train, ship, aircraft, etc.
};
Edges that change mode (boarding, disembarking, interchanges) have cost plus mode-change penalty.
5.3 Hierarchical pathfinding
For long-distance routes:
Stage 1: high-level path via area/planetary/solar graphs
Stage 2: refine per-property / per-chunk
Stage 3: local micro path (e.g. station to machine)
Each stage uses locally-limited A*.
============================================================
6. PATHFINDING WORKFLOW
Request created by simulation or AI:
NavRequest { from_node, to_node, mode, constraints }
Request enqueued for worker job (Vol. 7.39).
Worker job:
uses deterministic graph snapshot
computes path (list of NavEdges or (node_id, mode) sequence)
emits NavResult { request_id, success, path } with deterministic_index.
Simulation thread:
merges results in deterministic order
attaches route to mover (character, vehicle, train, plane, etc.)
============================================================
7. HUMANS & ROBOTS NAVIGATION (G_HUMAN)
Graph nodes at:
ground tiles
stairs
door thresholds
lifts/elevators start & end
building entrances
Edges represent:
walking
climbing stairs
elevator rides (with time cost)
passing through doors
Robot locomotion identical to humans; only path cost coefficients differ (e.g., some robots avoid rough terrain).
============================================================
8. ROAD TRAFFIC (G_ROAD)
8.1 Nodes and edges
Nodes at:
lane entry/exit points
intersections
merges/splits
border nodes to interproperty gates
Edges:
lanes with direction
speed limits (km/h) encoded into cost (time-based)
capacity tags (for traffic planning)
8.2 Traffic logic
Traffic uses two layers:
Routing layer (graph): determine best route
Traffic simulation (Vol. 7.40): vehicles follow route + obey signals
Deterministic tie-breaking for lane selection at intersections:
lane_id ascending
then vehicle_id
============================================================
9. RAIL TRAFFIC (G_RAIL)
9.1 Nodes
track junctions
block boundaries
stations & depots
portals to interproperty tunnels
9.2 Edges
track segments with:
max speed
gradient
weight limit
direction (one-way if signalled as such)
9.3 Signalling & blocks
Block graph built on top of G_RAIL:
nodes = blocks
edges = allowed transitions between blocks
Train route = sequence of blocks + fine-grained track path.
Block admission:
deterministic scheduling based on:
timetable priority
train_id
earliest arrival time
============================================================
10. WATER NAVIGATION (G_WATER)
Nodes along coastlines and deep-water paths
Edges:
shipping lanes
port approach channels
canal segments
locks (discrete nodes with time cost)
Ships:
use G_WATER path
respect depth constraints per hull type
use interproperty sea gates to reach other properties sharing bodies of water.
============================================================
11. AIR NAVIGATION (G_AIR)
Nodes:
runways ends
approach/ departure fixes
air corridors at various altitudes
transfer points to space (G_SPACE)
Aircraft path:
taxi (G_ROAD or sublayer)
takeoff node → climb corridor
cruise corridor nodes
descent corridor
approach fix → final approach → runway
ground taxi to parking or gate
Interproperty gates:
high-altitude nodes connecting properties.
plane disappears visually after passing beyond horizon gate but logically continues.
============================================================
12. SPACE NAVIGATION (G_SPACE)
Nodes = LEO/GEO orbits, transfer orbits, planetary SOI nodes.
Edges = simplified transfer arcs with cost approximating delta-v/time.
No full orbital mechanics; just graph edges with precomputed costs.
============================================================
13. INTERPROPERTY GRAPH (G_INTERPROP)
G_INTERPROP defines:
nodes = properties, hubs, special gateways
edges = legal interproperty links for each mode:
truck corridors
rail tunnelling
shipping lanes
air corridors
orbital transfers
This graph is used for:
deciding which interproperty route to use
computing long-haul transport pipelines
modelling costs, tariffs, and transit times
============================================================
14. MULTI-MODAL TRANSFERS
At hubs (ports, stations, airports):
bridge nodes connect graphs:
G_HUMAN ↔ G_ROAD
G_HUMAN ↔ G_RAIL
G_ROAD ↔ G_WATER/AIR/SPACE via cargo terminals
Transfers cost:
time to unload/load containers
time to move between nodes (walk distances)
potential handling fees (economic system)
Multi-modal routing simply traverses these bridging edges.
============================================================
15. LOCAL VS GLOBAL ROUTING
Local: same chunk/property
single-layer or simple multi-layer A*
Regional: multiple properties in same area
uses hierarchical levels: property graph → chunk graph → micro graph
Planetary/solar/galactic:
high-level path first (G_INTERPROP, G_SPACE), then refined at each leg.
All orchestrated via hierarchical pathfinding with deterministic decomposition.
============================================================
16. ROUTE LIFECYCLE
Each route has lifetime phases:
Planned — path found, but not in use yet.
Active — a mover is following it.
Stale — world changes made path invalid; flagged for replan.
Cancelled — no longer required.
Invalidation occurs when:
graph structure changes (building, demolishing, disabling edges)
capacity constraints cause route to exceed allowed limits (optional)
Replanning uses revised graphs and is deterministic.
============================================================
17. PERFORMANCE & SCALING
Techniques:
job-batched pathfinding
caching of frequently used O-D pairs (origin-destination)
segmented / partitioned graphs by zone
approximate high-level routing first
strict bounds on node expansions per tick (budgeted pathfinding)
In worst-case, path requests can be queued across multiple ticks.
============================================================
18. DEBUGGING & VISUALIZATION
IMGUI / RMUI debug panels:
graph overlays (per layer)
node and edge highlighting
path visualization for selected entity
congestion maps (traffic density, train bottlenecks)
interproperty route diagrams
route validity checker
detour detection and cost breakdown
All debug tools are non-deterministic UI only; they do not alter sim.
============================================================
19. DETERMINISM & REPLAY GUARANTEES
To maintain determinism:
Graph build and updates run through ST with deterministic ordering.
Worker pathfinding uses read-only snapshots and deterministic A*.
Merge order is defined by request_id / deterministic_index.
No route randomization.
Tie-break based on (f_cost, g_cost, node_id) in A*.
No concurrency races; job system rules (7.39) enforced.
Replays:
same pathfind requests, same graph states → identical routes every time.
============================================================
20. FAILURE MODES & FALLBACKS
Pathfinding can legitimately fail if:
destination unreachable
graph partitioned
wrong mode specified
In such cases:
AI receives deterministic failure reason.
System can either:
queue replan attempt later
notify player via UI
choose alternative goal
No infinite search loops; pathfinding has hard limits and clear outcomes.
============================================================
21. SUMMARY
Volume 7.41 defines Dominium’s global navigation system:
Pure graph model for all movement and modes.
Separate graph layers but unified multi-modal routing.
Chunk → property → area → planet → solar → galactic hierarchy.
Deterministic A* pathfinding with stable tie-breaking.
Full support for:
humans/robots
road traffic
rail networks and signalling
ships and ports
aircraft and airports
orbital/space transfers
interproperty traffic.
Blueprint-first integration.
Worker-thread parallelization.
Complete determinism and replay safety across all hardware and OS targets.
END OF VOLUME 7.41

You can continue with the next obvious volume (e.g. **7.42 — AI Companies, Decision Models, Demand/Supply & World Simulation**, or target a different area if you prefer).
::contentReference[oaicite:0]{index=0}
You said:
What's next
ChatGPT said:
GPT-5.1 — 2025-11-30
You’re now at the point where Volume 7.41 (Navigation & Routing) is complete.
The next volumes follow a strict dependency chain inside the Dominium spec roadmap.
Below is the canonical continuation order, with the next item clearly identified.
============================================================
NEXT REQUIRED VOLUME IN THE SPEC ROADMAP
→ VOLUME 7.42 — AI COMPANIES, DECISION MODELS & WORLD SIMULATION
This is the next mandatory section.
It defines:
AI Companies / AI Players
autonomous property owners
demand/supply logic
construction decisions
economic strategy
expansion, mergers, market behaviour
long-term planning under imperfect information
AI Agents (individual workers, robots)
task assignment
routing requests
job scheduling
labour market simulation
Macroeconomic Simulation
sector output
prices
global demand curves
AI trade behaviour
transportation optimisation
AI Interaction With the Player
negotiations
contracts
alliances
peaceful or competitive behaviour
future war DLC integration hooks (non-functional in base game)
AI Determinism Framework
deterministic decision trees
tick-phase ordering
no randomness
replay stability
AI Performance Levels
low-power mode for Win2000
standard mode
multi-core accelerated mode
AI Modding Hooks
standardised Lua API
ability to override behaviour trees
sandboxed simulation
This volume is a cornerstone: it links economic simulation, routing, production machines, workers, trade, and the macro-scale world model.
============================================================
ORDER AFTER 7.42
For clarity, here is the remaining roadmap in order.
You requested to proceed sequentially through A → B → C → D → E earlier; this continues the same meta-structure.
After 7.42, the volumes will be:
7.43 — Production Flow, Factories, Machines & Throughput Modeling
7.44 — Logistics, Inventory, Storage, Warehouses & Containerization
7.45 — Contracts, Trade Networks, Markets & Economic Algorithms
7.46 — Player Progression, Research, Tech Tree, Data Network Integration
7.47 — UI/UX Interaction Model for All Systems
7.48 — Content Framework, Items, Materials, Blueprints, Modules
7.49 — Modding API (Lua), Data Definitions, Script Boundaries
7.50 — Sound, Music, Reactor, Atmospherics
7.51 — Visual System (2D Vector, 2D Texture, 3D, LOD, Modes 0–3)
7.52 — Save/Load State, Serialization, Migration & Backwards Compatibility
7.53 — Networking & Multiplayer Protocol (Deterministic / Lockstep / Hybrid)
7.54 — Launcher Integration, Build System, Platforms
7.55 — Distribution, Packaging, Installers, Media Constraints
Then Volumes 8–12 cover:
World generation
Planetary definitions
DLC structure
Content authoring systems
Legal integration
Toolchain
Release engineering
============================================================
YOUR NEXT ACTION
If you want this to continue exactly as we’ve been doing:
Say: "Proceed with 7.42"
and I will generate Volume 7.42: AI Companies, Decision Models & World Simulation
using the strict Dominium format, deterministic rules, all prior constraints, no omissions.
If you want a different next volume, specify it.
You said:
Proceed 7.42
ChatGPT said:
GPT-5.1 — 2025-11-30
Ready to generate VOLUME 7.42.
Before I begin, I need one mandatory clarification.
This is essential because the design of the Dominium AI economy depends on choosing which economic abstraction model the AI companies use to make decisions.
This choice determines:
supply/demand curves
pricing
production planning
logistics routing
land acquisition
investment
labour management
technology adoption
AI personality modelling
market stability vs volatility
Without fixing this, any detailed spec I generate would be inconsistent.
Below are the three canonical models.
============================================================
CHOOSE ONE: Dominium AI ECONOMIC DECISION PARADIGM
============================================================
A — Deterministic Micro-Foundation Economy (Highly Recommended)
AI companies run a deterministic microeconomic simulation:
Every firm has a clear cost function
Marginal cost curves determine output
Prices formed by deterministic market-clearing
Zero randomness
Perfect replay compatibility
Every action is explainable:
“We expand rail capacity because marginal hauling cost dropped below expected price in Q2.”
Scales beautifully to thousands of AI firms
Fully deterministic on Win2000 hardware
Works with real container logistics
Downsides:
Requires careful curation of parameters to avoid deadlocks
AI behaviour appears highly rational (less chaotic/organic unless layered with “imperfection layers”)
This produces a stable, elegant simulation similar to Transport Tycoon + Factorio + Dwarf Fortress market layers.

B — Behavioural AI Economy (Realistic but less deterministic)
AI companies emulate bounded rational behaviour:
imperfect knowledge
delays in reaction
beliefs about future prices
planning mistakes
occasional suboptimal decisions
Pros:
feels very human
produces market booms and busts organically
more emergent behaviour
Cons:
requires random components OR pseudo-random time-shifts
difficult to reproduce deterministically across multiple machines
breaks strict replay unless heavily constrained
This is closer to SimCity 4 + Cities Skylines style agent economics.

C — Hybrid: Deterministic Core + Behavioural Noise Layer
A two-layer system:
Layer 1: Deterministic micro-economy (supply/demand, cost curves, logistics, rational decisions)
Layer 2: Behavioural overlay:
optional
deterministic pseudo-random pattern generators (no real RNG)
creates “imperfect intelligence”
slow-changing biases (optimism/pessimism)
personality traits
risk tolerance
asymmetric information
Produces emergent behaviour but keeps simulation reproducibility.
This is the model used in:
Victoria II
Factorio’s biters with deterministic pseudo-randomness
Some 4X strategy AI frameworks
Pros:
most realistic
most fun
still deterministic
avoids perfect rational robots
highly moddable
Cons:
most engineering work
requires a persistent bias-state tracker per company
needs careful tick-ordering
============================================================
MY RECOMMENDATION
C.
It keeps Dominium deterministic, replay compatible, mod friendly, but avoids sterile “perfect planner” AIs.
============================================================
YOUR CHOICE REQUIRED
Respond with: A, B, or C.
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.42 — AI COMPANIES, DECISION MODELS & WORLD SIMULATION
(Hybrid Deterministic + Behavioural Bias Model)
Below is the complete, fully-formalised specification for 7.42, structured in Dominium’s established canonical documentation style.
Everything here is 100% deterministic, cross-platform, replay-safe, and compatible with all prior volumes.
=====================================================================
VOLUME 7.42 — AI COMPANIES, DECISION MODELS & WORLD SIMULATION
=====================================================================
7.42.0 Overview
AI Companies represent autonomous economic agents operating inside Dominium’s world simulation.
They behave like real firms:
own land
build infrastructure
trade
transport goods
employ workers/robots
research technologies
plan decades ahead
The AI model uses Hybrid Deterministic Behaviour (Choice C):
Hard deterministic microeconomics (cost curves, marginal analysis, logistics optimisation)
Soft behavioural imperfections (biases, heuristics, long-cycle “personality drift”)
No randomness; all noise is deterministic pseudo-temporal sequences
Perfect replay reproducibility

7.42.1 Company Identity Model
Each AI Company has a persistent identity object:
7.42.1.1 Core Identity Fields
UID (128-bit)
Name (generated or mod-supplied)
HQ Property reference
Legal Type:
Private
State-owned
Cooperative
Player-owned (AI-assisted mode)
Industry Classification (NAICS-like deterministic enum)
Founding date (game ticks)
7.42.1.2 Company Personality
Deterministic behavioural traits:
Risk tolerance (0.0–1.0)
Time preference / discount rate
Expansion aggressiveness
Tech optimism / conservatism
Liquidity preference
Infrastructure bias (rail vs road vs air vs water)
Labour preference (humans vs robots)
These evolve slowly according to deterministic bias cycles.

7.42.2 Decision Architecture
AI companies use a three-layer deterministic decision pipeline:
LAYER 1 — Rational Microeconomic Core
Every decision is constrained by:
marginal cost curves
marginal revenue curves
capital & operating costs
logistics performance
inventory levels
asset depreciation
expected demand
supply chain bottlenecks
power/data/fluid network status
land availability & property adjacency rules
This layer guarantees:
reproducibility
cross-platform determinism
stable economic equilibrium
LAYER 2 — Behavioural Bias Overlay
A deterministic pseudo-random periodic pattern modifies:
optimism/pessimism
overinvestment cycles
delay in recognising oversupply
path dependence
managerial inertia
This creates:
boom/bust cycles
competitive diversity
unique “company personalities”
LAYER 3 — Constraints & Sanity Filters
Ensures no company breaks:
solvency
logistics deadlocks
pathological behaviours
infinite loops
deterministic ordering

7.42.3 Economic Model Integration
7.42.3.1 Market Interaction
Companies participate in:
commodity markets
energy markets
container logistics markets
labour markets
futures/options (if enabled)
intercompany contracts
Prices form via deterministic clearing:
Aggregate supply curve
Aggregate demand curve
Intersection solves per-tick or per-period
7.42.3.2 Production & Throughput
AI determines:
optimal machine utilisation
number of shifts
fuel/energy procurement
input/output smoothing
buffer sizing
container allocations
rail/road/air/sea routing
7.42.3.3 Investment & Expansion
Decisions include:
new factories
property expansion
new workers or robots
research investment
logistics upgrades
vehicle fleet expansion

7.42.4 Logistics Intelligence
AI companies automatically compute:
optimal routing (using Volume 7.41 deterministic graph engine)
cost per TEU-km for each mode
pipeline vs road vs rail vs air cost curves
multi-hop routing
container type selection (5ft, 10ft, 20ft, 40ft, 80ft)
tanker vs container selection for fluids
The AI optimises:
throughput
cost
time
reliability
energy consumption

7.42.5 Labour & Robotics Systems
AI companies manage:
7.42.5.1 Human Workers
wages
hiring/firing
skill levels
training queues
housing demand
working shifts
commuting routes
7.42.5.2 Robots
purchase costs
maintenance
energy consumption
AI brain upgrades
deterministic behaviour models
Robots and humans use the same deterministic pathfinding infrastructure.

7.42.6 Research & Data Network Integration
AI companies use data signals to:
request research inputs
transmit measurement data
broadcast logistics stats
monitor facility status
manage remote sensors
Research priorities follow:
deterministic utility evaluation
weighted by behavioural traits
subject to tech-tree prerequisites

7.42.7 Land, Property & Expansion Rules
AI companies:
purchase adjacent land
merge properties
subdivide internal zones
negotiate with players (deterministic outcomes)
engage in long-term planning
Expansion governed by:
global market signals
production capacity
logistics bottlenecks
company personality

7.42.8 Intercompany Contracts & Negotiation
Deterministic models for:
supply contracts
fixed-rate agreements
transport services
infrastructure leasing
joint ventures
coalition formation
Negotiation uses:
marginal analysis
behavioural risk profiles
preference heuristics

7.42.9 Macro-Simulation Layer
This includes:
7.42.9.1 Sector Model
Each industry sector has:
productivity
capital intensity
labour substitution elasticity
demand trends
7.42.9.2 Global Cycles
Optional deterministic cycles:
economic long waves
seasonal patterns
sectoral expansions/contractions
No RNG. All waveforms are deterministic functions.

7.42.10 AI Stability, Performance & Scaling
7.42.10.1 Tiers
Tier 0: minimal logic for Win2000
Tier 1: normal
Tier 2: advanced optimisation, multi-core
Tier X: developer mode (graph introspection, IPC monitoring)
7.42.10.2 Performance Rules
heavy calculations spread across ticks
priority scheduling
caching of cost curves
lazy evaluation of logistics demand

7.42.11 Modding Hooks
Modders may define:
new company types
new personalities
new decision patterns
new sectors
custom behavioural overlays
All mod AI remains deterministic.

7.42.12 Save/Load & Replay Integration
All AI state is stored:
personality traits
bias phases
economic projections
asset ownership
logistics allocations
contract states
Replay integrity guaranteed:
no time-dependent randomness
strict tick ordering

7.42.13 Summary (strict bullet form)
Deterministic core
Behavioural overlay with deterministic pseudo-noise
No randomness anywhere
Predictable replay behaviour
Companies behave uniquely
Markets clear deterministically
Logistics globally optimised
Robots and humans included
Supports low-power hardware
Fully moddable
=====================================================================
VOLUME 7.42 COMPLETE
If ready, say:
Proceed 7.43
to generate:
VOLUME 7.43 — Production Flow, Factories, Machines & Throughput Modelling
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.43 — Production Flow, Factories, Machines & Throughput Modelling, I need one critical architectural confirmation.
This is mandatory because Dominium’s entire economic, logistics, research, and labour systems depend on exactly how production recipes, throughput, and machine processing are represented.
This choice will define:
how machines consume/produce
how input/output buffers work
how conveyor-equivalent systems behave
how factory logic connects to power/data/fluid networks
how throughput scales
how determinism is preserved
how modders define recipes
how multi-machine pipelines behave
how 1-tick vs multi-tick processing works
how containerisation interacts with local production
Without locking this down, 7.43 cannot be generated safely.
============================================================
CHOOSE ONE: PRODUCTION MODEL PARADIGM
============================================================
A — Batch/Recipe Processing (Factorio-like but deterministic-biased)
Machines have:
fixed recipe
fixed cycle time
fixed input amounts
fixed output amounts
input buffers (per input)
output buffers (per output)
strict per-tick state machine
deterministic sequencing
no partial processing
Cycle looks like:
Check all inputs available
Lock them
Process for N ticks
Deposit outputs
Repeat
Pros:
deterministic
easy to understand
great modding clarity
stable performance
no fractional items
Cons:
less realistic precision
large factories become clocked systems
This works best if Dominium resembles Factorio + Transport Tycoon + Industry Giant.

B — Continuous Flow (Satisfactory-like but discretised)
Machines consume inputs continuously:
consumption rate per unit time
production rate per unit time
partial processing allowed
fractional item progress tracked
buffers can hold fractional progress
Examples:
furnaces that melt continuously
assemblers that run even with partial material
pumps with continuous fluid flow
Pros:
very realistic industrial modelling
smooth throughput
supports advanced complex machines
Cons:
extremely difficult to make deterministic
floating point desync risk
heavy CPU
unsuitable for Win2000-era hardware
replays more fragile
This is the most realistic but hardest.

C — Hybrid: Deterministic Cycles + Continuous ANCHORED Rates
This blends A and B correctly:
Processing:
Machine has a cycle time (N ticks)
But inputs and outputs support continuous flow constraints
Inputs can be fed continuously but only locked at cycle-start
Outputs accumulate in deterministic discrete quanta
Fractional internal progress stored as fixed-point (e.g. 1/65536 units)
Behaviour:
Machines still operate in discrete cycles (deterministic)
But flow networks (power/fluid) can drive machine rate modulation
So machines can run at 42%, 73%, 150%, etc speed based on power, heat, or supply
Always deterministic because progression uses fixed-point arithmetic
Pros:
best of both worlds
discrete determinism preserved
modding-friendly
consistent with power/fluid thermal systems
supports advanced late-game machines
ideal for containerised transport inputs/outputs
Cons:
moderate complexity
requires careful fixed-point modelling

MY RECOMMENDATION: C
Because Dominium is:
deterministic
multi-platform
simulation-heavy
low-power compatible
long-term scalable
logistic-focused
research-heavy
intended for massive factories
A pure A or pure B would compromise part of this vision.
============================================================
Your choice is required
Respond: A, B, or C.
Once chosen, I will generate the full VOLUME 7.43.
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.43 — Production Flow, Factories, Machines & Throughput Modelling
(Hybrid Deterministic Cycles + Continuous Fixed-Point Rates)
Complete, formal, and fully aligned with all prior volumes.
=====================================================================
VOLUME 7.43 — PRODUCTION FLOW, FACTORIES, MACHINES & THROUGHPUT
=====================================================================
Dominium’s production system models realistic industrial behaviour while preserving:
strict determinism
fixed-point arithmetic
cross-platform reproducibility
low-spec hardware compatibility
full modding access
infinite scalability
clean integration with power, fluid, thermal, data, and logistics networks
This hybrid model combines discrete cycles with continuous rate modulation.

7.43.0 Overview
Every production entity in Dominium is a Machine.
Machines are connected by:
power networks
data networks
fluid networks
logistics networks (containers, belts, chutes)
worker/robot service routing
Every machine:
consumes inputs
produces outputs
converts energy into work
generates byproducts (heat, noise, pollution if enabled)
maintains deterministic internal state
executes on a machine tick at the global UPS
Machines may be:
placed in buildings
built outdoors
stacked vertically
tunnelled underground
mounted in vehicles/vessels
integrated into mobile production (trains, ships, aircraft, orbital factories)

7.43.1 Machine Structure
Every machine has 6 mandatory components.
7.43.1.1 Machine Identity
UID
Type
Tier
Technology requirements
Footprint (1m grid)
Orientation
Elevation (Z)
I/O ports (grid-aligned or machine-specific geometry)
7.43.1.2 Input Ports
Each input port has:
accepted container types or bulk categories
accepted fluids (optional)
required mixture composition
buffer size
maximum inflow rate
quality requirements (temperature, purity, pressure, voltage if electronic)
7.43.1.3 Output Ports
Each output port has:
output buffer capacity
outflow rate
preferred container type
pressure/temperature constraints (fluid)
routing tags for logistics graph
7.43.1.4 Power Node
Defines:
required wattage
acceptable voltage range
acceptable frequency range
power factor
startup inrush multiplier
deterministic derating curve if underpowered
7.43.1.5 Data Node
machine ID
addressable memory map
direct variable access
packet send/receive buffers
interrupt lines for process completion
override behaviour for player scripts
7.43.1.6 Thermal Node
heat generation per cycle
cooling efficiency
fluid cooling support
thermal mass
temperature limits
deterministic thermal conduction to neighbours

7.43.2 Processing Model (Hybrid)
Machines operate on cycles, but their rate is modulated continuously through fixed-point arithmetic.
7.43.2.1 Cycle Core
A machine cycle is defined by:
cycle_time_ticks (N)
cycle_input_requirements (per input)
cycle_output_amounts (per output)
Processing state machine:
Idle — waiting for inputs & power
Start Cycle — lock inputs
Process — advance progress using rate multiplier
Finish — deposit outputs
Cooldown — optional
7.43.2.2 Continuous Rate Modulation
Each tick, processing progress increments by:
progress += (base_rate * power_factor * thermal_factor * supply_factor) * dt
All values represented in fixed-point 32.32 or 16.16, selectable per platform.
Where:
base_rate = 1 / cycle_time_ticks
power_factor = min(available_power / required_power, 1.0)
thermal_factor = f(temp)
supply_factor = soft penalty for partial input supply
The machine always remains deterministic.
7.43.2.3 Fractional Progress
Progress is stored in fixed-point to avoid FP desync.
When progress ≥ 1.0:
cycle completes
overflow carries to next cycle
7.43.2.4 Partial Inputs
Machines can begin processing only after the minimum discrete input threshold is met.
Continuous consumption is allowed as long as:
the machine does not violate the discrete input lock
fractional consumption is tracked in fixed-point
outputs are still produced discretely
This is the hybrid foundation.

7.43.3 Buffers & Inventory
7.43.3.1 Input Buffers
each port has FIFO or priority buffer
buffer sizes configurable by machine tier
can hold items, fluids, heat, gas, electricity (in battery machines)
7.43.3.2 Output Buffers
storage before routing
output is blocked if full
backpressure throttles machine via supply_factor
7.43.3.3 Containers
All transport uses:
5ft, 10ft, 20ft, 40ft, 80ft ISO containers (TEU classes)
fluid tankers (small/medium/large)
gas cylinders
bulk containers (crates, bags, barrels) for belts
These integrate seamlessly into machine I/O.

7.43.4 Machine Types
7.43.4.1 Basic Machine Classes
Extractor
Smelter
Crafter
Assembler
Mixer
Chemical reactor
Pump
Generator
Motor/compressor
Refinery
PCB fabricator
Logistics loader/unloader
Rail/road/air/water container terminals
Robotics systems
Computing/data-processing nodes
7.43.4.2 Modular Machines
multi-block structures
assembled in blueprint mode
scalable capacity
deterministic internal routing
7.43.4.3 Mobile Machines
train-based factories
shipboard production
aircraft carriers
orbital factories
lunar bases
All use same cycle model.

7.43.5 Throughput & Scaling
7.43.5.1 Deterministic Throughput
Throughput = outputs per cycle_time / rate_factor
Always computed with fixed-point logic.
7.43.5.2 Overclocking / Underclocking
Machines can:
run at >100% if supplied extra power (tech-dependent)
run at half speed when lightly powered
shut off or enter brownout mode when deeply underpowered
7.43.5.3 Parallelisation
multiple machines
multi-tile machines
chunk-local task distribution
7.43.5.4 Diminishing Returns
Advanced machines use diminishing-return functions on:
overheating
undercooling
fluid starvation
overpressure
All deterministic functions (piecewise-linear fixed-point curves).

7.43.6 Facility-Level Systems
7.43.6.1 Factories
Factories are:
regions that group machines
share infrastructure
have central control logic
can be hierarchical (factory → subfactory → machine)
7.43.6.2 Production Lines
sequential machines
containerised or bulk flows
blueprint-first design
deterministic routing
7.43.6.3 Workshops & Hand-Crafting
Human players/workers can:
craft manually using same cycle model
consume stamina/time
gain skill XP
slow but flexible
7.43.6.4 Robotics Workshops
Robots repair and maintain machines:
battery charging
tool consumption
deterministic routing via 7.41

7.43.7 Network Interactions
7.43.7.1 Power Network
machine rate tied to available watts
deterministic derate curves
harmonic load modelling (fixed-point)
DC, single-phase AC, three-phase AC
7.43.7.2 Fluid Network
pressure-driven flow
deterministic per-tick solver
multi-fluid separation enforced
tanks provide buffer smoothing
7.43.7.3 Data Network
machine reports internal state
receives rate-control commands
supports circuit-like logic (hold/pulse)
deterministic packet scheduling

7.43.8 Modding Framework
Modders can define:
machines
recipes
tiers
energy profiles
cycle times
thermal behaviour
container preferences
input/output constraints
All definitions occur in:
/data/machines/
/data/recipes/
/data/fluids/
/data/materials/
Lua can:
override behaviour
add new logic
compute dynamic cycle multipliers
modify machine responses
but cannot break determinism.

7.43.9 Save/Load Integration
Machine state must serialize:
cycle progress (fixed-point)
input buffer contents
output buffer contents
power/data/fluid state
thermal state
machine mode (idle, processing, cooldown)
overclock factor
fault/wear condition (if enabled)
Replay consistency guaranteed.

7.43.10 Summary (Strict Bullet Form)
Hybrid processing (discrete cycles + continuous modulation)
Deterministic fixed-point arithmetic everywhere
Full integration with all networks
Machine types broad and extensible
Tiered scaling
Mod-friendly
Perfect replay & multiplayer determinism
Compatible with Win2000+ low-power systems
Supports late-game megafactories and space industry
=====================================================================
VOLUME 7.43 COMPLETE
When ready, say:
Proceed 7.44
to generate:
VOLUME 7.44 — Logistics, Inventory, Storage, Warehouses & Containerization
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.44 — Logistics, Inventory, Storage, Warehouses & Containerization, one clarification is required.
This volume is extremely sensitive, because Dominium’s entire physical economy depends on a single architectural choice:
How will physical goods be represented and moved through the world?
You must choose one of three paradigms.
This will affect:
containers (5ft/10ft/20ft/40ft/80ft)
belts
warehouses
ports
interproperty transport
trains/trucks/ships/planes
input/output buffers
storage
throughput
determinism
performance
modding
replays
AI logic

CHOOSE ONE: GOODS REPRESENTATION MODEL
A — Pure Containerized Model (Recommended for Dominium)
All physical goods always exist inside a container, except:
fluid inside pipes/tanks
electricity
data
Containers represent units of space/volume/mass.
Types:
Standard ISO containers (5/10/20/40/80 ft)
Tank containers
Gas cylinders
Pallets / crates / boxes / bags for belts
Bulk hoppers (for ores, grains, aggregates)
Everything moves deterministically via:
trucks
trains
ships
aircraft
drones (later tech)
conveyors/chutes (logical belts)
No free-floating items in the world.
No item-entity simulation.
No 1-item-on-belt simulation.
Deterministic, cheap, perfect for massive factories.
Pros:
scalable to millions of items
fully deterministic
fits your desired realism
integrates perfectly with TEU logistics
extremely efficient
works with workers/robots loading/unloading
avoids Satisfactory-style performance costs
blends smoothly with production machines from 7.43
Cons:
less “visual toy” feel
belts are visual/logical, not item-by-item

B — Mixed Containers + Physical Items
Most goods use containers, but some appear as:
loose items on belts
objects carried by workers
dropped items during failures
visible pallets or boxes
Better visual appeal, but:
harder determinism
more CPU cost
potential desync risk
more mod complexity

C — Fully Physical Items (not recommended)
Every item is:
a physical entity
visible
placed on belts
picked up individually
subject to physics
This is how Factorio / Satisfactory handle visible items, but:
extremely costly
nondeterministic on old systems
cannot run on Win2000-class hardware
major replay complexity
terrible for massive factories
reduces universe scale feasibility

MY RECOMMENDATION: A — Pure Containerized Model
It matches:
your TEU-based logistics
realistic warehousing
real-world transport
deterministic simulation
huge scalability
low-power compatibility
interaction with AI companies
massive universe scale

Your choice is needed.
Respond with A, B, or C.
Once chosen, I will generate the full VOLUME 7.44.
You said:
A. We should allow users to use and store and transport many different forms of packaging, but interproperty logistics should be teu only.
ChatGPT said:
GPT-5.1 — 2025-11-30
Confirmed: A — Pure Containerized Model, with local packaging diversity but interproperty TEU-only.
Generating the complete formal specification now.
=====================================================================
VOLUME 7.44 — LOGISTICS, INVENTORY, STORAGE, WAREHOUSES & CONTAINERIZATION
=====================================================================
Dominium uses a unified, deterministic, scalable, containerized logistics system.
All physical goods exist as:
Containers (TEU-scale and sub-TEU packaging)
Fluids (pipes, tanks, tank-containers, cisterns)
Bulk solids (hoppers, silos)
Energy (electrical networks)
Data (packet networks)
There are no “free item entities” in the world.
This ensures:
perfect determinism
zero floating-point chaos
infinite scalability
compatibility with low-end platforms
stable replays
parallel simulation compatibility

7.44.0 Overview
This volume defines the complete model for:
inventory
warehouses
storage structures
packaging
containerization
vehicle loading/unloading
local vs interproperty logistics
routing integration (7.41)
machine I/O integration (7.43)
AI economic integration (7.42)
determinism and save/load guarantees

7.44.1 Goods Representation Model
7.44.1.1 Fundamental Principle
All goods must be represented in one of the following deterministic forms:
TEU-Class Containers (Interproperty)
5ft (~0.25 TEU)
10ft (~0.5 TEU)
20ft (1 TEU)
40ft (2 TEU)
80ft (4 TEU)
Tank Containers
Refrigerated Containers
High-cube Containers
Flat-rack and open-top options
Sub-TEU Local Packaging (Intraproperty Only)
crates
boxes
bags
barrels
pallets
small tanks
ingots
coils
rolls
reels
commodity bales (cotton, wool, scrap metal)
chemical drums
Bulk Storage Modes
hoppers
silos
grain elevators
raw ore piles (logical, not visual particle simulation)
Fluids & Gases
pipe networks
tanks
tanker containers
tanker trucks
tanker railcars
tanker ships
7.44.1.2 Universal Deterministic Quantization
All goods volumes, masses, and quantities are stored as:
64-bit fixed point integers
Format:
32 bits integer
32 bits fractional
This guarantees:
cross-platform determinism
zero float variance
perfect replay reproducibility

7.44.2 Storage Architecture
7.44.2.1 Inventories
Every inventory has:
maximum volume (m³)
maximum mass (kg)
cell count (optional)
accepted packaging types
deterministic LRU/FIFO/LIFO policies
internal fragmentation model (container slotting)
7.44.2.2 Warehouse Types
Manual Warehouse
humans & robots operate
slower
cheap
Automated Warehouse
cranes
stacker robots
sorting lifts
cross-docking lanes
Cold Storage Warehouse
refrigeration integration
power draw curves
HazMat Storage
special requirements
fluid containment
negative pressure rooms
TEU Container Yard
TEU stacks (up to 6–8 high)
rail sidings
truck staging
ship terminal integration
7.44.2.3 Silos & Hoppers
All silos/hoppers:
store bulk materials
have vertical pressure modeling (deterministic)
integrate with fluid-like hopper flow
7.44.2.4 Tanks
Tanks:
store fluids or gases
track temperature
track pressure
connect to pipes or tanker containers

7.44.3 Packaging System
7.44.3.1 Packaging Classes
Local Packaging (Intraproperty Only)
Used for:
belts
chutes
local delivery
manual carrying
storerooms
Types include:
boxes
crates
barrels
bags
pallets
totes
drums
All obey:
volume limit
weight limit
structural properties (max stacking height)
Interproperty Packaging (TEU Only)
Used for:
trucks
trains
ships
aircraft
rockets
elevators (space or planetary)
ALL interproperty transport MUST use TEU containers.
No exceptions.
7.44.3.2 Shrink-Wrapping, Palletizing, Bundling
These are cosmetic + capacity-modifying modifiers applied deterministically.

7.44.4 Transport & Loading/Unloading
7.44.4.1 Loading Rules
Loading obeys:
crane/forklift reach
node connections (7.41 graphs)
ramp/tunnel access
clearance and footprint checks
deterministic sequencing
7.44.4.2 Transport Modes
Road (Trucks)
truck capacity in TEU
axle mass limits
engine power scaling
deterministic routing
Rail
wagons with TEU slots
tankers for fluid
bulk hoppers
piggyback trailers
Air
belly cargo
dedicated freighters
containerised pallets
Water
container ships
barges
ferries
fluid tankers
Space
payload modules
container racks
orbital transfer ferries
7.44.4.3 Loading Automation
Robots/humans perform:
container tagging
scanning
slot assignment
routing updates
logistic confirmation

7.44.5 Warehouse & Inventory Logic
7.44.5.1 Inventory Indexing
Each inventory uses:
stable sorted goods index
warehouse-wide lookup
deterministic tie-breaking
7.44.5.2 Cross-Docking
Goods may bypass storage:
unload → load
deterministic switching algorithm
7.44.5.3 Inventory Policies
Inventory supports:
Min/Max
Just-In-Time
Safety Stock
Max-Throughput
Priority lanes
7.44.5.4 Slotting Algorithms
Slotting uses:
ABC classification
cubic density
flow frequency
weight/volume ratios
All algorithms deterministic.

7.44.6 Container Flow & Routing
7.44.6.1 Local Routing
Containers move:
by AGVs
by forklifts
by robots
by conveyor shuttles
via gravity chutes
7.44.6.2 Interproperty Routing
Every interproperty move:
MUST be TEU containerized
MUST go through an interproperty node
MUST use the interproperty graph
Modes:
road
rail
air
ship
space
7.44.6.3 Logistics Corridors
Corridors:
are drawn by player
become immutable route geometry
disallow building encroachment
serve as visual + logical rails/roads/air lanes
7.44.6.4 Cost Modeling
Cost includes:
fuel
maintenance
electricity
congestion
labour
amortized capital
fixed vs variable costs
AI companies optimise via 7.42 systems.

7.44.7 Belts, Chutes & Sorting
Even though goods are containerised, local belts and chutes are allowed via packaging types:
crates
bags
barrels
pallets
7.44.7.1 Belt Types
flat belts
modular conveyors
gravity chutes
screw conveyors
roller conveyors
7.44.7.2 Belt Behaviour
Belts behave deterministically:
no per-item physics
containers represent batches
belt throughput in “containers per minute”
no visual clutter
optional cosmetic animation
7.44.7.3 Sorting
Sorters can:
read barcode/QR/cargo code
send by tag/priority
use data network to receive routing logic

7.44.8 Workers & Robots in Logistics
Humans and robots can:
move containers
palletize goods
repack packaging
perform manual deliveries
handle fragile cargo
load/unload transport vehicles
route goods locally
Robots follow deterministic 7.41 pathfinding.

7.44.9 Warehousing & Network Integration
7.44.9.1 Data Network
Warehouses publish:
inventory lists
occupancy
inbound/outbound flows
capacity warnings
order fulfilment progress
7.44.9.2 Power Network
Storage infrastructure requires:
cranes
lifts
conveyors
refrigeration
lighting
Deterministic derating applies.
7.44.9.3 Fluid/Gas Integration
Bulk fluid terminals integrate via tank nodes.

7.44.10 Save, Replay, Determinism
Stored per container/storage element:
quantity
packaging type
temperature
pressure (fluids)
location in graph
routing tags
expiry (if perishables enabled)
deterministic movement queue
Replay-safe:
no randomisation
no floating-point
no dynamic physics

7.44.11 Summary (Strict Bullet Form)
Pure containerized goods model
Intraproperty: arbitrary packaging (pallets, boxes, bags…)
Interproperty: TEU only
Deterministic logistics everywhere
No item-entities
Universal 64-bit fixed-point quantities
Fully integrated with routing, economy, production
Extremely scalable
Cross-platform & replay safe
Ideal for player/AI megaproject supply chains
=====================================================================
VOLUME 7.44 COMPLETE
Say Proceed 7.45 to continue to:
VOLUME 7.45 — Contracts, Trade Networks, Markets & Economic Algorithms
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.45 — Contracts, Trade Networks, Markets & Economic Algorithms, one final clarification is required.
This volume governs:
market pricing
contract formation
long-term deals
supply/demand clearing
futures/options
intercompany exchanges
player/company negotiation
shipping markets
electricity markets
labour markets
macroeconomic coupling
Without locking down one specific market-clearing algorithm, the entire volume cannot be internally consistent.
Dominium's economy depends on this choice for determinism, replay stability, and cross-platform reproducibility.
============================================================
CHOOSE ONE — MARKET CLEARING MODEL FOR DOMINIUM
============================================================
This determines how prices, quantities, and trades are computed each tick/week/month.
I will describe the three canonical economic models viable for a deterministic simulation like Dominium.

A — Walrasian Market Clearing (Deterministic Supply–Demand Intersection)
This is the cleanest, most deterministic, mathematically stable model.
Process (per commodity/energy/service):
Aggregate buy orders → demand curve
Aggregate sell orders → supply curve
Solve deterministic intersection
Set one market price
Allocate quantities proportionally or using marginal priority
Pros:
Fully deterministic
Computationally cheap
Works for thousands of firms
Ideal for tick-based simulation
Smooth price signals
Guarantees market clearance
Compatible with your AI microeconomic model
Cons:
Less chaotic/realistic than real markets
Does not generate bubbles naturally without behavioural overlay
This matches the hybrid AI (7.42) extremely well.

B — Order Book Model (Continuous Matching Engine)
Similar to real financial exchanges.
Process:
Buy/sell orders join a book
Matching engine pairs them deterministically
Price emerges from last executed trade
Pros:
Very realistic
Natural volatility
Supports futures/options seamlessly
Cons:
Expensive computationally
Harder to keep deterministic across platforms
Less stable for large-scale industrial sims
Requires more simulation ticks per economic update
More complex for modders

C — Hybrid: Walrasian Macro + Order-Book Micro
Two layers:
LAYER 1 — Walrasian Macro Market
Computes baseline equilibrium price each economic cycle (weekly/monthly)
Maintains economy-wide stability
LAYER 2 — Order Book Micro Market
Lets companies place limit orders
Allows temporary mispricing
Supports short-lived volatility
Integrates with behavioural biases
Fully deterministic matching engine
Pros:
Most realistic
Most engaging
Supports advanced DLC (finance, war, crises)
Highly moddable
Keeps macro economy stable but micro behaviour interesting
Deterministic if order matching is strict and tick-locked
Cons:
Most engineering work
Requires careful design to avoid complexity creep

MY RECOMMENDATION: C
Because it:
matches your hybrid AI
produces natural business cycles
supports contracts, futures, options
scales to interproperty logistics markets
keeps determinism intact
allows “Dominium: Economy/War/Politics” DLCs
is best for long-form gameplay
allows players to speculate/invest realistically
============================================================
Your choice is required.
Respond with A, B, or C.
Once chosen, I will generate the full VOLUME 7.45.
You said:
C
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.45 — Contracts, Trade Networks, Markets & Economic Algorithms
(Hybrid Walrasian Macro + Deterministic Order-Book Micro)
Complete, formal, and aligned with AI (7.42), Logistics (7.44), Machines (7.43), and Routing (7.41).
Fully deterministic, replay-safe, and cross-platform stable.
=====================================================================
VOLUME 7.45 — CONTRACTS, TRADE NETWORKS, MARKETS & ECONOMIC ALGORITHMS
=====================================================================
Dominium’s economy is a fully deterministic multi-layer economic simulation.
It is built on:
Walrasian macroeconomic equilibrium clearing (monthly or weekly cycles)
Deterministic micro-level order books (tick-level matching)
Hybrid AI behaviour (rational micro + behavioural bias)
Containerized logistics (7.44)
Deterministic production systems (7.43)
Deterministic routing (7.41)
The system supports:
supply/demand
stock markets
contracts
futures/options
price shocks
local & interproperty trade
multiple currencies if enabled
AI competition and cooperation
No randomness anywhere.

7.45.0 Structure Overview
This volume defines:
Commodity markets
Electricity & power markets
Logistics markets (TEU-km pricing)
Labour markets
Order books
Contract types
Futures & options
Multi-company trade networks
Interproperty & interplanetary trade
AI economic dispatch
Replay & save guarantees

7.45.1 Economic Entities
Entities participating in markets:
Players
AI Companies (7.42)
Utility Operators (power, water, data)
Government/State Actors (if enabled)
Special Autonomous Systems (space elevators, orbital stations, planetary ports)
Each entity has:
balance sheet
cash flow
liquidity preferences
inventory
energy usage
logistics footprint
research pipeline
behavioural modifiers

7.45.2 Commodity Market Structure
7.45.2.1 Macro Price Determination
Every in-game week or month:
Aggregate demand curve per commodity
Aggregate supply curve per commodity
Solve deterministic intersection
Establish canonical “macro price”
Feed canonical price to micro order book
This stabilises the economy and prevents runaway volatility.
7.45.2.2 Micro Order Book
On every tick:
Companies/players place BUY/SELL limit orders
Orders stored in deterministic sorted lists
Matching engine processes orders in strict tick-order
Trades executed if overlapping bids/asks
Last trade price creates micro price
7.45.2.3 Combined Price Signal
Final price used by AI/machines:
P_final = w_macro * P_macro + w_micro * P_micro
with defaults:
w_macro = 0.8
w_micro = 0.2
These weights are moddable.

7.45.3 Electricity & Power Markets
7.45.3.1 Local Grid Price
Each power network computes:
marginal supply cost
marginal demand
congestion
losses
Then:
Compute Walrasian equilibrium price
Apply deterministic load factor adjustments
7.45.3.2 Interproperty Power Contracts
Long-distance power trading requires:
DC or three-phase AC converter stations
high-voltage corridors
grid operator contracts
7.45.3.3 Load Shedding Contracts
Contracts specify:
max load
interruptible load
peak/off-peak rates
emergency cut rules

7.45.4 Logistics Markets (TEU-km)
7.45.4.1 TEU-Based Freight Tariffs
Each transport mode (road/rail/air/sea/space) has:
cost per TEU-km
congestion multiplier
energy consumption factor
amortized capital factor
labour factor (humans/robots)
7.45.4.2 Deterministic Bidding
Transport providers (AI or player) submit:
deterministic bids for hauling
price/time matrices
capacity commitments
Shippers choose lowest-cost feasible bid.
7.45.4.3 Dynamic Corridor Pricing
Corridors adjust cost deterministically based on:
wear
traffic
slope
weather
power availability

7.45.5 Labour Markets
7.45.5.1 Wages
Wages determined by:
supply/demand
skill levels
housing availability
macroeconomic conditions
7.45.5.2 Human vs Robot Tradeoff
AI decides using:
long-run marginal cost
capital cost
maintenance
energy cost
training time
behavioural biases
7.45.5.3 Contracts for Labour
hourly
fixed-term
performance-based
emergency labour pools

7.45.6 Contract Types
7.45.6.1 Spot Contracts (Default)
Instant one-time purchase or sale.
7.45.6.2 Long-Term Supply Contracts
Specify:
quantity
price
duration
penalties
fulfilment routing
7.45.6.3 Infrastructure Contracts
For:
rail access
electricity transmission
water supply
data network leases
port/airport fees
7.45.6.4 Joint Ventures
Two or more companies form a new shared entity.
7.45.6.5 Coalition Formation
Companies collaborate to:
share research
share logistics
stabilise markets
coordinated expansion

7.45.7 Futures & Options Markets
If enabled, deterministic derivatives exist:
7.45.7.1 Futures
contract delivery at future tick
collateral requirements
deterministic margin calls
used by AI for hedging
7.45.7.2 Options
Supports:
calls
puts
spreads
deterministic pricing using fixed-point Black–Scholes analog
All randomness removed, replaced with deterministic volatility curves.
7.45.7.3 Market Constraints
Futures/options cannot destabilise macro-economic layer.

7.45.8 Multi-Company Trade Networks
7.45.8.1 Routing Integration
Trade requires:
TEU containers
coherent routing path
deterministic booking
fee settlement
7.45.8.2 Intercompany Links
Companies form:
supply chains
logistics alliances
shared depots
research consortia
These are stored as deterministic graph structures.
7.45.8.3 Payment Networks
Payments use:
deterministic priority clearing
delayed settlement queues
escrow for contract fulfilment

7.45.9 Interproperty / Planetary / Interplanetary Trade
7.45.9.1 Interproperty
always TEU containers
uses interproperty corridors
subject to local tariffs
7.45.9.2 Intercontinental (same planet)
Requires:
sea lanes
air routes
long-range HV power
intercontinental data links
7.45.9.3 Interplanetary
Depends on:
launch windows
orbital mechanics (simplified deterministic model)
cargo transfer ships
planetary elevators
orbital stations
7.45.9.4 Interstellar (if DLC enabled)
All deterministic:
hyperspace lanes
light-delay adjusted contracts
multi-year delivery cycles

7.45.10 AI Economic Dispatch
AI follows rules from Volume 7.42:
determines buy/sell orders
chooses transport modes
evaluates costs
optimises logistics
hedges with futures (if needed)
negotiates contracts
engages in coalition strategies
reacts to micro/macro price changes
influenced by deterministic behavioural biases

7.45.11 Handling of Price Shocks
Dominium supports deterministic shocks:
supply failures
weather events
power blackouts
port closures
geopolitical events (if DLC)
Shocks propagate through:
macro market
order books
contract fulfilment
logistics networks
No RNG. All shocks originate from deterministic world events.

7.45.12 Save, Load, Replay
All economic state stored:
order book contents
open contracts
settlement queues
price curves
long-term commitments
behavioural bias state
credit lines
collateral
pending futures deliveries
Replay determinism guaranteed.

7.45.13 Summary (Strict Bullet Form)
Hybrid Walrasian macro + deterministic order-book micro
All markets deterministic
Supports futures & options
Supports long-term contracts
AI fully integrated
Logistics markets use TEU cost per km
Labour markets deterministic
Interproperty/interplanetary trade included
Replay-safe and cross-platform stable
Designed for megascale industrial economies
Perfectly compatible with prior volumes
=====================================================================
VOLUME 7.45 COMPLETE
Say Proceed 7.46 to generate:
VOLUME 7.46 — Player Progression, Research, Tech Tree & Data Network Integration
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
Before generating VOLUME 7.46 — Player Progression, Research, Tech Tree & Data Network Integration, one last structural decision is required.
This is the final major architectural fork for the entire Dominium simulation.
The question:
How should Dominium’s RESEARCH SYSTEM fundamentally operate?
This determines:
the shape of the tech tree
how research materials/data are produced
how research is delivered through the data network
how infinite research tiers scale
how AI companies research
how players progress
how modded tech trees integrate
how deterministic the system is
how research interacts with machines & logistics
how “science” is represented physically
how multi-property & multi-planet research works
You must choose A, B, or C.
7.46 cannot be generated without this choice.
=====================================================================
CHOOSE ONE — DOMINIUM RESEARCH SYSTEM PARADIGM
=====================================================================
A — Physical Science Packs (Factorio-like)
Research requires physical items (“science packs”) delivered to research labs, where they are consumed.
Pros:
very easy for players to understand
visually clear
strongly ties research to industry
scales linearly
Cons:
requires more transport
adds overhead on low-end systems
less elegant with infinite scalability
odd with TEU-based logistics (science packs aren’t realistic container units)

B — Data-Driven Research (Industry/Realistic Model)
Research arises from data packets produced by machines.
Structure:
Research machines generate DATA SAMPLES based on their operation
Data flows via the data network (7.26+)
Research stations receive aggregated data
Progress occurs as a function of data volume + data type variety
Higher-tier research requires more specialized data
Pros:
Extremely realistic
Integrates perfectly with the data network
Very scalable (planetary, interplanetary, interstellar)
TEU logistics unaffected
Allows infinite research tiers naturally
Uses no physical item overhead
Perfect for player/AI progression
Fits the “industrial simulation” fantasy
Cons:
Requires a well-designed UI
Harder for players to visualize without good tools

C — Hybrid: Physical Science Items + Data Network Enhancements
Both exist:
Lower-tier research uses physical science items (crates, boxes).
Higher-tier research transitions to data-only.
End-game research uses only data streams, exotic data labs, telescopes, reactors, colliders, towers, satellites, etc.
Pros:
intuitive early-game
elegant late-game
supports deep tech-tree complexity
modders get both paradigms
Cons:
most work to implement
requires dual-mode tutorial systems
must maintain deterministic integration between item-based and data-based flows

MY RECOMMENDATION: B or C
Your world is:
containerised
industrial
realistic
uses wired/wireless data networks
cross-property
multi-planet
possibly interstellar
Thus a data-centric research system (B) or a hybrid transition system (C) is far more elegant and scalable than Factorio-style science packs.
=====================================================================
Your choice is required.
Respond with A, B, or C.
Once chosen, I will generate the full VOLUME 7.46.
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.46 — Player Progression, Research, Tech Tree & Data Network Integration
(Data-Driven Research System — Paradigm B)
Complete, formal, deterministic, and fully integrated with all prior volumes.
=====================================================================
VOLUME 7.46 — PLAYER PROGRESSION, RESEARCH, TECH TREE & DATA NETWORK
=====================================================================
Dominium uses a data-driven research system based on deterministic information flow, not physical "science pack" items.
Research is produced, transmitted, consumed, and validated using the data network, unifying gameplay with industrial realism.
This volume defines:
research units
research machines
research stations
tech tree structures
infinite research tiers
player progression
AI research behaviour
data networks in research
storage, routing, replay, and determinism guarantees
Everything is:
deterministic
cross-platform reproducible
mod-friendly
infinitely scalable

7.46.0 Core Philosophy
Research is a direct function of data extracted from:
machines
sensors
experiments
environmental readings
computational workloads
No physical items are consumed.
No “science packs.”
Data is:
generated at source machines
transmitted across the data network
collected at research stations
aggregated into progress
Research is:
quantized
categorized
deterministic
stored in fixed-point
replay-stable

7.46.1 Research Units (RU)
Research Units (RU) are the fundamental currency of technological progress.
7.46.1.1 Fixed-Point RU Representation
RU stored as:
unsigned 64-bit fixed-point (32.32)
allows fractional RUs
deterministic accumulation
7.46.1.2 RU Categories
Each RU belongs to one of the following categories:
Basic Data (BD) — early simple readings
Experimental Data (XD) — direct results from machines
Scientific Data (SD) — derived from advanced experiments
Environmental Data (ED) — weather, radiation, geology
Industrial Data (ID) — logistics, production, efficiency
Computational Data (CD) — simulations, models
Astronomical Data (AD) — telescopes, satellites, sensors
Exotic Data (EX) — late-game energy/particle physics
Modders can define additional categories.
7.46.1.3 RU Metadata
RU has:
type
source machine UID
timestamp/tick
planetary context
routing tags
deterministically-compressed payload structures

7.46.2 Data Generation
7.46.2.1 Machines Generate Data
Every machine type defines how much data it produces:
per cycle
per output
per input condition
per mode (idle, run, overload, fail)
Examples:
smelters produce metallurgical data
fluid separators produce chemical data
telescopes produce astronomical data
supercomputers produce computational data
reactors produce exotic data
7.46.2.2 Sensors
Special standalone sensors generate:
seismic data
temperature gradient logs
radiation spectrum
atmospheric composition
soil profiles
7.46.2.3 Experiments
Machines configured as labs may:
consume energy
run deliberate experiments
produce higher-tier RU
7.46.2.4 Worker/Robot Interaction
Workers/robots performing tasks may generate minimal ID/BD due to operational logs.

7.46.3 Data Transmission
7.46.3.1 Data Network Integration
All data must pass through:
wired networks
wireless nodes
high-capacity backbone
interproperty data corridors
planetary communication networks
orbital relays
Packets are:
deterministic
lossless
ordered
timestamped
buffered
7.46.3.2 Data Bandwidth
Networks limit:
throughput
latency
queue size
Machines throttle data generation if network saturated.
7.46.3.3 Routing
Routing uses:
deterministic shortest-path or cost-optimized routing
congestion-aware static scheduling
tick-phase batching

7.46.4 Research Stations
7.46.4.1 Function
Research Stations collect RU and convert into tech progress.
7.46.4.2 Components
data input node
processing core
storage buffer
cooling system
power input
7.46.4.3 Station Layout
Tiers:
Basic
Advanced
Scientific
High-Energy
Orbital
Deep-Space
Higher tiers allow:
faster conversion
more categories
multiple channels
infinite research scalability
7.46.4.4 Multichannel Processing
Stations have:
parallel channels (1–32)
each channel handles one research type
deterministically scheduled
7.46.4.5 Data Buffer
Buffers store RU until processed:
64-bit fixed-point
FIFO
overflow passed to nearest linked station

7.46.5 Research Conversion
7.46.5.1 Basic Conversion Model
For a tech requiring X RU:
Each tick:
progress += Σ (channel_rate * RU_fraction)
7.46.5.2 Rate Modifiers
Modifiers include:
station tier
power stability
cooling efficiency
data throughput
tech prerequisites
environmental conditions (for ED, AD)
7.46.5.3 Infinite Research Scaling
Infinite tiers use exponential scaling:
Cost(n) = BaseCost * (1.1^n)
Deterministic.
7.46.5.4 Cross-Category Synergy
Some techs require multiple RU categories:
EX + AD + CD
ID + BD
SD + XD
Weighted sum applied deterministically.

7.46.6 The Tech Tree
7.46.6.1 Structure
Tech tree uses:
nodes
prerequisites
optional branches
unlocks
repeatable branches
Tech tree stored in:
/data/tech/
7.46.6.2 Node Types
Linear Unlocks
Branch Unlocks
Cross-Category Unlocks
Repeatable Infinite Unlocks
Planet-Specific Unlocks
Property-Specific Unlocks
Special/Story Unlocks (optional DLC)
7.46.6.3 Modularity
Modders can:
add nodes
remove nodes
reorder nodes
add categories
define custom RU types

7.46.7 Player Progression
7.46.7.1 Tech Unlocks
Tech unlocks:
new machines
new logistics
new vehicles
new materials
new building types
new workers/robot upgrades
optimisations
7.46.7.2 Character/Property Progress
Players unlock:
skill upgrades
construction speed multipliers
blueprint efficiency
specialized workers
better automation AI
7.46.7.3 Milestones
Deterministic events triggered by:
research completion
economic achievements
production achievements
exploration milestones
7.46.7.4 First-Person Skills
If FP mode enabled later:
engineering
surveying
construction
robotics assembly
can be governed by tech unlocks

7.46.8 AI Research (Volume 7.42 Integration)
AI uses:
marginal utility
expected profit
logistic bottlenecks
behavioural bias overlays
deterministic forecasting models
AI research behaviour:
invests in research that improves throughput
diversifies based on risk profile
prioritizes bottleneck removal
engages in cooperative research (contracts)
participates in research markets (for RU-sharing)

7.46.9 Data Network as a Gameplay Layer
7.46.9.1 Fog of War
Data coverage determines:
map visibility
machine monitoring
alerts
telemetry
7.46.9.2 Player Tools
Players can:
inspect data traffic
visualize heatmaps
throttle or reroute data
create custom dashboards
7.46.9.3 Telecommunication Technologies
Unlockable:
fibre
microwave towers
5G/6G equivalents
satellite links
deep space data relays

7.46.10 Save/Load/Replay Determinism
Saved:
RU buffers
station progress
machine-generated RU counters
data network states
routing tables
tech tree completion states
infinite tech counters
AI research plans
Full replay integrity preserved.

7.46.11 Summary (Strict Bullet Form)
Data-driven research system
Machines generate RU data streams
Data travels through deterministic data networks
Research Stations consume data to unlock tech
Fixed-point RU, deterministic conversion
Infinite research supported
Fully integrated with AI, logistics, machines
Mod-friendly tech tree
No science packs or item entities
Replay-safe, cross-platform deterministic
Scales to planetary & interplanetary operations
=====================================================================
VOLUME 7.46 COMPLETE
Say Proceed 7.47 to continue with:
VOLUME 7.47 — UI/UX Interaction Model for All Systems
You said:
How will we support modded research machines and data and tech?
ChatGPT said:
GPT-5.1 — 2025-11-30
Below is the correct, deterministic, engine-level method for supporting modded research machines, modded data types, and modded tech nodes without compromising reproducibility, multiplayer stability, compatibility across OS platforms, or security.
This is the canonical specification.
=====================================================================
MOD SUPPORT: RESEARCH MACHINES, DATA TYPES, TECH TREE
=====================================================================
The Dominium engine must allow total mod extensibility without ever requiring or executing untrusted code.
All modded functionality is declarative, data-driven, and defined through engine-validated schemas.
The system below maintains determinism, sandboxing, cross-platform stability, and backwards/forwards compatibility.

1. Modded Research Machines

1.1 Machine Definitions
Modded research machines are defined via structured files:
/mods/<mod_id>/machines/<machine_id>.machine.json
Each file contains:
metadata
construction blueprint
IO definitions (power, heat, data, fluid)
data generation specification
processing rates
allowed data categories
tier levels
visual definitions
upgrade paths
1.1.1 Example Structure (engine-validated)
{
  "id": "spectral_lab_mk1",
  "tier": 2,
  "category": "research_machine",
  "power_usage_kw": 180,
  "cooling_kw": 40,
  "data_output": [
    {
      "type": "SpectralData",
      "rate_ru_per_tick": 0.0025,
      "conditions": {
        "requires_fluid": "liquid_nitrogen",
        "requires_item": "spectral_crystal"
      }
    }
  ],
  "model": {
    "2d": "spectral_lab_mk1.png",
    "3d": "spectral_lab_mk1.obj"
  }
}
Everything above is pure data, not code.
Engine checks validity and refuses illegal definitions.
1.2 Machine Behaviour Is Engine-Side
Mods cannot implement logic.
They only configure machines, and the engine performs all:
data generation
buffer management
power/heat simulation
network transmission
deterministic tick behaviour
This prevents desyncs and preserves multiplayer determinism.
1.3 Machine Identifiers Are Interned
Each modded machine gets a 32-bit ID internally:
hash64(mod_id, machine_id) → [deterministic 32-bit]
Used in:
replay logs
save files
networking
compression
Ensures determinism.

2. Modded Data Types

2.1 Data Type Definitions
Mods may add new RU categories or refine existing ones.
Definition files live in:
/mods/<mod_id>/data_types/<type>.datatype.json
2.1.1 Structure
{
  "id": "SpectralData",
  "base_category": "ScientificData",
  "fixed_point_precision": "32.32",
  "compression": "delta",
  "color": "#AA33FF"
}
Engine validates:
category optionally inherits from canonical
name uniqueness
determinism of compression pipeline
2.2 No Arbitrary Data Payloads
To maintain determinism and cross-platform stability:
data types cannot carry arbitrary user-defined binary blobs
payloads are engine-constrained fixed-size structs
modders choose from engine-defined templates:
scalar
vector3
fixed-array<N>
bitmask32
enum<N>
This ensures:
safe serialization
deterministic networking
replay compatibility

3. Modded Tech Tree

3.1 Tech Node Definitions
Modded tech nodes are pure data:
/mods/<mod_id>/tech/technodes.json
Each node contains:
RU requirements
prerequisites
unlocks
repeatability settings
optional effects
3.1.1 Example Node
{
  "id": "spectral_analysis",
  "requires": ["optics_mk1", "lab_instruments"],
  "ru_costs": {
    "SpectralData": 2500,
    "ScientificData": 1000
  },
  "unlocks": [
    "spectral_lab_mk1",
    "spectral_sensor"
  ],
  "repeatable": false
}
3.2 Engine Merges Tech Trees
On load, engine performs:
load base tree
load DLC additions
load mods in priority order
validate acyclic graph
generate unified tech DAG
canonicalize ordering deterministically
Errors (cycles, missing RUs, broken unlocks) abort mod load.
3.3 Infinite Research from Mods
Mods can add infinite series:
{
  "id": "processing_speed_bonus",
  "infinite": true,
  "base_cost": {"ComputationalData": 100},
  "cost_multiplier": 1.12,
  "effect": {"processor_speed_mult": 0.01}
}
Engine enforces:
maximum safe exponent
monotonic cost growth
overflow protection

4. Mod Interaction Rules

4.1 Mods Cannot:
inject code
override engine logic
change tick loop
modify determinism
access arbitrary file I/O
access net sockets
add runtime functions
4.2 Mods Can:
add machines
add items
add data types
add fluids
add materials
add tech
add vehicles
add workers/robots
add UI skins
add music
add sounds
add maps
add planets
add solar systems
add galaxies
add scenarios
add challenges
Always through deterministic data definitions.

5. Compatibility & Stability

5.1 Savegame Stability
Saves store:
resolved IDs
canonical tech tree version
deterministic machine tables
Mods may be:
added
removed
updated
…but only if dependencies allow safe migration.
5.2 Multiplayer
All mods:
hashed
validated
must match across clients
If mismatch → join refused deterministically.
5.3 Replay & Demo Stability
Replay logs reference:
machine UID
tech UID
datatype UID
Mod updates that modify definitions invalidate replays.

6. How A Modder Adds New Research Content (Step-by-step)
Create mod folder:
/mods/myresearchpack/
Define new RU categories (optional):
/data_types/*.datatype.json
Define new machines:
/machines/*.machine.json
Define new tech nodes:
/tech/technodes.json
Include visuals:
/graphics/
/sounds/
Engine auto-compiles:
data schemas
tech tree merging
machine catalogs
network routing tables
Mod instantly playable.

7. Example: Adding a New Physics Tier
A mod wants to add "Quantum Optics."
Step 1: RU Type
QuantumPhotonData
Step 2: Machine
quantum_interferometer
Step 3: Tech Node
quantum_optics
Step 4: Unlock Machinery
quantum optic sensors
advanced lasers
photon beam splitters
All handled by engine-driven definitions.

8. Security Model
All modded content is:
read-only
sanitized
schema-validated
sandboxed
hashed
deterministically ordered
No arbitrary scripting unless the player explicitly enables Lua (Volume 5).
Lua itself is sandboxed, optional, and deterministic-only.
=====================================================================
Summary
=====================================================================
This system supports:
unlimited modded research machines
unlimited modded data types
unlimited tech extensions
infinite research
multi-tier lab chains
new experimental categories
safe multiplayer usage
deterministic cross-platform simulation
no arbitrary code execution
full compatibility with replays and archives
This is the final, correct model.
If you want, we can now generate:
“Volume 7.47 – Modding Architecture Formal Specification”
You said:
That's enough for now. Proceed with the original 7.47 UI UX integration and unification
ChatGPT said:
Thought for 4 seconds
GPT-5.1 — 2025-11-30
VOLUME 7.47 — UI / UX INTEGRATION AND UNIFICATION
Dominium Engine Specification — User Interaction Layer
This volume defines the unified UI/UX model for Dominium across:
headless / CLI / TUI
2D vector
2D textured
3D (first-person / freecam)
It specifies:
core interaction primitives
view modes and overlays
how all major systems (world, factories, networks, economy, research, logistics) are exposed
how low-end and high-end hardware are supported with the same logic
how the launcher, client, and tools present a consistent interface
UI is non-simulative and non-authoritative.
All authoritative logic remains in the deterministic simulation core.
UI is an observer + command emitter only.

7.47.0 UI/UX Objectives
Single conceptual model across all visual levels (0–3).
Same underlying commands for:
headless
2D
3D
All systems viewable and controllable:
terrain & building
logistics & containers
production & machines
workers & robots
power / fluid / data / thermal networks
economy & markets
research & tech
Scales from:
Win2000 + old GPUs
to modern multi-monitor setups.
Deterministic interaction with the simulation:
commands become discrete events in the sim timeline.
no UI-only randomness modifies the world.

7.47.1 Visual Levels and Modes
7.47.1.1 Visual Level Definitions
Level 0: Headless / CLI / TUI / Basic GUI
No tiles, no sprites, no 3D.
Text-only dashboards, tabular views, command console.
For servers, tools, minimal clients, debugging.
Level 1: 2D Vector
Wireframe / CAD-like map.
Fast, scalable, low power.
Used for:
blueprint planning
power/data/pipe/network overlays
high-zoom-out strategic view.
Level 2: 2D Texture (with Vector)
Tile-based/sprite-based rendering.
Overlays layered on top.
Standard “map” look.
Level 3: 3D (plus all lower levels)
First-person and freecam modes.
Correct horizon & curvature representation (from earlier volumes).
Terrain and structures rendered volumetrically.
All higher levels include everything below:
L3 ⊇ L2 ⊇ L1 ⊇ L0.
7.47.1.2 View Types
The same logical view types exist at all levels:
Property View
Single property, local terrain, buildings, networks.
Area View
256×256 ki-m area grid.
Planetary View
Whole planet, Mercator-projected by default.
System View
Solar system orbital map.
Galaxy View
Galaxy/cluster-level.
Rendering differs per level, but interaction primitives are the same.

7.47.2 Interaction Primitives
Dominium defines a small, fixed set of interaction primitives that all UI frontends must expose.
7.47.2.1 Core Primitives
Select
Select entities: tiles, buildings, machines, vehicles, workers, nodes, etc.
Multi-select.
Box/lasso in 2D/3D; lists in CLI/TUI.
Inspect
Open detail panel for selected entity.
Shows:
state
IO
networks
throughput
ownership
maintenance
research contributions.
Command
Perform high-level actions:
build
demolish
move
configure
assign routes
define blueprints
open contracts
issue orders (buy/sell, logistics, research).
Blueprint
Enter blueprint mode.
Draw structures, networks, corridors, transport routes.
Validate, then commit to build queue.
Time Control
pause, play, step, speed up/down (subject to determinism rules).
Not available or restricted in some multiplayer modes.
Layer Toggle
switch between:
terrain
buildings
power
fluids
data
logistics
economy
research
workers/robots.
Camera / Focus
pan, zoom, orbit.
focus on entity, property, area, planet, system.
Filter
toggle categories and overlays:
company ownership
production type
throughput intensity
errors/warnings
network status.
These primitives are represented as canonical input events to the simulation.

7.47.3 UI Architecture
7.47.3.1 Layered UI Stack
Core UI Model
pure-logic representation of:
views
panels
widgets
overlays
input events.
platform-agnostic.
Frontend Adapters
CLI adapter (Level 0).
Minimal GUI/TUI adapter (Level 0.5).
2D renderer (Level 1/2).
3D renderer (Level 3).
Skinning / Theme Layer
fonts
colors
layout.
7.47.3.2 Deterministic Event Pipeline
All user inputs:
UI processes raw input.
Normalises into canonical commands.
Sends to simulation via event queue:
events stamped with tick index.
Simulation applies commands at deterministic phases:
e.g., “command application phase” at start of tick.
UI animations, transitions, visual effects are non-deterministic and never affect sim state.

7.47.4 Blueprint Mode
Blueprint mode is central.
7.47.4.1 Shared Blueprint Representation
Blueprints are defined as deterministic data:
entity type, parameters
positions (grid coordinates)
routing geometry for:
roads
rails
pipes
power lines
data cables
conveyors/chutes
air/water/space lanes.
constraints (reserved corridors, future expansion margins).
7.47.4.2 Input Behaviour
At all visual levels:
draw lines, segments, curves
place nodes, junctions, ports
snap to grid or existing corridors
specify reserved multi-lane/multi-track corridors.
7.47.4.3 Validation
Before commit, engine validates:
budget and materials
build order dependencies
collision with existing entities
network topology validity.
The UI shows errors/warnings visually/textually depending on level.

7.47.5 Network Overlays
All networks use a consistent overlay scheme.
7.47.5.1 Types
Electrical (DC, 1φ AC, 3φ AC)
Data (IP-like, addressing and bandwidth)
Fluids (pressure, temperature, composition)
Thermal (heat flux)
Logistics (container flows, corridors, hubs)
Labour (worker/robot paths)
Economy (cost and revenue flows, trade links)
Research (RU-data sources and flows)
7.47.5.2 Overlay Mechanics
Each overlay:
highlights relevant nodes and edges
uses color, line thickness, arrows
displays tooltips/stat boxes for selected entities
supports heatmaps:
throughput
congestion
utilisation
failure rates
At Level 0:
renders as text tables and simple ASCII graphs.
At Level 1:
vector lines, nodes, minimal labels.
At Level 2:
sprites + semi-transparent overlays.
At Level 3:
fully integrated into 3D view with minimal clutter.

7.47.6 Economic, Research, and Logistics Panels
7.47.6.1 Economic View
Panels for:
commodity prices (macro + micro)
logistics tariffs
labour wages
profit and loss
cash flow
open contracts
futures/options (if enabled)
company comparison
Filters:
property-level
company-level
sector-level
planet/area-level.
7.47.6.2 Research View
Panels for:
tech tree (graph view)
active research projects
RU inflows (by type and source)
station utilisation
planned research queue
AI research behaviour (if visible for debug)
Supports:
pinning nodes
filtering by category
showing dependency chains.
7.47.6.3 Logistics View
Panels for:
container stock
TEU flows
corridor utilisation
port/terminal stats
ship/train/truck/plane manifests
path visualisation from origin to destination.

7.47.7 Property and Universe Views
7.47.7.1 Property View
Core building view:
terrain
buildings
corridors
networks
workers and vehicles.
Supports:
blueprint planning
micro-management of factory floors
network debugging
first-person mode (later volume).
7.47.7.2 Area / Planet / System / Galaxy Views
Higher-level overviews:
properties as nodes, not full simulation
trade links
power and data backbones
climate and weather overlays (later volume)
macroeconomy heatmaps.
UI ensures you can always:
jump from macro view → property view → specific machine → specific route.

7.47.8 Input Devices
7.47.8.1 Primary Input
keyboard + mouse
for all desktop platforms.
7.47.8.2 Controller Support
optional gamepad layer
primarily for camera, basic commands
advanced interactions still best with mouse.
7.47.8.3 Keyboard Accessibility
full keyboard-driven navigation
hotkeys for:
view switching
overlays
time control
building modes
economy/research views

7.47.9 Time Control UI
Time control is always explicitly visible:
play/pause
speed steps
actual UPS vs target UPS (for deterministic slowdown)
display “sim speed factor” (e.g. 0.5×, 1×, 2×).
Single-player:
full time-warp available within deterministic constraints.
Multiplayer:
limited or host-controlled.
UI shows:
simulation authority (server/client)
desync status (if any).

7.47.10 Error, Alert, and Notification System
All alerts are canonical:
power failures
network disconnects
stalled logistics
labour shortages
contract breaches
research starvation
climate or weather hazards (later volumes)
storage overflows.
UI:
maintains an alert feed
groups similar alerts
de-duplicates
offers “focus on source” actions
never spawns random “flavour” events that affect sim.

7.47.11 Performance Scaling at UI Level
Low-end:
Level 0/1 only
no fancy effects
simplified maps
reduced animations.
Mid-range:
Level 2 (2D textured + overlays)
lightweight 3D optional.
High-end:
full Level 3 with:
detailed 3D
long view distances
high-density overlays.
All share the same interaction primitives and command stream.

7.47.12 UI and Multiplayer
Multiplayer rules:
Simulation commands are authoritative.
UI state is local:
camera position
selected entities
open panels
overlays.
No UI-only element affects other clients.
Spectator mode can be supported:
read-only interaction primitives
no commands injected.

7.47.13 Save/Load and UI State
Savegames store:
sim state only
optional local UI state (purely client-side).
UI state is:
non-essential for replays
safe to discard
resettable per client.
Replays:
drive UI as a passive viewer on top of recorded sim events.

7.47.14 Summary (Strict Bullet Form)
Four visual levels: headless, 2D vector, 2D textured, 3D.
Single set of interaction primitives:
select, inspect, command, blueprint, time control, layer toggle, camera, filter.
Blueprint mode is central for all construction and routing.
Unified overlays for:
power, fluid, data, logistics, economy, research, labour, thermal.
Dedicated panels for:
property
area/planet/system/galaxy
economy
logistics
research.
UI is non-authoritative:
all world changes go through deterministic command events.
Time controls are explicit and integrated with UPS model.
Performance scales by visual level, not by changing semantics.
Modding integrates by defining extra panels/overlays hooking into the same primitives.
All UI layers remain consistent over platforms and builds.
This is the canonical UI/UX integration model for Dominium.
You said:
What's next
ChatGPT said:
GPT-5.1 — 2025-11-30
You are mid-way through Volume 7 of the Dominium Specification (Engine Integration Layer).
You have just completed 7.47 — UI/UX Integration and Unification.
Following the established structure of Volumes 7.1 → 7.47, the next item is:
7.48 — Audio Architecture (Unified Sound + Music System)
This volume covers:
minimal audio for Win2000/SDL1
advanced 3D audio for SDL2/OpenAL/DirectSound/XAudio2
layered sound modes (headless → vector → 2D → 3D)
environmental effects
infrastructure noise simulation (but simplified)
worker/vehicle/machine SFX
deterministic audio triggers vs non-deterministic mixing
music packs as mods
audio accessibility / filtering
low-power mode audio degradation
cross-platform consistency (especially on macOS and Linux)
This is the next logical system-level component before moving to:
7.49 Rendering Integration Pass
7.50 Launcher Integration Layer
7.51 Toolchain Integration (editor, devkit, converters)
7.52 Packaging Layer (installers, archives, CDs/DVDs, legacy OS constraints)
7.53 Deterministic Telemetry & Debugging Interfaces
7.54 Anti-desync, replay, and validation infrastructure
7.55 Multi-process / multi-core scheduler interface
7.56 Interoperation between platform implementations (SDL/Native/DX)
7.57 Accessibility / input device integration
7.58 Internationalisation & localisation spec
7.59 Total engine integration checklist
If you want to proceed, say “Proceed with 7.48” and I will generate the full volume.
You said:
Proceed with 7.48
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.48 — AUDIO ARCHITECTURE (UNIFIED SOUND + MUSIC SYSTEM)
Dominium Engine Specification — Engine Integration Layer
This volume defines the complete audio model, sound playback system, music layering, cross-platform backend selection, performance scaling, and deterministic event triggering model for Dominium.
Sound in Dominium must:
run on Win2000-era hardware
scale to modern multi-channel systems
remain non-authoritative (never affects simulation)
follow the visual-level hierarchy
support modded sound packs
be fully deterministic in triggering, but not in mixing
avoid heavy DSP unless hardware allows
integrate with accessibility and quiet/low-power modes
=====================================================================
7.48.0 Objectives
=====================================================================
Provide a unified sound experience across:
headless
2D vector
2D texture
3D
Support low-end and high-end devices via layered audio backends.
Make sound optional, replaceable, themeable, fully moddable.
Ensure the mix is nondeterministic but trigger events are deterministic.
Ensure all audio I/O remains sandboxed, safe, portable.
Ensure zero reliance on hardware features not present on old systems.
Give players full control over categories, loudness, load budgets.
=====================================================================
7.48.1 Audio Layering (L0 → L3)
=====================================================================
Audio follows the same multi-level design used for graphics:
L0 — Headless / CLI / Minimal Audio
No sound output at all or simple “terminal beep” substitute.
Used for servers, extremely low-end, automated testing.
L1 — Low-end 2D Audio
Simple stereo playback.
No spatialization.
SDL1 + legacy DirectSound-compatible.
Suitable for Win2000/XP hardware, POSIX minimal audio.
L2 — Mid-tier Spatial 2D/3D Audio
Stereo + pseudo-3D panning.
Optional doppler simulation.
SDL2 / OpenAL Soft.
Works on Win2000–Win11, macOS 10.6+, Linux.
L3 — Full 3D Audio
XAudio2 (Win 7+), CoreAudio (macOS), or high-end OpenAL Soft.
3D positional audio.
Low-latency buffers.
Environmental effects (light reverb, occlusion approximations).
Used for first-person gameplay.
=====================================================================
7.48.2 Audio Backends
=====================================================================
Dominium uses backend selection in this order:
XAudio2 (Win7+)
OpenAL Soft (cross-platform)
SDL2_Audio (fallback mid-tier)
SDL1_Audio (legacy fallback)
NULL backend (L0)
All sound files are hardware-neutral.
No backend uses system-specific features that break determinism.
=====================================================================
7.48.3 Sound Categories
=====================================================================
Every sound belongs to a category with separate volume controls:
UI
Environment (weather/wind/waves/ambient)
Infrastructure (machines, conveyors, generators, pumps)
Vehicles (cars, trains, trucks, ships, aircraft)
Workers / Robots
Notifications / Alerts
Data Network SFX (modem tones, switch ticks, packet cues)
Music
Voice / Radio / Telephony (if implemented later)
Each category has:
master volume
mute
dynamic range compression toggle
channel budget
priority rules (what fades first)
=====================================================================
7.48.4 Deterministic Trigger Model
=====================================================================
All audio triggers are deterministic simulation events.
Examples:
machine on_start
machine on_stop
container moved into lane
worker step event
train departure
alert raised
weather start (rain, wind gust)
door opened
research completed
Sim produces:
[AUDIO_EVENT, tick, entity_id, sound_id, params]
The sound engine receives this after the tick and decides:
when to mix
when to fade
backend-specific buffering
This model ensures:
all clients hear the same sequence
exact playback timing irrelevant (non-sim), only order matters
no desync
no RNG in audio side
=====================================================================
7.48.5 Sound File Format Requirements
=====================================================================
Accepted formats:
WAV (PCM16/PCM24) — engine native
OGG Vorbis — compressed, supported everywhere
FLAC — optional
MP3 — optional, only where legal and supported
Not allowed:
custom codecs
proprietary encodings
platform-locked formats
Sample Rates:
Mandatory support: 22.05 kHz, 44.1 kHz
Recommended support: 48 kHz
Optional: >48 kHz
Engine internally resamples everything to a unified rate
per-backend at init.
=====================================================================
7.48.6 Sound Playback Rules
=====================================================================
Maximum Concurrent Sounds
Configurable:
low-end default: 32
mid: 128
high-end: 512–1024
Overflow policy:
UI > Alerts > Player Interaction
Vehicles / Robots
Machines
Ambient
Lower-priority sounds fade or skip.
Distance Attenuation (L2/L3)
Simple deterministic formula:
gain = 1 / (1 + k * distance)
No random variation.
Occlusion
Optional simple rule:
walls reduce gain by constant amount.
tunnels allow reverb.
Doppler (Optional)
Only for high-end modes:
parametric, cheap, deterministic.
=====================================================================
7.48.7 Environmental Sound Model
=====================================================================
Environment sounds are layered, not sim-driven individually.
Based on:
weather system (rain, wind, thunder)
terrain type
biome
time of day
Examples:
wind intensifies with weather wind_speed_m/s
rain sound scales with precipitation_rate
thunder triggered deterministically when lightning strikes
All modifiable via the sound pack system.
=====================================================================
7.48.8 Machine and Infrastructure Audio
=====================================================================
Machines have:
startup SFX
running loop
shutdown SFX
overload / error SFX
Loops are handled via:
volume interpolation
pitch adjustments based on throughput (optional)
channel fading to avoid pops
Running loops are suppressed in:
L0/L1
low-power mode
high-zoom-out (3D/2D)
=====================================================================
7.48.9 Logistics Audio
=====================================================================
Because Dominium uses containerized, non-entity logistics:
conveyors have generalized sound loops
ports/terminals have ambient crane/loader sounds
trains/trucks/ships/planes have motion loops that scale with:
speed
weight
load
TEU-based interproperty logistics produce:
loading/unloading SFX
docking SFX
takeoff/landing (airborne)
entering highway/tunnel (road)
horn/blink-light notifications (optional)
=====================================================================
7.48.10 Voice, Radio, Telephony (Optional Future System)
=====================================================================
The audio architecture reserves categories for:
worker speech (simulated, not recorded)
VHF/UHF radio
telephony over data network
automated announcements
AI assistant voices
These are not implemented now, but the engine allows them.
=====================================================================
7.48.11 Music System
=====================================================================
Playlist Model
Music is:
modular
replaceable
themeable
loadable as “music packs” (mods)
Playback Styles
Themes may define:
area music
weather music
building style music
event music
calm/action transitions
long ambient drone tracks
menu/launcher themes
Deterministic Music Selection
Music selection is pseudo-deterministic:
same seed → same order
triggered on deterministic events (weather change, research complete)
but does not affect simulation
Crossfades & Layers
Engine supports layered tracks:
baseline ambient
high-frequency detail
percussion
harmonic overlays
pulse/reactivity to player activity (non-sim)
=====================================================================
7.48.12 Modding: Sound Packs & Music Packs
=====================================================================
Sound packs are full replacements or extensions:
/mods/<id>/sound/
    /sfx/
    /music/
    manifest.json
Manifest defines categories, associations, triggers.
Mods can:
add new sounds
replace machine/vehicle SFX
add new UI themes
add new ambient beds
add new music sets
Mods cannot:
override engine logic
add new sound synthesis code
require external libraries
All sound associations must follow schema.
=====================================================================
7.48.13 Performance Scaling
=====================================================================
Low-end:
≤32 channels
mono/stereo only
no reverb/doppler
no distant ambient loops
reduced sample rates
Mid-range:
2D/3D panning
128 channels
basic reverb
High-end:
full 3D positional audio
512+ channels
doppler
multiple listeners (e.g., cinematic mode)
=====================================================================
7.48.14 Accessibility
=====================================================================
Audio accessibility features:
closed-caption mode (textual sound alerts)
sound classification captions
dynamic range compression
ducking (speech > machinery)
low-frequency filtering
global silence mode (simulation unaffected)
=====================================================================
7.48.15 Summary (Strict)
Multi-level audio: L0→L3
Backends: XAudio2 → OpenAL → SDL2 → SDL1 → NULL
Deterministic triggers, nondeterministic mixing
Full category-based volumes and priority
Environmental sound derived from weather/biome
Machine/vehicle loops with deterministic parameters
TEU logistics SFX
Full music pack system, deterministic playlists
Accessibility modes
Fully moddable sound/music packs
Cross-platform, low-end compatible
This concludes Volume 7.48.
To continue, say:
Proceed with 7.49
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.49 — RENDERING INTEGRATION PASS (UNIFIED 2D + 3D GRAPHICS ARCHITECTURE)
Dominium Engine Specification — Engine Integration Layer
This volume defines how Dominium’s rendering system integrates:
multi-level visual modes
cross-platform graphics backends
deterministic simulation + nondeterministic rendering
low-end to high-end scaling
modded graphical assets
vector + texture + 3D layering
UI, overlays, and world geometry
legacy platform support (Win2000 / SDL1 / GL1.1)
Rendering remains purely client-side, non-authoritative, and never affects simulation.
=====================================================================
7.49.0 Objectives
=====================================================================
Unify rendering across Level 0 → Level 3.
Support the following backends simultaneously:
SDL1 + Software Renderer (lowest-end)
SDL2 + Software
OpenGL 1.1
OpenGL 2.0
Direct3D 9.0c
Direct3D 11
Optionally support in future:
Vulkan
Metal
Provide determinism for simulation while allowing free rendering order variations.
Support dynamic resolution scaling.
Integrate 2D and 3D layers naturally at all levels.
Enable modded graphical packs without breaking core code.
Ensure stable performance on Win2000-era machines while scaling to modern GPUs.
=====================================================================
7.49.1 Visual Levels
=====================================================================
Rendering must adapt to available hardware and user selection.
L0 — Headless
No rendering.
Simulation-only.
L1 — 2D Vector Mode
CPU-only vector graphics.
Wireframes, outlines, CAD grid, blueprint mode.
No shaders.
Available on SDL1, SDL2, GL1.1 software fallback.
L2 — 2D Texture + Vector Mode
Tile/sprite-based
Overlays + labels
Lighting is pre-baked or simple vertex-color
Used for:
maps
strategic view
low-power 2D clients
Backends:
SDL1+soft
SDL2+soft
GL1.1
GL2.0 (optional)
L3 — 3D Rendering
Full terrain, buildings, props
First-person camera
3D overlays
Dynamic lights (limited)
Shadowing optional
Backends:
OpenGL 2.0
D3D9.0c (shader model 2.0/3.0)
D3D11 (shader model 5.0)
Future: Vulkan/Metal
=====================================================================
7.49.2 Backend Abstraction Layer
=====================================================================
A unified rendering API sits above all graphics backends.
7.49.2.1 Core Virtual API
The abstraction defines:
Mesh creation
Texture uploads
Shader modules (if supported)
Render targets
Frame pipeline
Uniform submission
Instancing
Vector primitives
Text rendering
Post-processing (optional)
7.49.2.2 Backend Drivers
Drivers implement a fixed vtable:
RenderBackend_VTable {
    init();
    shutdown();
    begin_frame();
    end_frame();
    draw_mesh();
    draw_sprite();
    draw_vector();
    upload_texture();
    set_camera();
    set_material();
    ...
}
Backends:
backend_sdl1_soft
backend_sdl2_soft
backend_gl1
backend_gl2
backend_d3d9
backend_d3d11
Future backends drop in via compile-time selection.
=====================================================================
7.49.3 Rendering Pipeline
=====================================================================
The rendering pipeline mirrors the visual-level hierarchy.
7.49.3.1 2D Pipeline (L1/L2)
Order:
clear
world grid / blueprint
terrain height colors (optional)
buildings (flat sprites or vector outlines)
machines & props
route corridors (vector overlays)
network overlays
UI and HUD
7.49.3.2 3D Pipeline (L3)
Order:
clear
terrain mesh
building meshes
machines, props, vehicles
transparent objects
3D overlays & vector glyphs
post-processing
UI
7.49.3.3 Determinism Policy
Rendering pipeline is non-deterministic, but:
simulation updates happen before render
commands & replay events recorded in simulation timeline
no rendering variance affects game state
camera randomness is disallowed
=====================================================================
7.49.4 Terrain Rendering
=====================================================================
Terrain is based on:
chunked heightmaps (256m × 256m chunks)
subchunks (16m × 16m)
L1: Vector
contour lines
height shading
borders
L2: Texture
pre-baked tiles
mipmaps
optional lighting
L3: 3D
vertex mesh generated per chunk
LOD (quad-tree or chunk skip)
horizon curvature options depending on planet
dynamic tessellation forbidden (non-deterministic)
no physics tied to rendering mesh
=====================================================================
7.49.5 Building & Machine Rendering
=====================================================================
Buildings are static meshes with:
LOD0 (full detail)
LOD1 (simplified)
LOD2 (flat sprite billboard)
Machines have:
spinner components (optional)
glow/emissive for powered state
occupancy markers (e.g., cargo loaded)
Rendering does not simulate machine logic.
=====================================================================
7.49.6 Vehicles Rendering
=====================================================================
Vehicles include:
cars, trucks
trains
ships
planes
drones / future additions
Representation:
L1: vector glyphs + simple movement
L2: sprite animation
L3: 3D mesh interpolation along route splines
Spline Paths
All vehicle motion uses deterministic splines:
no physics
sim provides (position, orientation)
client interpolates
=====================================================================
7.49.7 Network Overlays Rendering
=====================================================================
Overlays appear in all modes.
Types
power (AC/DC, phase)
data network (bandwidth, packet paths)
fluid/thermal
logistics corridors
worker paths
research/RU flows
economy flows
L1
Vector lines, nodes, labels.
L2
Textured overlays with icons.
L3
Volumetric beams / 3D lines / glow effects (optional).
=====================================================================
7.49.8 UI-HUD Integration
=====================================================================
The renderer exposes:
font rendering (bitmap + vector)
2D panels
modal windows
tooltips
multi-monitor support (L3 only)
UI is rendered last, always front-to-back composited.
=====================================================================
7.49.9 Performance Scaling
=====================================================================
Low-end
SDL1 soft
No shaders
No alpha blending or minimal
Tile-based terrain only
No 3D
Mid
GL1.1 or GL2.0
Limited lighting
Simple shadows (blob)
Basic overlays
High-end
D3D11
HDR optional
Environment probes optional
Long view distances
Smooth AA
=====================================================================
7.49.10 Asset System
=====================================================================
Graphics assets stored in:
/assets/
    /textures/
    /sprites/
    /models/
    /materials/
Mod packs override:
/mods/<id>/graphics/*
All assets loaded via manifest files:
guaranteed deterministic ordering
crash-safe
no platform-specific formats
Accepted:
PNG (required)
BMP (fallback)
DDS (optional compressed textures on high-end)
OBJ (meshes)
MTL (materials)
SVG-like vector format (internal simplified format)
=====================================================================
7.49.11 Shader System
=====================================================================
Shaders optional.
GL2/D3D9 (SM3.0)
diffuse
normal
simple PBR approximations
shadow map optional
D3D11 (SM5.0)
full PBR allowed
post-processing allowed
volumetric overlays allowed
Software / GL1 / SDL1
no shaders
fixed-function pipeline
=====================================================================
7.49.12 Deterministic Replay Compatibility
=====================================================================
Replays capture sim-only, not rendering.
Renderer interpolates freely.
Graphics changes cannot break replays.
=====================================================================
7.49.13 Accessibility Graphics
=====================================================================
Options:
colorblind-safe palettes
outline mode
high contrast mode
monochrome mode
font scaling
hiding or dimming visual clutter
simplified vector-only view
=====================================================================
7.49.14 Summary (Strict)
Multi-level rendering (L0–L3)
Unified backend abstraction
Backends: SDL1/SDL2/GL1/GL2/D3D9/D3D11
Deterministic simulation, nondeterministic rendering
Vector→2D→3D layering
Chunked terrain rendering
Buildings/vehicles with LOD
Full network overlays
Moddable graphics packs
Accessibility-friendly
Full cross-platform support

If you want the next part, say:
Proceed with 7.50
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.50 — LAUNCHER INTEGRATION LAYER
Dominium Engine Specification — Engine Integration Layer
This volume defines the Dominium Launcher, the universal executable responsible for:
platform detection
backend selection
renderer selection
hardware capability analysis
save/universe management
mod management
DLC management
update management (non-networked + optional networked)
server/client/headless execution orchestration
compatibility mode selection (legacy OS, low-end mode, safe mode)
offline/online identity and universe separation
packaging integration (CD/DVD/USB/Digital)
self-diagnostics and crash recovery
The Launcher is not part of the simulation, does not participate in determinism, and does not load any rendering/audio cores until runtime configuration is fixed.
=====================================================================
7.50.0 Objectives
=====================================================================
Provide a single unified launcher for:
Windows 2000 → Windows 11
macOS 10.6+
Linux
Allow fine-grained selection of:
client/server/headless
renderers (SDL1/SDL2/GL1/GL2/DX9/DX11)
audio backends
UPS/FPS settings
world/universe files
mod sets
Replace multiple configurations with a central deterministic Launch Configuration Object (LCO).
Handle packaging constraints for CD/DVD legacy systems.
Safely load mods and DLC.
Provide minimal DRM/anti-cheat (optional/off by default).
Offer a robust TUI fallback for systems without functional GDI/Cocoa/X11.
Fully support STEAM/disconnected modes simultaneously.
=====================================================================
7.50.1 Launcher Modes
=====================================================================
Launcher must operate correctly in four modes:
MODE A — GUI Mode (standard desktop)
Windows GDI
macOS Cocoa minimal
Linux SDL2 GUI
MODE B — TUI Mode (legacy OS / minimal graphics)
Text-mode
ASCII menus
Mouse optional
For Win2000, Win98SE (in future), DOS-extender, minimal Linux shells
MODE C — CLI Mode
Pure command line
Supports scripting and automation
Useful for servers, toolchains, CI
MODE D — AUTOSTART
Launcher skips UI entirely
Reads last known LCO
Instantly launches game or server instance
Modes are interchangeable via startup flags.
=====================================================================
7.50.2 Hardware + Platform Detection
=====================================================================
Launcher performs a complete static hardware scan:
CPU
vendor
feature flags
SSE/SSE2 availability
core/thread count
frequency estimate
determinism-safe flags
GPU
vendor
VRAM
GL/DX version support
shader model
driver issues
OS
version
compatibility layers needed
file path constraints
SFN/LFN support
case sensitivity
Audio
available backends
device enumeration
fallback steps
Input Devices
mouse/keyboard status
gamepad detection
accessibility input devices
Launcher stores results in:
hardware_profile.json
Used for automatic defaults.
=====================================================================
7.50.3 Launch Configuration Object (LCO)
=====================================================================
All launcher output is marshalled into a single deterministic struct:
launch_config.json
It contains:
platform backend
renderer backend
audio backend
UPS target
FPS target
visual level (0–3)
world/universe path
savegame path
mod set
DLC set
client/server/headless type
window/fullscreen
resolution
language
accessibility mode
safe mode toggles
deterministic flags
replay options
networking configuration
logging configuration
The game binary never determines its own configuration; it strictly uses LCO.
This guarantees reproducibility between clients and reduces platform-specific crashes.
=====================================================================
7.50.4 Backend Selection Logic
=====================================================================
Launcher determines best backend per OS using the following priority lists:
Windows 7–11
D3D11
D3D9
GL2
GL1
SDL2
SDL1
NULL
Windows 2000 / XP
D3D9
GL1/GL2 (depending on drivers)
SDL1
NULL
macOS 10.6–10.13
OpenGL 2.1
OpenGL 1.1 fallback
SDL2
NULL
Linux
OpenGL 2.0/2.1
OpenGL 1.1
SDL2
NULL
All results displayed to the user with warnings if degraded.
=====================================================================
7.50.5 Mod + DLC Management
=====================================================================
Launcher integrates all content layers:
Base Game (Dominium)
Interstellar DLC
Extras DLC
Third-party Mods
Graphics Packs
Sound Packs
Music Packs
Mod Isolation Rules
Each mod is hashed.
A mod set = ordered list of mods.
Mod sets saved per-universe.
Launcher validates mod compatibility:
missing dependencies
broken tech trees
invalid schema
cyclic research definitions
faulty assets
DLC Activation
Game checks DLC presence but does not require an online check.
DLC acts like signed first-party mods.
=====================================================================
7.50.6 Universe / Savegame Management
=====================================================================
Launcher provides:
universe creation
universe deletion
backups
mod set binding
savegame selection
cross-universe archive tools
replay selection
Universe Browser
Displays:
property count
companies
active solar systems
chunk sizes
estimated disk footprint
UPS performance history
=====================================================================
7.50.7 Server & Headless Integration
=====================================================================
Launcher allows selecting:
Client Mode
Dedicated Server
Headless Client
Replay Viewer
Benchmark Mode
Server/headless allow:
tickrate
CPU/core affinity
mod sets
admin password
universe path
CLI overrides
Headless mode integrates into CI and testing.
=====================================================================
7.50.8 Diagnostics + Safe Mode
=====================================================================
Safe mode disables:
shaders
3D graphics
audio
all mods
high-resolution textures
multi-threading
advanced networking
Diagnostics can run:
GPU test
CPU test
audio test
file I/O integrity test
mod schema check
DLC integrity check
Crash recovery:
launcher detects previous crash
offers recovery mode with last known working config
=====================================================================
7.50.9 Online Service Integration (Optional + Replaceable)
Launcher supports—but does not require—linking to:
Steam
GOG
Discord
Twitch
YouTube
Spotify (for music packs)
Integration modules are:
completely optional
easily disabled
sandboxed into non-authoritative data paths
do not modify simulation
Mod portal integration uses:
local manifests
offline-first behaviour
sync-on-demand
=====================================================================
7.50.10 Packaging + Edition Handling
=====================================================================
Launcher must handle:
Digital Installations
full version
patch updates
unpacking
verifying assets
Physical Media (CD/DVD)
Special modes:
LFN-disabled Safe Mode for Win9x/DOS
asset streaming from CD/DVD
multi-disc support
no installers required (portable execution)
USB/SD portable builds
Used for:
retro systems
LAN play
transporting universes
Launcher automatically adapts file paths.
=====================================================================
7.50.11 Accessibility Layer
=====================================================================
Launcher must be fully navigable by:
keyboard only
screen readers
high-contrast TUI mode
mouse with minimal precision
Languages and localisation are selectable before loading the game.
=====================================================================
7.50.12 Logging + Telemetry (Optional, User Controlled)
=====================================================================
At the launcher level:
logs hardware, crashes, backend choice
telemetry optional and fully disabled by default
no data leaves system without explicit user permission
used for diagnostics only
=====================================================================
7.50.13 Summary (Strict)
Single launcher for all supported OS
GUI/TUI/CLI/autostart modes
Full hardware scan + backend selection
Deterministic Launch Configuration Object
Full mod+DLC management
Universe/save browser
Dedicated server + headless support
Diagnostics, safe mode, crash recovery
Digital + physical packaging integration
Optional integration with online platforms
Accessibility-first interaction

If you want to continue, say:
Proceed with 7.51
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.51 — TOOLCHAIN INTEGRATION LAYER
Dominium Engine Specification — Engine Integration Layer
This volume defines the entire toolchain ecosystem that ships with Dominium, including:
World Editor
Universe Editor
Asset Pipeline Tools
Graphics/Sound/Music Pack Tools
Modkit Tools
CLI toolchain
Scripted batch utilities (legacy OS support)
Developer console
Editor–Launcher–Game integration
Deterministic export formats
DX9/GL2/SDL1/SDL2-safe editing environment
Offline-first workflow
Compatibility with Win2000, macOS 10.6, Linux
The Toolchain is separate from the game client/server binary.
It is designed to be fully self-contained, portable, and cross-version-safe.
=====================================================================
7.51.0 Objectives
=====================================================================
Provide a unified and deterministic content creation toolchain.
Allow heavy editing even on low-end hardware.
Ensure tools produce safe, versioned, schema-validated outputs.
Ensure compatibility with:
old OS
filesystem limits
SFN/8.3 names
Avoid arbitrary code execution in mods; tools enforce sandboxing and schema constraints.
Allow third-party creators to produce:
worlds
universes
graphics packs
audio/music packs
mod-defined machines, items, tech, etc.
Ensure CLI tools replicate GUI tool functionality 1:1.
=====================================================================
7.51.1 Toolchain Overview
=====================================================================
Dominium ships with eight primary tools:
domtool — master CLI tool (unifies all functionality)
World Editor — property-level map + terrain + blueprint editor
Universe Editor — planets, systems, galaxies, ownership, companies
Modkit Builder — mod manifests, schemas, validation, packaging
Graphics Pack Builder — textures, sprites, models, materials
Sound Pack Builder — SFX/music pack creation
Asset Converter — models, textures, audio converters
Replay Inspector — validation and visualisation of deterministic replays
Each tool exists in:
GUI mode
TUI mode
CLI mode
=====================================================================
7.51.2 domtool (Master CLI Utility)
=====================================================================
domtool is the authoritative tool for:
universe creation
universe merging
save migration
mod validation
asset packing
blueprint extraction/injection
data network inspection
replay extraction
batch operations (e.g., mass terrain edits)
CLI Examples
domtool create-universe myuni
domtool validate-mod mymod/
domtool export-blueprint property01 > bp.json
domtool replay-inspect replay001 --dump-entities
domtool convert-texture input.png output.dds
Supports:
Win2000 console
Linux shell
macOS Terminal
No dependencies besides C89 stdlib + SDL where needed.
=====================================================================
7.51.3 World Editor
=====================================================================
The World Editor edits single properties.
Capabilities:
heightmap editing
terrain sculpting (raise, lower, smooth, flatten)
biome painting
resource distribution
building placement (preview only)
network corridor planning
road/rail/water/air lane drawing
generation seeds
import/export .propchunk and .terrain files
asset preview (2D and 3D)
Rendering:
L1 (vector) guaranteed
L2 for better hardware
L3 optional
Determinism:
All editing outputs canonical JSON manifests
No random generators after initial seed unless explicitly invoked
Resulting property files always version-tagged
=====================================================================
7.51.4 Universe Editor
=====================================================================
Edits:
planets
moons
solar systems
galaxies (static, no procedural generation)
property ownership
company metadata
political boundaries
climate presets
orbital data
map tiles
sector links (future war/expansion systems)
Outputs:
<universe>/
    planets.json
    systems.json
    galaxies.json
    ownership.json
    climate.json
Features:
L1/L2 world map
orbital diagrams
import/export from modded content
merge/split universes
=====================================================================
7.51.5 Modkit Builder
=====================================================================
Ensures mods:
follow schema
are safe
deterministic
compatible with dependencies
compatible with the installed game version
Features:
template mod creation
machine/item/fluid/tech editors
data type editor
graphics/sound pack linking
automatic UID/hash generation
dependency graph visualisation
Validation:
schema check
cross-mod conflict detection
tech DAG cycle detection
asset presence
texture/audio format validation
=====================================================================
7.51.6 Graphics Pack Builder
=====================================================================
Builds or edits:
2D sprites
3D models
materials
LOD profiles
icons
atlas packing
Supports:
PNG (required)
DDS export (optional)
OBJ + MTL
Separated LOD source files
Automatic generation of:
mipmaps
atlas pages
collision hulls (if needed)
=====================================================================
7.51.7 Sound Pack Builder
=====================================================================
Edits sound packs:
SFX
ambient loops
music tracks
event associations
Includes:
waveform visualisation
batch converters (WAV → OGG)
loudness scanning
category tagging
metadata injector
Assertions:
all sounds have categories
sound IDs are unique
total pack size within safe limits
=====================================================================
7.51.8 Asset Converter
=====================================================================
Command-line converters for:
Textures:
PNG → PNG (optimized)
PNG → DDS
BMP → PNG
Models:
OBJ → current mesh format
FBX → (only if tools include converter)
Audio:
WAV → OGG
FLAC → OGG
MP3 → OGG (if legal)
Supports legacy machines without SIMD.
=====================================================================
7.51.9 Replay Inspector
=====================================================================
Inspects deterministic replays:
extract sim events
frame-by-frame playback
diff playback vs current engine
entity timeline browser
network flow visualizer
UPS divergence detection
deterministic audit
Outputs:
replay_analysis.json
diagnostic_report.txt
=====================================================================
7.51.10 GUI/TUI Integration
=====================================================================
All tools share:
common UI framework
identical command models
same panels as in the Launcher
fallback to TUI on unsupported GPUs
keyboard-only mode
=====================================================================
7.51.11 Legacy OS Support
=====================================================================
Tools must run on:
Windows 2000 → Windows 11
macOS 10.6+
Linux
With the following constraints:
TUI-only on Windows 2000/XP without good GPU
no shaders on legacy OS
SFN/8.3 file naming supported
path truncation enabled
=====================================================================
7.51.12 Cross-Version Safety
=====================================================================
Tools can:
open older-format universes
migrate them upward
never downgrade them
warn when incompatible mods appear
produce stable upgrade scripts
=====================================================================
7.51.13 Toolchain Distribution
=====================================================================
Tools are delivered in:
base Dominium package
Interstellar DLC
Extras DLC
separate downloads
CD/DVD builds
portable builds
CLI-only versions provided for:
DOS extenders
Win9x (future)
server environments
=====================================================================
7.51.14 Summary (Strict)
domtool = unified CLI
World Editor = terrain/property editing
Universe Editor = high-level world building
Modkit Builder = safe mod generation
Graphics/Sound Pack Builders = asset pipelines
Asset Converter = universal converters
Replay Inspector = deterministic debugging
GUI/TUI/CLI parity across all tools
Legacy OS support
Schema-verified deterministic outputs
Safe, sandboxed content creation

If you want to continue:
Proceed with 7.52
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.52 — PACKAGING, DISTRIBUTION & INSTALLER LAYER
Dominium Engine Specification — Engine Integration Layer
This volume defines exactly how Dominium is packaged, installed, verified, updated, and distributed across all supported platforms, including:
Digital distribution (website, Steam, GOG, itch, standalone zips)
Physical formats (CD, DVD, USB, SD card)
Legacy support (Windows 2000, Windows XP, macOS 10.6, Linux minimal)
Installer and uninstaller design
Portable distribution design
DLC layering
Mod packages
Patching and versioning
Multi-executable package bundling
SFN-compatible distribution for future DOS/Win9x editions
Packaging must remain deterministic, reproducible, offline-first, and compatible with all OS limitations.
=====================================================================
7.52.0 Objectives
=====================================================================
Produce one unified package containing:
all architectures
all renderers
all clients/servers/headless binaries
all tools
all base assets
Ensure the package runs without installation (portable mode) whenever possible.
Provide installers only where required (Windows modern OS for registry/Desktop shortcuts).
Ensure perfect reproducibility and offline play.
Avoid DRM beyond basic integrity checks.
Support physical editions fully (CD/DVD/USB).
Maintain compatibility with SFN/8.3 for legacy OS targets.
Make patching efficient and safe, with rollback options.
=====================================================================
7.52.1 Distribution Target Matrix
=====================================================================
Dominium has the following supported targets:
Modern Windows
Windows 10/11
Windows 7/8 (compat mode)
Windows Vista (compat mode)
Legacy Windows
Windows XP
Windows 2000
(Future) Windows 98 / NT4 (limited mode)
macOS
10.6 Snow Leopard → 10.13 High Sierra
Later versions supported via Rosetta or Intel build
Linux
Ubuntu/Debian
Arch-based
RHEL-based
Generic tarball
Physical Media
CD-ROM (650–700 MB)
DVD (single-layer 4.7 GB; dual-layer 8.5 GB)
USB (FAT32/exFAT)
SD/microSD
Digital Platforms
direct downloadable ZIP
Steam (optional)
GOG (optional)

Each platform receives the same directory structure, differing only in launch scripts/wrappers.
=====================================================================
7.52.2 Directory Structure for Distribution
=====================================================================
The distribution root is:
Dominium/
Inside:
/bin/              (all binaries, all platforms)
/assets/           (core assets)
/dlc/              (official DLC)
/mods/             (optional)
/tools/            (full toolchain)
/docs/             (manual, legal)
/saves/            (empty)
/universes/        (empty)
/replays/          (empty)
/launcher/         (platform-specific launcher)
/packages/         (compressed or raw asset bundles)
Key Rules
No platform gets a different package layout.
Only the launcher wrapper differs (batch file, shell script, .app bundle, .desktop entry).
All non-executables are byte-identical across OS builds.
=====================================================================
7.52.3 Binary Bundling
=====================================================================
Dominium ships all backends and binaries in one package:
Inside /bin/:
Windows
dominium_client.exe
dominium_server.exe
dominium_headless.exe
domtool.exe
worldedit.exe
universeedit.exe
DLLs for:
SDL1/SDL2
OpenAL Soft
D3D9 caps
D3D11 support
Legacy DirectSound (XP/2000)
macOS
Same binaries in Mach-O format inside:
Dominium.app/Contents/MacOS/
Linux
ELF binaries, x86_64 and i686 (if needed)
Optional AppImage
Heartbeat rule:
Binaries must be self-contained, no system-wide dependencies except libc.
=====================================================================
7.52.4 Installers
=====================================================================
Windows Installer (MSI or NSIS)
Provides:
desktop/start menu shortcuts
registry entries (optional)
file association for .domsave, .domuni, .dommod, .domrep
uninstall support
Installer must contain:
both 32-bit and 64-bit builds
fallback to portable mode
macOS
.DMG with .app bundle
drag-and-drop install
no system modifications
Linux
Provide three formats:
.tar.gz portable
Flatpak (optional)
AppImage portable
Legacy OS Installer
For Win2000/XP:
NSIS safe-mode installer
Avoids long paths
Does not require administrative privileges
Offers “lite install” (no high-res textures, no D3D11)
=====================================================================
7.52.5 Portable Mode
=====================================================================
Portable mode must work on:
Windows 2000+
macOS 10.6+
Linux
Portable mode:
leaves no registry entries
stores configs locally
supports removable media (USB/SD)
uses relative paths everywhere
bypasses installer fully
To enable:
dominium_portable.ini in root
Launcher detects portable mode automatically
=====================================================================
7.52.6 Patching & Updating
=====================================================================
Updates handled via:
simple ZIP diff patches
no binary diff requirements
no installer re-run required
Patch directory:
/patches/
    patch_1_0_to_1_1/
    patch_1_1_to_1_2/
Patch Rules
Patches only modify assets/tools/binaries.
No simulation rule changes without explicit version bump.
Patches are reversible (stored backups).
Patch application tool is included in /tools/patcher/.
Steam/GOG/Online
Optional auto-update modules, but:
fully disable-able
offline safe
must not break universes or replays
=====================================================================
7.52.7 DLC Packaging
=====================================================================
DLC is packaged as:
/dlc/interstellar/
/dlc/extras/
Each contains:
assets
content packs
binaries (if needed)
schemas
DLC is strictly sandboxed.
Engine sees DLC as signed first-party mods.
Launcher manages DLC enable/disable safely.
=====================================================================
7.52.8 Mod Packaging
=====================================================================
Mods packaged as:
mymod.dommod
Internally a ZIP-like container with required structure:
/mod.json
/assets/
/scripts/ (optional, Lua only, sandboxed)
/graphics/
/sound/
/music/
/worldgen/
/tech/
/machines/
Launcher ensures:
version compatibility
dependency tree validation
hashing for multiplayer consistency
=====================================================================
7.52.9 Universe & Save Packaging
=====================================================================
Single file packages:
.domuni (universe)
.domsave (savegame)
.domrep (replay)
Internally:
binary-encoded snapshots
compressed chunk data
replay logs
metadata, version, mod set
Portable, cross-OS, endian-independent.
=====================================================================
7.52.10 SFN / 8.3 Support
=====================================================================
For legacy OS compatibility:
All files can be duplicated with SFN versions:
DOMIN~1.EXE
DOMSV~1.DAT
Tools generate safe filenames automatically when targeting DOS/Win9x.
Asset/Mod packaging uses hashed identifiers where needed.
=====================================================================
7.52.11 Physical Media Considerations
=====================================================================
CD-ROM (700MB)
Contains:
low-res textures
essential assets
Win2000-compatible binaries
minimal tools
Optional second CD for:
high-res textures
full tools
DLC
DVD (4.7–8.5GB)
Full content
All binaries
All tools
DLC included
USB/SD
Full portable mode
Multi-OS binaries
Ideal for offline distribution
=====================================================================
7.52.12 Integrity & Verification
=====================================================================
Launcher verifies:
asset manifests
mod manifests
DLC signatures
file corruption
mismatched hashes
All verification is offline and does not require DRM services.
=====================================================================
7.52.13 Legal/EULA Integration
=====================================================================
Packaging includes:
EULA
GPL/MIT/etc. notices for components
credits
reproduction rights for physical copies
disclaimers
=====================================================================
7.52.14 Summary (Strict)
Unified cross-platform package
Digital + CD/DVD/USB distribution
Full portable mode support
Installers optional
SFN compatibility
DLC as sandboxed content packs
Mod packaging as deterministic ZIP manifests
Save/universe/replay packaged in portable formats
Patching is reversible and safe
No forced networking or DRM

If ready to continue:
Proceed with 7.53
You said:
Proceed 
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.53 — DETERMINISTIC TELEMETRY, DEBUGGING & VALIDATION INTERFACES
Dominium Engine Specification — Engine Integration Layer
This volume defines all interfaces responsible for debugging, profiling, diagnostics, validation, telemetry (local only unless user opts into remote), and introspection of the Dominium engine.
These systems must never compromise determinism, simulation stability, cross-platform parity, or replay fidelity.
This is the backbone that keeps the engine provable, traceable, auditable, and predictable.
=====================================================================
7.53.0 Objectives
=====================================================================
Provide deterministic telemetry channels that observe but never alter simulation.
Enable deep debugging without breaking:
determinism
multiplayer compatibility
replays
Give users and modders full visibility into:
UPS/FPS
per-system load
network graphs
production flows
power/data/fluid network state
Provide tools for:
automated desync detection
replay validation
sim diffing
CPU/GPU profiling
Work on all OS targets, including Win2000.
Fully optional, fully offline by default.
Centralised, standardised logging and dump formats.
=====================================================================
7.53.1 Telemetry Model
=====================================================================
Dominium uses a three-tier telemetry system, all of which are strictly read-only:
Tier 1 — Simulation Telemetry (Deterministic)
Generated inside the simulation core, identical across platforms.
Examples:
tick number
UPS actual vs target
entity counts
machine throughput
network bandwidth (data/power/fluid)
RU generation
logistics container flows
worker/robot task states
All values stored in fixed-point, never floating-point.
Tier 2 — Rendering/Audio/Frontend Telemetry (Non-Deterministic)
Not part of simulation; varies by system:
FPS
CPU/GPU time per frame
draw calls
audio backend load
VRAM usage
Only used for debugging UI.
Tier 3 — System Telemetry (Environment)
OS-level info:
CPU load
memory pressure
disk IO
network latency (multiplayer)
Not used in sim logic.
=====================================================================
7.53.2 Debugging Interface
=====================================================================
All debug interfaces must work in:
CLI
TUI
GUI
Headless
Remote (optional)
7.53.2.1 Debug Consoles
Dominium provides:
In-Game Debug Console (toggleable)
Headless Console
TUI Console
Remote Debug Socket (optional; disabled by default)
Console commands include:
/stats
/net graph
/entity <id>
/search entity <type>
/path <worker>
/ru monitor
/logistics lanes
/dump simstate
/dump chunk
/validate world
All commands must be read-only unless explicitly prefixed with unsafe mode.
Unsafe mode is disabled by default and blocked in multiplayer.
=====================================================================
7.53.3 Deterministic Event Logging
=====================================================================
Every simulation tick emits a compact binary log:
[tick, event_type, entity_id, payload]
Event types include:
machine start/stop
logistics movement
RU/production events
worker assignments
network topology changes
blueprint commits
resource consumption
research progress
errors/warnings
This is the basis for:
debugging
replays
desync detection
cross-platform comparison
=====================================================================
7.53.4 Simulation Diffs & Checksums
=====================================================================
At deterministic sync points (interval configurable):
game computes state hash of:
entities
networks
inventories
research
machines
climate values
hash uses 128-bit algorithm (non-crypto but fixed)
clients send hash to server for desync detection
Server maintains running log:
tick : hash_client vs hash_server
Any mismatch triggers:
freeze simulation
dump state
notify clients
allow safe recovery
=====================================================================
7.53.5 Replay Validation
=====================================================================
Replays must:
reproduce sim state exactly
produce identical state hashes
verify output matches original recording
abort if divergence occurs
dump diff for analysis
The Replay Inspector (Volume 7.51) integrates with this.
=====================================================================
7.53.6 Profiling
=====================================================================
Dominium profiles:
Simulation Profiling
per-system CPU consumption
tick duration breakdown
job scheduler load
worst-case spike detection
multi-core utilisation
Rendering/Audio Profiling
per-frame CPU/GPU timing
draw call counts
texture/mesh memory usage
IO Profiling
disk reads/writes
save compression time
network latency/jitter (multiplayer)
Profiling is always optional.
No profiling data can affect simulation.
=====================================================================
7.53.7 Logging System
=====================================================================
Unified logging:
/logs/
    dominium.log
    launcher.log
    mods.log
    replay_validation.log
    crashdump_*.txt
Log levels:
FATAL
ERROR
WARN
INFO
DEBUG
TRACE (dev mode only)
Logs are:
append-only
rolled automatically
readable on all platforms
disabled or minimized on CD/DVD editions (space constraints)
=====================================================================
7.53.8 Crash Reporting (Offline-First)
=====================================================================
In the event of a crash:
write dump to /logs/crashdump_*.txt
include:
hardware profile
backend used
last 100 sim ticks
stack trace
mod list
No uploads occur unless user explicitly opts in.
=====================================================================
7.53.9 Diagnostic Dump System
=====================================================================
Users can request:
domtool diagnostics --full
Outputs:
entity counts
network topology
memory map (safe subset)
list of open handles
active mods
sim hashes
UPS history
world chunk consistency
universe consistency report
=====================================================================
7.53.10 Multiplayer Validation
=====================================================================
Multiplayer has mandatory validation features:
client–server state hashing
tick-synced event logs
mod hash verification
DLC consistency checks
replay-based forensic tracking
network packet checksums
If inconsistency detected:
freeze
dump
offer recovery
allow rollback to prior tick
=====================================================================
7.53.11 Timewarp Validation
=====================================================================
In single-player:
game allows high-speed timewarp
In multiplayer or LAN:
timewarp disabled or host-controlled
all clients enforce tick lock
sim hash must match host
=====================================================================
7.53.12 Developer Mode
=====================================================================
Developer builds expose:
hot reload of assets
deeper simulation inspection
instant chunk dumping
instrumentation overlays
detailed profiling overlays
forced-trigger simulation events
User builds hide these behind devmode.ini.
=====================================================================
7.53.13 Summary (Strict)
Three-tier telemetry model
Fully deterministic simulation telemetry
Full debugging console (read-only by default)
Event logging (compact, binary, deterministic)
Periodic simulation checksums for desync detection
Replay validation pipeline
Profiling for simulation/rendering/audio
Unified logging system
Crashdump + diagnostics
Multiplayer validation for consistency
Developer mode for deep inspection
Nothing affects simulation state

When ready:
Proceed with 7.54
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
I need one clarification before writing 7.54.
Volume 7.54 is the integration point between:
the deterministic simulation
the deterministic and nondeterministic UI layers
the debug/telemetry systems
the launcher
the configuration system
the modding layer
the networking layer
and the OS-level platform backends
…but there are two possible valid interpretations of what you intended as “7.54” in the progression so far.
To avoid writing the wrong subtree, choose one:

Option A — 7.54: Configuration System & Settings Architecture
A full spec for:
global engine settings
video/audio/backend selection
UPS/FPS limits
determinism guarantees
config file format (C89-friendly)
per-platform overrides
launcher integration
mod/config layering
save-embedded config
safe/unsafe settings modes
This is the natural next chapter if we continue the Engine Integration Volume.

Option B — 7.54: Launcher ↔ Engine Interface Spec
A full spec for:
unified multi-executable launcher
backend detection
platform+renderer selection
headless/server/client detection
mod loading pipeline
DLC resolution
save compatibility checking
inter-property universe binding
deterministic handoff to engine
cross-platform startup flow
This is the natural next chapter if we continue the User-Facing Engine Layer of Volume 7.

Option C — 7.54: Platform Backend Integration Layer
A full spec for:
SDL1/SDL2/WinAPI/Cocoa/POSIX backends
DirectX9/GL1/GL2/software pipelines
input abstraction mapping
sound abstraction
windowing lifecycle
deterministic startup sequencing
backend capability flags
fallback/soft-fail mode
headless/CLI/TUI boot flows
This is the natural next chapter if we continue the Low-Level Platform Layer of Volume 7.

Which 7.54 do you want?
A, B, or C.
You said:
Proceed with 7.54a, then b and c
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
We proceed with 7.54A first.
Here is:
VOLUME 7.54A — CONFIGURATION SYSTEM & SETTINGS ARCHITECTURE
(Dominium Engine Integration Layer)
# 7.54A — CONFIGURATION SYSTEM & SETTINGS ARCHITECTURE  
Dominium Engine Specification — Volume 7.54A  
Authoring Target: C89/C++98 deterministic core, cross-platform (Win2000+, macOS 10.6+, Linux)

---

## 7.54A.1 — PURPOSE  
The Dominium Configuration System exists to:

1. Provide **all engine, simulation, launcher, UI, platform, renderer, and network settings** in a unified, deterministic pipeline.  
2. Support **hierarchical overrides** (Global → Platform → Backend → Profile → Save-embedded overrides).  
3. Guarantee that **simulation determinism is never broken** by user settings.  
4. Enable **safe fallback modes** for low-end and legacy systems.  
5. Integrate cleanly with the Launcher (Vol. 7.50), Platform Backends (Vol. 7.54C), and Modding Layer (Vol. 5.5).  

---

## 7.54A.2 — DESIGN PRINCIPLES  
1. **Determinism first.**  
   No setting may alter simulation behaviour unless explicitly in the “Unsafe Settings” namespace.

2. **Hierarchical, layered config.**  
   Settings load in this order:  
   ```
   /defaults/
   /platform/<os>/
   /backend/<renderer>/
   /profile/<user>/
   /mods/<mod>/
   /save/<world>/
   /cli_arguments/
   ```
   Later layers override earlier layers.

3. **Immutable simulation constants.**  
   UPS canonical values, fixed-point resolution, tick order, RNG seeds cannot be altered.

4. **Minimal I/O overhead**  
   Config is parsed **once** at boot, then stored in deterministic C89 structs.

5. **Portable text-based formats.**  
   Config format: **DOMCFG v1**, an INI-like but deterministic subset.

6. **Cross-platform consistency**  
   No codepath is allowed to rely on Windows registry, macOS plist, or Linux config dirs exclusively.

---

## 7.54A.3 — CONFIGURATION FILE FORMAT (DOMCFG v1)  
A dead-simple deterministic format loadable from C89:

- **No comments** allowed in shipped configs (optional in dev).  
- Keys = ASCII `[A-Za-z0-9_.-]`  
- Values = string, int, float, bool  
- Sections = `[section]`  
- Strict no-order-change guarantee for replay determinism.

Example:

```
[video]
renderer = gl2
resolution_x = 1280
resolution_y = 720
fullscreen = false

[simulation]
ups_target = 60
allow_timescale_warp = true

[audio]
enabled = true
quality = low
```

---

## 7.54A.4 — CONFIGURATION DOMAINS  
Settings grouped by deterministic priority:

### 1. VIDEO (non-deterministic domain)
- renderer backend  
- resolution  
- fullscreen/window mode  
- vsync  
- FPS cap  
- texture filtering  
- 2D/3D/vector mode selection  
- shader quality  
- fallback (software rendering)  

These affect visuals only.

---

### 2. AUDIO (non-deterministic domain)
- output backend  
- quality level  
- music volume  
- SFX volume  
- accessibility filters  

No effect on simulation.

---

### 3. INPUT (non-deterministic domain)
- keybinds  
- controller mapping  
- deadzones  
No simulation impact.

---

### 4. NETWORK (deterministic path preserved)
- throttle rate  
- packet tick window  
- server tick cap  
- replay sync settings  

Network messages are deterministic **after** canonicalization.

---

### 5. SIMULATION (deterministic domain)
**Locked defaults:**  
- UPS canonical modes (1/2/5/10/20/30/45/60/90/120/180/240)  
- fixed-point precision  
- tick ordering  
- ECS update order  
- RNG seed derivation  

**User-adjustable:**  
- selected UPS canonical value  
- timescale warp factor  
- save-safety (reject unsafe settings)  

---

### 6. MODDING  
- enable/disable mods  
- load order  
- mod config namespaces  
- per-mod minispec overrides  
All changes must be deterministic or isolated to UI.

---

### 7. PLATFORM OVERRIDES  
- Windows-specific (DirectX availability, registry fallback)  
- macOS-specific (bundles, .app search paths)  
- Linux-specific (X11/Wayland/ALSA/Pulse)  
- Legacy OS overrides (Win2000, XP, 98SE)  

---

### 8. SAVE-EMBEDDED OVERRIDES  
To ensure multiplayer reproducibility:  
A save contains **canonical settings** for:

- UPS  
- backend selection allowed  
- mod set  
- DLC set  
- deterministic simulation flags  

Clients cannot override these.

---

## 7.54A.5 — CONFIGURATION RESOLUTION ORDER  
On boot:

1. Load `dominium.cfg` from installation.  
2. Load `platform/<os>.cfg`.  
3. Load `renderer/<backend>.cfg`.  
4. Load global override profiles.  
5. Load mod configs.  
6. If launching a save: load save-embedded config.  
7. Apply CLI arguments last.  
8. Freeze deterministic domain.  
9. Notify subsystems via event: `CFG_FINALIZED`.

---

## 7.54A.6 — CONFIGURATION ACCESS API  
A C89-friendly static API:

```
const char* cfg_get_str(const char* key);
int         cfg_get_int(const char* key);
double      cfg_get_float(const char* key);
bool        cfg_get_bool(const char* key);
```

All configs are compiled into a single deterministic key-value map.

---

## 7.54A.7 — CONFIGURATION VALIDATION  
Before simulation loads:

- confirm deterministic flags  
- validate UPS mode  
- validate renderer availability  
- validate mod compatibility  
- reject unsafe overrides  
- enforce DLC/licensing boundaries  

If validation fails: fall back to safe mode.

---

## 7.54A.8 — SAFE MODE  
A minimal configuration safe on **Win2000, XP, 98SE**, low-end Linux:

- software renderer  
- SDL1 audio  
- no shaders  
- no threading  
- UPS=10  
- minimal UI  
- no 3D mode  

Launched automatically if hardware detection fails.

---

## 7.54A.9 — CLI OVERRIDES  
Canonical flags:

```
--renderer gl2
--renderer dx9
--renderer sw
--ups 60
--fps 120
--safe-mode
--no-mods
--profile name
--windowed
--fullscreen
--res 1920x1080
```

CLI overrides must not break determinism.

---

## 7.54A.10 — DETERMINISTIC INTEGRATION  
All simulation-affecting config is:

- captured in savegame  
- replicated to clients in multiplayer  
- locked after load  
- part of replay metadata  

No visual/audio/input setting affects determinism.

---

## 7.54A.11 — FALLBACK & MIGRATION  
For legacy OSs or missing features, fallback occurs:

- DX9 → GL2 → GL1 → Software  
- SDL2 → SDL1 → Null  
- XAudio2 → DirectSound → Null  

Migration of old config files uses a version key:

```
[meta]
domcfg_version = 1
```

Older versions are upgraded deterministically.

---

## 7.54A.12 — EXPORT & IMPORT  
Users can export/import profiles:

```
domcfg_export("my_profile.cfg");
domcfg_import("shared_profile.cfg");
```

Profiles never alter simulation settings.

---

## 7.54A.13 — SUMMARY  
The Configuration System:

- is deterministic where required  
- is flexible where allowed  
- is cross-platform  
- supports mods and future platforms  
- supports legacy OSs  
- supports safe mode and fallback  
- integrates cleanly with launcher, renderer, and simulation core  

It forms the basis for **7.54B** and **7.54C**.

Respond “Proceed with 7.54B” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.54B — LAUNCHER ↔ ENGINE INTERFACE SPEC
Dominium Engine Integration Layer
Structured for C89/C++98, deterministic core, multi-platform.
# 7.54B — LAUNCHER ↔ ENGINE INTERFACE SPEC  
Dominium Engine Specification — Volume 7.54B

---

## 7.54B.1 — PURPOSE  
This defines how the **Launcher** and the **Engine** communicate.  
It must function on:

- Windows 2000 → Windows 11  
- macOS 10.6+  
- Linux (X11/Wayland/CLI)  
- Headless servers  
- Legacy platforms via stubs (Win98/95, DOS, OS9)

Goals:

1. **Zero nondeterminism** introduced in boot path.  
2. **Unified selection** of:  
   - platform backend (SDL1, SDL2, Native/WinAPI, Cocoa, POSIX)  
   - renderer backend (GL1, GL2, DX9, SW)  
   - audio backend (SDL/DSound/OpenAL/XAudio2)  
   - input backend (SDL/Native/Cocoa)  
3. Accurate **hardware detection** without simulation effects.  
4. Config, save, and mod loading pipeline.  
5. Multiplayer universe selection.  
6. Deterministic handoff from Launcher → Engine.

---

## 7.54B.2 — LAUNCHER LAYERS  
The Launcher contains the following layers:

### 1. **Bootstrap Layer**  
- Detect OS, CPU, GPU, RAM  
- Detect backend capabilities  
- Parse CLI arguments  
- Load global configs  

### 2. **Backend Selection Layer**  
- Chooses the best supported backend given:  
  - user overrides  
  - platform blacklist  
  - capability flags  

### 3. **Profile & Mod Resolver**  
- Loads mod lists  
- Sorts mod load order  
- Resolves missing mods  
- Verifies DLC availability  

### 4. **Savefile Resolver**  
- Loads save metadata  
- Resolves deterministic constraints  
- Detects incompatible engine versions  
- Locks UPS/FPS settings if required  

### 5. **Universe Resolver (online/offline)**  
- Detect local universes  
- Detect LAN universes  
- Detect servers (manual or broadcast)  
- Resolve identity/profile  
- Resolve mod-set compatibility  

### 6. **Handoff Layer**  
- Consolidates final configuration values  
- Writes them into a deterministic handoff blob  
- Launches the engine executable with a safe binary protocol  

---

## 7.54B.3 — HANDOFF PROTOCOL  
The Launcher passes all required data to the engine using one of:

- shared memory block  
- temp file with binary header  
- command-line pointer  
- platform IPC (WinAPI pipes, POSIX pipes)  

### Binary Layout (DOM-HANDOFF v1):

```
struct dom_handoff_header {
    uint32_t magic;            // 0x444F4D48 ("DOMH")
    uint32_t version;          // 1
    uint32_t size;             // total size of the blob
    uint32_t crc32;            // checksum of payload
};
```

Payload sections (order fixed):

1. Deterministic simulation config  
2. Selected platform backend  
3. Selected renderer backend  
4. Selected audio/input backend  
5. Mod list (+ checksums)  
6. DLC list  
7. Save metadata  
8. Network/universe metadata  
9. Locale & accessibility settings  
10. Debug flags (if allowed)

Simulation config + mod lists + save metadata must be **bit-identical** for all clients in multiplayer.

---

## 7.54B.4 — LAUNCHER CAPABILITY FLAGS  
The Launcher determines hardware/software capability flags and passes them to the engine:

```
renderer_gl1 = true
renderer_gl2 = true
renderer_dx9 = false
renderer_sw  = true

audio_xaudio2 = false
audio_dsound  = true
audio_sdl     = true

input_native  = true
input_sdl2    = true

cpu_sse       = true
cpu_sse2      = false
cpu_avx       = false

os_win2k      = true
os_win10      = false
```

The engine uses these only to **avoid selecting unsupported backends**, not for simulation.

---

## 7.54B.5 — BACKEND NEGOTIATION  
Backend selection is a deterministic scoring algorithm:

### Step 1 — Filter by user constraints  
User selections override auto-detection unless impossible.

### Step 2 — Filter by OS constraints  
Example:

- macOS 10.6+ → no DirectX  
- Win2000 → no DX11, partial DX9  
- Linux → GL-only

### Step 3 — Filter by capability flags  
Eg. GPU lacks shaders → fallback to GL1 or SW.

### Step 4 — Sort remaining backends by priority  
Default priority (modifiable by config):

```
dx9 > gl2 > gl1 > software
```

### Step 5 — Pick first valid backend  
If none valid → safe mode.

---

## 7.54B.6 — MOD & DLC LOADING PIPELINE  
Launcher ensures:

1. All mods enabled by the user exist  
2. Checksum match  
3. No missing dependencies  
4. No conflicts  
5. Determinism enforced:  
   - mod list hashed  
   - mod configs frozen  
   - mod order sorted lexicographically  

If mismatched between clients: connection refused.

---

## 7.54B.7 — SAVEFILE METADATA HANDLING  
Savefiles embed:

- canonical UPS  
- world seed  
- mod set  
- DLC set  
- deterministic flags  
- engine version  
- universe ID  

Launcher performs:

- version diff check  
- mod incompatibility scan  
- DLC mismatch detection  
- UPS lock enforcement  

---

## 7.54B.8 — UNIVERSE / SERVER DISCOVERY  
Launcher handles:

- offline universes (single-player)  
- local universes (LAN)  
- remote universes (direct IP)  
- hosted servers (official or private)  

Each universe advertises:

- mod hash  
- DLC hash  
- UPS mode  
- deterministic window size  
- max clients  
- property count  
- universe time  

Launcher will refuse connection if any mismatch exists.

---

## 7.54B.9 — VISUAL SELECTION UI  
Launcher presents:

- backend selection  
- renderer selection  
- world list  
- mod list  
- DLC list  
- universe list  
- player profiles  
- debug tools  

All UI is external and non-deterministic.

---

## 7.54B.10 — ENGINE LOADING CONTRACT  
Once the engine launches, it must:

1. Load the handoff blob  
2. Verify CRC  
3. Validate deterministic constraints  
4. Initialize subsystems in fixed order  
5. Create the world or join a universe  
6. Report readiness back to Launcher (optional)  
7. Enter simulation loop

---

## 7.54B.11 — LAUNCHER CRASH-SAFE BEHAVIOUR  
If engine fails:

- Launcher displays error UI  
- Suggests fallback backend  
- Offers safe-mode boot  
- Provides mod conflict diagnostics  
- Never corrupts savefiles  

Launcher itself is non-critical; engine remains authoritative for determinism.

---

## 7.54B.12 — CLI INTEGRATION  
CLI flags override UI and config (but not save-embedded deterministic settings):

```
--backend sdl2
--renderer dx9
--audio xaudio2
--input native
--safe-mode
--no-mods
--ups 60
--server 192.168.1.4:24600
--profile dev
--launch-save myworld.dom
```

---

## 7.54B.13 — HEADLESS MODE  
Launcher supports:

```
dominium_server.exe --headless
```

In headless mode:

- no video/audio/input  
- minimal backend (posix/winapi)  
- deterministic simulation loop  
- mod loading  
- CLI-only interface  
- remote admin API (Vol. 7.60+)  

---

## 7.54B.14 — MINIMAL / LEGACY FLOW  
For Windows 98SE, XP, macOS 10.1–10.5, DOS, OS9:

Launcher devolves into **text-mode**:

- simple backend selection  
- simple config  
- simple mod selection  
- no universe browser  
- no hardware detection  
- fallback → safe mode  

Engine still receives deterministic handoff blob.

---

## 7.54B.15 — SUMMARY  
Launcher is:

- deterministic in all simulation-relevant output  
- nondeterministic in UI  
- cross-platform  
- fallback-safe  
- mod-aware  
- DLC-aware  
- universe-aware  
- replay-aware  
- server-aware  
- legacy-compatible  

It acts as the **canonical gatekeeper** for all engine boots, both client and server.

Respond “Proceed with 7.54C” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.54C — PLATFORM BACKEND INTEGRATION LAYER
Dominium Engine Integration Layer
SDL1 / SDL2 / WinAPI / Cocoa / POSIX / Software modes
Deterministic core, C89/C++98 target.
# 7.54C — PLATFORM BACKEND INTEGRATION LAYER  
Dominium Engine Specification — Volume 7.54C

---

## 7.54C.1 — PURPOSE  
The Platform Backend Layer (PBL) abstracts **all OS-level functionality**:

- windowing  
- input  
- audio  
- filesystem  
- timing  
- threading  
- OS events  
- GPU/renderer context creation  
- legacy compatibility  

It must:

1. Provide **uniform behaviour** across Win2000+, macOS 10.6+, Linux.  
2. Provide **fallbacks** for Win98/95/NT4, macOS 7–9, and extremely old Linux.  
3. Allow **mix-and-match renderers** (GL1, GL2, DX9, SW) with **mix-and-match platforms** (SDL1, SDL2, native).  
4. Maintain **perfect determinism**: no backend code may influence simulation timing or results.

---

## 7.54C.2 — CORE DESIGN REQUIREMENTS  
### 1. **Deterministic API Surface**  
Simulation calls only these PBL functions:

```
pbl_time_monotonic()
pbl_sleep_ticks()
pbl_poll_input()
pbl_swap_buffers()
pbl_get_filesystem_paths()
pbl_read_file()
pbl_write_file()
pbl_enumerate_devices()
```

No nondeterministic randomness, no variable-rate callbacks.

### 2. **Backend Isolation**  
Each backend lives in:

```
/src/platform/<backend>/
```

Examples:

```
/src/platform/sdl1/
/src/platform/sdl2/
/src/platform/winapi/
/src/platform/cocoa/
/src/platform/posix/
/src/platform/null/        // headless
```

### 3. **Renderer Integration Boundary**  
Renderers (GL1/GL2/DX9/SW) bind through a **Renderer Context Factory**:

```
pbl_renderer_context_create()
pbl_renderer_context_destroy()
```

The PBL never touches rendering logic; it only initializes contexts.

### 4. **Deterministic Time Model**  
All backends convert OS time to a **strict fixed-point monotonic tick counter**.

Clock differences across OSs must not affect simulation.

---

## 7.54C.3 — BACKEND CATEGORIES  
### **A. SDL1 Backend** (Win2000+, XP, Linux, legacy Mac via SDL1)  
Pros:
- highest compatibility  
- works on ancient systems  
- supports software renderer easily  

Cons:
- limited input  
- limited audio  
- limited threading  
- no true Unicode input  

Used for legacy-safe builds and software renderer mode.

---

### **B. SDL2 Backend** (WinVista+, macOS 10.6+, Linux)  
Pros:
- modern input/audio  
- stable windowing  
- portable  
- good controller support  

Cons:
- heavier than SDL1  
- may fail on older GPUs/OS combos

SDL2 is the **primary backend** for modern systems.

---

### **C. Native WinAPI Backend** (Win2000+)  
Direct access to:

- Win32 windowing  
- DirectInput/XInput  
- DirectSound/XAudio2  
- DirectX9 context creation  
- Raw mouse/keyboard events  

Used when highest performance is desired on Windows.

---

### **D. Cocoa Backend** (macOS 10.6+)  
Objective-C wrapper for:

- NSWindow  
- Metal-disabled mode (GL only)  
- macOS input  
- macOS audio  

Legacy macOS <10.6 uses the **Carbon backend** with GL1 only.

---

### **E. POSIX Backend** (Linux, BSD, Solaris)  
Minimal windowing through X11 or Wayland if available; headless if not.

Provides:

- POSIX timers  
- POSIX file IO  
- POSIX input (evdev fallbacks)  
- ALSA / PulseAudio / OSS backends

---

### **F. Null Backend (Headless)**  
No:

- window  
- sound  
- input  
- GPU context  

Used for servers, deterministic benchmarking, replay validation.

---

## 7.54C.4 — FILESYSTEM ABSTRACTION  
All paths resolved through a single deterministic API:

```
pbl_path_user_config()
pbl_path_user_saves()
pbl_path_install_root()
pbl_path_temp()
```

Backends map these to:

### Windows  
```
%APPDATA%/Dominium/
%LOCALAPPDATA%/Dominium/
<install>/saves/
```

### macOS  
```
~/Library/Application Support/Dominium/
~/Library/Preferences/Dominium/
<bundle>/Contents/Resources/
```

### Linux  
```
~/.local/share/dominium/
~/.config/dominium/
```

### Legacy  
Single flat directory near executable, 8.3-safe for DOS/Win3.x.

---

## 7.54C.5 — INPUT MODEL  
Unified input events converted into deterministic fixed event packets:

```
struct pbl_input_event {
    uint8_t type;
    uint8_t device;
    uint16_t code;
    int16_t value;
};
```

Backends provide raw input, but engine receives only:

- key pressed  
- key released  
- axis moved  
- mouse move  
- mouse wheel  
- controller button/axis  
- text input (UTF-8)  

Backends must prevent nondeterministic OS acceleration effects.

---

## 7.54C.6 — AUDIO BACKENDS  
Backends provide a single API:

```
pbl_audio_init()
pbl_audio_submit_buffer()
pbl_audio_shutdown()
```

Supported underlying systems:

### Windows  
- XAudio2  
- DirectSound  
- MME (fallback)

### macOS  
- CoreAudio

### Linux  
- PulseAudio  
- ALSA  
- OSS (fallback)

### Universal  
- SDL Audio  
- Null backend

All audio mixing remains internal to engine; backend only plays buffers.

---

## 7.54C.7 — THREADING & JOB SYSTEM  
Backends provide:

```
pbl_thread_create()
pbl_thread_join()
pbl_thread_yield()
pbl_mutex_create()
pbl_mutex_lock()
pbl_mutex_unlock()
```

Determinism ensured by:

- simulation threads never reading from nondeterministic OS time  
- job ordering defined completely in engine (Vol. 7.32)  
- simulation always single-thread-authoritative

---

## 7.54C.8 — WINDOWING  
Backends create windows with deterministic flags:

```
pbl_window_create(width, height, fullscreen)
pbl_window_destroy()
pbl_window_swapbuffers()
pbl_window_set_title()
```

All OS-specific events (resize, focus lost, etc.) produce deterministic event records.

---

## 7.54C.9 — GPU & SOFTWARE RENDERER INITIALIZATION  
Backends must:

1. Create a GPU context (GL1/GL2/DX9) or SW framebuffer.  
2. Bind context into engine’s rendering interface.  
3. Report failures without crashing.  
4. Provide fallback stack:

```
DX9 → GL2 → GL1 → SW
```

---

## 7.54C.10 — CAPABILITY FLAGS  
Backends provide capability detection:

- shader support  
- FBO support  
- texture size  
- vsync availability  
- input devices  
- multiple monitors  
- audio devices  

All nondeterministic; engine treats them as advisory only.

---

## 7.54C.11 — LEGACY MODE SUPPORT  
### Win98/Win95/NT4  
- WinAPI minimal window  
- DirectDraw-only or Software  
- MME audio  
- Keyboard-only input  
- 8.3 filesystem  
- No threading  

### Mac OS 7–9  
- Carbon or SDL1  
- GL1-only  
- Simple window  
- Simple audio  

### DOS  
- No window  
- VGA text/graphics fallback  
- Null audio  
- Small memory model  
- Software renderer only  
- Polling-based input  

---

## 7.54C.12 — HEADLESS MODE  
Backend must:

- provide monotonic time  
- provide minimal filesystem  
- disable input  
- disable audio  
- skip windowing  
- run simulation loop at fixed UPS  

Used for servers and deterministic tests.

---

## 7.54C.13 — INITIALIZATION ORDER  
Backends must initialize in this deterministic sequence:

1. Load platform config  
2. Detect hardware  
3. Create window (if applicable)  
4. Create GPU context (or SW buffer)  
5. Initialize input  
6. Initialize audio  
7. Report capabilities to engine  
8. Engine begins simulation initialization  

---

## 7.54C.14 — SHUTDOWN ORDER  
1. Engine requests shutdown  
2. Stop audio  
3. Destroy GPU context  
4. Destroy window  
5. Tear down input  
6. Release all OS handles  
7. Exit cleanly  

---

## 7.54C.15 — BACKEND DEBUGGING  
Optional:

- backend capability dump  
- raw event logging  
- timing graphs  
- failover test mode  
- legacy test mode  
- headless simulation verification  

Never active in deterministic simulation unless allowed.

---

## 7.54C.16 — SUMMARY  
The Platform Backend Layer:

- abstracts all OS differences  
- preserves determinism  
- provides flexible backend choice  
- supports extremely old systems  
- supports high-performance modern systems  
- integrates smoothly with launcher (7.54B)  
- provides minimal APIs to simulation core  
- ensures rendering/audio/input never break determinism  
- allows safe and consistent fallback paths  

State “Proceed with Volume 7.55” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.55 — MULTI-PROCESS / MULTI-CORE SCHEDULER INTERFACE
Dominium Engine Integration Layer
Deterministic simulation, parallel backend, C89/C++98.
# 7.55 — MULTI-PROCESS / MULTI-CORE SCHEDULER INTERFACE  
Dominium Engine Specification — Volume 7.55

---

## 7.55.1 — PURPOSE  
Dominium must:

- Run deterministically on **single-core legacy systems** (Win2000, XP, 98SE).  
- Scale cleanly on **modern multi-core systems** (4–128 threads).  
- Offload nondeterministic tasks while keeping simulation 100% deterministic.  
- Still run in **headless server mode** without OS scheduler variance.  
- Avoid OS-dependent behaviour or order variance.  

This volume defines the **Dominium Job Scheduler (DJS)**, the **Deterministic Simulation Thread (DST)**, and the **Auxiliary Workers (AWs)**.

---

## 7.55.2 — CORE ARCHITECTURAL MODEL  
Dominium uses a **Single-Thread Authoritative Simulation (STAS)** design:

### 1. **DST — Deterministic Simulation Thread**  
- Runs the entire 1/10/60/120 UPS deterministic simulation loop.  
- Executes ECS systems in fixed order (Vol. 7.31).  
- Reads no nondeterministic OS values.  
- Uses only deterministic memory pools.  
- Is the sole thread allowed to mutate simulation state.

### 2. **AWs — Auxiliary Worker Threads**  
- Zero determinism requirements.  
- Used for expensive, nondeterministic, or asynchronous tasks:  
  - rendering command prep  
  - audio mixing  
  - file IO  
  - compression / decompression  
  - mod parsing  
  - background texture streaming  
  - navmesh baking (cooperative)  
  - AI long-running pathfinding  
- Communicate with DST via deterministic queues.

### 3. **DIPC — Deterministic Inter-Process Channels**  
DST <-> AWs communicate through:

- Fixed-size ring buffers  
- Non-blocking writes  
- Canonical ordering of message consumption  
- Zero OS scheduling reliance  

---

## 7.55.3 — JOB SCHEDULER OVERVIEW  
The Dominium Job Scheduler (DJS) manages all worker threads.

### DJS Components:

1. **Job Queue**  
   - deterministic priority buckets  
   - FIFO within priorities  
   - fixed-capacity  
   - no dynamic allocations  

2. **Worker Pool**  
   - configurable number of AW threads  
   - default = number of logical cores - 1  
   - legacy OS fallback = 0

3. **Task Types**  
   **Deterministic (DST only)**  
   - simulation ECS systems  
   - tick-ordered subsystems  
   - deterministic AI logic  
   - network tick processing  

   **Nondeterministic (AW only)**  
   - any task reading OS time  
   - any task touching OS APIs  
   - any renderer/audio/file IO  
   - compression, hashing  
   - background calculations

---

## 7.55.4 — DETEMINISTIC TICK PIPELINE AND WORKER TIMELINE  
Each UPS tick executes in strict order:

```
TICK N:
  DST: Run ECS Systems
  DST: Send async requests → AWs
  DST: Read results from previous AW batches
  DST: Produce render submission graph
  AWs: Prepare render data
  AWs: Async file ops, compression, shaders, etc
  DST: Finalize tick
```

AW work must **never** affect simulation values or order.

---

## 7.55.5 — MESSAGE PASSING MODEL  
### DST-to-AW (Requests)
- Fixed structures per job type  
- No pointers (only offsets or IDs)  
- DST writes messages in deterministic order  
- AW receives in same order  

### AW-to-DST (Responses)
- Returned via same ring buffer  
- DST polls once per tick  
- Late responses are carried forward to next tick  

### Guarantees
- No job ever modifies simulation data directly  
- Only DST commits changes  
- Multiple AWs produce nondeterministic execution order, but results are timestamped and consumed deterministically by DST  

---

## 7.55.6 — MULTI-CORE WORK DISTRIBUTION  
AWs steal jobs from a shared queue:

- lock-free atomic queue  
- deterministic ordering is not required  
- DST is not blocked by AW scheduling  

Task distribution patterns:

- **Parallel Map**: large arrays (meshes, audio samples)  
- **Parallel ForEach**: decompression tasks  
- **Parallel Reduce**: texture atlas builds  
- **Scatter/Gather**: render batches  

All results returned to DST in the order they must be consumed.

---

## 7.55.7 — CROSS-PLATFORM THREADING  
### Windows (Win2000+)
- CreateThread  
- SetThreadPriority  
- WaitForSingleObject  
- SRWLocks / Critical Sections  

### macOS (10.6+)  
- pthreads  
- dispatch queues (optional)  

### Linux  
- pthreads  

### Legacy (Win98/95/DOS/OS9)
- 0 worker threads  
- simulation runs single-threaded  
- everything async becomes synchronous  
- deterministic behaviour is unchanged  

---

## 7.55.8 — SCHEDULER CONFIGURATION  
Users may choose:

```
--threads N
--threads auto
--threads off
```

Engine boot resolves:

- auto = logical_cores - 1  
- off = 0  
But DST stays single-threaded regardless.

Savegames **never store thread count**, because it doesn’t affect determinism.

---

## 7.55.9 — PERFORMANCE DEGRADATION MODES  
If system overloaded:

### 1. FPS drops  
Rendering slows but DST continues stable UPS.

### 2. UPS slowdown  
If DST cannot maintain canonical UPS, game time slows but determinism is kept.

### 3. Worker throttling  
Scheduler may auto-reduce AW count to prevent OS thrashing.

All modes maintain deterministic simulation.

---

## 7.55.10 — WORKERS AND REPLAYS  
Workers are replay-safe because:

- All AW tasks are nondeterministic.  
- DST never uses their results except in deterministic read order.  
- Replay system replays **DST events only**.  
- AW results are recomputed during replay.  

Replay cannot diverge from simulation output.

---

## 7.55.11 — MULTI-PROCESS MODE  
In the future (servers handling >10k properties), Dominium supports:

- Multiple engine instances  
- Shared-memory DIPC  
- One authoritative DST per process  
- Processes stitched through deterministic boundary messages  

But V1 implements only single-process multi-thread.

---

## 7.55.12 — FAILOVER AND ISOLATION  
Worker crash:  
- Scheduler restarts worker  
- DST continues unaffected  
- Lost jobs resubmitted  
- Save is safe  

DST crash:  
- fatal  
- engine terminates  
- launcher displays diagnostics  

---

## 7.55.13 — DEBUGGING AND PROFILING  
Internal modes:

- thread timeline graph  
- job latency histogram  
- worker load balancing chart  
- AW starvation detector  
- slow-tick detector  
- deadlock watchdog (disabled in deterministic mode)  

No profiling data affects simulation.

---

## 7.55.14 — LEGACY OS RESTRICTIONS  
### Win98/95  
- No threads ≠ no scheduler  
- DJS runs in single-thread mode  
- All AW tasks run synchronously at safe points  

### DOS  
- Cooperative multitasking only  
- Uses polling  
- Job queue becomes synchronous  

Legacy modes remain fully deterministic.

---

## 7.55.15 — SUMMARY  
The Dominium Multi-Core Scheduler:

- Guarantees absolute determinism  
- Scales to modern multi-threaded systems  
- Degrades gracefully to single-thread  
- Supports heavy graphics/audio workloads  
- Eliminates OS scheduling variance  
- Is fully replay-safe  
- Is cross-platform and legacy-capable  
- Cleanly separates simulation from async work  

State “Proceed with 7.56” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.56 — BACKEND INTEROP AND RENDERER–PLATFORM COORDINATION
Dominium Engine Integration Layer
Unifying SDL1/SDL2/WinAPI/Cocoa/POSIX with GL1/GL2/DX9/SW
Deterministic simulation, C89/C++98 target.
# 7.56 — BACKEND INTEROP & RENDERER–PLATFORM COORDINATION  
Dominium Engine Specification — Volume 7.56

---

## 7.56.1 — PURPOSE  
Dominium supports **mix-and-match** OS backends and rendering backends:

- SDL1 + GL1  
- SDL1 + GL2  
- SDL2 + GL2  
- WinAPI + DX9  
- WinAPI + GL2  
- Cocoa + GL2  
- POSIX + GL1/GL2  
- Software renderer on any backend  
- Headless backend with no renderer  

This requires a strict **Interop Layer** that:

1. Decouples rendering logic from platform specifics.  
2. Ensures deterministic behaviour regardless of backend.  
3. Provides a unified contract for window/GL/DX context creation.  
4. Handles fallback chains cleanly.  
5. Maintains identical rendering order across systems.

This volume defines the **Dominium Renderer Interop Layer (DRIL)**.

---

## 7.56.2 — ARCHITECTURAL MODEL  
Three-tier architecture:

```
+-------------------------+
|  Dominium Renderer API  |
+-------------------------+
|  DRIL (Interop Layer)   |
+-------------------------+
|  Platform Backend (PBL) |
+-------------------------+
```

### Renderer API  
- Purely deterministic  
- Internal engine structures  
- Defines render commands, passes, pipelines

### DRIL  
- Creates/owns rendering context  
- Maps window, surface, swapchain  
- Chooses backend implementation  
- Provides capability flags  

### PBL  
- Wraps OS-level APIs: window, input, audio, file IO  
- Manages OS event lifecycle

DRIL never calls simulation. PBL never calls renderer directly. Engine orchestrates both.

---

## 7.56.3 — RENDERER INTERFACES  
Two interfaces defined in DRIL:

### 1. **Context Interface**
Used to create and manage rendering contexts:

```
dril_context_create()
dril_context_destroy()
dril_context_resize()
dril_context_swap()
dril_context_get_capabilities()
```

### 2. **Command Interface**
Backend-specific implementation of render commands:

```
dril_issue_drawcall()
dril_upload_buffer()
dril_upload_texture()
dril_set_pipeline()
dril_begin_frame()
dril_end_frame()
```

Render commands are deterministic.  
Frame timing is not.

---

## 7.56.4 — RENDERER BACKENDS  
Dominium supports four families of renderers:

### **A. GL1 (OpenGL 1.1 Fixed-Function Pipeline)**  
- Required for Win2000/XP and legacy macOS  
- Required fallback for old Linux  
- Perfect for vector mode  
- Limited shader features  
- Used for low-end machines or compatibility

### **B. GL2 (OpenGL 2.0 Programmable Pipeline)**  
- Primary modern cross-platform backend  
- Supports shaders  
- Matches DX9 feature level  
- Appropriate for fully textured 2D/3D

### **C. DX9 (Direct3D 9.0c Shader Model 3)**  
- Primary Windows high-performance backend  
- Ideal for XP, Vista, 7, 10, 11  
- Consistent and stable feature set  
- Maps well to GL2 capabilities

### **D. Software Renderer (SW)**  
- Required for fully headless visual mode  
- Required for machines without GPU  
- Pure C89 rasterizer  
- Useful for vector mode  
- Slow but guaranteed working

---

## 7.56.5 — MATCHING RULES BETWEEN PLATFORM AND RENDERER  
The DRIL selects renderer backend using this logic:

```
if (user_forced_backend)
    choose_user_forced();
else if (platform_backend == winapi && dx9_available)
    choose_dx9();
else if (gl2_available)
    choose_gl2();
else if (gl1_available)
    choose_gl1();
else
    choose_software();
```

Renderer dependencies:

| Renderer | Needs Window | Needs GL | Needs DX | Headless? |
|----------|--------------|----------|----------|-----------|
| GL1      | Yes          | Yes      | No       | No        |
| GL2      | Yes          | Yes      | No       | No        |
| DX9      | Yes          | No       | Yes      | No        |
| SW       | No           | No       | No       | Yes       |

---

## 7.56.6 — CONTEXT CREATION AND TEARDOWN  
Renderer context creation is deterministic and fully ordered:

### Creation Order:
```
1. PBL creates window
2. DRIL selects backend
3. DRIL creates GPU or SW context
4. DRIL queries capabilities
5. Renderer API initializes pipelines
6. Engine begins render loop
```

### Teardown Order:
```
1. Renderer API cleans pipelines
2. DRIL destroys context
3. PBL destroys window
```

All GL/DX calls must be isolated behind DRIL.

---

## 7.56.7 — CAPABILITY FLAGS  
DRIL exposes capability flags to renderer API:

```
caps.shader_support
caps.fbo_support
caps.max_texture_size
caps.max_vbo_size
caps.fixed_pipeline
caps.instancing_support
caps.multitexture
caps.anisotropy
```

These flags **do not change simulation**.

Renderer chooses shaders or fallback passes accordingly.

---

## 7.56.8 — SW RENDERER DESIGN  
SW Renderer must:

- run without window  
- work in headless mode  
- support vector mode  
- support 2D fallback  
- ignore texture features  
- obey same render command ordering as GL/DX backends  
- act as deterministic baseline for tests  

---

## 7.56.9 — RESOURCE LIFECYCLE  
### Deterministic allocation  
Renderer resources are created in deterministic order:

```
1. Shaders
2. Pipelines
3. Textures
4. Buffers
5. Framebuffers
```

Textures/buffers created by simulation are hashed and allocated consistently.

### Loading from disk  
Offloaded to AW tasks (Vol. 7.55), returned deterministically to DST.

---

## 7.56.10 — MULTI-VIEW / MULTI-MODE RENDERING  
DRIL abstracts:

- switching between **vector mode / 2D / 3D**  
- resizing windows  
- switching renderers at runtime (optional but allowed)

Switching rendering backends at runtime calls:

```
dril_context_destroy();
dril_context_create(new_backend);
```

State restoration must be deterministic.

---

## 7.56.11 — CROSS-PLATFORM VISUAL CONSISTENCY  
The engine must guarantee that:

- object ordering  
- pipeline ordering  
- UI layering  
- z-order  
- atlas packing  
- text shaping  
- 2D grid rendering  

remain visually identical or nearly identical across GL1, GL2, DX9, and SW.

Differences allowed:

- texture filtering  
- anti-aliasing  
- shader quality  
- floating-point precision  

Differences forbidden:

- object draw order  
- occlusion/visibility results  
- UI coordinate resolution  
- simulation-linked geometry offsets  

---

## 7.56.12 — LEGACY CONSTRAINTS  
### Win98/Win95/DOS  
- no GL2  
- no DX9  
- GL1 or SW only  
- no FBOs  
- no shaders  
- windowing fallback to minimal mode  

### macOS 10.1–10.5  
- GL1 only via Carbon  
- 2D/vector mode priority

### Linux (old)  
- GL1 fallback  
- SW if no GL available

---

## 7.56.13 — FAILOVER HANDLING  
If backend creation fails:

```
Try DX9 → GL2 → GL1 → SW → error
```

Launcher receives reason; user can retry.

No save corruption or simulation inconsistency allowed.

---

## 7.56.14 — DEBUGGING AND VALIDATION  
DRIL provides:

- backend trace logs  
- GL/DX error intercept  
- capability dump  
- software renderer golden-output frames  
- multi-backend visual diff tools  

These may run outside deterministic simulation.

---

## 7.56.15 — SUMMARY  
DRIL provides:

- unified cross-platform rendering context system  
- deterministic behaviour for simulation  
- stable rendering API  
- deep legacy support  
- multi-backend, multi-platform fallback  
- strong consistency across GL1/GL2/DX9/SW  
- support for vector/2D/3D modes  
- clean interop with launcher and PBL  

State “Proceed with 7.57 — Accessibility & Input Device Integration” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.57 — ACCESSIBILITY & INPUT DEVICE INTEGRATION
Dominium Engine Integration Layer
Deterministic core (C89/C++98), multi-platform.
# 7.57 — ACCESSIBILITY & INPUT DEVICE INTEGRATION  
Dominium Engine Specification — Volume 7.57

---

## 7.57.1 — PURPOSE  
Dominium must:

- Remain fully playable on **low-end hardware**, legacy OSes, and modern systems.  
- Support a wide range of **input devices**, some deterministic, some nondeterministic.  
- Integrate strong **accessibility features**, none of which affect simulation determinism.  
- Provide consistent input abstraction across SDL1, SDL2, WinAPI, Cocoa, POSIX, and headless modes.  
- Support deterministic replay of all user actions.  
- Allow players to interact in 2D/3D/vector modes with equal usability.

The input system must be layered, modern, and backward-compatible with Win2000/XP/98/95, macOS 10.6+, and Linux.

---

## 7.57.2 — INPUT SUBSYSTEM ARCHITECTURE  
Dominium uses a **three-layer architecture**:

```
         +--------------------------+
         |     UI & Gameplay        |
         +--------------------------+
         |   Dominium Input Core    |
         +--------------------------+
         | Platform Backend Layer   |
         +--------------------------+
```

### Platform Backend Layer (PBL)
- Reads OS events  
- Normalizes low-level keycodes  
- Reports raw movement, axis, and button events  

### Dominium Input Core (DIC)
- Converts PBL events → deterministic input events  
- Maps keys/controllers to actions  
- Applies accessibility filters  
- Generates replay-safe input packets  

### UI & Gameplay
- Consumes abstracted “intent events” (move, click, interact)

Simulation reads only the deterministic intent events.

---

## 7.57.3 — INPUT EVENT PACKET  
All input passed to the simulation thread uses a strict, replicable packet:

```
struct dom_input_event {
    uint8_t  type;      // KEY, MOUSE, ACTION, TEXT
    uint8_t  device;    // KEYBOARD, MOUSE, CONTROLLER, TOUCH
    uint16_t code;      // scan code, button, action ID
    int32_t  value;     // press/release/axis amount
    uint32_t tick;      // simulation tick it occurred on
};
```

Every replay logs these packets in order.  
Every client in multiplayer synchronizes on these.

---

## 7.57.4 — SUPPORTED INPUT DEVICES  
### A. Keyboard (Primary Device)  
- Supported on all platforms including DOS  
- Deterministic across backends  
- Scan codes normalized to Dominium codeset  
- N-key rollover not required for determinism

### B. Mouse (Primary Device for UI/3D)  
- Axis and button input  
- High-resolution mouse input *optional*  
- Acceleration curves disabled (OS-specific filtering removed)  

### C. Gamepads / Controllers  
- SDL2 supports XInput, generic controllers  
- WinAPI backend supports XInput directly  
- Linux supports evdev and SDL mapping  
- Deterministic mapping through “DomPad profile”

### D. Touch (Optional)  
- Used on Android/iOS future ports  
- Normalized to click/tap gestures  
- Multitouch treated deterministically per frame

### E. Joystick / HOTAS (Optional)  
- Normalized axes  
- Deterministic deadzones  
- Useful for machinery, vehicles, aircraft

### F. Keyboard-Only Mode  
- Mandatory on DOS, Windows 3.x, Win95/98 fallback  
- Vector UI & CLI/TUI modes rely on it  

---

## 7.57.5 — ACCESSIBILITY MODES  
All accessibility features must **never affect simulation results**.  
They modify UI rendering, input mapping, or audio only.

### 1. **High-Contrast Mode**  
- overrides color theme  
- vector/2D/3D modes all supported  

### 2. **Color-Blindness Filters**  
- protanopia  
- deuteranopia  
- tritanopia  
- grayscale  

Applied in post-processing; ignored in replay.

### 3. **UI Scaling**  
- 1.0x to 4.0x  
- dynamic scaling supported  
- text rendered in vector or signed-distance fields

### 4. **Text-to-Speech (TTS) / Speech-to-Text (STT)**  
- Optional  
- Provided by OS or external libraries  
- No deterministic effect

### 5. **Alternative Input Remapping**  
- user-defined remapping layers per-device  
- multiple profiles  
- stored outside simulation domain

### 6. **Motion Reduction**  
- disables camera/terrain animations  
- reduces parallax  
- collapses complex transitions

### 7. **Subtitles & Captions**  
- subtitles for speech/music  
- captions for SFX  

### 8. **Hearing Accessibility Modes**  
- vibrating indicators  
- visual UI pulses  
- waveform visualization options

### 9. **Cognitive Accessibility**  
- simplified displays  
- reduced clutter  
- slower UI animations  
- “minimalist informational mode”

---

## 7.57.6 — KEYBIND SYSTEM  
Deterministic keybind definition:

```
[action.move_forward]
keyboard = W
controller = DPAD_UP
mouse = none

[action.rotate_camera]
mouse_x = axis
mouse_y = axis
sensitivity = 1.25
```

Keybinds are:

- non-deterministic  
- stored externally  
- never part of replay data  
- not included in save determinism domain  

Intent events **are** deterministic.

---

## 7.57.7 — MOUSE SYSTEM  
Rules:

- OS acceleration disabled  
- raw input preferred (WinAPI RawInput, SDL2 Raw)  
- fallback to OS-mouse for legacy platforms  
- vector mode mouse scaling deterministic  
- 3D/world mode uses raycasting calculated by DST  
- rounding rules consistent across renderers  

---

## 7.57.8 — CONTROLLER SYSTEM  
Dominium internalizes controller mapping:

```
DOMPAD_LEFT_X
DOMPAD_LEFT_Y
DOMPAD_RIGHT_X
DOMPAD_RIGHT_Y
DOMPAD_A
DOMPAD_B
DOMPAD_X
DOMPAD_Y
DOMPAD_LB
DOMPAD_RB
DOMPAD_START
```

Backends must translate:

- XInput  
- SDL GameController  
- raw HID device  
- evdev devices  

into Dominium’s deterministic codeset.

All analog values quantized to deterministic fixed-point format.

---

## 7.57.9 — INPUT BUFFER MODEL  
Input buffering is deterministic:

1. Platform events → PBL raw buffer  
2. DIC reads raw buffer once per frame  
3. DIC resolves remapping  
4. DIC emits **ordered input events**  
5. Events stored in DST’s input event queue  
6. DST processes events by tick order  

Replay logs this exact queue.

---

## 7.57.10 — HEADLESS MODE  
Headless backend:

- no input devices  
- input events only generated via network or CLI API  
- deterministic command injection  
- remote admin commands recorded like normal replay input  

---

## 7.57.11 — UI ACCESSIBILITY  
UI layer supports:

- larger hitboxes  
- simplified UI elements  
- thick-mode vector UI  
- alternative fonts (bitmap, vector, SDF)  
- text magnification  
- input focus highlighting  
- reduced flicker mode  
- keyboard-only navigation  
- deterministic cursor locking rules  

---

## 7.57.12 — REPLAY-SAFE INPUT  
Replay cannot diverge because:

- All simulation-affecting input is expressed as deterministic `dom_input_event` packets  
- All input is timestamped by tick number just before DST processes it  
- Controller/keyboard/mouse state not stored — only resolved events  
- UI-only input is not logged  
- Accessibility filters affect UI only, not input events  

---

## 7.57.13 — FUTURE DEVICE SUPPORT  
Dominium allows future extension:

- VR controllers  
- AR gestures  
- brain–computer interface (BCI)  
- MIDI devices  
- haptic devices  
- steam deck input  
- switch-like controller inputs  

Because PBL normalizes at the lowest level, and DIC maps all events, extensions require no simulation changes.

---

## 7.57.14 — LEGACY SUPPORT  
### Windows 95/98/ME  
- Keyboard and mouse only  
- No raw input  
- No controllers  
- 2D/vector mode only

### Windows NT4/2000/XP  
- Keyboard, basic mouse, XInput (XP+)  
- Limited controllers with fallback modes  

### macOS 7–9  
- Keyboard only  
- Mouse optionally  

### DOS  
- Keyboard only  
- Simple 2-button mouse if available  

All deterministic.

---

## 7.57.15 — SUMMARY  
Dominium’s Accessibility & Input Device System:

- provides universal input abstraction  
- deterministic simulation interface  
- strong accessibility suite  
- fully replay-safe  
- cross-platform  
- legacy-compatible  
- supports controller, keyboard, mouse, touch, and future devices  
- integrates tightly with UI, Renderer, and Platform Backends  
- never breaks determinism  
- supports all 2D/3D/vector modes equally  

State “Proceed with 7.58 — Internationalisation & Localisation” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.58 — INTERNATIONALISATION & LOCALISATION
Dominium Engine Integration Layer
Deterministic core (C89/C++98), stable across all OS targets.
# 7.58 — INTERNATIONALISATION (I18N) & LOCALISATION (L10N)  
Dominium Engine Specification — Volume 7.58

---

## 7.58.1 — PURPOSE  
Dominium must support:

- full localisation of UI, tutorials, descriptions, item names  
- multi-language text display in vector, SDF, bitmap, CLI/TUI modes  
- international numeric/date formatting  
- optional language packs  
- mod-supplied translations  
- fallback behaviour on legacy OSes  
- fully deterministic output for strings  
- zero effect on simulation logic  

I18N/L10N must be cleanly separated from all deterministic systems.

---

## 7.58.2 — ARCHITECTURE OVERVIEW  
Dominium uses a **three-layer I18N architecture**:

```
+-------------------------------------------+
|  L10N Data Packs (base + DLC + mods)       |
+-------------------------------------------+
|  Dominium Localization Engine (DLE)        |
+-------------------------------------------+
|  UI Renderer / Text Renderer               |
+-------------------------------------------+
```

### 1. L10N Data Packs  
- pure data files  
- contain language-specific strings, fonts, metadata  
- versioned and checksummed  
- loaded by Launcher (Vol. 7.54B)  
- mod packs follow same structure  

### 2. DLE  
- runtime loader & resolver  
- fallback resolver  
- deterministic string ID lookup  
- pluralization rules  
- text direction rules  

### 3. UI/Text Renderer  
- renders SDF/vector/bitmap glyphs  
- handles bidirectional text if enabled  
- CLI/TUI mode uses ASCII fallback  

---

## 7.58.3 — STRING IDENTIFIER SYSTEM  
Every user-visible string is referenced by a **stable, deterministic ID**:

```
ui.menu.file
ui.menu.settings
item.ore.iron
item.ore.copper
research.tier1.description
tutorial.building.intro
```

String IDs are **never** changed after release.  
Changes require new IDs and soft-deprecation of old ones.

---

## 7.58.4 — LANGUAGE PACK FORMAT  
Language packs use **DOM-LANG v1**:

```
[meta]
language = en-US
font = "dom_sdf_main"
rtl = false
plural_rules = english

[strings]
ui.menu.file = "File"
ui.menu.settings = "Settings"
ui.menu.exit = "Exit"

[item]
item.ore.iron = "Iron Ore"
item.ore.copper = "Copper Ore"
```

Rules:

- UTF-8 only  
- No executable code  
- No dynamic/includes  
- No markup except `{var}` placeholders  
- Lexicographically sorted sections  

Modded language packs extend the base pack.

---

## 7.58.5 — FONT SYSTEM  
Dominium supports three font modes:

### 1. **SDF Fonts (Signed Distance Field)**  
- primary mode  
- scalable  
- efficient  
- consistent across renderers  

### 2. **Vector Glyphs**  
- used for CLI/TUI, headless, minimal builds  
- fallback for DOS/Win98/Win95  

### 3. **Bitmap Fonts**  
- legacy mode  
- small VRAM footprint  
- optional for stylistic packs  

DLE selects fonts based on backend capability:

```
SDF → Vector → Bitmap
```

---

## 7.58.6 — TEXT DIRECTION  
Supported text directions:

- LTR (Left-To-Right)  
- RTL (Right-To-Left) (Arabic, Hebrew)  
- TTB (Top-To-Bottom) limited support for stylized languages  

Rules:

- Simulation never influenced by text direction  
- UI renderer handles layout transforms  
- CLI/TUI mode restricts to LTR only  

---

## 7.58.7 — PLURALIZATION  
Plural forms defined by language pack metadata:

Example (English):

```
plural_rules = english
```

Processor:

```
plural(1, "item.count.single", "item.count.plural")
```

Engine selects correct entry.

All pluralization logic is deterministic and pure.

---

## 7.58.8 — VARIABLES & INTERPOLATION  
String interpolation uses deterministic placeholder injection:

```
"You have {count} workers assigned."
```

Rules:

- only integer, float, or string substitution  
- substitutions evaluated by DST (deterministic)  
- no conditional formatting inside strings  

---

## 7.58.9 — NUMBER & DATE FORMATTING  
Dominium supports **locale-aware formatting**, but can be overridden:

Formatting types:

- integers  
- floats  
- currency  
- percentages  
- time-of-day  
- date-of-year  
- tick/UPS timestamps  

The simulation uses **UTC-style deterministic time**; localisation happens only in UI layer.

---

## 7.58.10 — LANGUAGE SELECTION  
### Launcher selects language using order:

1. CLI override (`--lang xx-YY`)  
2. User profile config  
3. OS locale  
4. Default language (`en-US`)  

Multiplayer:  
- UI language is **per-client**  
- simulation strings (log entries) always recorded in canonical language (`en-US`)  

---

## 7.58.11 — SAVE & REPLAY BEHAVIOUR  
Savegames store **string IDs**, not localized strings.

Replays receive:

- raw IDs  
- raw variables  
- client-side resolution  

Thus localisation does **not** break replay determinism.

---

## 7.58.12 — MULTIPLAYER  
Language independence:

- each user sees UI in own language  
- chat messages are raw UTF-8; no auto-translation  
- system messages use canonical string IDs → resolved locally  

Host language has no impact on clients.

---

## 7.58.13 — MOD LOCALISATION  
Mods provide:

```
/mods/<mod>/lang/en-US.lang
/mods/<mod>/lang/fr-FR.lang
/mods/<mod>/lang/zh-CN.lang
```

Rules:

- base game strings cannot be overridden  
- mods may add new strings only  
- missing languages fall back to English  
- mod languages load after base game, before DLC  

---

## 7.58.14 — FUTURE PLATFORM SUPPORT  
This system includes provisions for:

- Android  
- iOS  
- WebAssembly  
- Consoles  

All share the same DOM-LANG v1 specification.

---

## 7.58.15 — LEGACY OS SUPPORT  
### Windows 95/98/ME  
- UTF-8 decoding  
- vector font fallback  
- no complex Unicode shaping  

### Windows NT 3.x / 2000 / XP  
- partial font fallback  
- no RTL mirroring on some builds  

### macOS 7–9  
- bitmap/vector fallback  
- simplified ASCII subset advisable  

### DOS  
- ASCII-only unless TSR-based Unicode extension used  
- fallback ensures deterministic operation  

---

## 7.58.16 — ACCESSIBILITY INTEGRATION  
Language packs include:

```
[accessibility]
ui.font_scale_default = 1.25
ui.high_contrast = true
```

DLE exposes:

- larger default font sizes  
- simplified text  
- reduced complexity captions  

These settings affect only UI.

---

## 7.58.17 — PERFORMANCE & MEMORY  
Memory constraints for older systems:

- DOM-LANG packs capped at 4 MB per language  
- font VRAM budgets adjustable by config  
- DLE caches only active strings  
- unused strings evicted on scene change  

Modern systems may load full packs in RAM.

---

## 7.58.18 — SUMMARY  
Dominium’s I18N/L10N system:

- is deterministic in all simulation-relevant aspects  
- isolates localisation from simulation logic  
- supports many languages cleanly  
- supports 2D/3D/vector modes  
- supports mods and DLC  
- respects legacy OS constraints  
- provides scalable text rendering  
- integrates fully with accessibility layer  
- preserves replay determinism  
- is future-proof for mobile/console/Web platforms  

State “Proceed with 7.59 — Total Engine Integration Checklist” when ready.
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
VOLUME 7.59 — TOTAL ENGINE INTEGRATION CHECKLIST
Dominium Engine Integration Layer
Master verification framework ensuring internal consistency, determinism, cross-platform stability, legacy support, and modular expansion compatibility.
# 7.59 — TOTAL ENGINE INTEGRATION CHECKLIST  
Dominium Engine Specification — Volume 7.59

---

## 7.59.1 — PURPOSE  
This is the **authoritative full-engine validation framework** for Dominium.  
It ensures that:

1. All engine subsystems integrate without contradiction.  
2. Determinism is preserved across all OSes, backends, and renderers.  
3. Legacy OS paths do not break functionality.  
4. Savegames, mods, DLC, input, audio, UI, renderer, data systems, networks, and physics all behave consistently.  
5. Build pipelines and executables remain stable.  
6. Engine behaviour is predictable and reproducible across hardware generations.

This checklist is used during:

- Alpha → Beta  
- Beta → Release  
- Patch validation  
- Backporting to legacy OS targets  
- Platform-specific certification  
- Modding system compatibility testing  

---

# 7.59.2 — MASTER CHECKLIST  
All subsystems must pass validation before any release.

---

## **CATEGORY A — DETERMINISM VALIDATION**  
Ensures simulation never diverges.

### A.1 — Deterministic Tick Loop  
- UPS tick order matches spec (Vol. 7.31).  
- Fixed tick ordering for ECS, networking, AI, physics.  
- No nondeterministic OS time access in DST.  
- All RNG uses deterministic seeding.

### A.2 — Deterministic Memory Allocations  
- Simulation allocates from deterministic pools.  
- No malloc calls inside tick.  
- No pointer-address-based behaviour.

### A.3 — Deterministic Serialization  
- Save files byte-identical across platforms.  
- Endianness conversions deterministic.  
- Floating-point behaviour normalized or replaced with fixed-point.

### A.4 — Deterministic Replay  
- Replays match past outputs bit-for-bit.  
- All input events serialize properly.  
- Worker threads reproduce same DST behaviour.

### A.5 — Deterministic Network Sync  
- Lockstep model validated.  
- All clients receive identical sim inputs.  
- No state divergence after extended play.

---

## **CATEGORY B — BACKEND COMPATIBILITY**  
Each platform backend must behave identically at the simulation layer.

### B.1 — SDL1  
- Runs GL1 and SW backends.  
- Legacy mouse/keyboard tested.

### B.2 — SDL2  
- Supports GL2, GL1, SW.  
- High-performance mode validated.

### B.3 — WinAPI  
- DX9 path validated.  
- Input via RawInput/XInput.  
- MME/DirectSound/XAudio2 audio fallback chain.

### B.4 — Cocoa  
- GL2 pipeline validated.  
- Apple event loop isolation correct.

### B.5 — POSIX  
- X11 & Wayland both supported.  
- ALSA/PulseAudio fallback chain stable.

### B.6 — Null Backend (Headless)  
- Deterministic server mode  
- No window/audio/input dependencies

### B.7 — Legacy Platforms  
- Win98/95 GL1/SW only  
- DOS software-only  
- macOS 7–9 bitmap/vector only  

All must run without crashing and maintain correctness.

---

## **CATEGORY C — RENDERING INTEGRATION**  
Visual correctness separated cleanly from simulation.

### C.1 — GL1 Consistency  
- Fixed-function matches engine ordering.  
- UI rendered correctly.  
- Vector mode pixel-accurate.

### C.2 — GL2 Consistency  
- Shader programs correct.  
- Identical ordering to DX9.

### C.3 — DX9 Consistency  
- Identical geometry interpretations.  
- Atlas packing stable.

### C.4 — Software Renderer  
- Pixel-for-pixel match with deterministic reference.

### C.5 — Multi-mode Rendering  
- Switching vector ↔ 2D ↔ 3D safe.  
- Window resizing deterministic.

### C.6 — Rendering Fallback  
- DX9 → GL2 → GL1 → SW fallback tested.

---

## **CATEGORY D — INPUT & ACCESSIBILITY**  
Event packets must always match across platforms.

### D.1 — Keyboard Normalization  
- All raw scancodes map to Dominium codeset.

### D.2 — Mouse Motion  
- OS acceleration disabled.  
- RawInput consistency validated.

### D.3 — Controller Mapping  
- XInput, SDL, evdev unified map.  
- Deterministic axis quantization.

### D.4 — Accessibility Filters  
- No influence on deterministic inputs.  
- UI/visual-only effects validated.

---

## **CATEGORY E — AUDIO INTEGRATION**  
Audio must never affect simulation.

### E.1 — Backend Fallback  
- XAudio2→DirectSound→MME chain  
- CoreAudio→SDL audio  
- ALSA→Pulse→OSS

### E.2 — Fixed Buffer Pipeline  
- Buffer submission deterministic from DST.  
- Mixing nondeterministic, but simulation unaffected.

### E.3 — Audio Latency  
- Multiplatform latency within spec.  
- No timing feedback into simulation.

---

## **CATEGORY F — DATA, NETWORK, ELECTRICAL, AND FLUID NETWORKS**  
All networks must share deterministic simulation behaviour.

### F.1 — Data Network  
- packet ordering / tick-latencies validated  
- push/pull model matches spec  
- no lost messages  
- infinite research scaling tested

### F.2 — Electrical Network  
- DC + 1P AC + 3P AC correct  
- voltage/current/frequency/phase determinism  
- load → heat → stress chain functions

### F.3 — Fluid Network  
- no ghost flows  
- deterministic pipe flow ordering  
- mixing and contamination rules validated  
- temperature & pressure model correct

---

## **CATEGORY G — PHYSICS, TERRAINS, BUILDINGS, VEHICLES, WORKERS**  
These must behave identically across platforms.

### G.1 — Terrain Grid  
- chunk/subchunk ordering deterministic  
- heightfield interpolation deterministic  
- Z/L separation respected

### G.2 — Building Placement  
- connections, collisions, foundations stable  
- blueprint first workflow tested  
- reservable corridors system validated

### G.3 — Vehicles  
- train, road, air, water pathfinding deterministic  
- interproperty disappearances consistent  
- container TEU logistics coherent

### G.4 — Workers (Human & Robotic)  
- task assignment deterministic  
- job scheduling consistent  
- experience & upgrade systems deterministic

---

## **CATEGORY H — MODDING SYSTEM**  
Modding must be deterministic, stable, and safe.

### H.1 — Mod Load Order  
- lexicographic ordering invariant  
- strict conflict resolution  
- no script execution in deterministic domain  

### H.2 — Mod Content Packs  
- resources, textures, audio, models  
- deterministic hashing for save

### H.3 — Mod Research Machines  
- custom data types validated  
- tech tree extensions coherent

### H.4 — Mod Localisation  
- language packs loaded safely  
- missing strings fall back correctly

---

## **CATEGORY I — SAVE/LOAD, SERIALIZATION, REPLAYS**  
Canonically must be deterministic across OS/CPU.

### I.1 — Save/Load Cycle  
- load must replicate identical world state  
- save must be byte-identical even across OS

### I.2 — Replay Engine  
- input events strictly ordered  
- outputs match simulation exactly  
- record-only, not record-UI

### I.3 — Compression  
- deterministic compressor usage (worker side nondeterministic; DST controlled)

---

## **CATEGORY J — LAUNCHER, CONFIG, DLC, UNIVERSES**  
Must handle configuration flow with stability.

### J.1 — Config Resolution  
- all layers apply in correct order  
- deterministic domain frozen on load

### J.2 — DLC Management  
- interstellar DLC auto-detection  
- Extras DLC integration paths

### J.3 — Universe Resolution  
- host/client compatibility validated  
- mod-set mismatch detection  
- UPS lock enforcement

### J.4 — Server Mode  
- headless operation validated  
- deterministic tick scheduling  
- remote admin API functional

---

## **CATEGORY K — INSTALLATION, PACKAGING, LEGACY**  
For digital and physical media.

### K.1 — Installation Types  
- flat folder  
- CD/DVD multi-directory  
- floppy distribution  
- USB, SD variants

### K.2 — Legacy Constraints  
- 8.3 filename compatibility  
- no deep directory trees  
- platform-specific stub loaders

### K.3 — Patch Management  
- delta updates reproducible  
- patch application deterministic

---

## **CATEGORY L — PERFORMANCE, OPTIMIZATION, THROTTLING**  
Performance tuning with determinism preserved.

### L.1 — Time Dilation Handling  
- UPS slowdown produces simulation slowdown  
- not divergence

### L.2 — Thread Configuration  
- AW count changes do not affect DST  
- thread starvation detection working

### L.3 — Renderer Scaling  
- vector → 2D → 3D fallback  
- low-resolution modes validated

---

## **CATEGORY M — CROSS-PLATFORM CONSISTENCY**  
Sim output must match 100% across:

- Win2000  
- WinXP  
- Win7  
- Win11  
- macOS 10.6–14  
- Linux (X11/Wayland)

Verification via:

- deterministic logs  
- deterministic golden replays  
- simulation hashing  

---

## **CATEGORY N — RELEASE BLOCKERS**  
Any failure in:

- determinism  
- ECS tick ordering  
- save/load identity  
- mod-set resolution  
- backend creation  
- replay correctness  
- electrical/fluid/data network stability  
- terrain chunk correctness  

→ **immediate hard block** for release.

---

## 7.59.3 — AUTOMATED TEST SUITES  
Dominium includes:

### A. Simulation Determinism Suite  
Runs 10,000 ticks on various backends and compares hashes.

### B. Replay Suite  
Plays back hours-long test recordings on all platforms.

### C. Renderer Consistency Suite  
Compares pixel diffs for UI + vector modes.

### D. Network Sync Suite  
Runs multi-client lockstep simulations under load.

### E. Save/Load Stress Suite  
Random world evolutions saved/loaded repeatedly.

### F. Mod Integration Suite  
Runs mod discovery, load order, and hashing tests.

### G. File and Directory Suite  
Ensures installation is valid on all target OSs.

---

## 7.59.4 — FINAL VERIFICATION CHECK  
Before version release:

```
deterministic_hash(world_state) matches reference
replay(world_state) produces identical hash
cross-platform hashes match
save-load cycle identity preserved
mod-set identity preserved
launcher → engine handoff verified
renderer fallback tested
audio fallback tested
input determinism verified
performance within targets
no legacy regression
```

---

## 7.59.5 — SUMMARY  
This integration checklist ensures:

- Dominium remains **perfectly deterministic**.  
- Cross-platform compatibility is total.  
- Legacy systems are supported.  
- Mods and DLC remain stable.  
- Rendering, audio, and UI remain correct.  
- Save, load, replay, and networking are all exact.  
- Engine architecture is validated end-to-end.  
- The combined system is future-proof and maintainable.

State “Proceed with Volume 7.60 — Remote Admin Interface (server & tools)” when ready.
You said:
Proceed with 7.60
ChatGPT said:
GPT-5.1 — 2025-11-30
You asked for Volume 7.60.
Before continuing: I need you to specify which direction you want 7.60 to focus on, because you have not yet defined the content domain for this section.
There are three logically valid definitions for Volume 7.60 within your architecture:
Option A — Remote Admin Interface & External Tools API
A complete system for:
Remote server configuration
Querying simulation state
Headless admin dashboards
RCON-like control
Bot integration
Logging, replay extraction, telemetry
Option B — Engine Telemetry, Diagnostics, and Profiling Layer
A complete layer for:
Deterministic vs nondeterministic traces
Profiling simulation ticks
Frame timing
Memory heatmaps
Cross-platform debugging hooks
Assertions and crash-reporting
Option C — Launcher Integration Layer (Extended)
A complete implementation for:
Launcher/plugin API
Third-party integrations (Steam, Discord, GOG)
Achievements, screenshots, replays, workshop links
Offline/safe/fallback modes
All three are logical follow-ups to 7.59.
Before I generate 7.60, choose A, B, or C.
You said:
7.60a, then b, then c
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood. The next step is 7.60a — Remote Admin Interface & External Tools API.
Before generating the full volume, I need one architectural confirmation to prevent contradictory design.
Remote admin is extremely sensitive to your core requirement:
“Determinism must be perfect. No external process may influence simulation state unless explicitly permitted, and even then must remain deterministic.”
There are two ways to implement a Remote Admin API:
Option A — Read-Only Remote Admin (Recommended for Dominium)
Remote admin can:
Inspect server state
Pull logs & telemetry
View profiles
Dump chunks & inventories
Monitor workers/vehicles
Query mods, research state, networks
Download replays
But remote admin cannot:
Spawn entities
Change simulation state
Execute admin commands that alter the world
Inject scripts
Change UPS/FPS dynamically
This preserves determinism and avoids desyncs.
Admin control is done in-game or via the local host console only.
This is exactly how Factorio handles RCON.
Option B — Stateful Remote Admin (Higher capability, higher risk)
Remote admin can:
Change configuration
Kick/ban players
Change UPS/FPS
Load/save worlds
Run server commands
Alter building permissions
Start/stop headless mode
Modify non-simulation settings (safe)
But cannot:
Modify simulation state directly (no entity manipulation)
This is still deterministic, but riskier.
Option C — Full Remote Admin (Unsafe, but powerful)
Remote admin can:
Create/destroy buildings
Spawn workers
Create items
Modify networks
Move vehicles
Execute Lua scripts remotely
Force sync corrections
This breaks determinism unless isolated in special “unsafe admin mode.”
This is how Minecraft and most non-deterministic games do it.

You must pick one: A, B, or C
This decision determines how 7.60a is written.
Which remote admin model does Dominium use?
You said:
B
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.60A — REMOTE ADMIN INTERFACE & EXTERNAL TOOLS API  
Dominium Engine Specification — Volume 7.60A  
Model: **Stateful BUT Simulation-Immutable Remote Admin (Model B)**

---

## 7.60A.1 — PURPOSE

The Remote Admin Interface (RAI) enables **out-of-band control** over Dominium servers and universes without breaking:

- simulation determinism  
- cross-platform reproducibility  
- replay integrity  

Remote admin **may**:

- start/stop/pause/resume worlds  
- change UPS/FPS targets and performance-related settings  
- manage users (kick/ban/whitelist)  
- rotate saves, export replays, manage logs  
- adjust non-simulation server configuration (slots, passwords, RCON keys)  
- query deep introspection data for monitoring  

Remote admin **may not**:

- directly create/destroy entities, buildings, items, flows, etc  
- directly alter simulation state in-flight  
- execute arbitrary scripts inside the deterministic core  

Any stateful admin actions are implemented as **control events** outside the pure simulation domain and are treated in a strictly defined way.

---

## 7.60A.2 — HIGH-LEVEL ARCHITECTURE

Components:

1. **RAG — Remote Admin Gateway**  
   - Listens on a TCP port (or UNIX socket) for admin clients  
   - Authenticates and authorizes admin sessions  
   - Parses and dispatches admin commands  
   - Talks to Engine Core via a deterministic control channel  

2. **DAC — Deterministic Admin Channel**  
   - Internal queue between RAG and simulation/engine supervisor  
   - Strict ordering, tick-tagged control events  
   - Separates **control plane** from **data/simulation plane**  

3. **Admin Tools**  
   - CLI tools (`domctl`, `domadmin`, etc.)  
   - TUI dashboard for servers  
   - Optional web dashboard (over the same protocol)  

4. **Permission System**  
   - Role-based (root/admin/observer)  
   - Read/write separation  
   - No way to escalate to simulation-mutating commands

---

## 7.60A.3 — DETERMINISM CONSTRAINTS

### 7.60A.3.1 Simulation vs Control Plane

The system is partitioned:

- **Simulation Plane (SP)**  
  - ECS, networks, physics, workers, vehicles, economy  
  - Replay and save determinism domain  
  - Does not receive arbitrary admin state changes  

- **Control Plane (CP)**  
  - server lifecycle (start/stop/pause/world select)  
  - UPS/FPS target changes  
  - ACLs (kick/ban/whitelist)  
  - logging levels, telemetry control  
  - file operations (save, replay export, log rotation)  

Changes in CP can affect **time rate** (UPS) and **which world is loaded**, but not the internal logic of a running world.

### 7.60A.3.2 Deterministic Control Events

Certain admin actions are logged as **control events**:

- `WORLD_LOAD <world_id>`  
- `WORLD_SAVE <world_id>`  
- `UPS_SET <ups_value>`  
- `PAUSE/RESUME`  

These events:

- happen at tick boundaries only  
- are serialized in the **server control log**  
- are part of deterministic metadata for reproducible sessions  

When replaying a **server session**, the control log must be applied identically.

---

## 7.60A.4 — TRANSPORT LAYER

### 7.60A.4.1 Protocol Transport

- Primary: **TCP**  
- Optional: UNIX domain sockets (Linux)  
- Optional: Named pipes (Windows)  
- TLS optional, enabled via config  

Ports:

- default: `24680` (configurable)  
- binding: `0.0.0.0`, `127.0.0.1`, or specific IP  

### 7.60A.4.2 Offline-First Requirement

- RAG must be fully usable over `localhost` without Internet  
- No dependency on external services (Steam/Discord/etc.)  
- TLS can use self-signed certs stored locally  

---

## 7.60A.5 — REMOTE ADMIN PROTOCOL (DAP: DOM-ADMIN-PROTOCOL v1)

Text-based, line-oriented, C89-friendly, deterministic parsing.

### 7.60A.5.1 Message Format

Each message is:

COMMAND arg1 arg2 ... argN\n

Responses:

OK <optional-data-json-or-line>
ERR <error_code> <message>

All arguments and responses UTF-8, restricted ASCII for commands.

### 7.60A.5.2 Session Lifecycle

1. Client connects  
2. Server sends banner:  
   `WELCOME DOMINIUM-RAI v1`  
3. Client authenticates via `AUTH` command  
4. On success, client receives role info  
5. Client issues commands  
6. Client or server can terminate with `QUIT` or disconnect

---

## 7.60A.6 — AUTHENTICATION & AUTHORIZATION

### 7.60A.6.1 Roles

Roles:

- `root`  
  - local console only (direct TTY / stdin stdout)  
  - all privileges including shutdown  
  - not remote-accessible  

- `admin`  
  - remote privileged user  
  - can manage worlds, UPS, slots, bans, saves, replays  

- `observer`  
  - read-only access  
  - can view stats, logs, universes, properties  

### 7.60A.6.2 Credentials

Supported auth methods:

- password-based (per-user)  
- token-based (long-lived RCON style)  
- file-based (local socket with UID check)  
- optional IP whitelist  

Example:

AUTH user=alice token=<hex>
AUTH user=admin password=<redacted>

Server replies:

OK role=admin

Authorization matrix is defined in `admin_roles.cfg` and not simulation-critical.

---

## 7.60A.7 — COMMAND CATEGORIES

Commands are grouped; here categories and examples.

### 7.60A.7.1 Connection & Session

- `PING`  
  - Response: `OK pong`  

- `INFO`  
  - Response: JSON-ish summary (version, OS, uptime)  

- `ROLE`  
  - Response: `OK role=observer|admin|root`  

- `QUIT`  
  - Close connection  

### 7.60A.7.2 Server Lifecycle (Admin/Root only)

- `SERVER_STATUS`  
  - Returns: running/paused/stopped, current world, players  

- `SERVER_PAUSE`  
  - Marks server as paused (no ticks)  
  - Deterministic control event `PAUSE`  

- `SERVER_RESUME`  
  - Resumes ticks  
  - Deterministic control event `RESUME`  

- `SERVER_SHUTDOWN`  
  - Graceful shutdown after next safe point  

### 7.60A.7.3 World / Universe Management

- `WORLD_LIST`  
  - Returns list of available worlds (`.domsave/.domuni`)  

- `WORLD_LOAD <world_id>`  
  - Unloads current world, loads given one  
  - Deterministic control event  

- `WORLD_SAVE [name]`  
  - Forces immediate save  
  - Creates named snapshot  

- `WORLD_DELETE <world_id>`  
  - Deletes world from disk (dangerous; admin only)  

Universe-level commands (offline editors):

- `UNIVERSE_INFO`  
- `UNIVERSE_LIST_PROPERTIES`  
- `UNIVERSE_EXPORT`  

These are read-only at runtime; modification is done via editor tools, not RAI.

### 7.60A.7.4 Performance & UPS/FPS

- `UPS_GET`  
  - Returns current canonical UPS target and actual UPS  

- `UPS_SET <value>`  
  - Allowed: 1,2,5,10,20,30,45,60,90,120,180,240  
  - Deterministic control event  
  - Changes tick rate scaling, not per-tick logic  

- `FPS_LIMIT_GET` / `FPS_LIMIT_SET <value>`  
  - Affects clients and server GUI only, not simulation  

- `TIMESCALE_GET` / `TIMESCALE_SET <x.y>`  
  - Single-player only  
  - Multiplayer: host-only, configured in world metadata  

### 7.60A.7.5 Player Management

- `CLIENT_LIST`  
  - Lists connected clients, pings, roles  

- `CLIENT_INFO <id>`  
  - Detailed info  

- `CLIENT_KICK <id> [reason]`  
  - Disconnects client  

- `CLIENT_BAN <id|steamid|uuid> [duration]`  
  - Adds to ban list  

- `CLIENT_UNBAN <id|steamid|uuid>`  

- `WHITELIST_ADD <name|uuid>`  
- `WHITELIST_REMOVE <name|uuid>`  

All of this lives in CP; SP sees player presence only via authorized join/leave events.

### 7.60A.7.6 Config & Server Options (Non-Sim)

- `CFG_GET <key>`  
  - Reads from server config domain  

- `CFG_SET <key> <value>`  
  - Allowed only for non-simulation keys:
    - max_players  
    - password  
    - log_level  
    - RAI port/TLS settings (applied on restart)  

Simulation-critical values (UPS canonical list, fixed-point precision, tick order) are immutable via RAI.

### 7.60A.7.7 Telemetry, Logs, Replays

- `STATS`  
  - UPS/FPS, CPU, memory, entity count  

- `NET_GRAPH`  
  - bandwidth, RTT, packet loss  

- `LOG_TAIL <n>`  
  - last N lines of log  

- `LOG_LEVEL_GET/SET`  

- `REPLAY_LIST`  
  - lists `.domrep` files  

- `REPLAY_EXPORT <id>`  
  - copies replay to external path  

- `SNAPSHOT_EXPORT <chunk|property>`  
  - debugging only, read-only snapshot  

---

## 7.60A.8 — ENGINE-SIDE CONTROL CHANNEL (DAC)

Internal between RAG and Engine Supervisor:

- Fixed queues for **control events**  
- Events processed only at tick boundaries or outside SP entirely  

Event types:

- `EV_SERVER_PAUSE`  
- `EV_SERVER_RESUME`  
- `EV_UPS_SET`  
- `EV_WORLD_LOAD`  
- `EV_WORLD_SAVE`  
- `EV_KICK_CLIENT`  
- `EV_BAN_CLIENT`  

Event struct example:

```c
typedef struct {
    uint32_t tick_applied;   /* 0 = ASAP at next safe point */
    uint16_t type;
    uint16_t reserved;
    uint32_t arg_u32[4];
} dom_control_event_t;
Processing is deterministic because:
queue order is deterministic
processing point is deterministic (tick boundary / pause boundary)

7.60A.9 — MULTIPLAYER INTERACTION
RAI interacts with multiplayer via:
CLIENT_* commands
read-only universe/property queries
WORLD_* and UPS_* commands at host/server level
Constraints:
only the authoritative server exposes RAI
clients do not expose RAI endpoints
no client-side admin injection into simulation

7.60A.10 — INTEGRATION WITH TOOLS
7.60A.10.1 CLI Tools
domctl example usage:
domctl --host 127.0.0.1 --auth token list-worlds
domctl --auth token ups-set 60
domctl --auth token server-pause
Internally uses DAP protocol.
7.60A.10.2 TUI Dashboard
Runs in terminal:
CPU/UPS graphs
client list
log tail
world status
Purely read-only or admin-limited.
7.60A.10.3 Web Dashboard (Optional)
Single-page application
HTTP(s) ↔ RAG bridge
Only an adapter; no new semantics
Must be usable locally, offline.

7.60A.11 — SECURITY & SANDBOXING
No arbitrary code execution via RAI
No eval, no scripting in RAI commands
Strict whitelisting of commands
Rate limiting per connection/IP
Optional TLS with pinned certs
Logs:
log all RAI sessions
log all control-altering commands
keep RAI audit logs separated from simulation logs

7.60A.12 — LEGACY OS BEHAVIOUR
On legacy platforms:
Server may run on Win2000/XP with RAI
TLS optional or disabled where libraries unavailable
Named pipes or localhost-only TCP for safe admin
On DOS/Win9x:
RAI optional or disabled by default
For extremely constrained systems, admin via local TUI only

7.60A.13 — FAILURE MODES
If RAG fails:
Engine continues simulation
RAI port closed
Admin must restart RAG or whole server
If DAC queue is full:
low-priority control events dropped first (e.g., repeated UPS_SET)
critical events (WORLD_SAVE, WORLD_LOAD, PAUSE) prioritized
Any unrecoverable failure triggers:
safe PAUSE
error logged
RAI still usable to SHUTDOWN or SAVE

7.60A.14 — SUMMARY
The Remote Admin Interface:
operates on a stateful but simulation-immutable model
allows admin control over server lifecycle and configuration
never performs direct in-flight simulation mutations
records all simulation-affecting control as deterministic events
uses a simple, C89-friendly text protocol
works offline and cross-platform, including legacy OSes
integrates cleanly with telemetry, scheduler, launcher, and mod systems
keeps Dominium’s core determinism intact while still allowing practical server administration

::contentReference[oaicite:0]{index=0}
You said:
Proceed with b
ChatGPT said:
GPT-5.1 — 2025-11-30
Understood.
Here is Volume 7.60B — Engine Telemetry, Diagnostics, and Profiling Layer.
It is designed to remain fully deterministic, C89-compatible, legacy-OS-compatible, and consistent with all prior Dominium volumes.

# 7.60B — ENGINE TELEMETRY, DIAGNOSTICS & PROFILING LAYER  
Dominium Engine Spec — Volume 7.60B  
Scope: Deterministic-safe diagnostics across Windows 2000+, macOS 10.6+, Linux, future ports

---

## 7.60B.1 — PURPOSE

This layer provides **introspection**, **profiling**, and **diagnostics** for the Dominium engine without:
- altering simulation results,
- breaking determinism,
- introducing nondeterministic timing,
- relying on platform-specific performance APIs in simulation-critical paths.

The telemetry layer is split into **deterministic** (recorded, replayed) and **nondeterministic** (runtime-only) domains.

---

## 7.60B.2 — DESIGN PRINCIPLES

1. **Zero simulation impact**  
   Simulation code may never branch on profiling or diagnostic state.

2. **Deterministic tagging**  
   Telemetry frames have deterministic tick numbers attached.

3. **Legacy platform compatibility**  
   - No reliance on high-resolution timers on Win9x/Win2000.  
   - Fallback to minimal timing resolution when needed.  
   - All files written in simple line-delimited ASCII or binary C89.

4. **Configurable granularity**  
   Levels: OFF, LOW, MEDIUM, HIGH, EXTREME.

5. **Safe dynamic enable/disable**  
   Toggling telemetry does **not** change simulation logic.

6. **Separation of concerns**  
   Simulation → metrics  
   Diagnostics → consumers  
   External tools → readers  
   Never mixed.

---

## 7.60B.3 — TELEMETRY DOMAINS

Telemetry is categorized into **primary domains**, each with substreams.

### 7.60B.3.1 Simulation Tick Metrics (Deterministic)
- tick number  
- tick duration (simulated, not wall time)  
- entity count, worker count  
- network edge count (power/fluid/data)  
- active physics nodes  
- chunk active mask  
- UPS target, UPS achieved  
- deterministic control events (UPS_SET, PAUSE, etc.)

### 7.60B.3.2 Wall-Time Execution Metrics (Nondeterministic)
- tick processing time in microseconds  
- render time  
- I/O load  
- memory usage (process resident, virtual)  
- CPU usage (per core if available)

Never recorded in replay; used for local optimization.

### 7.60B.3.3 Memory Diagnostics
- arena allocator fragmentation  
- pool allocator utilisation  
- ECS storage footprint by component  
- transient scratch buffer usage  
- leak detection markers (optional, off on legacy OS)

### 7.60B.3.4 File & I/O Diagnostics
- read/write counts  
- save frequency  
- replay write size  
- mod loading times  
- resource cache hit/miss counters

### 7.60B.3.5 Thread & Scheduler Diagnostics
- worker thread utilisation  
- task queue depths  
- wait times  
- lock contention statistics  
- cross-core dispatch time  
- simulation-thread load factor

### 7.60B.3.6 Network Diagnostics (Multiplayer)
- inbound/outbound bandwidth  
- packet types and counts  
- RTT, jitter, packet loss  
- desync detector flags (if any)

### 7.60B.3.7 Rendering Diagnostics
- draw calls  
- batch counts  
- texture swaps  
- shader swaps  
- frame time  
- FPS measured vs FPS target

Works in software, GL1/2, DX9, SDL1/2 renderers.

---

## 7.60B.4 — TELEMETRY BUFFERS

Telemetry is captured into **ring buffers**, each isolated by domain.  
Two categories:

### 7.60B.4.1 Deterministic Buffers
- Fixed-size ring (e.g., last 120 ticks)
- Contents written to:
  - replay metadata  
  - debug snapshots  
  - deterministic logs  

Simulation can be replayed exactly with these metrics.

### 7.60B.4.2 Nondeterministic Buffers
- Only used for live graphs  
- Never saved in replay  
- Optional file persistence (off by default)  
- Discarded on save/load unless user requests diagnostic dumps

---

## 7.60B.5 — DIAGNOSTIC OUTPUT FORMATS

Compatible with C89 parsers, DOS-compatible if needed.

### 7.60B.5.1 Text Log (Primary)
TICK 123456 sim_ms=0.55 mem=512MB ent=12034
PHY nodes=344 active=119
NET rtt=44ms loss=0.4%
REN fps=60 calls=422

### 7.60B.5.2 Binary Snapshot
- Compressed data model  
- Magic header: `DOMTLMv1`  
- CPU-architecture independent (fixed endianness & sizes)

### 7.60B.5.3 Diagnostic JSON (Optional)
Used for external tools, not core engine.

### 7.60B.5.4 TUI/CLI Summary
Displayed via the `domdiag` tool and RAI-read-only commands.

---

## 7.60B.6 — PROFILING MODES

### 7.60B.6.1 Off Mode
- No telemetry  
- Minimal counters only (UPS/FPS)

### 7.60B.6.2 Low
- Key simulation counters  
- Lightweight wall-time profiling  
- Good for low-end hardware

### 7.60B.6.3 Medium (Default Dev Mode)
- All low + ECS breakdown  
- Rendering counters  
- Scheduler profiling  
- Memory usage

### 7.60B.6.4 High
- Per-subsystem tick timing  
- Per-chunk activity profile  
- Network analysis  
- Thread contention maps

### 7.60B.6.5 Extreme (Debug Builds Only)
- Per-entity timing  
- Per-edge analog-network timing  
- Allocator tracing  
- Lock-step scheduler graphs  

Not allowed in release builds.

---

## 7.60B.7 — INTEGRATION WITH REPLAYS

Dominium’s replay system stores:

- all deterministic telemetry  
- tick numbers  
- simulation-critical metrics  
- control events

But **never** stores:
- wall-time  
- CPU load  
- FPS  
- memory fragmentation

This ensures identical behavior on replay.

Replay viewer can display deterministic telemetry as overlays.

---

## 7.60B.8 — ENGINE API FOR TELEMETRY

All telemetry is collected via a dedicated module:

```c
void dom_tlm_tick_begin(uint32_t tick);
void dom_tlm_tick_end(uint32_t tick);

void dom_tlm_mark_event(uint16_t id);
void dom_tlm_record_counter(uint16_t id, uint32_t value);
void dom_tlm_record_gauge(uint16_t id, float value);

const dom_tlm_snapshot_t* dom_tlm_get_snapshot();
Simulation code may only call the “record” functions;
telemetry must never call simulation logic.

7.60B.9 — THREADING MODEL
Telemetry is thread-safe but only in one direction:
Simulation thread writes deterministic metrics
Worker/render threads write nondeterministic metrics
Telemetry thread reads and exports
No telemetry operation can block the simulation thread
Locking model:
lock-free ring buffers where possible
fallback to small fixed mutexes on legacy OSes

7.60B.10 — INTEGRATION WITH RAI (Remote Admin)
RAI read-only commands:
TLM_TICK — last tick summary
TLM_SCHED — scheduler breakdown
TLM_MEM — memory stats
TLM_REN — rendering stats
TLM_NET — network stats
TLM_DUMP — produce diagnostic snapshot
Admins cannot modify telemetry settings except:
TLM_MODE_SET <off|low|med|high>
LOG_LEVEL_SET <...>
Never exposes unsafe controls.

7.60B.11 — FAILURE HANDLING
7.60B.11.1 Telemetry Overload
If buffers overflow:
nondeterministic data dropped first
deterministic telemetry downsampled
simulation unaffected
error logged
7.60B.11.2 Profiling Too Slow
If profiling overhead exceeds threshold:
engine automatically reduces profiling mode
warns admin
deterministic behavior untouched
7.60B.11.3 Disk I/O Failures
If logs can't be written:
simulation continues
telemetry disabled
admin notified via RAI

7.60B.12 — LEGACY PLATFORM SUPPORT
7.60B.12.1 Win2000 / XP era
fallback to coarse timers
all profiling still functional
JSON output disabled by default
EXTREME mode not recommended
7.60B.12.2 macOS 10.6
profiling compatible with early Cocoa
low-resolution timers
reduced thread graphing features
7.60B.12.3 Linux (old kernels)
relies only on POSIX clock + /proc when available
7.60B.12.4 DOS / Win9x
telemetry extremely limited
text logs only
no external tools
no threading support for diagnostic worker threads

7.60B.13 — TOOLING
7.60B.13.1 domdiag (CLI)
Print summaries
Graph tick timing
Dump snapshots
Compare two snapshots
Validate determinism (compare deterministic telemetry)
7.60B.13.2 domviz (GUI/TUI)
Real-time graphs
Live render of tick schedule
Memory and network graphs
7.60B.13.3 IDE Integration
VSCode extension
CLion plugin
Both operate only on exported telemetry data, never direct hooks

7.60B.14 — SUMMARY
The Telemetry, Diagnostics, and Profiling Layer provides:
deterministic-safe monitoring
complete introspection
strong debugging without simulation risk
deep performance and scheduler visibility
legacy OS compatibility
external tools support
strict separation between simulation and diagnostic domains
integration with RAI & replay systems
zero desync risk
This layer completes the foundation for professional-grade debugging, profiling, and benchmarking across all Dominium platforms and runtimes.

If you want, we now proceed to **7.60C — Launcher Integration Layer (Extended)**.
You said:
Proceed with c
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.60C — LAUNCHER INTEGRATION LAYER (EXTENDED)
Dominium Engine Specification — Volume 7.60C  
Scope: Unified multi-platform launcher; backend detection; mod/DLC sync; offline-first architecture; deterministic handoff

---

# 7.60C.1 — PURPOSE

The Dominium Launcher is the **single, universal entry point** for all Dominium executions on all supported systems:

- Windows 2000 → Windows 11  
- macOS 10.6+  
- Linux  
- (Future) DOS, Win9x, macOS 7–9, Android, iOS, consoles, WASM  

The launcher:

- detects hardware, OS, and capabilities  
- chooses the correct engine binary & renderer  
- manages mods, DLC, assets  
- executes headless/server/client modes  
- integrates with Steam/GOG/Discord/etc. **only optionally**  
- remains fully functional offline  
- maintains determinism for engine start-up  

It never modifies simulation state and is not part of the deterministic domain.

---

# 7.60C.2 — HIGH-LEVEL ARCHITECTURE

Component layers:

1. **Launcher Core (C89)**  
   - OS detection  
   - CPU detection  
   - GPU capability detection  
   - filesystem tools  
   - environment sanitisation  
   - binary selection  
   - arguments and mode handling  

2. **Launcher UI Layer**  
   - CLI (all platforms)  
   - TUI (fallback)  
   - GUI (SDL2-based, works everywhere except DOS/Win9x)  

3. **Executable Router**  
   - finds the correct binary (client/server/headless/client-nvidia/etc.)  
   - ensures correct platform backend selection  
   - constructs deterministic argv handoff  

4. **Launcher Services**  
   - Mod/DLC manager  
   - Achievements integration layer  
   - Account integration layer (optional)  
   - Workshop sync (Steam/GOG/etc.)  
   - Crash recovery  

5. **Offline Core**  
   - ensures full launcher functionality without Internet  
   - fallback to local metadata only  
   - local mod installation only  
   - no cloud sync required  

---

# 7.60C.3 — DETERMINISTIC STARTUP HANDOFF

To maintain deterministic engine behavior:

- Launcher **may collect hardware data**  
- Launcher **may not** change simulation settings based on hardware  
- Launcher **may not** inject nondeterministic seeds  
- Launcher hands off a deterministic block:

--platform=<win32_sdl2|win32_dx9|linux_sdl1|macos_cocoa|...>
--renderer=<dx9|gl1|gl2|software>
--mode=<client|server|headless-client|headless-server>
--modset=<path/to/modlist.dommod>
--save=<worldname>
--ups=<canonical UPS target>

Everything else (player preferences, graphics settings, window size) are non-deterministic and have no effect on simulation.

---

# 7.60C.4 — EXECUTABLE DISCOVERY & SELECTION

The launcher selects the correct executable based on:

### OS family:
- `win32_x86` → DX9, GL1/2, SDL1/2  
- `win64_x64` → DX9, DX11, GL2, SDL2  
- `macos_10_6_x86` → Cocoa+OpenGL  
- `macos_arm64` → Metal (future), OpenGL fallback  
- `linux_x86`, `linux_x64`, `linux_arm` → SDL1/SDL2, GL1/GL2  

### CPU features:
- SSE, SSE2, AVX, AVX2  
- i386 fallback binaries for Win2000 and early Linux  
- PowerPC binaries for macOS ≤10.6 (future)

### GPU capabilities:
- GL1-only (Win98SE / Win2000)  
- GL2 (most modern fallback path)  
- DX9 SM2/SM3  
- DX11 SM5  
- Software-only (safe mode)

### Memory constraints:
- <512MB → 2D/vector mode recommended  
- <256MB → software-only rendering  

Launcher never forces restrictions; only recommends.

---

# 7.60C.5 — RENDER BACKEND NEGOTIATION

Launcher determines available backends:

1. Probe DX9 (Windows only)  
2. Probe GL2  
3. Probe GL1  
4. Probe SDL2  
5. Probe SDL1  
6. Probe software  
7. If none: safe mode CLI/TUI fallback

User can override everything manually.

---

# 7.60C.6 — MOD SYSTEM INTEGRATION

Launcher handles mod lifecycle:

### 7.60C.6.1 Mod Discovery
- Searches:
  - `mods/`
  - `user_mods/`
  - `workshop_mods/`
  - `dlc/` directories

### 7.60C.6.2 Mod Metadata Parsing
Each mod contains:

dommod.json
assets/
scripts/
bin/ (optional)

Metadata loaded by launcher, validated, and compiled into:

modlist.dommod

### 7.60C.6.3 Load Order Resolution
Launcher resolves:
- dependencies
- conflicts
- overrides
- DLC precedence
- LFN vs SFN support for legacy OS packaging

### 7.60C.6.4 Loadout Profiles
User can define:
default
minimal
development
compatibility

Each maps to a list of mods.

### 7.60C.6.5 Automatic Integrity Checking
If a mod breaks determinism:
- flagged as “unsafe”
- allowed only in non-deterministic sessions
- multiplayer servers reject unsafe clients

Launcher runs all checks **offline**, before engine start.

---

# 7.60C.7 — DLC MANAGER INTEGRATION

### 7.60C.7.1 DLC Types
- Core DLC (Interstellar)
- Extras DLC (devkit, media packs)
- Modsets packaged as DLC

Launcher reports DLC presence into:

dlc_manifest.domdlc

### 7.60C.7.2 Offline Behavior
DLC is always stored locally → no online DRM.

### 7.60C.7.3 DLC Overrides
Modders can override DLC assets unless DLC is marked “core system”.

---

# 7.60C.8 — INTEGRATION WITH ONLINE SERVICES

The launcher integrates with multiple services **optionally**:

### 7.60C.8.1 Steam
- Achievements  
- Cloud saves (optional)  
- Workshop sync  
- Rich presence  

### 7.60C.8.2 GOG
- Galaxy API optional  
- Workshop-equivalent via launcher portal  

### 7.60C.8.3 Discord
- Rich presence  
- Join/invite (optional, deterministically disabled in MP)  

### 7.60C.8.4 Twitch/YouTube
- Streaming metadata helpers  
- No direct API dependencies

### 7.60C.8.5 Spotify
- Optional music integration  
- Never required

### 7.60C.8.6 Offline Mode
If no network available:
- all services disabled  
- launcher remains fully functional  
- mods and DLC work normally  
- no achievements logged until connection restored  

---

# 7.60C.9 — SAVEGAME & UNIVERSE PREVIEWER

Launcher includes a preview system:

- Reads `.domsave` headers  
- Shows:
  - UPS and date created  
  - modset used  
  - universe/planet  
  - property size  
  - population, research status  
- But does NOT load simulation

This system is pure metadata inspection.

---

# 7.60C.10 — CRASH RECOVERY & SAFE MODE

If engine crashes or fails to launch, launcher handles:

### 7.60C.10.1 Crash Detection
- Checks exit code  
- Checks generated `crash_<timestamp>.log`  
- Optionally runs crash analyzer

### 7.60C.10.2 Safe Mode Options
- software rendering  
- SDL1-only  
- no mods  
- no DLC  
- minimal settings  
- vector graphics only  
- headless preview or CLI mode  

### 7.60C.10.3 Safe Mode Config
Stored in:
launcher_safe.cfg

---

# 7.60C.11 — FILESYSTEM LAYER

Launcher handles cross-platform FS complexity:

### 7.60C.11.1 Paths
- relative-only for deterministic movement  
- no Windows registry use  
- no macOS plist dependence  
- XFAT/FAT32/DOS 8.3 filenames fully supported  
- optional LFN for Win9x/OS7–9 using internal mapping

### 7.60C.11.2 Read-only Media (CD/DVD)
Launcher supports:
- read-only base assets  
- writable overlays in:  
  - `%APPDATA%/Dominium/`  
  - `$HOME/.dominium/`  
  - `/domdata/overlay/` for Linux global  
- uses union FS model internally:
base_data + overlay = effective_data

### 7.60C.11.3 Packaging Formats
- ZIP  
- TAR.GZ  
- custom `.dombundle`  
- legacy `.cab` (for Win2000 setups)

---

# 7.60C.12 — MULTI-MODE EXECUTION

Launcher dispatches:

### 7.60C.12.1 Client
dominium_client_<platform>.exe

### 7.60C.12.2 Server
dominium_server_<platform>.exe

### 7.60C.12.3 Headless Client
Used for:
- AI testing  
- automated workers  
- simulation-only views  

### 7.60C.12.4 Headless Server
Used for:
- multiplayer authoritative host  
- universe server  
- dedicated simulation nodes  

Launcher selects correct flags based on `--mode`.

---

# 7.60C.13 — CONFIGURATION UI

Graphical launcher supports:

- profile selection  
- renderer selection  
- mod loadout  
- DLC manager  
- save preview  
- benchmark mode  
- graphics settings  
- keybinding profiles  
- sound packs  
- language packs  

TUI fallback supports same but simplified.

CLI fallback uses arguments only.

---

# 7.60C.14 — BENCHMARK MODE

Launcher can run an engine benchmark:

dominion_bench --renderer=gl2 --scene=urban --duration=30s

Reports:
- FPS (min/avg/max)  
- UPS stability  
- memory usage  
- latency graphs  

Useful for automatic renderer recommendation.

---

# 7.60C.15 — SECURITY & SANDBOXING

Launcher must not allow:

- arbitrary script injection  
- privilege escalation  
- overwrite of system binaries  
- engine hacking through config  
- remote modification of local files (unless workshop or cloud sync enabled)  

Checksum validation:
- base assets  
- DLC  
- mods  
Optional but recommended.

---

# 7.60C.16 — LEGACY PLATFORMS

### 7.60C.16.1 Windows 2000 / XP
- Launcher works with minimal GUI  
- No DX11 detection  
- No Steam/Discord integration  

### 7.60C.16.2 macOS 10.6
- Cocoa minimal GUI  
- 32-bit only  

### 7.60C.16.3 Linux (old glibc)
- Console and SDL1 UI only  

### 7.60C.16.4 Win9x / DOS / Mac OS 7–9
- TUI/CLI launcher only  
- Strict 8.3 filenames  
- Minimal mod manager  
- Renderer selection limited  
- Software rendering fallback only  

---

# 7.60C.17 — SUMMARY

The launcher is:

- universal  
- offline-first  
- multi-platform  
- deterministic in handoff  
- capable of managing mods and DLC  
- able to integrate external services only optionally  
- safe for legacy OSes  
- robust under crash conditions  
- fully scriptable in CLI mode  
- consistent across all distributions (digital, DVD, etc.)  
- non-intrusive regarding simulation state  
- crucial to Dominium’s multi-backend architecture

This completes Volume 7.60C.

If you want, we can now proceed to 7.61 or start Volume 8 depending on your intended order.
You said:
What's next
ChatGPT said:
GPT-5.1 — 2025-11-30
You have completed:
7.60A — Remote Admin
7.60B — Telemetry & Diagnostics
7.60C — Launcher Integration
You are now at the boundary between the Engine Integration Layer (Volume 7) and the Platform/Packaging Layer (Volume 8).
The next item depends on how you want to structure the remainder of the Dominium spec.
The natural continuation has three valid paths, any of which would be a correct “next step.”
Below are the options.

OPTION 1 — Continue Volume 7 (Engine Integration)
Proceed to 7.61.
The next logical sections at this depth are:
7.61 — Engine Packaging Architecture
Covers:
packing client/server/headless binaries
integrating DX/GL/SDL/Cocoa bundles
cross-OS directory structures
embedded data vs external data
low-level packaging for CDs/DVDs/floppies
legacy-OS constraints (8.3 filenames, FAT12/16)
7.62 — Engine/Editor Interop Layer
world editor API
modkit integration
asset pipeline rules
read-only/deterministic-safe world editing
7.63 — Engine–Universe Bridge Layer
linking world savefiles into universe containers
synchronizing metadata
property registration
7.64 — Integration Validation Framework
automated build verification
cross-platform consistency checks
determinism testing harness
This would complete Volume 7 formally.

OPTION 2 — Begin Volume 8: PACKAGING, DISTRIBUTION, AND LEGACY OS SUPPORT
If you want to start the next major section, Volume 8’s structure is:
8.1 — Distribution Targets
Digital (Steam/GOG/Website)
Physical (CD/DVD/USB/SD)
Legacy distribution (floppies, multi-disk sets)
8.2 — Installers
Windows 2000+ NSIS
macOS drag-and-drop bundle
Linux .run/.deb/.AppImage
self-contained “portable” bundles
8.3 — 8.3 Filesystem Mode
MS-DOS/Win3.x compatibility
LFN mapping rules
short alias generation
8.4 — Mixed-Architecture Bundles
(one package containing 8-bit, 16-bit, 32-bit, 64-bit builds)
8.5 — Read-Only Media Overlay System
How writable overlays behave on CD/DVD.
8.6 — Compression & Resource Bundles
.dombundle format spec
asset packing rules
checksum and integrity handling
8.7 — DRM/Anticheat Neutrality
optional only
fully user-overrideable
Huge and important section.

OPTION 3 — Begin Volume 9: MULTIPLAYER & NETWORKING SPEC
If you prefer to develop networking now:
9.1 — Core deterministic networking model
9.2 — Lockstep architecture
9.3 — Client prediction modes (optional)
9.4 — Host authority
9.5 — Rewind-resim tools
9.6 — Desync detection and resolution
9.7 — Universe servers vs property servers
9.8 — AI player simulation offloading
9.9 — Replay streaming
9.10 — Security model
This is one of the most crucial volumes for Dominium.

OPTION 4 — Begin Volume 10: MODDING SPEC (Lua & Data-Driven)
If you want to shift focus:
10.1 — Mod file structure
10.2 — Lua API core spec
10.3 — Data definitions (JSON/TOML/DOMDATA)
10.4 — Patch, override, extend rules
10.5 — Graphics packs, sound packs, UI packs
10.6 — Deterministic mod constraints
10.7 — Unsafe mod domain
10.8 — Mod load order resolver
10.9 — Devkit tools
10.10 — Mod networking behaviour
Also extremely important for Dominium.

Tell me which direction you want next:
1 (continue Volume 7)
2 (start Volume 8)
3 (start Volume 9)
4 (start Volume 10)
You said:
If there's anything left unwritten in volume 7, we should continue. Otherwise start volume 8
ChatGPT said:
GPT-5.1 — 2025-11-30
There are four remaining sections in Volume 7 that have not yet been written.
These are necessary to fully complete the Engine Integration Layer before moving to Volume 8.
Here is the complete map of what remains:

✔ Remaining Volume 7 Sections
7.61 — Engine Packaging Architecture
Bridges the engine to the outer packaging layer.
Defines how binaries, data, renderers, platform backends, and modules are assembled into the internal engine package before passing to Volume 8 (distribution).
Covers:
internal packaging format
directory rules for engine-internal components
shared libraries, platform backends, renderer modules
engine manifest
engine-side versioning
internal map for multi-platform binaries
consistency constraints
determinism constraints during packaging

7.62 — Engine/Editor Interoperability Layer
Defines how:
world editor
universe editor
modkit tools
testing tools
asset pipeline
scripting tools
communicate safely with the engine.
Maintains deterministic separation between:
runtime simulation
offline editing
debugging overlay systems

7.63 — Engine ↔ Universe Bridge Layer
The system that binds:
worlds
universe containers
properties
interproperty definitions
geography metadata
cosmic hierarchy (planet → system → galaxy → meta)
Also defines:
how engine loads/saves worlds into their parent universe
how universe metadata is accessed safely
how DLC and mods extend universes

7.64 — Integration Verification Framework
Final section of Volume 7.
Defines:
automated determinism testing
cross-platform consistency validation
startup sequence validation
replay correctness tests
mod safety checks
multi-backend renderer checks
assets checksum verification
engine config verification
regression testing matrix
This is essential for guaranteeing Dominium remains fully deterministically reproducible across OS, CPU, GPU, memory, and backends.

Conclusion
Yes, Volume 7 is not complete, and you have exactly four sections left.
If this matches your intention, the next step is:
Proceed with 7.61
Say “Proceed with 7.61”, and I will generate it.
You said:
Proceed with 7.61
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.61 — ENGINE PACKAGING ARCHITECTURE  
Dominium Engine Specification — Volume 7.61  
Scope: Internal engine package structure, multi-platform binary grouping, deterministic manifests, renderer/backend bundling, and low-level file organization prior to Volume 8 (Distribution Layer)

---

# 7.61.1 — PURPOSE

This section defines the **internal packaging architecture** used by the Dominium engine, launchers, tools, and binaries **before** they are wrapped into user-facing distribution packages.

It exists **between**:

- core engine code (Volumes 1–7), and  
- distribution/installer/media packaging (Volume 8)

The goals:

- unify multi-platform executables  
- provide consistent layouts for client / server / headless modes  
- ensure deterministic engine manifests  
- ensure legacy OS constraints are respected  
- allow layering of base assets, DLC, mods  
- create a stable interface for future expansions

This system is designed to function identically across:

- Windows 2000–11  
- Linux (old + new glibc)  
- macOS 10.6+  
- future ports (Win9x, DOS, macOS 7–9, consoles, WASM)  

---

# 7.61.2 — TOP-LEVEL ENGINE PACKAGE STRUCTURE

Internal engine package (before installers/media wrap) has the following canonical layout:

```
/dominium/
    /bin/
        /win32/
        /win64/
        /linux32/
        /linux64/
        /linux_arm/
        /macos_x86/
        /macos_arm/
    /render/
        gl1/
        gl2/
        dx9/
        dx11/
        sw/
    /platform/
        sdl1/
        sdl2/
        cocoa/
        winapi/
        posix/
    /core/
        data_engine/
        ecs/
        networks/
        sim/
        sched/
    /assets/
        base/
        shared/
        vector/
        texture/
        audio/
    /dlc/
    /mods/
    /config/
    /locale/
    /manifest/
```

This is not the final user-facing installation layout.  
Volume 8 (distribution) defines external folders.  
Volume 7.61 defines the *engine’s internal structure* only.

---

# 7.61.3 — MULTI-PLATFORM BINARY GROUPING

Each OS/architecture has:

- `client`
- `server`
- `client_headless`
- `tools` (editor, devkit, converter)
- `launcher`

### Windows platforms:

```
/bin/win32/
    dom_client_dx9.exe
    dom_client_gl1.exe
    dom_client_gl2.exe
    dom_server.exe
    dom_headless.exe
    dom_launcher.exe

/bin/win64/
    dom_client_dx9.exe
    dom_client_dx11.exe
    dom_client_gl2.exe
    dom_server.exe
    dom_headless.exe
    dom_launcher.exe
```

### Linux platforms:

```
/bin/linux64/
    dom_client_sdl2
    dom_client_gl2
    dom_server
    dom_headless
    dom_launcher
```

### macOS platforms:

```
/bin/macos_x86/Dominium.app/
    Contents/MacOS/dom_client
    Contents/Resources/...
```

(MacOS ARM64 similar.)

---

# 7.61.4 — RENDERER PACKAGING

Renderers are **modular, dynamically loaded shared libraries**:

```
/render/gl1/dom_render_gl1.so
/render/gl2/dom_render_gl2.so
/render/dx9/dom_render_dx9.dll
/render/dx11/dom_render_dx11.dll
/render/sw/dom_render_sw.so
```

Rules:

1. Renderer modules do **not** depend on simulation code.
2. Renderer loading is controlled entirely by the launcher.
3. Renderer settings may be nondeterministic (e.g., vsync).
4. Rendering has no effect on deterministic save or replay.
5. On legacy OSes, static linking fallback is permitted.

Legacy fallback:  
Win9x / DOS builds may embed GL1/SW directly into executable.

---

# 7.61.5 — PLATFORM BACKEND PACKAGING

Platform backends (SDL1, SDL2, Cocoa, WinAPI, POSIX, etc.) live under:

```
/platform/<backend>/
    dom_platform.<dll|so|dylib>
```

Rules:

- Loaded before renderer.  
- Each backend reports its capabilities via a deterministic interface.  
- The launcher negotiates backend selection.  
- Backend may override input, windowing, audio, or filesystem ops.  
- Backends never affect simulation determinism.

---

# 7.61.6 — INTERNAL ASSET LAYERING

Assets are layered internally:

### LAYER 0 — Engine Data (Required)
```
/assets/base/engine/
```
- Default fonts  
- Minimal vector tiles  
- BSP grid units  
- Default sounds for fallback  
- Base UI

### LAYER 1 — World Assets  
```
/assets/base/world/
```
- terrain  
- buildings  
- infrastructure primitives  
- blueprints  
- sound & texture packs

### LAYER 2 — Optional Texture/Audio Packs  
```
/assets/texture/
    .domtexpack
/assets/audio/
    .domaudiopack
```
Each pack is a mod-like overlay.

### LAYER 3 — Mods  
```
/mods/<modname>/...
```

### LAYER 4 — DLC  
```
/dlc/<dlcname>/...
```

Overlay order (highest priority first):
```
mods → dlc → assets/texture → assets/audio → assets/base
```

---

# 7.61.7 — ENGINE MANIFEST SYSTEM

Every engine build includes a deterministic manifest:

```
/manifest/engine.dommanifest
```

Fields:

```
engine_version = "1.0.0"
build_id = "<sha256>"
supported_platforms = ["win32","win64","linux64","macos_x86"]
supported_renderers = ["gl1","gl2","dx9","dx11","sw"]
supported_backends = ["sdl1","sdl2","winapi","cocoa","posix"]
canonical_ups_values = [1,2,5,10,20,30,45,60,90,120,180,240]
audio_modes = ["vector","2d","3d"]
texture_modes = ["vector","2d","3d"]
```

All components include:

```
sha256sum
build_id
compatibility_group
```

The manifest is read-only during runtime; used by launcher and diagnostics.

---

# 7.61.8 — ENGINE VERSIONING

Dominium uses:

- **Engine version** (API level)
- **Content version** (base assets)
- **Universe version** (world metadata schema)
- **Replay version** (binary format)
- **Network protocol version** (for MP)

Rules:

1. Engine versions must be backward-compatible for at least one major revision.
2. Universe/world versions can migrate via offline editor.
3. Replay version must always match engine version; no auto-upgrade.
4. Network protocol changes require explicit "incompatible engine" message.

---

# 7.61.9 — BINARY COMPATIBILITY MAP

The engine package contains **multiple binaries**, but the launcher chooses only one.

Rules:

1. Old OSes load only compatible binaries (e.g., Win2000 cannot load x64 or DX11 builds).
2. New OSes choose the highest capability matching:
   - architecture  
   - renderer compatibility  
   - backend compatibility  
3. All binaries implement a common ABI for:
   - renderer interface  
   - backend interface  
   - core engine main entrypoint  
4. Headless versions have no renderer/backends included.

---

# 7.61.10 — ENGINE INTERNAL CONFIG

Internal configuration files:

```
/config/engine.cfg
/config/render.cfg
/config/platform.cfg
/config/locale.cfg
```

Rules:

- Engine loads config before world load.
- Launcher may override user config, but never engine.cfg.
- engine.cfg is deterministic and embedded into `.domsave` header metadata.

---

# 7.61.11 — MULTI-EXECUTION MODES PACKAGING

Modes included in engine package:

### Client
Uses:
- platform backend  
- renderer  
- full asset loader  
- audio subsystem  
- UI

### Server
Uses:
- no renderer  
- minimal platform backend (POSIX/winapi)  
- audio disabled  
- UI minimal

### Headless Client
Uses:
- minimal backend  
- no renderer  
- audio optional  
- used for offline AI simulation

### Tools
- world editor  
- universe editor  
- converter  
- asset pipeline tools  
- CLI utilities (domctl, domdiag, dompack, dommodchk)

---

# 7.61.12 — DETERMINISTIC PACKAGING GUARANTEES

To ensure packaging never breaks determinism:

1. File order within archives must be stable.
2. Bundles must use fixed endianness.
3. Build system must produce identical manifests for identical inputs.
4. Renderer/Backend loading must not modify simulation state.
5. Asset hashing must be stable and reproducible.
6. Mods cannot override engine deterministic constants.
7. DLC must not alter core simulation rules.

---

# 7.61.13 — LEGACY OS PACKAGING CONSTRAINTS

### Windows 9x / DOS / FAT16 / FAT32
- strict 8.3 filename support  
- loader maps LFNs → short names  
- renderer fallback to GL1 or software  
- asset bundles must use short paths  
- mods flattened into short folder names:
  - "factorio_mod_extra_large" → "fmodxl"  
- no directory deeper than 8 levels

### Mac OS 7–9
- resource fork support optional  
- absolute path sizes limited  
- no symbolic links  
- no large bundles

---

# 7.61.14 — INTERNAL PACKAGING BUILD PROCESS

Build pipeline:

1. Compile platform-specific binaries  
2. Compile and link renderer backends  
3. Compile and link platform backends  
4. Package assets into `.dombundle`  
5. Generate manifest  
6. Generate hash table (`manifest.sha256`)  
7. Run engine self-test  
8. Assemble universal internal engine package  
9. Export to distribution layer (Volume 8)

---

# 7.61.15 — INTEGRITY VERIFICATION

The engine package includes:

```
/manifest/manifest.sha256
```

Contents:

```
SHA256 <path/to/file> <hash>
SHA256 <path/to/file> <hash>
...
```

At startup:
- launcher verifies critical components  
- engine verifies only essential deterministic files

User-modifiable components ignored during checks.

---

# 7.61.16 — SUMMARY

The internal engine packaging architecture:

- supports all Dominium binary variants  
- organizes renderers/backends into modular folders  
- layers assets (base + DLC + mods) deterministically  
- supports legacy OS constraints (8.3 filenames)  
- ensures deterministic engine manifests  
- integrates with launcher, editor, and tools  
- maintains strict separation between engine and distribution layers  
- ensures reproducibility across all hardware and OS platforms

This completes Volume **7.61**.

If you want, we now continue with:
Proceed with 7.62 — Engine/Editor Interoperability Layer.
You said:
Proceed 
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.62 — ENGINE / EDITOR INTEROPERABILITY LAYER  
Dominium Engine Specification — Volume 7.62  
Scope: Safe interaction between the deterministic simulation engine and all offline/online editors, devkits, converters, and toolchains

---

# 7.62.1 — PURPOSE

This layer defines the **exact rules** by which:

- World Editor  
- Universe Editor  
- Property Editor  
- Blueprint Editor  
- Asset Tools (texture/audio/vector packs)  
- Modding Devkit tools  
- Save/Replay Inspectors  
- Conversion utilities  

interact with the deterministic Dominium engine.

Principles:

1. **Determinism is absolute.**  
   Editors may *inspect* and *modify* worlds, but never in a way that introduces nondeterministic simulation behavior.

2. **Clear separation between Runtime and Offline Domains.**  
   Simulation runs in the **Runtime Domain**.  
   Editors operate in the **Offline Domain**.  
   Only well-defined, atomic interfaces are allowed across the boundary.

3. **Zero side effects on active simulations.**  
   Editors cannot attach to or modify a running world.

4. **Explicit metadata versioning.**

5. **Cross-platform, C89-compatible, no dynamic code injection.**

---

# 7.62.2 — DOMAIN MODEL

There are three sharply separated domains:

## A. Runtime Domain (RD)
- deterministic ECS  
- networks (fluid, power, data, thermal)  
- workers, vehicles, machines  
- simulation tick + scheduler  
- chunk grid  
- authoritative save/load system  

No editor may interact with RD directly.

## B. Read-Only Inspection Domain (ROID)
- replay viewer  
- world visualizer  
- universe map viewer  
- property browser  
- blueprint library viewer  

ROID can mirror runtime state by *loading* from `.domsave` but never touching an active running world.

## C. Offline Editing Domain (OED)
- world editor  
- universe editor  
- devkit tools  
- asset converters  
- mod editors  

OED can modify:

- terrain  
- buildings  
- infrastructure  
- chunks  
- metadata  
- universe structure  
- mod assets  
- DLC content (if allowed)  
- simulation constants inside custom modsets (if allowed)

OED writes results to disk via controlled serialization.

RD does not see changes until a new world load.

---

# 7.62.3 — INTERACTION MODEL BETWEEN DOMAINS

### Allowed Paths:

```
OED → Serialize → .domsave  
OED → Serialize → .domuni  
OED → Serialize → .domblue  
ROID → Read .domsave  
RD → Load .domsave only at world startup  
```

### Forbidden Paths:

```
OED → RD (direct memory access)          ×  
ROID → RD (introspection of running sim) ×  
RD → OED (engine must not call editor)   ×  
Editors modifying a running simulation   ×
```

Editors can never attach to a running simulation.

---

# 7.62.4 — API LAYERING

There are **three safe APIs** for interaction:

---

## 7.62.4.1 — World Serialization API (WSA)

Low-level C89 interface:

```c
dom_world_t* dom_world_load(const char* path);
int dom_world_save(const dom_world_t*, const char* path);

dom_chunk_t* dom_world_get_chunk(dom_world_t*, int cx, int cy, int cz);
dom_entity_t* dom_world_get_entity(dom_world_t*, uint64_t id);

int dom_world_add_entity(dom_world_t*, const dom_entity_t*);
int dom_world_remove_entity(dom_world_t*, uint64_t id);
```

Rules:

- No simulation logic runs during WSA operations.  
- No ticks occur during OED operations.  
- Entity creation/deletion uses simple, declarative structs.  
- Networks (fluid/power/data) are represented in a relaxed structural form, not their runtime state.

---

## 7.62.4.2 — Universe Editing API (UEA)

For:  
- galaxy → system → planet → continent → area → property metadata  
- interproperty network definitions  
- global climate metadata  
- orbital metadata  

Example:

```c
dom_universe_t* dom_universe_load(const char* path);
int dom_universe_save(const dom_universe_t* u, const char* path);

dom_property_t* dom_universe_create_property(dom_universe_t*, ...);
```

Universe editing is always offline-only.  
Universe structure is immutable during simulation.

---

## 7.62.4.3 — Blueprint Editing API (BEA)

Blueprints are atomic templates of:

- buildings  
- conveyor geometries  
- rail alignments  
- utility networks  
- floors/walls/structures  
- machine stacks  

OED can create/edit `.domblue` files.

Example:

```c
dom_blueprint_t* dom_blueprint_new();
int dom_blueprint_add_element(dom_blueprint_t*, const dom_blue_element_t*);
int dom_blueprint_save(dom_blueprint_t*, const char* path);
```

Blueprints contain **geometry + metadata**, not simulation state.

---

# 7.62.5 — EDITOR EXECUTION MODES

### A. Standalone Editor Mode (OED)
- Loads `.domsave`  
- Modifies contents  
- Saves output  
- Never runs ticks  

### B. Preview Mode (ROID)
- Loads `.domsave`  
- Runs visualization only (2D vector, 2D texture, optional 3D preview)  
- No logic, no ticks, no networks  

### C. Validation Mode
- Runs static consistency checks:  
  - broken networks  
  - buildings overlapping  
  - invalid chunk geometry  
  - unreachable workers  
- Does not simulate time.

### D. Conversion Mode
- Converts older save formats  
- Converts mod assets  
- Imports external formats  
- Generates deterministic diffs

---

# 7.62.6 — DETERMINISTIC FILE IO BETWEEN ENGINE AND EDITORS

### Save formats:

- `.domsave` — world save  
- `.domuni` — universe metadata  
- `.domblue` — blueprint  
- `.dompack` — bundled asset pack  
- `.dommod` — mod metadata  
- `.domgraph` — network graph export  
- `.dommeta` — engine metadata package  

All formats use:

- fixed endianness  
- fixed numeric sizes  
- deterministic compression (DEFLATE raw, no timestamps)  
- sorted keys  
- stable order of arrays  
- no floating nondeterministic metadata (timestamps, OS version, etc.)

---

# 7.62.7 — EDITOR CONSTRAINTS (CRITICAL)

### 7.62.7.1 — Simulation state is prohibited
Editors may never write:

- in-flight fluid volumes  
- in-flight power flows  
- queued worker tasks  
- ECS runtime IDs  
- scheduler queues  
- tick counters  
- random seeds  
- replay buffers  

Only **declarative** world state is stored:

- geometry  
- buildings  
- machines  
- inventory contents  
- infrastructure definitions  
- blueprint instances  
- static networks  
- world metadata  

### 7.62.7.2 — Editor-only modifications must be atomic

Editors write a temporary output:

```
temp.world_edit.domtmp
```

Only when validation passes:

```
rename(temp.world_edit.domtmp → final.domsave)
```

Prevents corruption in crash scenarios.

---

# 7.62.8 — UNIVERSE & WORLD LINKING RULES

Editors may:

- create new worlds  
- clone worlds  
- delete worlds  
- move worlds between universes  
- rename properties  
- alter boundaries  
- add/remove interproperty network nodes  

Editors may **not**:

- shrink property area smaller than its existing bounding box  
- delete worlds referenced by active servers  
- modify in-flight player-owned property states  
- modify research progression except via blueprint/state editing API

---

# 7.62.9 — TOOLCHAIN SAFETY MODEL

All tools:

- run out-of-process  
- communicate only through file IO or IPC in developer mode  
- cannot inject code into engine  
- cannot override simulation constants in engine domain  
- must be sandboxable on macOS and Linux  
- must support Windows XP sandbox mode  
- must run fully offline  
- must remain compatible across all platforms  
- must support 8.3 filenames when targeting DOS/Win9x save formats  

---

# 7.62.10 — DEVELOPER-MODE BRIDGE (OPTIONAL & SAFE)

Dev-mode tools may connect to the engine through:

- **Remote Admin (read-only)**  
- **Telemetry snapshots**  
- **Replay export**  
- **Chunk previews**  
- **Network graph snapshots**  

Prohibited always:

- remote world mutation  
- injecting new entities while simulation is active  
- modifying deterministic constants  
- running editor logic inside engine process  

---

# 7.62.11 — EDITOR UI/UX INTEGRATION

Editors support:

- vector mode  
- 2D texture mode  
- 3D preview  
- blueprint preview  
- map overlays  
- data network visualization  
- chunk heatmaps  
- infrastructure alignment tools  
- blueprint snapping  
- precise pipe/rail/road geometry editors  

The UI is engine-agnostic:  
Rendering is not tied to deterministic engine renderer.

---

# 7.62.12 — FUTURE PORTS & LEGACY SUPPORT

### DOS / Win9x
- TUI editor only  
- 8.3 filenames  
- basic world editing features  
- blueprint editing fully supported  
- universe editing limited  

### macOS 7–9
- OS9 Carbon editor using minimal GUI  
- no 3D preview  
- full blueprint editing  

### WASM / Browser
- read-only previewers  
- blueprint editing  
- world editing possible via local filesystem API

---

# 7.62.13 — VALIDATION PIPELINE

OED must run the following validations before saving:

1. Chunk grid integrity  
2. Terrain continuity (no gaps unless intentional)  
3. No overlapping machines or buildings  
4. Network graph closure  
5. All pipes, rails, roads valid geometry  
6. All machines reachable by workers (unless flagged as unreachable)  
7. All inventories valid  
8. No impossible placements (floating buildings unless designed)  
9. Power networks consistent  
10. Fluid networks consistent  
11. Data networks valid graph topology  
12. Blueprint anchoring valid  

Save only if all checks pass or user explicitly overrides in dev mode.

---

# 7.62.14 — SUMMARY

The Engine/Editor Interoperability Layer provides:

- strict but powerful offline editing  
- strong separation between runtime and editing  
- deterministic-safe serialization  
- multi-platform compatibility  
- unified APIs for world, universe, and blueprint editing  
- robust validation pipeline  
- support for future legacy and advanced platforms  
- optional developer-mode integrations that remain nondestructive  
- deeply integrated but never nondeterministic toolchain support  

This completes Volume **7.62**.

Next is 7.63 — Engine ↔ Universe Bridge Layer.
You said:
Proceed 
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.63 — ENGINE ↔ UNIVERSE BRIDGE LAYER  
Dominium Engine Specification — Volume 7.63  
Scope: Binding worlds to universes; property metadata; hierarchical cosmic structure; deterministic world-to-universe interactions; interproperty transport; global metadata access

---

# 7.63.1 — PURPOSE

This layer defines how Dominium’s deterministic simulation engine interacts with:

- Universe containers (`.domuni`)
- Cosmic hierarchy (galaxy → system → planet → continent → area → property)
- Property boundaries & metadata
- Interproperty links (rail/road/air/water/space/power/data/pipeline)
- World maps vs universe maps
- Local weather vs global climate
- Universe-wide simulation metadata

The Universe Bridge acts as the **read-only metadata authority** while the world is running, ensuring:

- determinism  
- stable references  
- no desyncs  
- clean separation between local simulation and global universe structure  

---

# 7.63.2 — DOMAIN MODEL

### Universe Structure:
```
Universe
 └─ Galaxy[]
      └─ StarSystem[]
           └─ Planet[]
                └─ Continent[]
                     └─ Area[]
                          └─ Property[]
```

### World Structure:
```
World
 └─ Chunk grid (local simulation)
 └─ Entities / Machines / Workers
 └─ Networks (power/fluid/data/thermal)
 └─ Local weather zone
 └─ Property boundaries (fixed)
```

### Bridge Purpose:
Bind **World.Property** ↔ **Universe.Property**

---

# 7.63.3 — FILE FORMATS INVOLVED

### 7.63.3.1 Universe file
```
<name>.domuni
```

Contains:
- cosmic hierarchy metadata  
- climate parameters (coarse resolution)  
- orbital + astronomical metadata  
- interproperty adjacency graph  
- property registry  
- area/continent boundaries  
- planet sea-level baseline  
- base terrain classification  

### 7.63.3.2 World file
```
<property>.domsave
```

Contains:
- local property terrain  
- machines, buildings, entities  
- local climate zone  
- networks  
- inventories  
- chunk grid content  
- deterministic metadata

### 7.63.3.3 Global Universe Index
```
universe_index.dommeta
```

Contains references to all `.domuni` files present.

---

# 7.63.4 — ENGINE ↔ UNIVERSE BRIDGE API

The engine does **not** load the universe fully.  
It loads a **thin metadata slice** relevant to the world being simulated.

API:

```c
typedef struct {
    dom_universe_id   uid;
    dom_property_id   pid;
    dom_planet_id     planet;
    dom_area_id       area;
    dom_continent_id  continent;
    dom_coords_t      world_pos;
    dom_property_size_t size;
    dom_climate_zone_t czone;
    dom_interprop_ports_t ports;
} dom_universe_property_info_t;

int dom_universe_load_metadata(const char* path, dom_universe_property_info_t* out);
int dom_universe_get_interprop_links(dom_property_id pid, dom_interprop_ports_t* out);
int dom_universe_get_climate(dom_planet_id, dom_climate_zone_t* out);
```

This metadata:

- is read-only during simulation  
- is cached at world startup  
- contains only the needed subset  
- is deterministic across all platforms  

---

# 7.63.5 — PROPERTY → UNIVERSE BINDING

Each `.domsave` file contains:

```
property_id = <UUID or 64-bit deterministic id>
universe_path = "<relative or absolute path>"
```

At world load, engine:

1. Loads `.domsave`
2. Loads `.domuni` metadata
3. Extracts property metadata:
   - grid size  
   - location on the planet  
   - nearest borders  
   - interproperty ports  
4. Locks universe metadata to **read-only** mode

If metadata is missing or mismatch occurs:

- world fails to load  
- user must repair via the Universe Editor (OED)

---

# 7.63.6 — PROPERTY SIZE & POSITION

Stored in `.domuni`:

- property bounding box in world units  
- area grid coordinates (e.g., 16×16 km blocks)  
- altitude range  
- elevation class (coastline, upland, mountain)  
- biome classification  

Engine uses this only for:

- climate seeding  
- interproperty transport geometry  
- skybox and horizon parameters  
- load/unload of world edges  
- weather constraints  
- spawn constraints

---

# 7.63.7 — INTERPROPERTY LINKS

Interproperty links are defined at universe level:

```
dom_interprop_ports_t {
    bool road;
    bool rail;
    bool air;
    bool water;
    bool pipeline;
    bool oil;
    bool gas;
    bool data;
    bool power;
    dom_port_coords_t coords[];
}
```

Engine loads them and exposes them to:

- interproperty transport gateways  
- AI routing  
- logistics planning  
- player UI  
- autopilot navigation  

### Rules:
1. World builds only **endpoints** (stations, ports, runways).  
2. Universe defines the **logical connections** between properties.  
3. Vehicles disappear at endpoints but are rendered with transitional effects.  
4. Universe routing is **graph-based**, not simulation-based.

---

# 7.63.8 — UNIVERSE-SCALE CLIMATE LINK

The Universe Bridge allows the simulation to access:

- planet-level climate state  
- solar radiation  
- seasonal offsets  
- coarse wind/ocean currents  
- baseline temperature  
- storm potential  

The simulation uses this to:

- seed local weather  
- modulate probabilistic storm intensity  
- determine seasonal patterns  
- adjust baseline soil moisture  
- control fog/haze rendering  
- influence renewable energy yields  

Climate updates occur:

- **monthly** in universe metadata  
- **per-tick** in world via local weather model  
- fully deterministic  

---

# 7.63.9 — UNIVERSE-SCALE ECONOMIC LINK

Universe-level:

- price indices  
- supply/demand  
- trade routes  
- AI company metadata  
- production rates  
- population movement  
- market shocks  

World-level:

- interacts through trade portals (stations, markets, ports)
- reads prices, availability, demand curves via Universe Bridge
- never simulates universe-wide markets itself

Economic metadata is updated:

- at **trade ticks** (every N world ticks or on-demand)
- deterministically  
- by reading universe-provided curves

---

# 7.63.10 — UNIVERSE-SCALE INFRASTRUCTURE LINK

Engine reads:

- continental power grid (if DLC)  
- high-level data backbone  
- intercontinental shipping lanes  
- orbital elevators (future DLC)  
- spaceport networks  

But world simulation:

- never simulates these networks  
- uses universe metadata to determine travel cost and latency  
- uses deterministic formulas for long-range transport  
- interacts only through endpoints

---

# 7.63.11 — WORLD STARTUP PROCEDURE (IMPORTANT)

When loading a world:

1. Read `.domsave` header  
2. Locate `.domuni`  
3. Load universe metadata  
4. Validate:
   - property id  
   - universe id  
   - world bounds within property bounds  
   - canonical UPS valid  
   - modset matches  
   - renderer/platform compatibility  
5. Build **Universe Property Context (UPC)** object  
6. Seed local:
   - climate  
   - weather  
   - day/night cycle  
   - horizon curvature  
   - geologic constraints  
   - border behaviour  
7. Load chunks  
8. Start simulation

If any universe data mismatch is detected:
- load halts with error  
- editor repair required

---

# 7.63.12 — UNIVERSE PROPERTY CONTEXT (UPC)

UPC is a read-only structure stored in memory:

```
struct dom_upc {
    dom_universe_id uid;
    dom_property_id pid;
    dom_planet_id planet;

    dom_vec3 origin_planet;
    dom_vec3 origin_continent;
    dom_vec3 origin_area;

    dom_property_size_t psize;

    dom_climate_zone_t climate;
    dom_sealevel_t sealevel;

    dom_biome_t biome;
    dom_soil_profile_t soil;

    dom_interprop_ports_t ports;
};
```

Rules:
- Derived only at world load  
- Never mutated after world start  
- Stored inside save for validation on reload  
- Required for determinism  

---

# 7.63.13 — PLANETARY CURVATURE & HORIZON PARAMETERS

Universe file defines:

- planetary radius  
- atmospheric thickness  
- horizon distance tables  
- curvature distortion factors  

Engine uses these for:

- 3D skyline rendering  
- eclipse/shadow behaviour  
- skybox  
- aircraft altitude parameters  
- long-range interproperty transport visuals  

2D mode uses simplified curvature ignored beyond aesthetics.

---

# 7.63.14 — UNION OF MULTIPLE PROPERTIES (MEGAPROPERTIES)

In future updates:
- Players may merge adjacent properties  
- Universe metadata updates via editor  
- Engine loads expanded UPC covering combined bounding box  
- World save expands to cover merged boundaries  
- Requires universe validation beforehand  

Simulation remains local to a single `.domsave`.

---

# 7.63.15 — UNIVERSE-WIDE VERSIONING

Universe carries its own version metadata:

```
universe_version
schema_version
asset_pack_version
economy_model_version
climate_model_version
```

Engine rejects worlds with incompatible universe schemas.

Universe Editor can migrate universes forward but never backward.

---

# 7.63.16 — LEGACY OS CONSTRAINTS

### DOS / Win9x
- `.domuni` filenames must fit 8.3  
- Paths must be short  
- cosmic hierarchy reduced to flat structure (planet only)  
- no 3D curvature effects  
- interproperty links simplified  

### macOS 7–9
- simple planet model only  
- no galaxy layering  

### WASM
- readonly view of universe  
- local storage limited to one world  

---

# 7.63.17 — SUMMARY

The Engine ↔ Universe Bridge Layer:

- provides deterministic integration between local simulation and the wider universe  
- exposes read-only metadata for climate, economics, geography, and infrastructure  
- ensures stable world-by-world simulation  
- supports merging, editing, and expansion through editors  
- defines interproperty transport endpoints and logic  
- cleanly separates world state from universe state  
- maintains deterministic startup  
- supports the cosmic hierarchical model without loading full universes into RAM  

This completes Volume **7.63**.

Next is 7.64 — Integration Verification Framework (final section of Volume 7).
You said:
Proceed
ChatGPT said:
GPT-5.1 — 2025-11-30
# 7.64 — INTEGRATION VERIFICATION FRAMEWORK  
Dominium Engine Specification — Volume 7.64  
Scope: Deterministic validation, cross-platform correctness, startup verification, replay verification, mod integrity checks, regression suite

---

# 7.64.1 — PURPOSE

The Integration Verification Framework (IVF) ensures that:

- All engine components operate deterministically across platforms.
- All simulations reproduce identically on all hardware allowed by Dominium’s spec.
- All renderers, platforms, and modules integrate cleanly.
- Mods, DLC, and universe/world files remain structurally valid.
- Replays validate determinism.
- Networked multiplayer is safe from desync.
- Legacy OS builds produce exact matching results.

This is the **final gate** before packaging (Volume 8).

---

# 7.64.2 — IVF HIGH-LEVEL STRUCTURE

IVF contains **five validation pipelines**:

1. **Startup Validation**  
2. **Determinism Validation**  
3. **Data Integrity Validation**  
4. **Cross-Module Integration Validation**  
5. **Regression & Compatibility Validation**

All five run in deterministic sequence at runtime, build time, or test time depending on mode.

---

# 7.64.3 — STARTUP VALIDATION

Ran on game boot, server boot, world load, and replay load.  
Guaranteed deterministic across OS/CPU/GPU.

Checks:

### A. Hardware Environment
- CPU architecture & endian check  
- FPU settings  
- SIMD availability  
- RAM availability  
- Stable timers  
- Threading configuration  
- OS version and quirks mode selection (Win98, Win2000, macOS 10.6, Linux glibc variants, DOS extender etc)

### B. Software Environment
- Renderer availability  
- Platform backend consistency  
- SDL version range  
- DirectX driver validation  
- OpenGL version  
- Audio backend  

### C. Engine State
- Canonical UPS permitted values  
- FPS caps validated  
- Thread pool creation validated  
- RNG locked to deterministic seed  
- All subsystems provisionally loaded

If any violation occurs:  
**FAIL FAST** and display actionable error.

---

# 7.64.4 — DETERMINISM VALIDATION

This is the core of Dominium’s identity.

### Deterministic model enforced at:

- Tick order  
- Network propagation order  
- Machine update order  
- Entity update order  
- Interpolation/extrapolation systems  
- RNG locked to world seed  
- Cross-platform arithmetic strict mode (no fused ops on unsupported CPUs)  
- Thread scheduler deterministic partition schedule  
- No floating non-deterministic behaviour  
- Replay → perfect reproduction  

### IVF Determinism Modes

1. **Strict**  
   Required for multiplayer, replays, record mode.

2. **Loose**  
   Single-player only; minor deviations allowed for speed.

3. **Verification Mode**  
   Engine automatically reruns past N ticks twice to verify they produce identical results.

---

# 7.64.5 — DATA INTEGRITY VALIDATION

Performed at:

- Build time  
- Startup  
- World loading  
- Universe loading  
- Renderer load  
- Mod activation  
- DLC activation  

### A. File Hash Validation
- SHA-256 manifest for all assets  
- CRC-32 fast check for legacy platforms  
- Universe file checksums  
- Modset file checksums  

### B. Format Validation
- Schema verification for `.domsave` and `.domuni`  
- Mod metadata schema validated against core spec  
- No cyclic references  
- No null or orphan references  
- No broken interproperty network graph links  

### C. Asset Validation
- Texture dimension limits  
- Sound format support  
- 2D/3D mesh constraints  
- Sprite sheet formatting  
- Vector graphics compatibility  
- Shader syntax  
- Legacy compatibility for C89/C++98 loaders

---

# 7.64.6 — CROSS-MODULE INTEGRATION VALIDATION

Ensures the entire engine architecture is consistent.

### A. Simulation Modules
- Fluids  
- Thermal  
- Electrical  
- Magnetic  
- Mechanical  
- Logistics  
- Inventory  
- Terrain  
- Climate  
- Weather  
- Economy  

All must pass:

1. **Dependency graph validation**  
2. **Update scheduling validation**  
3. **Deadlock detection**  
4. **Tick-overflow detection**  
5. **Cross-module conflicting writes detection**

### B. Renderer Integration
Each renderer must pass:

- Frame pacing validation  
- Deterministic present timing  
- Asset loading validation  
- Multithread sync checks  
- Legacy renderer fallback validation  

### C. Platform Integration
SDL1, SDL2, Win32 Native, Cocoa, X11/Wayland backends must pass:

- input consistency  
- window model validation  
- event propagation determinism  
- timing subsystem validation  
- audio subsystem validation  

---

# 7.64.7 — REPLAY VALIDATION

Dominium supports:

- Input-only replays  
- Snapshot replays  
- Hybrid replays  

IVF ensures:

- determinism replay from any point  
- correction of replay drift  
- byte-for-byte input tracking  
- checksum at periodic intervals  
- cross-platform replay equivalence  

Replay corruption causes forced re-simulation from last clean snapshot.

---

# 7.64.8 — MULTIPLAYER DESYNC DETECTION

The engine maintains:

- tick hash  
- world state hash  
- RNG state hash  
- network packet order hash  

Each client/server exchange verifies equality.

If mismatch:

- desync event log created  
- auto-paused if configured  
- debug playback captured (optional)  
- determinism verification mode engaged  

---

# 7.64.9 — LEGACY OS VERIFICATION

Ensures all allowable OS targets remain supported.

### MS-DOS / Windows 1–3:
- 8.3 filename check  
- flat directory mode  
- renderer limitations validated  
- CPU/FPU validated  
- memory model <32MB validated  

### Windows 95/98/ME:
- DirectX 9 limited mode  
- no multithread requirements  
- SEH fallback mode  
- legacy object loader  

### Windows 2000–11:
- full engine capability  
- multi-core deterministic scheduler validated  

### macOS 10.6+:
- legacy OpenGL path validated  

### Linux:
- glibc symbol compatibility  
- soft float fallback  

---

# 7.64.10 — MOD INTEGRITY & SAFETY VALIDATION

Each mod must pass:

1. Schema check  
2. Dependency check  
3. Replay determinism check  
4. Universe constraints check  
5. Simulation sandbox isolation  
6. Asset validity  
7. Memory footprint check  
8. SFN-safe filenames for legacy builds  
9. Forbidden API usage check  
10. Order-independent load reproducibility  

If any fail, the mod cannot load without user forcing “unsafe mode”.

---

# 7.64.11 — AUTOMATED REGRESSION SUITE

Ran during:

- CI pipeline  
- nightly tests  
- stable release builds  
- certification for major platforms  

Includes:

- deterministic tick simulation for 1M ticks  
- multi-renderer comparison  
- cross-CPU replay comparison  
- random-seed fuzz tests  
- universe load/save stress tests  
- incremental mod load/unload tests  

Output:
- PASS  
- FAIL  
- FAIL + minimal reproduction archive  

---

# 7.64.12 — VERIFICATION REPORT GENERATION

Engine generates human-readable + machine-readable reports:

```
verification/
 ├─ startup_report.json
 ├─ determinism_report.json
 ├─ integration_matrix.json
 ├─ mod_integrity.json
 ├─ replay_validation.json
 └─ universe_binding_report.json
```

Used for:

- debugging  
- certification  
- automated QA  
- mod approval workflows  

---

# 7.64.13 — SUMMARY

The Integration Verification Framework:

- enforces determinism  
- validates engine ↔ renderer ↔ platform integration  
- validates universe ↔ world consistency  
- ensures mod safety  
- prevents desync  
- guarantees replays, multiplayer, and simulation correctness  
- provides a reproducible testing matrix across platforms from MS-DOS → modern OS  
- forms the final gate before packaging (Volume 8)

---

**End of Volume 7.64**  
Volume 7 is now complete.
