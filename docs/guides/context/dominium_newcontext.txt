Thought for 5s
GPT-5.1 Thinking • build 2025-12-03
High-level: my tree is broadly aligned in spirit but structurally conflicts with your “Dominium — DIRECTORY CONTEXT AND CONTRACT” in several places. If the contract is the law, my tree has to be adjusted, not the other way around.
I’ll go through it systematically.

1. Top-level comparison
Contract top-level:
• /docs
• /engine
• /game
• /data
• /mods
• /tools
• /tests
• /third_party
• /build
• /packaging
• /scripts
• /ports
My tree top-level:
• /docs
• /third_party
• /scripts
• /config
• /tools
• /platform
• /engine
• /game
• /render
• /data
• /assets
• /tests
• /build
• (no explicit /mods, /packaging, /ports)
Immediate mismatches
• I added: /config, /platform, /render, /assets.
• I omitted: /mods, /packaging, /ports.
• I put platform and render as separate top-level dirs instead of under /engine as the contract wants.
• I kept assets separate from /data, whereas the contract expects all canonical game data under /data and third-party mods under /mods.
Conclusion: structurally incompatible as-is; you need a remap.

2. /docs
Contract:
• /docs/spec, /docs/design, /docs/legal, /docs/architectureive.
My tree:
• /docs/engine, /docs/gameplay, /docs/modding, /docs/platforms, /docs/tools.
Issues:
• I didn’t follow the spec/design/legal/archive split.
• I mixed “spec” and “design” content under /docs/engine and /docs/gameplay.
Fix:
• Move/rename:
o /docs/engine → mostly /docs/spec (core engine spec) plus some /docs/design.
o /docs/gameplay → /docs/design.
o /docs/modding → /docs/spec (modding API) or /docs/design (higher-level).
o /docs/platforms → /docs/spec or /docs/architectureive depending on maturity.
o /docs/tools → /docs/design (tool design) or /docs/architectureive if stale.
• Add /docs/legal and /docs/architectureive explicitly, per contract.

3. /engine and /platform//render
Contract:
• /engine is the only home for core engine code.
• Subdirs: /engine/core, /engine/sim, /engine/render, /engine/audio, /engine/platform, /engine/net, /engine/ui.
My tree:
• /engine/core, /engine/ecs, /engine/space, /engine/topo, /engine/blueprints, /engine/sim, /engine/physics, /engine/io, /engine/modding, /engine/api.
• Separate /render/ for backends.
• Separate /platform/ for OS-specific code.
Conflicts:
• Contract wants /engine/render + /engine/platform, not top-level /render and /platform.
• I split “render” and “platform” out to top level and gave them their own hierarchies.
• I don’t have /engine/audio or /engine/net//engine/ui as named in the contract (though they’re conceptually easy to add).
Fix:
• Move /render/* → /engine/render/* and wire them to dom_render_api.[ch].
• Move /platform/* → /engine/platform/* and align naming with dom_platform_* APIs.
• Add stubs for:
o /engine/audio
o /engine/net
o /engine/ui
• Keep the rest of /engine (core/sim/ecs/space/topo/blueprints/physics/io/modding/api) – they fit under “core” + “sim” + generic engine modules. You don’t need to rename them, but you should ensure determinism-sensitive parts sit under /engine/core + /engine/sim to match rule 13.3.

4. /game
Contract:
• /game/client
• /game/server
• /game/launcher
My tree:
• /game/core
• /game/worldgen
• /game/gameplay
• /game/blueprints
• /game/ui
• /game/render
• /game/scripting
Issues:
• I didn’t separate client vs server vs launcher.
• I duplicated a “render” layer inside /game (but the contract expects rendering abstraction in engine and “client logic” in /game/client).
Fix:
• Restructure:
o /game/client:
• Move /game/ui, /game/render, and client entrypoints of /game/core.
o /game/server:
• Move headless logic: parts of /game/core, worldgen, gameplay that run without UI/render.
o /game/launcher:
• Add a small launcher app that selects renderer/platform/mode.
• Keep worldgen, gameplay, blueprints, scripting as subdirs under client or server as appropriate or as /game/shared used by both.

5. /data, /assets, /mods
Contract:
• /data = first-party canonical content:
o /data/base
o /data/dlc
o /data/packs
o /data/templates
• /mods = third-party/local mods:
o /mods/local
o /mods/workshop
o /mods/disabled
My tree:
• /data/archetypes, /data/prefabs, /data/blueprints, /data/research_trees, /data/economy, /data/languages, /data/packs.
• /assets/gfx, /assets/audio, /assets/fonts.
• No /mods at all.
Issues:
• I split “assets” and “data”; the contract collapses official game content under /data.
• Missing /data/base, /data/dlc, /data/templates.
• Missing /mods tree.
Fix:
• Merge /assets into /data according to contract:
o /assets/gfx, /assets/audio, /assets/fonts → under /data/base and /data/packs as appropriate.
• Wrap existing content in:
o /data/base/archetypes, .../prefabs, .../languages, etc.
• Add /data/dlc/* even if empty.
• Add /data/templates for sample universes/saves.
• Add /mods/local, /mods/workshop, /mods/disabled now, even if empty, and keep toolchains/mod loaders aligned.

6. /tools
Contract:
• /tools/editor
• /tools/devkit
• /tools/pipeline
My tree:
• /tools/editor
• /tools/asset_pipeline
• /tools/debug_viewers
• /tools/cli
Mostly compatible but more granular.
Fix:
• Rename:
o /tools/asset_pipeline → /tools/pipeline.
• Keep:
o /tools/editor as-is (world/blueprint/prefab editor).
o /tools/debug_viewers under /tools/devkit or keep as /tools/debug_viewers but document it.
o /tools/cli can live under /tools/devkit or stay at root level inside /tools.

7. /tests
Contract:
• /tests/unit
• /tests/integration
• /tests/replay
• /tests/perf
My tree:
• /tests/unit
• /tests/sim
• /tests/regression (with saves/, replays/)
Issues:
• Different naming; contract wants /integration, /replay, /perf.
Fix:
• Map:
o /tests/unit → keep as is.
o /tests/sim → /tests/integration.
o /tests/regression/replays → /tests/replay.
o Add /tests/perf explicitly for performance/load tests.
o Keep regression saves either in /tests/replay or /tests/integration depending on usage.

8. /third_party
Contract:
• /third_party/src
• /third_party/include
• /third_party/licenses
My tree:
• /third_party/SDL1, /third_party/SDL2, /third_party/glad, miniz, lua, imgui, etc.
Issues:
• I used per-library subdirs instead of the src/include/licenses split.
Fix:
• Either:
o Conform fully and lay out:
• /third_party/src/SDL, /third_party/include/SDL, etc.
• /third_party/licenses/SDL_LICENSE.txt, etc.
o Or document a variant in the contract if you want library-per-folder style. Right now it’s technically a violation.

9. /build, /packaging, /scripts, /ports
Contract:
• /build = build scripts, cmake modules, local outputs under /build/output.
• /packaging = installers/images (windows/linux/macos/retro).
• /scripts = meta-automation (not build).
• /ports = experimental targets (DOS, Win9x, WASM, etc).
My tree:
• /build/debug, /build/release, /build/tools, /build/pkg.
• /scripts with build scripts and test runners.
• No /packaging.
• No /ports.
• I shoved DOS/Win9x under /platform/win9x_dos instead of /ports.
Issues:
• I mixed packaging under /build/pkg instead of /packaging.
• I put build scripts under /scripts and some under /build (mixed responsibilities).
• I ignored /ports.
Fix:
• Move packaging material:
o /build/pkg → /packaging (/packaging/windows, /packaging/linux, /packaging/retro, etc).
• Cleanly separate:
o /build = CMake, build helper modules, maybe output/ if you really want.
o /scripts = repo utilities, codegen, analysis, CI scripts.
• Move experimental DOS/Win9x stuff to /ports/dos, /ports/win9x, and leave /engine/platform for “primary” platforms only (win32, linux, macOS, etc).

10. Overall judgement
• Conceptually: my tree and the contract are aligned in intent:
o /engine vs /game vs /data vs /mods vs /tools vs /tests vs /third_party vs /build.
• Structurally: my version violates the contract in multiple clear ways:
o platform/ and render/ at top-level instead of under /engine.
o Missing /mods, /packaging, /ports.
o Different /docs structure.
o Data/assets split inconsistent with /data spec.
o Slightly different /tests and /third_party layout.
If you treat the “Dominium — DIRECTORY CONTEXT AND CONTRACT” as the canonical law, the correct move is:
• Take that contract as the frame.
• Remap my concrete tree into it.
• Fix the handful of missing directories (mods, packaging, ports).
• Consolidate platform/render into /engine.
You do not keep both; you normalise the tree to the contract and use my tree as an implementation suggestion for inside those contract directories.
You said:
Okay generate an optimal directory for development with modularity and extensibility and determinism.
ChatGPT said:
Thought for 10s
GPT-5.1 Thinking • build 2025-12-03
dominium/
├─ .gitignore
├─ LICENSE
├─ README.md
├─ VERSION              # engine+game semantic version
│
├─ docs/                # design + spec; not a source of truth for code layout
│  ├─ spec/             # binding technical specs that code must obey
│  │  ├─ SPEC-core.md           # determinism kernel, math rules
│  │  ├─ SPEC-ecs.md            # entity/component/system contract
│  │  ├─ SPEC-space.md          # frames, lattice hierarchy, grids
│  │  ├─ SPEC-networks.md       # graphs, fields, utilities (power, data, etc.)
│  │  ├─ SPEC-io.md             # save/load, replay, formats
│  │  └─ SPEC-modding.md        # mod API, data formats, guarantees
│  ├─ design/           # higher-level design, non-binding
│  │  ├─ DESIGN-game.md
│  │  ├─ DESIGN-ui.md
│  │  ├─ DESIGN-orbit.md
│  │  └─ DESIGN-content-packs.md
│  ├─ legal/
│  │  ├─ LICENCE.md
│  │  ├─ EULA.md
│  │  └─ ATTRIBUTION.md
│  └─ archive/          # obsolete docs only
│
├─ engine/              # deterministic, platform-agnostic core
│  ├─ core/             # primitive utilities, no sim state
│  │  ├─ dom_core_types.[ch]
│  │  ├─ dom_core_log.[ch]
│  │  ├─ dom_core_mem.[ch]
│  │  ├─ dom_core_fp.[ch]       # fixed-point, no floats
│  │  ├─ dom_core_rng.[ch]      # deterministic RNG only
│  │  └─ dom_core_bits.[ch]
│  │
│  ├─ sim/              # deterministic simulation kernel
│  │  ├─ dom_sim_tick.[ch]      # tick phases, UPS, lane scheduling
│  │  ├─ dom_sim_lanes.[ch]     # virtual lanes, merge rules
│  │  ├─ dom_sim_events.[ch]    # buses, command buffers, deferred ops
│  │  ├─ dom_sim_jobs.[ch]      # job system core
│  │  ├─ dom_sim_world.[ch]     # world/surface/system hierarchy
│  │  ├─ dom_sim_network_power.[ch]
│  │  ├─ dom_sim_network_fluid.[ch]
│  │  ├─ dom_sim_network_data.[ch]
│  │  ├─ dom_sim_network_thermal.[ch]
│  │  ├─ dom_sim_orbit.[ch]     # orbit rails / integer orbital model
│  │  └─ dom_sim_economy.[ch]
│  │
│  ├─ ecs/              # entity/component/system architecture
│  │  ├─ dom_ecs.[ch]
│  │  ├─ dom_ecs_components.[ch]   # registry of component types
│  │  ├─ dom_ecs_systems.[ch]      # system registry, fixed order
│  │  └─ dom_ecs_archetypes.[ch]   # engine-level archetypes
│  │
│  ├─ spatial/          # grids, chunks, BVH, queries
│  │  ├─ dom_space_frames.[ch]   # universe → galaxy → system → surface
│  │  ├─ dom_space_lattice.[ch]  # subnano..surface lattice ops
│  │  ├─ dom_space_chunks.[ch]   # chunk/subchunk/subregion indexing
│  │  ├─ dom_space_grid.[ch]     # tile-level operations
│  │  ├─ dom_space_bvh.[ch]      # BVH / wide grid
│  │  └─ dom_space_query.[ch]
│  │
│  ├─ physics/          # integer physics, no randomness
│  │  ├─ dom_phys_core.[ch]
│  │  ├─ dom_phys_colliders.[ch]  # AABB, slabs, simple hulls
│  │  ├─ dom_phys_contacts.[ch]
│  │  └─ dom_phys_raycast.[ch]    # integer DDA
│  │
│  ├─ render/           # engine render API + backends (no OS windows)
│  │  ├─ dom_render_api.[ch]      # abstract draw calls
│  │  ├─ software/
│  │  │  ├─ dom_render_sw.[ch]
│  │  ├─ gl1/
│  │  │  ├─ dom_render_gl1.[ch]
│  │  ├─ gl2/
│  │  │  ├─ dom_render_gl2.[ch]
│  │  ├─ dx9/
│  │  │  ├─ dom_render_dx9.[ch]
│  │  └─ dx11/
│  │     ├─ dom_render_dx11.[ch]
│  │
│  ├─ audio/
│  │  ├─ dom_audio_api.[ch]
│  │  ├─ sdl_mixer/
│  │  │  ├─ dom_audio_sdl.[ch]
│  │  └─ null/
│  │     ├─ dom_audio_null.[ch]
│  │
│  ├─ platform/         # OS/CRT layer only, behind dom_platform_* APIs
│  │  ├─ dom_platform_api.[ch]     # stable interface to rest of engine
│  │  ├─ win32/
│  │  │  ├─ dom_platform_win32.[ch]
│  │  ├─ linux/
│  │  │  ├─ dom_platform_linux.[ch]
│  │  ├─ macos/
│  │  │  ├─ dom_platform_macos.[ch]
│  │  └─ shared_sdl/
│  │     ├─ dom_platform_sdl.[ch]
│  │
│  ├─ net/              # deterministic network protocol
│  │  ├─ dom_net_proto.[ch]      # lockstep protocol
│  │  ├─ dom_net_serialise.[ch]
│  │  └─ dom_net_session.[ch]
│  │
│  ├─ ui/               # engine-level UI widgets/layout (game-agnostic)
│  │  ├─ dom_ui_core.[ch]
│  │  ├─ dom_ui_widgets.[ch]
│  │  └─ dom_ui_layout.[ch]
│  │
│  ├─ io/               # save/load, replay, data packs
│  │  ├─ dom_io_filesys.[ch]     # virtual FS over platform
│  │  ├─ dom_io_save.[ch]
│  │  ├─ dom_io_load.[ch]
│  │  ├─ dom_io_replay.[ch]
│  │  └─ dom_io_packs.[ch]       # .domdata archives
│  │
│  ├─ modding/          # engine-side mod loading + API exposure
│  │  ├─ dom_mod_loader.[ch]
│  │  ├─ dom_mod_registry.[ch]
│  │  └─ dom_mod_lua.[ch]        # if Lua is enabled
│  │
│  └─ api/              # C API used by /game and tools
│     ├─ dom_api.h
│     └─ dom_api.c
│
├─ game/                # Dominium-specific logic, not engine
│  ├─ shared/           # logic used by both client and server
│  │  ├─ dm_worldgen.[ch]      # Earth/Sol/MilkyWay defaults, surfaces
│  │  ├─ dm_archetypes.[ch]    # game-level archetypes built on engine
│  │  ├─ dm_blueprints.[ch]    # blueprint families, patterns
│  │  ├─ dm_transport.[ch]     # game-specific rail/road/air/sea rules
│  │  ├─ dm_utilities.[ch]     # power/data/fluids game rules
│  │  ├─ dm_research.[ch]
│  │  ├─ dm_companies.[ch]
│  │  └─ dm_workers.[ch]
│  │
│  ├─ client/           # UI, cameras, views, client-side control
│  │  ├─ dm_client_main.[ch]
│  │  ├─ dm_client_views.[ch]        # 2D/3D, overlays
│  │  ├─ dm_client_hud.[ch]
│  │  ├─ dm_client_input.[ch]
│  │  ├─ dm_client_menus.[ch]
│  │  └─ dm_client_debug.[ch]
│  │
│  ├─ server/           # dedicated/headless server
│  │  ├─ dm_server_main.[ch]
│  │  ├─ dm_server_config.[ch]
│  │  └─ dm_server_admin.[ch]
│  │
│  └─ launcher/         # launcher and mode selector
│     ├─ dm_launcher_main.[ch]
│     └─ dm_launcher_config.[ch]
│
├─ data/                # first-party, versioned game data
│  ├─ base/             # always present base game
│  │  ├─ archetypes/
│  │  ├─ prefabs/
│  │  ├─ blueprints/
│  │  ├─ research/
│  │  ├─ economy/
│  │  ├─ languages/
│  │  ├─ gfx/           # base sprites/textures
│  │  ├─ audio/         # base sfx/music
│  │  └─ ui/            # base UI layouts/themes
│  ├─ dlc/
│  │  ├─ interstellar/
│  │  ├─ extras/
│  │  └─ wargames/
│  ├─ packs/            # alternative graphics/audio packs
│  │  ├─ gfx_lowres/
│  │  ├─ gfx_vector/
│  │  └─ audio_alt/
│  └─ templates/        # example universes/saves
│     ├─ earth_sandbox.domsave
│     └─ tutorial.domsave
│
├─ mods/                # third-party / local mods only
│  ├─ local/
│  ├─ workshop/
│  └─ disabled/
│
├─ tools/               # non-runtime tools
│  ├─ editor/           # world/blueprint/prefab editor
│  │  ├─ src/
│  │  └─ CMakeLists.txt
│  ├─ devkit/           # modding SDK, schema, codegen
│  │  ├─ schemas/
│  │  ├─ codegen/
│  │  └─ examples/
│  ├─ pipeline/         # asset pipeline
│  │  ├─ atlas_builder/
│  │  ├─ audio_packer/
│  │  └─ mesh_converter/
│  └─ debug/            # inspectors and analyzers
│     ├─ graph_inspector/
│     ├─ field_viewer/
│     ├─ ecs_dump/
│     └─ replay_viewer/
│
├─ tests/               # tests only
│  ├─ unit/             # module-level
│  │  ├─ test_core.c
│  │  ├─ test_fixed.c
│  │  ├─ test_ecs.c
│  │  ├─ test_space.c
│  │  ├─ test_sim_tick.c
│  │  └─ test_io_save.c
│  ├─ integration/      # multi-module, headless engine runs
│  ├─ replay/           # deterministic replay scenarios
│  └─ perf/             # performance / load-shedding tests
│
├─ third_party/         # vendored libraries only
│  ├─ src/
│  ├─ include/
│  └─ licenses/
│
├─ build/               # build system glue and local outputs
│  ├─ cmake/            # shared CMake modules
│  ├─ scripts/          # build helpers (invoked by /scripts wrappers)
│  └─ output/           # ignored; local build artifacts
│
├─ packaging/           # installers, images, retro media layouts
│  ├─ windows/
│  ├─ linux/
│  ├─ macos/
│  └─ retro/            # floppy/CD/DVD layouts, 8.3 mappings
│
├─ scripts/             # repo automation (not core build logic)
│  ├─ check_style.py
│  ├─ regen_schemas.py
│  ├─ regen_docs_index.py
│  └─ ci_entry.sh
│
└─ ports/               # experimental/secondary targets
   ├─ dos/
   ├─ win9x/
   ├─ macos_classic/
   └─ wasm/
Key properties that give you modularity, extensibility, and determinism:
• Hard separation of concerns
o /engine = deterministic, platform-agnostic core. No game rules, no OS calls.
o /game = Dominium-specific rules and modes, purely a client of dom_api.
o /data vs /mods = first-party vs third-party content separated at the filesystem level.
o /tools and /tests never bleed into runtime logic.
• Determinism enforced by structure
o All determinism-sensitive code lives in /engine/core, /engine/sim, /engine/ecs, /engine/spatial, /engine/physics, /engine/io.
o Platform and rendering are segregated under /engine/platform and /engine/render and can be swapped without touching the simulation kernel.
o /tests/replay and /tests/perf are explicit hooks to continuously verify determinism and performance under load.
• Extensibility without rot
o /engine/api is the single interface surface for /game and most tools.
o /engine/modding plus /data/base//data/dlc//mods gives you a clean content + mod stack.
o /ports isolates weird target hacks away from the main platform layer; they can die or stabilise without contaminating core.
• Backward-compatibility & longevity
o Binary formats centralised in /engine/io and described in /docs/spec.
o Packaging and retro media support sit in /packaging and /ports, not scattered.
This is the directory structure you can commit to and grow for a decade without painting yourself into a corner.
You said:
Okay, give me a full as-long-as-you-can-generate message the describes the function for each directory and it's files, and what those files need to do and expose
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
I’ll walk the tree top-down and state, for each directory and key file group:
• What its responsibilities are.
• What it must not do.
• What it must expose (APIs, invariants, behaviours).
Assume C89/C++98 where applicable, and that determinism rules from your V3 spec are binding.

0. Repository root
dominium/
• Holds only:
o VCS and legal/identity files: .gitignore, LICENSE, README.md, VERSION.
• No code here, no build artifacts.
VERSION
• Single source of truth for engine+game semantic version (e.g. 3.0.0).
• Read at build time and embedded into:
o Engine binary metadata.
o Savefiles.
o Net protocol version.
• Never parsed by runtime determinism logic; it’s metadata only.

1. /docs — Specification and design
/docs/spec/
These files are the binding contract. Code that violates them is wrong.
SPEC-core.md
• Defines:
o Determinism philosophy (tick model, lanes, merge, UPS/FPS).
o Integer/fixed-point math rules.
o Prohibited operations (floats, UB, nondeterministic RNG).
• Must specify:
o Allowed numeric types.
o Overflow semantics.
o Ordering guarantees (tick phases, entity iteration, lane merge).
• Every subsystem in /engine must trace back to rules here.
SPEC-ecs.md
• Defines:
o Entity handle format (id + generation).
o Component storage layout (dense arrays, active lists).
o System ordering and multi-rate scheduling.
• Must specify:
o How creation/destruction works.
o How component masks are stored.
o What is allowed to reference entities (handles only).
SPEC-space.md
• Defines:
o Subnano → Surface lattice.
o Chunk/subchunk/subregion hierarchy.
o Surface, system, galaxy, universe identity and ranges.
• Must specify:
o Coordinate systems.
o Valid ranges and wrapping rules.
o How spatial indices (chunks, BVH, grids) must behave.
SPEC-networks.md
• Defines:
o Power, fluid, data, thermal networks.
o Signal propagation rules (1-tick latency etc.).
• Must specify:
o Network graph model.
o Node/edge semantics.
o Deterministic update equations.
SPEC-io.md
• Defines:
o Savefile format.
o Replay format.
o Block headers, checksums, endian rules.
• Must specify:
o Required blocks and their ordering.
o How versioning and migration works.
SPEC-modding.md
• Defines:
o Mod manifest format.
o What mods are allowed to change.
o How mods are loaded and resolved.
• Must specify:
o Stability guarantees.
o Extension points and prohibitions.
/docs/design/
Non-binding but influential. Describes:
• Game vision.
• UX design.
• Content structure (rails, roads, orbits, buildings).
These guides decisions but engine code may diverge if specs demand it.
/docs/legal/
Legal and licensing only:
• LICENCE.md – effective license.
• EULA.md – player-facing agreement.
• ATTRIBUTION.md – third-party credits.
No technical content.
/docs/architectureive/
• Superseded specs and designs.
• Must be clearly marked as obsolete.
• Never referenced by new code.

2. /engine — Deterministic, platform-agnostic core
Global rules:
• C89 C (or minimal C++98 where agreed) only.
• No platform headers except under /engine/platform.
• No floats, no wall clock, no OS RNG.
• No direct file I/O except via /engine/io and platform API.

2.1 /engine/core/ — Primitive utilities
dom_core_types.[ch]
• Defines canonical types:
o dom_int32, dom_uint32, dom_int64, etc.
o Fixed-point types dom_q16_16, dom_q32_32.
• Exposes:
o Compile-time asserts about sizes.
o Macros for min/max/clamp that are deterministic.
• No logic beyond trivial inline utilities.
dom_core_log.[ch]
• Provides:
o Deterministic logging API: dom_log_info, dom_log_warn, dom_log_error.
• Constraints:
o Cannot influence simulation state.
o Must be safe to disable fully in release builds.
• Output ordering must reflect deterministic call order, but log loss under load is allowed if bounded.
dom_core_mem.[ch]
• Provides:
o Deterministic allocation wrappers for engine use.
o Pool allocators for simulation structures (chunks, entities).
• Rules:
o No heap allocation inside the simulation tick path except via pre-allocated pools.
o Must support “bail out if full” in a deterministic way (no partial allocations).
dom_core_fp.[ch]
• Implements fixed-point math as specified in SPEC-core.
• Exposes:
o dom_q16_mul, dom_q16_div, etc.
o All operations implemented via 64-bit intermediates; right-shifts are exact.
• Constraints:
o Identical semantics across all compilers and platforms.
o No undefined shift behaviour.
dom_core_rng.[ch]
• Provides:
o Deterministic PRNG (e.g., xorshift or splitmix) with explicit 64-bit state.
• Exposes:
o dom_rng_step, dom_rng_u32, dom_rng_range.
• Usage rules:
o Only allowed in systems that are explicitly marked pseudo-random but deterministic (worldgen, cosmetic effects).
o Simulation core must not use RNG for gameplay decisions unless clearly defined.
dom_core_bits.[ch]
• Bit manipulation utilities:
o dom_ctz, dom_clz, dom_popcount with deterministic fallbacks if intrinsics absent.
• Used across ECS, bitmasks, etc.

2.2 /engine/sim/ — Simulation kernel
dom_sim_tick.[ch]
• Implements tick pipeline:
o Phases 1–7 (input → finalize).
• Exposes:
o dom_sim_step(World *w).
o Functions to set UPS and to reconfigure multi-rate schedules, with deterministic rules.
• Must orchestrate calls into ECS systems and lane executor.
dom_sim_lanes.[ch]
• Manages virtual lanes.
• Exposes:
o Lane assignment function: dom_lane_id(entity_id).
o Lane iteration and merge routines.
• Responsibilities:
o Ensure lane-local buffers and merge sequences obey the ordering in the spec.
dom_sim_events.[ch]
• Implements:
o Local, lane, cross-lane, global event buses.
o Command buffers.
o Deferred op queues.
• Exposes:
o Typed APIs to emit and consume events.
o Strict lifetime and scope functions.
• Restrictions:
o No dynamic allocation; bounded ring buffers.
o Hard overflow behaviour (drop oldest + flag).
dom_sim_jobs.[ch]
• Implements the job system:
o Job structs, queues, assignment logic.
• Exposes:
o APIs to submit, cancel, and query jobs.
o Worker assignment functions.
• Must be fully deterministic:
o Sorted queues.
o Tie-breaking by worker id, etc.
dom_sim_world.[ch]
• Defines:
o World state object(s): universe → galaxy → system → surface.
o Tick counter, seeds, global stats.
• Exposes:
o API functions to create/destroy world.
o Accessors for surfaces, regions, chunks.
• Must integrate with ECS and spatial modules.
dom_sim_network_power.[ch], *_fluid, *_data, *_thermal
• Each implements its network’s deterministic behaviour.
• Expose:
o Graph build/update functions.
o Per-tick update entrypoints called from the network phase.
• Must:
o Use integer/fixed-point only.
o Obey latency and scheduling rules from SPEC-networks.
dom_sim_orbit.[ch]
• Implements:
o Orbital rails model (discrete orbits, transfer arcs).
• Exposes:
o Functions to step orbital objects.
o Query functions: current orbital band, SoI, possible transfers.
• Must be:
o Deterministic, no continuous floating mechanics; integer or fixed-point rails.
dom_sim_economy.[ch]
• Implements:
o Markets, prices, trades in pure integer math.
• Exposes:
o APIs to add/remove orders.
o Functions for price updates per tick.
• Must:
o Never consult real-time.
o Only depend on sim state and deterministic RNG where explicitly allowed.

2.3 /engine/ecs/ — ECS core
dom_ecs.[ch]
• Central ECS API.
• Exposes:
o Entity creation/destruction.
o Handle validation.
o Component add/remove.
• Must enforce:
o Sorted active lists.
o No component modifications outside permitted phases.
dom_ecs_components.[ch]
• Component type registry.
• Exposes:
o Registration of component types (internal).
o Lookup by type id.
• Must:
o Know component sizes/layout for serialization.
dom_ecs_systems.[ch]
• System registry and fixed ordering.
• Exposes:
o System registration at startup.
o Run lists for each phase.
• No runtime reordering.
dom_ecs_archetypes.[ch]
• Engine-level archetypes:
o Predefined combinations of components for entity categories (e.g., “machine”, “worker”, “vehicle”).
• Exposes:
o APIs to instantiate archetypes (not game-specific; just patterns).

2.4 /engine/spatial/
dom_space_frames.[ch]
• Encodes:
o Universe, galaxy, system, surface identifiers.
• Exposes:
o Mapping between global IDs and indices.
o Utility to validate frames.
dom_space_lattice.[ch]
• Implements:
o Subnano → Surface scale lattice definitions and utilities.
• Exposes:
o Functions to convert between scales (e.g. meter ↔ tile index).
• Must use integer arithmetic only.
dom_space_chunks.[ch]
• Manages:
o Chunk/subchunk/subregion maps per surface.
• Exposes:
o Functions to look up or create chunks.
o Iteration over non-empty chunks.
• Must:
o Avoid dynamic allocation in the hot path (use pools).
dom_space_grid.[ch]
• Tile-level operations:
o Get/set tile material/flags.
o Query for passability, occupancy.
• Exposes:
o API used by game logic and physics.
dom_space_bvh.[ch]
• BVH / wide grid structures for entities.
• Exposes:
o Build/update functions (post-process).
o Query functions (broadphase, area queries).
• Must have:
o Deterministic build order and layout.
dom_space_query.[ch]
• High-level spatial queries:
• “Find nearest X by criteria.”
• Internally calls BVH/grid functions.
• Must be stable: same inputs → same entity set in same order.

2.5 /engine/physics/
dom_phys_core.[ch]
• Integrators for simple rigid body (if you choose to have them).
• Exposes:
o API to step body positions/velocities using fixed-point.
• Constraints:
o No chaotic, nondeterministic solvers.
o No random jitter; must be stable enough for lockstep.
dom_phys_colliders.[ch]
• Defines:
o Collider types (AABB, slab, multi-AABB hull).
• Exposes:
o Intersection tests and Minkowski operations if needed.
dom_phys_contacts.[ch]
• Contact generation and simple resolution.
• Exposes:
o Functions to build contact lists between colliders.
o Functions to resolve overlaps deterministically (order by entity id).
dom_phys_raycast.[ch]
• Integer DDA raycaster.
• Exposes:
o dom_raycast_tile, dom_raycast_entities.
• Must:
o Traverse tiles in a fixed, reproducible order.
o Apply ordering rules when multiple hits are coincident.

2.6 /engine/render/
dom_render_api.[ch]
• The engine’s render abstraction.
• Exposes:
o dom_render_context struct.
o API for draw commands (lines, quads, sprites, meshes, text).
• Constraints:
o No game-specific knowledge.
o No OS windowing; that’s platform layer.
Backends (software, gl1, gl2, dx9, dx11):
• Each implements the API using its underlying API.
• No simulation logic; only takes prepared draw lists from /game/client.

2.7 /engine/audio/
dom_audio_api.[ch]
• Abstract audio interface.
• Exposes:
o Functions to register sounds/music.
o Play/stop events with sample-accurate scheduling relative to sim ticks.
• Must:
o Treat audio as effect; determinism only matters in terms of event ordering, not playback jitter.
Backends sdl_mixer, null:
• Provide actual output or no-op.

2.8 /engine/platform/
dom_platform_api.[ch]
• Defines:
o OS-level abstractions:
• Filesystem open/read/write.
• Time sources.
• Threads (if used).
• Window/input creation for client.
• Exposes functions:
o dom_platform_fs_open, dom_platform_fs_read.
o dom_platform_time_monotonic_ms (for FPS scheduling only).
o dom_platform_input_poll.
• No simulation state here.
Subdirs: win32, linux, macos, shared_sdl implement this API.

2.9 /engine/net/
dom_net_proto.[ch]
• Defines:
o Lockstep/net protocol:
• Packet formats.
• Connection states.
• Exposes:
o APIs to encode/decode messages, not to use sockets directly (that’s platform).
dom_net_serialise.[ch]
• Serialisation routines for net packets.
• Must:
o Be purely deterministic, versioned.
dom_net_session.[ch]
• Session state for client/server:
o Queues for outgoing/incoming packets.
• Exposes:
o Functions to feed data in/out through platform layer.

2.10 /engine/ui/
dom_ui_core.[ch]
• Abstract UI tree:
o Panels, buttons, labels, lists.
• Exposes:
o Structures for UI elements.
o Layout, input dispatch from /game/client.
dom_ui_widgets.[ch]
• Standard widgets:
o Buttons, sliders, checkboxes, list views, etc.
dom_ui_layout.[ch]
• Layout engine:
o Anchors, grids, etc.
• No game logic.

2.11 /engine/io/
dom_io_filesys.[ch]
• Virtual filesystem abstraction over platform.
• Exposes:
o Paths for data packs, saves, mods.
o Mount points.
dom_io_save.[ch] / dom_io_load.[ch]
• Implement:
o Savefile writing/reading per SPEC-io.
• Exposes:
o dom_save_world(World*, const char *path).
o dom_load_world(World*, const char *path).
dom_io_replay.[ch]
• Replay log writer/reader.
• Exposes:
o APIs to record inputs.
o APIs to play them back into sim.
dom_io_packs.[ch]
• Data pack/archive format loader.
• Exposes:
o APIs to mount .domdata archives from /data.

2.12 /engine/modding/
dom_mod_loader.[ch]
• Discovers mod directories.
• Reads manifest files.
• Resolves load order.
• Exposes:
o dom_mod_scan, dom_mod_load, dom_mod_activate.
dom_mod_registry.[ch]
• Central registry of modded resources:
o Prefabs, archetypes, blueprints, etc.
• Enforces:
o No type/layout changes to core components at runtime.
dom_mod_lua.[ch] (optional)
• Lua bridge.
• Exposes:
o Safe subset of engine API to scripts.
• Must:
o Avoid exposing anything that can break determinism.

2.13 /engine/api/
dom_api.h / dom_api.c
• Single public API header for /game and /tools.
• Exposes:
o High-level creation of engine instance.
o Hooks to drive ticks, pass input, get render data.
o Accessors to world state through stable handles (never direct struct dependence).
• This is the main seam for later porting or partial rewriting.

3. /game — Dominium gameplay logic
Rules:
• Uses only dom_api and high-level engine headers.
• Contains all Dominium-specific rules, research trees, economic tweaks.
• No platform code; no OS headers.

3.1 /game/shared/
Game logic used by both client and server.
dm_worldgen.[ch]
• Generates:
o Default Earth/Sol/Milky Way surfaces.
• Exposes:
o Functions to create new game worlds with seeds.
• Must:
o Use deterministic RNG from /engine/core.
dm_archetypes.[ch]
• Game-level archetypes:
o E.g., “light industrial building”, “heavy rail locomotive”.
• Exposes:
o Registration functions to map game archetype IDs to engine prefabs/components.
dm_blueprints.[ch]
• High-level blueprint logic:
o Families:
• Rail line with signals.
• Power line runs.
• Road segments, etc.
• Exposes:
o Blueprint creation APIs for tools and game UI.
o Functions to expand blueprint into commands for the engine (construction jobs, prefab placements).
dm_transport.[ch]
• Game rules for:
o Railways, roads, waterways, air, orbital routes.
• Exposes:
o Functions that set up engine networks (graph nodes, track segments).
• Works only via engine ECS and spatial APIs.
dm_utilities.[ch]
• Game rules for:
o Power grids, data networks, fluid pipes, thermal systems.
• Exposes:
o Domain-specific tuning of networks (losses, capacities, thresholds).
dm_research.[ch]
• Implements:
o Dominium tech tree.
• Exposes:
o APIs to unlock technologies, check prerequisites, apply modifiers.
dm_companies.[ch]
• Game logic for companies, finances.
• Exposes:
o Company creation/management functions used by UI and scripts.
dm_workers.[ch]
• High-level worker and robot rules on top of engine job system.
• Exposes:
o Functions to define job types and worker capabilities.

3.2 /game/client/
Client-side host.
dm_client_main.[ch]
• Application entrypoint for client binary.
• Exposes:
o main() or equivalent; boots platform + engine + game state.
dm_client_views.[ch]
• Implements:
o 2D/3D camera logic.
o View modes (map view, building view, orbit view).
• Exposes:
o View state and projection parameters passed to render layer.
dm_client_hud.[ch]
• UI overlays for the player:
o Resource bars, minimap, status panels.
dm_client_input.[ch]
• Input binding and mapping to sim commands:
o Mouse/keyboard → engine input events.
• Exposes:
o Functions to translate raw input (via dom_platform_*) into dom_api commands.
dm_client_menus.[ch]
• Main menus, options, loading screens.
dm_client_debug.[ch]
• Debug visualization:
o Network overlays, tick timings, lane visualisation.

3.3 /game/server/
Server-side headless host.
dm_server_main.[ch]
• Entry for dedicated server.
• Sets up:
o Engine instance.
o Network session.
o World.
dm_server_config.[ch]
• Server configuration:
o Max players.
o Tick rates.
o Universe layout.
dm_server_admin.[ch]
• Administrative commands:
o Save/rollback.
o Kick/ban.
o Telemetry.

3.4 /game/launcher/
dm_launcher_main.[ch]
• Launcher app entrypoint.
• Tasks:
o Config detection.
o Graphics/audio options.
o Mod selection.
o Starts the appropriate client/server binary.
dm_launcher_config.[ch]
• Configuration storage:
o INI or JSON-like config for user options.

4. /data — First-party game data
No source code here. Stable, versioned packs.
• /data/base/: minimal base content.
• /data/dlc/: official DLC sets.
• /data/packs/: alternative graphics/audio packs.
• /data/templates/: sample saves.
Each pack should have:
• A manifest file describing its version and dependencies.
• Data in engine-defined binary or JSON/binary schema formats.

5. /mods — Third-party content
• /mods/local: user-installed.
• /mods/workshop: downloaded.
• /mods/disabled: installed but inactive.
Each mod directory must contain:
• Manifest (as per SPEC-modding).
• Data packs, scripts, and resources.
No engine binaries.

6. /tools — Editors, SDK, pipeline, debug viewers
/tools/editor/
• World editor and blueprint/prefab editor.
• Uses dom_api to act as a client with elevated privileges (edit mode).
• Must not access engine internals directly; only via API.
/tools/devkit/
• schemas/: schema definitions for data formats.
• codegen/: code generators for bindings, data structures.
• examples/: example mod projects.
/tools/pipeline/
• atlas_builder/: packs spritesheets.
• audio_packer/: builds soundbanks.
• mesh_converter/: for future 3D or complex 2D assets.
All offline; no determinism requirements beyond reproducible outputs.
/tools/debug/
• graph_inspector/: view engine network graphs.
• field_viewer/: visualise scalar/vector fields.
• ecs_dump/: inspect entity/component tables.
• replay_viewer/: replay logs in a visual tool.

7. /tests — Tests only
/tests/unit/
• Unit tests for engine modules.
• Mirror /engine structure.
Example:
• test_core.c tests dom_core_*.
• test_ecs.c tests entity creation/destroy, component operations.
• test_sim_tick.c tests tick pipeline invariants.
/tests/integration/
• Full engine runs in headless mode.
• Tests:
o Worldgen determinism.
o Orbits.
o Networks.
/tests/replay/
• Prebuilt replay logs to confirm deterministic replay end state.
/tests/perf/
• Stress tests:
o High entity counts.
o Large networks.
These enforce performance envelope and safe degradation behaviour.

8. /third_party — Vendored libraries
• /src/: library source.
• /include/: headers.
• /licenses/: license texts.
No Dominium code in this subtree.

9. /build — Build glue, not source of truth
• /build/cmake/:
o CMake modules.
• /build/scripts/:
o Build helper scripts used by build system.
• /build/output/:
o Local build artefacts. Should be ignored by VCS.

10. /packaging — Installers and media layouts
• /windows/: NSIS/Inno/etc. installer configs.
• /linux/: deb/rpm/flatpak/appimage metadata.
• /macos/: DMG, bundle setup.
• /retro/:
o Floppy/CD/DVD layout files.
o 8.3 filename mapping tables.
This is pure packaging logic; no core code.

11. /scripts — Repo automation
• Scripts for:
o Style checks.
o Doc index regeneration.
o Schema generation.
o CI entrypoints.
Must not be required at runtime; they operate around the repo.

12. /ports — Experimental targets
• /dos/, /win9x/, /macos_classic/, /wasm/.
Each contains:
• Glue code for those platforms, but only through /engine/platform abstractions.
• Port-specific docs describing:
o Memory limits.
o Filesystem constraints.
o Special build rules.
No duplication of core engine logic; only adaptation and shims.

This structure and the described responsibilities give you:
• A strict layering between platform, engine, game, and content.
• A clearly bounded deterministic core.
• Stable extension points for mods, tools, ports, and future features.
You said:
Excellent, give me a full git dir tree with ASCII box drawing chars
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
dominium/
├── .gitignore
├── LICENSE
├── README.md
├── VERSION
├── CMakeLists.txt
│
├── docs/
│   ├── spec/
│   │   ├── SPEC-core.md
│   │   ├── SPEC-ecs.md
│   │   ├── SPEC-space.md
│   │   ├── SPEC-networks.md
│   │   ├── SPEC-io.md
│   │   ├── SPEC-modding.md
│   │   └── MILESTONES.md
│   │
│   ├── design/
│   │   ├── DESIGN-overview.md
│   │   ├── DESIGN-dominium-book-v3.md
│   │   └── DESIGN-ui-ux.md
│   │
│   ├── legal/
│   │   ├── LICENCE.md
│   │   ├── EULA.md
│   │   └── ATTRIBUTION.md
│   │
│   └── archive/
│       └── SPEC-legacy-v2.md
│
├── engine/
│   ├── core/
│   │   ├── dom_core_types.h
│   │   ├── dom_core_types.c
│   │   ├── dom_core_log.h
│   │   ├── dom_core_log.c
│   │   ├── dom_core_mem.h
│   │   ├── dom_core_mem.c
│   │   ├── dom_core_fp.h
│   │   ├── dom_core_fp.c
│   │   ├── dom_core_rng.h
│   │   ├── dom_core_rng.c
│   │   ├── dom_core_bits.h
│   │   └── dom_core_bits.c
│   │
│   ├── sim/
│   │   ├── dom_sim_tick.h
│   │   ├── dom_sim_tick.c
│   │   ├── dom_sim_lanes.h
│   │   ├── dom_sim_lanes.c
│   │   ├── dom_sim_events.h
│   │   ├── dom_sim_events.c
│   │   ├── dom_sim_jobs.h
│   │   ├── dom_sim_jobs.c
│   │   ├── dom_sim_world.h
│   │   ├── dom_sim_world.c
│   │   ├── dom_sim_network_power.h
│   │   ├── dom_sim_network_power.c
│   │   ├── dom_sim_network_fluid.h
│   │   ├── dom_sim_network_fluid.c
│   │   ├── dom_sim_network_data.h
│   │   ├── dom_sim_network_data.c
│   │   ├── dom_sim_network_thermal.h
│   │   ├── dom_sim_network_thermal.c
│   │   ├── dom_sim_orbit.h
│   │   ├── dom_sim_orbit.c
│   │   ├── dom_sim_economy.h
│   │   └── dom_sim_economy.c
│   │
│   ├── ecs/
│   │   ├── dom_ecs.h
│   │   ├── dom_ecs.c
│   │   ├── dom_ecs_components.h
│   │   ├── dom_ecs_components.c
│   │   ├── dom_ecs_systems.h
│   │   ├── dom_ecs_systems.c
│   │   ├── dom_ecs_archetypes.h
│   │   └── dom_ecs_archetypes.c
│   │
│   ├── spatial/
│   │   ├── dom_space_frames.h
│   │   ├── dom_space_frames.c
│   │   ├── dom_space_lattice.h
│   │   ├── dom_space_lattice.c
│   │   ├── dom_space_chunks.h
│   │   ├── dom_space_chunks.c
│   │   ├── dom_space_grid.h
│   │   ├── dom_space_grid.c
│   │   ├── dom_space_bvh.h
│   │   ├── dom_space_bvh.c
│   │   ├── dom_space_query.h
│   │   └── dom_space_query.c
│   │
│   ├── physics/
│   │   ├── dom_phys_core.h
│   │   ├── dom_phys_core.c
│   │   ├── dom_phys_colliders.h
│   │   ├── dom_phys_colliders.c
│   │   ├── dom_phys_contacts.h
│   │   ├── dom_phys_contacts.c
│   │   ├── dom_phys_raycast.h
│   │   └── dom_phys_raycast.c
│   │
│   ├── render/
│   │   ├── dom_render_api.h
│   │   ├── dom_render_api.c
│   │   ├── software/
│   │   │   ├── dom_render_software.h
│   │   │   └── dom_render_software.c
│   │   ├── gl1/
│   │   │   ├── dom_render_gl1.h
│   │   │   └── dom_render_gl1.c
│   │   ├── gl2/
│   │   │   ├── dom_render_gl2.h
│   │   │   └── dom_render_gl2.c
│   │   ├── dx9/
│   │   │   ├── dom_render_dx9.h
│   │   │   └── dom_render_dx9.c
│   │   └── dx11/
│   │       ├── dom_render_dx11.h
│   │       └── dom_render_dx11.c
│   │
│   ├── audio/
│   │   ├── dom_audio_api.h
│   │   ├── dom_audio_api.c
│   │   ├── sdl_mixer/
│   │   │   ├── dom_audio_sdl.h
│   │   │   └── dom_audio_sdl.c
│   │   └── null/
│   │       ├── dom_audio_null.h
│   │       └── dom_audio_null.c
│   │
│   ├── platform/
│   │   ├── dom_platform_api.h
│   │   ├── dom_platform_api.c
│   │   ├── shared_sdl/
│   │   │   ├── dom_platform_sdl.h
│   │   │   └── dom_platform_sdl.c
│   │   ├── win32/
│   │   │   ├── dom_platform_win32.h
│   │   │   └── dom_platform_win32.c
│   │   ├── linux/
│   │   │   ├── dom_platform_linux.h
│   │   │   └── dom_platform_linux.c
│   │   └── macos/
│   │       ├── dom_platform_macos.h
│   │       └── dom_platform_macos.c
│   │
│   ├── net/
│   │   ├── dom_net_proto.h
│   │   ├── dom_net_proto.c
│   │   ├── dom_net_serialise.h
│   │   ├── dom_net_serialise.c
│   │   ├── dom_net_session.h
│   │   └── dom_net_session.c
│   │
│   ├── ui/
│   │   ├── dom_ui_core.h
│   │   ├── dom_ui_core.c
│   │   ├── dom_ui_widgets.h
│   │   ├── dom_ui_widgets.c
│   │   ├── dom_ui_layout.h
│   │   └── dom_ui_layout.c
│   │
│   ├── io/
│   │   ├── dom_io_filesys.h
│   │   ├── dom_io_filesys.c
│   │   ├── dom_io_save.h
│   │   ├── dom_io_save.c
│   │   ├── dom_io_load.h
│   │   ├── dom_io_load.c
│   │   ├── dom_io_replay.h
│   │   ├── dom_io_replay.c
│   │   ├── dom_io_packs.h
│   │   └── dom_io_packs.c
│   │
│   ├── modding/
│   │   ├── dom_mod_loader.h
│   │   ├── dom_mod_loader.c
│   │   ├── dom_mod_registry.h
│   │   ├── dom_mod_registry.c
│   │   ├── dom_mod_lua.h
│   │   └── dom_mod_lua.c
│   │
│   └── api/
│       ├── dom_api.h
│       └── dom_api.c
│
├── game/
│   ├── shared/
│   │   ├── dm_worldgen.h
│   │   ├── dm_worldgen.c
│   │   ├── dm_archetypes.h
│   │   ├── dm_archetypes.c
│   │   ├── dm_blueprints.h
│   │   ├── dm_blueprints.c
│   │   ├── dm_transport.h
│   │   ├── dm_transport.c
│   │   ├── dm_utilities.h
│   │   ├── dm_utilities.c
│   │   ├── dm_research.h
│   │   ├── dm_research.c
│   │   ├── dm_companies.h
│   │   ├── dm_companies.c
│   │   ├── dm_workers.h
│   │   └── dm_workers.c
│   │
│   ├── client/
│   │   ├── dm_client_main.c
│   │   ├── dm_client_views.h
│   │   ├── dm_client_views.c
│   │   ├── dm_client_hud.h
│   │   ├── dm_client_hud.c
│   │   ├── dm_client_input.h
│   │   ├── dm_client_input.c
│   │   ├── dm_client_menus.h
│   │   ├── dm_client_menus.c
│   │   ├── dm_client_debug.h
│   │   └── dm_client_debug.c
│   │
│   ├── server/
│   │   ├── dm_server_main.c
│   │   ├── dm_server_config.h
│   │   ├── dm_server_config.c
│   │   └── dm_server_admin.c
│   │
│   └── launcher/
│       ├── dm_launcher_main.c
│       └── dm_launcher_config.c
│
├── data/
│   ├── base/
│   │   ├── manifest.json
│   │   ├── prefabs.domdata
│   │   ├── tech_tree.domdata
│   │   ├── graphics_base.domdata
│   │   └── audio_base.domdata
│   │
│   ├── dlc/
│   │   ├── interstellar/
│   │   │   ├── manifest.json
│   │   │   └── interstellar_content.domdata
│   │   ├── extras/
│   │   │   ├── manifest.json
│   │   │   └── extras_content.domdata
│   │   └── wargames/
│   │       ├── manifest.json
│   │       └── wargames_content.domdata
│   │
│   ├── packs/
│   │   ├── gfx_default/
│   │   │   ├── manifest.json
│   │   │   └── gfx_default.dompack
│   │   └── sfx_default/
│   │       ├── manifest.json
│   │       └── sfx_default.dompack
│   │
│   └── templates/
│       ├── example_solo_world.domsave
│       └── example_server_world.domsave
│
├── mods/
│   ├── local/
│   │   └── example_mod/
│   │       ├── mod.json
│   │       ├── prefabs.domdata
│   │       └── scripts/
│   │           └── example.lua
│   │
│   ├── workshop/
│   │   └── .gitkeep
│   │
│   └── disabled/
│       └── .gitkeep
│
├── tools/
│   ├── editor/
│   │   ├── CMakeLists.txt
│   │   ├── editor_main.c
│   │   ├── editor_ui.h
│   │   └── editor_ui.c
│   │
│   ├── devkit/
│   │   ├── schemas/
│   │   │   ├── prefab_schema.json
│   │   │   ├── tech_tree_schema.json
│   │   │   └── savefile_schema.json
│   │   ├── codegen/
│   │   │   ├── generate_bindings.py
│   │   │   └── generate_docs.py
│   │   └── examples/
│   │       └── example_mod_skeleton/
│   │           ├── mod.json
│   │           ├── CMakeLists.txt
│   │           └── README.md
│   │
│   ├── pipeline/
│   │   ├── atlas_builder/
│   │   │   ├── atlas_builder_main.py
│   │   │   └── atlas_config.json
│   │   ├── audio_packer/
│   │   │   └── audio_packer_main.py
│   │   └── mesh_converter/
│   │       └── mesh_converter_main.py
│   │
│   └── debug/
│       ├── graph_inspector/
│       │   └── graph_inspector_main.py
│       ├── field_viewer/
│       │   └── field_viewer_main.py
│       ├── ecs_dump/
│       │   └── ecs_dump_main.c
│       └── replay_viewer/
│           └── replay_viewer_main.c
│
├── tests/
│   ├── unit/
│   │   ├── test_core.c
│   │   ├── test_ecs.c
│   │   ├── test_sim_tick.c
│   │   ├── test_space.c
│   │   └── test_io.c
│   │
│   ├── integration/
│   │   ├── test_full_world.c
│   │   ├── test_networks.c
│   │   └── test_orbits.c
│   │
│   ├── replay/
│   │   ├── replay_case_rail.domreplay
│   │   └── replay_case_power.domreplay
│   │
│   └── perf/
│       ├── perf_many_entities.c
│       └── perf_large_networks.c
│
├── third_party/
│   ├── src/
│   │   ├── lua/
│   │   │   ├── lua.c
│   │   │   └── ...
│   │   └── lz4/
│   │       ├── lz4.c
│   │       └── lz4hc.c
│   │
│   ├── include/
│   │   ├── lua/
│   │   │   └── lua.h
│   │   └── lz4/
│   │       └── lz4.h
│   │
│   └── licenses/
│       ├── LUA-LICENSE.txt
│       └── LZ4-LICENSE.txt
│
├── build/
│   ├── cmake/
│   │   ├── Toolchain-win32.cmake
│   │   ├── Toolchain-linux.cmake
│   │   ├── Toolchain-macos.cmake
│   │   └── DominiumCommon.cmake
│   │
│   ├── scripts/
│   │   ├── configure_release.sh
│   │   ├── configure_debug.sh
│   │   └── build_all.sh
│   │
│   └── output/
│       └── .gitkeep
│
├── packaging/
│   ├── windows/
│   │   ├── dominium_installer.nsi
│   │   └── win_layout.yaml
│   │
│   ├── linux/
│   │   ├── deb/
│   │   │   └── control
│   │   ├── rpm/
│   │   │   └── specfile.spec
│   │   └── appimage/
│   │       └── AppImageBuilder.yml
│   │
│   ├── macos/
│   │   ├── bundle_info.plist
│   │   └── dmg_layout.yaml
│   │
│   └── retro/
│       ├── floppy_layout.txt
│       ├── cd_layout.txt
│       └── sfn_mapping.csv
│
├── scripts/
│   ├── check_style.py
│   ├── regen_docs_index.py
│   ├── update_version.py
│   └── ci_entrypoint.sh
│
└── ports/
    ├── dos/
    │   ├── README.md
    │   └── dom_dos_port_notes.txt
    │
    ├── win9x/
    │   ├── README.md
    │   └── dom_win9x_port_notes.txt
    │
    ├── macos_classic/
    │   ├── README.md
    │   └── dom_macos_classic_port_notes.txt
    │
    └── wasm/
        ├── README.md
        └── dom_wasm_port_notes.txt
You said:
Okay, I want you to give me one message per directory with files, and that message will detail a Dev spec for the files within that dir. It will contain endpoints, methods, functions, declarations, inclusions, prohibitions, prerequisites, etc.
ChatGPT said:
Thought for 8s
GPT-5.1 Thinking • build 2025-12-03
This message is the dev spec for engine/core/ and its files only. Next directories can follow in later messages.
engine/
└── core/
    ├── dom_core_types.h
    ├── dom_core_types.c
    ├── dom_core_log.h
    ├── dom_core_log.c
    ├── dom_core_mem.h
    ├── dom_core_mem.c
    ├── dom_core_fp.h
    ├── dom_core_fp.c
    ├── dom_core_rng.h
    ├── dom_core_rng.c
    ├── dom_core_bits.h
    └── dom_core_bits.c
0. Global rules for engine/core
Scope: foundation for the entire engine. Every other engine module is allowed to depend on core. core depends on nothing except the C89 runtime and standard headers.
Language: C89 only. No C99, no C++ in this directory.
Determinism: all functions must be deterministic for given inputs. No wall clock, no OS randomness, no global hidden state except explicitly documented RNG state.
Allowed headers:
<stddef.h>, <stdint.h> (or local typedefs if you want to avoid C99), <limits.h>, <stdarg.h>, <string.h>, <stdlib.h>, <stdio.h> (for debug logging only behind compile-time flags).
Prohibited:
• Any platform-specific headers (<windows.h>, <unistd.h>, <pthread.h>, etc.).
• Floating point math in any function that may be used by simulation code.
• Dynamic allocation in hot loops unless explicitly documented and justified (and never from sim tick paths).
• Global mutable state except in controlled modules like log and rng, with explicit init/reset functions.
Namespace: all public symbols start with dom_ or DOM_. No bare log, min, max, etc.
Error handling: no exit() from these modules. Return error codes or assert in debug builds, clamp in release builds.

1. dom_core_types.[hc]
Purpose: single source of truth for fixed-size integer types, basic enums, and core engine typedefs. All other modules include this first.
Header: dom_core_types.h
Responsibilities:
• Define basic scalar types (dom_u8, dom_i32, etc.).
• Define core common enums (e.g. DomResult, DomBool).
• Define compile-time configuration macros (endianness flags, alignment assumptions).
• Provide DOM_STATIC_ASSERT macro for compile-time size checks.
Key contents:
• Include guards: #ifndef DOM_CORE_TYPES_H etc.
• Includes: minimal: <stddef.h>, <limits.h>. If you use <stdint.h>, wrap with fallback typedefs for old compilers.
Typedefs (examples, not exhaustive):
typedef unsigned char      dom_u8;
typedef signed   char      dom_i8;
typedef unsigned short     dom_u16;
typedef signed   short     dom_i16;
typedef unsigned int       dom_u32;
typedef signed   int       dom_i32;
typedef unsigned long long dom_u64;
typedef signed   long long dom_i64;

typedef dom_u8  dom_bool8;   /* 0 or 1 */
typedef dom_u32 dom_bool32;  /* kept for alignment */
Result / error code enum:
typedef enum DomResult {
    DOM_OK = 0,
    DOM_ERR_UNKNOWN = 1,
    DOM_ERR_INVALID_ARG = 2,
    DOM_ERR_OUT_OF_MEMORY = 3,
    DOM_ERR_OVERFLOW = 4,
    DOM_ERR_UNDERFLOW = 5,
    DOM_ERR_BOUNDS = 6,
    DOM_ERR_NOT_FOUND = 7,
    DOM_ERR_NOT_IMPLEMENTED = 8,
    DOM_ERR_IO = 9
    /* extend carefully, keep stable */
} DomResult;
Static assert macro:
#define DOM_STATIC_ASSERT(cond, msg) typedef char dom_static_assert_##msg[(cond) ? 1 : -1]
Platform assumptions (explicit):
• DOM_LITTLE_ENDIAN macro (1 or 0).
• DOM_PTR_SIZE (4 or 8).
Public API: this header exposes types only. No functions.
Implementation file dom_core_types.c:
Should be minimal; primarily used for:
• A function that returns build-time configuration, e.g.:
const char *dom_core_build_info(void);
DomResult dom_core_init(void);  /* if needed */
Prohibitions:
• No other modules’ includes except dom_core_types.h.
• No global mutable state other than optional build-info strings.

2. dom_core_log.[hc]
Purpose: central logging and assertion abstraction. Must be deterministic in message content and ordering. Actual IO routing can be platform-specific via callbacks.
Header: dom_core_log.h
Responsibilities:
• Define log levels.
• Provide logging API used across engine.
• Provide assertion macro that integrates with log.
Typical enums:
typedef enum DomLogLevel {
    DOM_LOG_DEBUG = 0,
    DOM_LOG_INFO  = 1,
    DOM_LOG_WARN  = 2,
    DOM_LOG_ERROR = 3,
    DOM_LOG_FATAL = 4
} DomLogLevel;
Public API:
typedef void (*DomLogSinkFn)(DomLogLevel level,
                             const char *file,
                             int line,
                             const char *msg,
                             void *user_data);

/* Initialize logging with a sink (can be null for default stderr in dev builds). */
void dom_log_init(DomLogSinkFn sink, void *user_data);

/* Optional: reset / shutdown if needed. */
void dom_log_shutdown(void);

/* Core logging function; do not call directly, use macros. */
void dom_log_message(DomLogLevel level,
                     const char *file,
                     int line,
                     const char *fmt,
                     ...);

/* Macros for convenience; compiled out in release if you want. */
#define DOM_LOG_DEBUG(fmt, ...) dom_log_message(DOM_LOG_DEBUG, __FILE__, __LINE__, fmt, __VA_ARGS__)
#define DOM_LOG_INFO(fmt, ...)  dom_log_message(DOM_LOG_INFO,  __FILE__, __LINE__, fmt, __VA_ARGS__)
#define DOM_LOG_WARN(fmt, ...)  dom_log_message(DOM_LOG_WARN,  __FILE__, __LINE__, fmt, __VA_ARGS__)
#define DOM_LOG_ERROR(fmt, ...) dom_log_message(DOM_LOG_ERROR, __FILE__, __LINE__, fmt, __VA_ARGS__)
Assertions:
#ifdef DOM_DEBUG
  #define DOM_ASSERT(cond) \
    do { if (!(cond)) dom_log_assert_fail(#cond, __FILE__, __LINE__); } while (0)
#else
  #define DOM_ASSERT(cond) ((void)0)
#endif

void dom_log_assert_fail(const char *expr, const char *file, int line);
Determinism constraints:
• dom_log_message must not affect simulation state.
• Logging content does not change simulation outcome.
• In replay/lockstep modes you may disable logging or route to deterministic buffers.
Implementation file dom_core_log.c:
Responsibilities:
• Maintain global sink pointer + user data.
• Provide default sink that writes to stderr in dev builds, or no-op in release.
• Implement dom_log_message using vsnprintf into a fixed-size local buffer, then call sink.
Prohibitions:
• No dynamic allocation per log call.
• No platform headers; platform-specific sink is installed by engine/platform.
• No re-entrancy issues: simple single-thread assumption here; multithread safety handled at higher level if needed.

3. dom_core_mem.[hc]
Purpose: deterministic memory abstraction for engine code. Thin wrappers around malloc/free + optional arenas, with predictable failure semantics. Simulation code should not call raw malloc directly.
Header: dom_core_mem.h
Responsibilities:
• Provide basic alloc/free wrappers.
• Provide arena allocator (linear region) for deterministic bulk allocations.
• Provide zeroing helpers.
Core types:
typedef struct DomArena {
    unsigned char *base;
    dom_u64        capacity;
    dom_u64        used;
} DomArena;
Public API:
/* Low-level heap wrappers (engine-level, not sim-tick). */
void *dom_alloc(dom_u64 size);
void  dom_free(void *ptr);
void *dom_realloc(void *ptr, dom_u64 new_size);

/* Deterministic zero-init helpers. */
void *dom_alloc_zero(dom_u64 size);

/* Arena management – for startup/load/editor, not per-tick. */
DomResult dom_arena_init(DomArena *arena, void *buffer, dom_u64 size);
void     *dom_arena_alloc(DomArena *arena, dom_u64 size);
void     *dom_arena_alloc_zero(DomArena *arena, dom_u64 size);
void      dom_arena_reset(DomArena *arena);

/* Alignment helpers. */
dom_u64 dom_align_up(dom_u64 value, dom_u64 align);
dom_u64 dom_align_down(dom_u64 value, dom_u64 align);
Constraints:
• dom_alloc may return NULL; caller must handle.
• Simulation tick paths should generally not call dom_alloc or dom_realloc.
• For hard determinism, use arenas or preallocated buffers. That policy is enforced at higher layers; this module only provides primitives.
Implementation file dom_core_mem.c:
Responsibilities:
• Implement wrappers on top of malloc/free/realloc.
• Implement trivial linear arena; no free in the middle, only reset.
Prohibitions:
• No global implicit arena.
• No “auto-growing” global allocators that hide OOM.
• No logging here except via dom_core_log (and only for non-sim code paths).

4. dom_core_fp.[hc] (fixed-point maths)
Purpose: canonical fixed-point arithmetic for deterministic simulation. No floats, no reliance on architecture-specific behaviour.
Header: dom_core_fp.h
Responsibilities:
• Define fixed-point types (q16.16, q32.32).
• Provide core operations: add, sub, mul, div, min, max, clamp, conversion to/from integers.
• Provide safe, wraparound semantics for overflow as per determinism spec.
Types:
typedef dom_i32 dom_q16_16;
typedef dom_i64 dom_q32_32;
Core operations (examples):
/* Addition and subtraction: simple integer add/sub (wraparound). */
static inline dom_q16_16 dom_q16_add(dom_q16_16 a, dom_q16_16 b);
static inline dom_q16_16 dom_q16_sub(dom_q16_16 a, dom_q16_16 b);

/* Multiplication/division with shift. */
dom_q16_16 dom_q16_mul(dom_q16_16 a, dom_q16_16 b);
dom_q16_16 dom_q16_div(dom_q16_16 a, dom_q16_16 b); /* b!=0; handle zero deterministically */

/* Conversion. */
dom_q16_16 dom_q16_from_int(dom_i32 v);
dom_i32    dom_q16_to_int_floor(dom_q16_16 v);
dom_i32    dom_q16_to_int_round(dom_q16_16 v);

/* Clamp. */
dom_q16_16 dom_q16_clamp(dom_q16_16 v, dom_q16_16 lo, dom_q16_16 hi);

/* Same for q32_32. */
dom_q32_32 dom_q32_mul(dom_q32_32 a, dom_q32_32 b);
dom_q32_32 dom_q32_div(dom_q32_32 a, dom_q32_32 b);
dom_q32_32 dom_q32_from_int(dom_i64 v);
dom_i64    dom_q32_to_int_floor(dom_q32_32 v);
Determinism and error handling:
• Multiplication uses 64-bit or 128-bit intermediates as needed, then shifts; documented exactly.
• Division by zero handled deterministically: return 0 and optionally set a flag (or report via higher-level error).
• No transcendental functions (sin, cos, etc.). Those belong in a separate, explicitly approximated module if ever needed, not in core_fp.
Implementation dom_core_fp.c:
• Implement the non-inline functions.
• Use explicit casts to avoid UB on signed overflow; use unsigned intermediates where necessary, consistent with earlier determinism spec.
Prohibitions:
• No double or float anywhere.
• No platform-specific intrinsics that change behaviour across targets.

5. dom_core_rng.[hc]
Purpose: deterministic pseudo-random number generator for simulation and tools, with explicit seeding and reproducibility. All RNG state is explicit or globally controlled.
Header: dom_core_rng.h
Responsibilities:
• Define a RNG state struct.
• Provide init/seed functions.
• Provide basic uniform RNG functions.
• Provide stable helper functions (e.g. range, shuffle) that must never change algorithm once released.
Types:
typedef struct DomRngState {
    dom_u64 s0;
    dom_u64 s1;
} DomRngState;
Public API:
/* Seed state with 64-bit value, deterministic. */
void dom_rng_seed(DomRngState *st, dom_u64 seed);

/* Next 64-bit random integer. */
dom_u64 dom_rng_next_u64(DomRngState *st);

/* Convenience: 32-bit. */
dom_u32 dom_rng_next_u32(DomRngState *st);

/* Uniform [0, n) with rejection to avoid bias. n>0 required. */
dom_u32 dom_rng_range_u32(DomRngState *st, dom_u32 n);

/* Global default RNG (for tools, non-sim). */
void    dom_rng_global_seed(dom_u64 seed);
dom_u32 dom_rng_global_u32(void);
Algorithm:
• Choose something simple and stable (e.g. xoroshiro128** or splitmix64). Once chosen, it is frozen. Changing algorithm is a format-breaking change and must be versioned.
Determinism:
• Given same initial DomRngState, sequence is identical across platforms.
• No time() or OS entropy inside core_rng; seeding comes from higher-level code.
Implementation dom_core_rng.c:
• Implement chosen algorithm with fixed bitwise operations.
• Ensure no UB via shifts; mask appropriately.
Prohibitions:
• No floating-point variants in this module.
• No calls to system RNG or OS APIs.

6. dom_core_bits.[hc]
Purpose: bit operations and small integer utilities that must be cross-platform and deterministic: bit scans, popcount, power-of-two rounding, etc.
Header: dom_core_bits.h
Responsibilities:
• Provide bit manipulation primitives without relying on compiler builtins.
• Provide integer min/max/clamp macros or functions, if you want them centralised.
Public API:
/* Bit operations: */

/* Returns index of highest set bit in x, or -1 if x==0. */
int dom_bit_scan_reverse_u32(dom_u32 x);
int dom_bit_scan_reverse_u64(dom_u64 x);

/* Returns index of lowest set bit in x, or -1 if x==0. */
int dom_bit_scan_forward_u32(dom_u32 x);
int dom_bit_scan_forward_u64(dom_u64 x);

/* Count number of set bits (popcount). */
dom_u32 dom_popcount_u32(dom_u32 x);
dom_u32 dom_popcount_u64(dom_u64 x);

/* Return next power of two >= x; returns 1 for x<=1, 0 on overflow. */
dom_u32 dom_next_power_of_two_u32(dom_u32 x);
dom_u64 dom_next_power_of_two_u64(dom_u64 x);

/* Generic min/max/clamp (prefer as static inline). */
#define DOM_MIN(a,b) (( (a) < (b) ) ? (a) : (b))
#define DOM_MAX(a,b) (( (a) > (b) ) ? (a) : (b))
#define DOM_CLAMP(v,lo,hi) (DOM_MAX((lo), DOM_MIN((v),(hi))))
Implementation dom_core_bits.c:
• Implement bit scans and popcounts via portable loops or word-level tricks; do not rely on __builtin_clz unless you gate by #ifdef and provide a pure-C fallback.
Prohibitions:
• No inline assembly.
• No reliance on UB shifting by word size, etc.

You now have a deterministic, minimal, and coherent contract for engine/core/. All higher layers (sim, ecs, spatial, etc.) should treat this as their only allowed “stdlib”.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev spec for engine/sim/ only.
engine/
└── sim/
    ├── dom_sim_tick.h
    ├── dom_sim_tick.c
    ├── dom_sim_lanes.h
    ├── dom_sim_lanes.c
    ├── dom_sim_events.h
    ├── dom_sim_events.c
    ├── dom_sim_jobs.h
    ├── dom_sim_jobs.c
    ├── dom_sim_world.h
    ├── dom_sim_world.c
    ├── dom_sim_network_power.h
    ├── dom_sim_network_power.c
    ├── dom_sim_network_fluid.h
    ├── dom_sim_network_fluid.c
    ├── dom_sim_network_data.h
    ├── dom_sim_network_data.c
    ├── dom_sim_network_thermal.h
    ├── dom_sim_network_thermal.c
    ├── dom_sim_orbit.h
    ├── dom_sim_orbit.c
    ├── dom_sim_economy.h
    └── dom_sim_economy.c
0. Global rules for engine/sim
Scope: deterministic simulation kernel and networks. Everything in this directory obeys the determinism spec you already have (tick pipeline, lanes, merge, integer-only).
Language: C89 only.
Includes:
Every .c here may include:
• dom_core_types.h
• dom_core_bits.h
• dom_core_fp.h
• dom_core_rng.h (for controlled, seeded sim RNG only)
• dom_ecs.h (entity/component access)
• local sim headers.
Never include platform headers or rendering or UI.
Never include <time.h>, <math.h>, <float.h>.
No malloc in per-tick hot paths.
Numeric rules:
• No float or double.
• Only integer and fixed-point as defined in core_fp.
• All operations must be deterministic and platform-independent.
Temporal rules:
• Only dom_sim_tick controls progression of ticks.
• No internal subsystem implements its own notion of “time” beyond integer tick counters and multi-rate schedules.
Lane rules:
• All lane concepts go through dom_sim_lanes.
• Subsystems that need lane awareness only use lane IDs provided there.
Event/Job rules:
• All messaging and jobs go through dom_sim_events / dom_sim_jobs.
• No ad-hoc global queues in other modules.

1. dom_sim_tick.[hc] — Tick pipeline and scheduler
Purpose: single authority for the 7-phase tick pipeline and multi-rate scheduling. All simulation advancement goes through here.
Header: dom_sim_tick.h
Responsibilities:
• Define tick ID type and canonical UPS values.
• Expose API to initialise, advance, and query simulation time.
• Expose configuration for multi-rate system scheduling.
• Expose hooks that call into subsystems in the correct phase order.
Types:
typedef dom_u64 DomTickId;

typedef struct DomSimConfig {
    dom_u32 target_ups;      /* canonical UPS */
    dom_u32 num_lanes;       /* virtual lanes */
    dom_u32 reserved[6];     /* for future */
} DomSimConfig;

typedef struct DomSimTime {
    DomTickId tick;
    dom_u32   ups;           /* effective UPS */
} DomSimTime;
Public API:
/* Initialise simulation tick controller. Must be called once before any sim use. */
DomResult dom_sim_tick_init(const DomSimConfig *cfg);

/* Hard reset simulation tick state (development / load only). */
void      dom_sim_tick_reset(DomTickId start_tick);

/* Advance simulation by exactly one tick. This is the high-level pipeline entry point. */
DomResult dom_sim_tick_step(void);

/* Query current tick/time. */
DomTickId dom_sim_tick_current(void);
DomSimTime dom_sim_tick_get_time(void);

/* Configure effective UPS (for degradation under load). */
DomResult dom_sim_tick_set_effective_ups(dom_u32 ups);
dom_u32   dom_sim_tick_get_effective_ups(void);
Internal (but visible) phase hooks, called by dom_sim_tick_step in strict sequence:
void dom_sim_phase_input(void);
void dom_sim_phase_pre_state(void);
void dom_sim_phase_simulation(void);     /* lane execution dispatch */
void dom_sim_phase_networks(void);       /* power/fluid/data/thermal/orbit */
void dom_sim_phase_merge(void);
void dom_sim_phase_post_process(void);
void dom_sim_phase_finalize(void);
Constraints:
• dom_sim_tick_step is the only function allowed to call the phase functions in production code.
• Phase functions are void and must not fail; they handle internal clamp/failover and write error events if needed.
• Multi-rate scheduling is enforced inside the phase functions, not ad-hoc elsewhere.
Implementation dom_sim_tick.c:
• Stores static DomSimConfig and current DomSimTime.
• Implements dom_sim_tick_step as:
1. Increment tick.
2. Invoke phases in order.
3. No early exits except for catastrophic error (return non-OK).
• Performs staggering decisions (e.g. network/thermal/economy at lower frequencies) via tick mod operations and constants that live in a config table (no magic numbers scattered in other modules).
Prohibitions:
• No lane-internal logic here (that is dom_sim_lanes).
• No ECS entity iteration here (phases call subsystems that do that).
• No direct network maths here.

2. dom_sim_lanes.[hc] — Virtual lane management
Purpose: deterministic mapping from entities to lanes, and per-lane execution control.
Header: dom_sim_lanes.h
Responsibilities:
• Define lane ID type.
• Provide mapping from entity IDs to lanes.
• Provide per-lane iteration helpers for systems.
• Provide per-lane buffers for merges (if needed by callers).
Types:
typedef dom_u32 DomLaneId;

typedef struct DomLaneConfig {
    dom_u32 num_lanes;   /* 1..N */
} DomLaneConfig;
Public API:
DomResult dom_sim_lanes_init(const DomLaneConfig *cfg);

/* Map entity id to lane; stable for lifetime. */
DomLaneId dom_sim_lane_for_entity(dom_u64 entity_id);

/* Get global lane count. */
dom_u32   dom_sim_lane_count(void);

/* Run a lane callback for each lane in deterministic order (0..N-1). */
typedef void (*DomLaneCallback)(DomLaneId lane_id, void *user_data);
void dom_sim_lanes_for_each(DomLaneCallback cb, void *user_data);
Optional lane-local scheduling support:
/* Per-lane system scheduling convenience, used inside sim systems. */
typedef void (*DomLaneSystemFn)(DomLaneId lane_id, void *ctx);

void dom_sim_lanes_run_system(DomLaneSystemFn fn, void *ctx);
Implementation dom_sim_lanes.c:
• Holds static num_lanes.
• Implements dom_sim_lane_for_entity(eid) = eid % num_lanes.
• No threading primitives here; actual thread use is in a higher-level executor if you add one. This module just defines IDs and order.
Prohibitions:
• No dynamic assignment/migration of lanes.
• No dependence on physical CPU threads.
• No knowledge of systems or components.

3. dom_sim_events.[hc] — Event buses and message queues
Purpose: implement the local/lane/cross-lane/global event queues and command buffers per your determinism spec.
Header: dom_sim_events.h
Responsibilities:
• Define message/event header struct.
• Implement the 4 event buses plus command buffers.
• Provide API for subsystems to emit and consume messages.
• Guarantee ordering and latency constraints.
Types (condensed):
typedef dom_u16 DomMsgType;
typedef dom_u16 DomMsgFlags;

typedef struct DomSimMessageHeader {
    DomMsgType  type;
    DomMsgFlags flags;
    dom_u32     system_id;
    dom_u64     sender;       /* entity handle or 0 */
    dom_u64     receiver;     /* entity handle or 0 (broadcast) */
    DomTickId   tick_created;
} DomSimMessageHeader;

#define DOM_SIM_MESSAGE_PAYLOAD_BYTES 112

typedef struct DomSimMessage {
    DomSimMessageHeader header;
    dom_u8              payload[DOM_SIM_MESSAGE_PAYLOAD_BYTES];
} DomSimMessage;
Bus types (opaque to users):
typedef struct DomSimLocalBus   DomSimLocalBus;
typedef struct DomSimLaneBus    DomSimLaneBus;
typedef struct DomSimCrossBus   DomSimCrossBus;
typedef struct DomSimGlobalBus  DomSimGlobalBus;
Public API overview:
Initialisation/reset:
DomResult dom_sim_events_init(void);
void      dom_sim_events_reset(void);
Emit/consume functions (examples, not exhaustive):
/* Local to a specific entity. */
DomResult dom_sim_events_local_emit(dom_u64 entity, const DomSimMessage *msg);
DomResult dom_sim_events_local_consume(dom_u64 entity,
                                       DomSimMessage *out_msg);

/* Lane-level bus. */
DomResult dom_sim_events_lane_emit(DomLaneId lane, const DomSimMessage *msg);
DomResult dom_sim_events_lane_consume(DomLaneId lane,
                                      DomSimMessage *out_msg);

/* Cross-lane bus: visible next tick. */
DomResult dom_sim_events_cross_emit(DomLaneId target_lane,
                                    const DomSimMessage *msg);

/* Global bus: broadcast to systems/entities next tick. */
DomResult dom_sim_events_global_emit(const DomSimMessage *msg);
Tick-phase integration entry points, called from dom_sim_tick:
/* Called in Pre-State phase: deliver last tick's global + cross-lane into local/lane queues. */
void dom_sim_events_phase_pre_state(void);

/* Called in Merge phase: move cross-lane FIFO into per-lane next-tick buffers. */
void dom_sim_events_phase_merge(void);

/* Called in Finalize phase: swap buffers, clear flags. */
void dom_sim_events_phase_finalize(void);
Command buffers (structural ops) are defined here too:
typedef dom_u16 DomCommandType;

typedef struct DomSimCommand {
    DomCommandType type;
    dom_u64        entity;
    dom_u32        param_a;
    dom_u32        param_b;
    dom_u64        data[2];
} DomSimCommand;

DomResult dom_sim_command_emit(DomLaneId lane, const DomSimCommand *cmd);
/* Called from Merge/Post-Process: */
void      dom_sim_command_drain_for_lane(DomLaneId lane);
Constraints:
• All buffers are fixed-size ring buffers with compile-time capacities.
• On overflow, follow deterministic oldest-drop policy and set global overflow flags (no silent loss).
Implementation dom_sim_events.c:
• Implements ring buffers and queues grouped by lane/global.
• Implements deterministic ordering: FIFO by insertion, plus tie-breakers if you sort.
• Only dom_sim_tick should drive phase methods.
Prohibitions:
• No simulation logic here (no machines, no jobs).
• No ECS access beyond entity handles.
• No dynamic memory allocation in tick-path functions.

4. dom_sim_jobs.[hc] — Job system core
Purpose: implement deterministic job queues and worker assignment as per job spec (construction, hauling, maintenance, etc.).
Header: dom_sim_jobs.h
Responsibilities:
• Define DomSimJob struct.
• Implement local/lane/global job queues.
• Implement deterministic worker assignment and task dispatch.
Types:
typedef dom_u32 DomJobType;

typedef struct DomSimJob {
    DomJobType job_type;
    dom_u32    priority;        /* lower = higher priority */
    dom_u64    requester;       /* entity */
    dom_u64    assignee;        /* worker entity or 0 */
    dom_u64    target;          /* entity or encoded tile */
    DomTickId  tick_created;
    dom_u32    est_ticks;
    dom_u32    payload[8];      /* job-type specific */
} DomSimJob;
Public API:
Initialisation:
DomResult dom_sim_jobs_init(void);
void      dom_sim_jobs_reset(void);
Queue operations:
/* Entity-level job emission. */
DomResult dom_sim_jobs_emit_local(dom_u64 entity, const DomSimJob *job);

/* Lane-level job promotion and dispatch. */
void      dom_sim_jobs_phase_simulation(void); /* called from sim phase */
void      dom_sim_jobs_phase_post(void);       /* cleanup, completion */
Worker assignment:
/* Called by worker systems to request next job for a worker entity. */
DomResult dom_sim_jobs_assign_to_worker(dom_u64 worker_entity,
                                        DomSimJob *out_job);

/* Called when job completes or fails. */
void      dom_sim_jobs_complete(const DomSimJob *job, dom_bool8 success);
Constraints:
• All prioritisation based on priority, job_type, requester, tick_created, and worker_id for tie-breaks. Algorithm must be frozen and documented.
• No pathfinding here; only assignment. Path cost estimates can come from other modules via integer inputs.
Implementation dom_sim_jobs.c:
• Uses arrays + stable sort or insertion order to maintain deterministic ordering.
• Integrates with events: emits completion/failure events where appropriate.
Prohibitions:
• No direct manipulation of worker components beyond job ID assignment; worker behaviour is in their system.
• No floats for distance or cost.

5. dom_sim_world.[hc] — World/universe hierarchy and registry
Purpose: define and manage the logical structure: universe → galaxy → system → planet → surface → region/chunk.
Header: dom_sim_world.h
Responsibilities:
• Define IDs for universe, galaxy, system, planet, surface.
• Define a small registry for these entities and their metadata.
• Provide lookup from IDs to coordinate frames and surface roots.
Types (example):
typedef dom_u32 DomUniverseId;
typedef dom_u32 DomGalaxyId;
typedef dom_u32 DomSystemId;
typedef dom_u32 DomPlanetId;
typedef dom_u32 DomSurfaceId;

typedef struct DomSurfaceMeta {
    DomSurfaceId id;
    DomPlanetId  planet;
    /* grid origin / radius etc. */
    dom_i64      origin_x;
    dom_i64      origin_y;
    dom_i64      radius_m;   /* half-extent of used area */
    dom_u32      flags;
} DomSurfaceMeta;
Public API:
DomResult dom_sim_world_init(void);
void      dom_sim_world_reset(void);

/* Default world selectors (Earth/Sol/MilkyWay). */
DomUniverseId dom_sim_world_default_universe(void);
DomGalaxyId   dom_sim_world_default_galaxy(void);
DomSystemId   dom_sim_world_default_system(void);
DomPlanetId   dom_sim_world_default_planet(void);
DomSurfaceId  dom_sim_world_default_surface(void);

/* Creation of additional surfaces/planets/systems for advanced use. */
DomResult dom_sim_world_create_surface(DomPlanetId planet,
                                       const DomSurfaceMeta *meta,
                                       DomSurfaceMeta       *out_meta);

/* Lookup metadata. */
const DomSurfaceMeta *dom_sim_world_get_surface(DomSurfaceId id);
Integration with spatial:
/* Map world coordinates to surface-local grid root/context. */
DomResult dom_sim_world_surface_of_coord(dom_i64 x, dom_i64 y, DomSurfaceId *out_surface);
Implementation dom_sim_world.c:
• Stores small fixed-size arrays of metas.
• Provides deterministic IDs and stable ordering.
• No heavy data; actual spatial/chunk data is in engine/spatial.
Prohibitions:
• No chunk iteration.
• No ECS stuff.
• No time or orbits.

6. Network modules
These are parallel patterns: power, fluid, data, thermal. They all follow the same overall structure.
6.1 dom_sim_network_power.[hc]
Purpose: deterministic LV/HV power network solver.
Header responsibilities:
• Define power node and edge types (opaque handles).
• Provide API to rebuild connectivity when topology changes.
• Provide per-tick update entrypoints for power flows.
• Expose per-entity interface functions (attach/detach nodes, set generator/load params, query results).
Key types (opaque IDs):
typedef dom_u32 DomPowerNodeId;
typedef dom_u32 DomPowerNetId;

typedef struct DomPowerNodeParams {
    dom_q32_32 max_gen;   /* W or kW in fixed-point */
    dom_q32_32 max_load;
    dom_q32_32 priority;  /* load shedding priority */
    dom_u32    flags;
} DomPowerNodeParams;

typedef struct DomPowerNodeState {
    dom_q32_32 actual_gen;
    dom_q32_32 actual_load;
    dom_q32_32 voltage;   /* optional */
} DomPowerNodeState;
Public API (sketch):
DomResult dom_sim_power_init(void);
void      dom_sim_power_reset(void);

/* Called when an entity gains/loses power component. */
DomPowerNodeId dom_sim_power_register_node(dom_u64 entity, const DomPowerNodeParams *params);
void           dom_sim_power_unregister_node(DomPowerNodeId node);

/* Connectivity: add/remove power lines between nodes. */
DomResult dom_sim_power_connect(DomPowerNodeId a, DomPowerNodeId b, dom_q32_32 capacity);
DomResult dom_sim_power_disconnect(DomPowerNodeId a, DomPowerNodeId b);

/* Per-tick update from Networks phase. */
void      dom_sim_power_phase_networks(void);

/* Query state after networks phase. */
const DomPowerNodeState *dom_sim_power_get_state(DomPowerNodeId node);
Implementation:
• Graph partition into components; each component solves total_gen vs total_load with deterministic ratio application.
• No real-world electrical transients; just discrete tick balances.
Prohibitions:
• No floats.
• No iterative numeric solvers with unstable convergence.

6.2 dom_sim_network_fluid.[hc]
Purpose: fluid network (pipes, tanks).
Header responsibilities:
• Define fluid node and edge IDs.
• Define fluid parameters (capacity, pressure, volume).
• Network solve API.
Types:
typedef dom_u32 DomFluidNodeId;

typedef struct DomFluidNodeParams {
    dom_q32_32 max_volume;
    dom_q32_32 max_flow;
    dom_u32    fluid_type;   /* water, oil, steam... */
} DomFluidNodeParams;

typedef struct DomFluidNodeState {
    dom_q32_32 volume;
    dom_q32_32 pressure;
} DomFluidNodeState;
Public API:
DomResult dom_sim_fluid_init(void);
void      dom_sim_fluid_reset(void);

DomFluidNodeId dom_sim_fluid_register_node(dom_u64 entity,
                                           const DomFluidNodeParams *params);
void           dom_sim_fluid_unregister_node(DomFluidNodeId node);

DomResult dom_sim_fluid_connect(DomFluidNodeId a, DomFluidNodeId b, dom_q32_32 capacity);
DomResult dom_sim_fluid_disconnect(DomFluidNodeId a, DomFluidNodeId b);

/* Network update (every N ticks). */
void      dom_sim_fluid_phase_networks(void);

const DomFluidNodeState *dom_sim_fluid_get_state(DomFluidNodeId node);
Implementation:
• Simple linear conductance: flow = clamp(G*(P_i - P_j), -cap, +cap).
• Node volumes updated by sum of flows.
• Pressure as deterministic function of volume.
Prohibitions:
• No partial updates between ticks.
• No continuous integration.

6.3 dom_sim_network_data.[hc]
Purpose: discrete data packets and logical “signals” (for control circuits).
Header responsibilities:
• Implement packet routing (one hop/tick).
• Implement “signal” sums (1-tick latency).
Types:
typedef dom_u32 DomDataNodeId;

typedef struct DomDataPacket {
    dom_u64 src;
    dom_u64 dst;
    dom_u32 payload[4];
    DomTickId tick_created;
} DomDataPacket;
Public API:
DomResult dom_sim_data_init(void);
void      dom_sim_data_reset(void);

DomDataNodeId dom_sim_data_register_node(dom_u64 entity);
void          dom_sim_data_unregister_node(DomDataNodeId node);

DomResult dom_sim_data_connect(DomDataNodeId a, DomDataNodeId b);
DomResult dom_sim_data_disconnect(DomDataNodeId a, DomDataNodeId b);

/* Emit and receive packets. */
DomResult dom_sim_data_send(DomDataNodeId from, const DomDataPacket *pkt);
DomResult dom_sim_data_recv(DomDataNodeId node, DomDataPacket *out_pkt);

/* Per-tick network phase. */
void      dom_sim_data_phase_networks(void);
Signals:
• Separate API for simple integer signal channels (Factorio-style) with 1-tick latency.
Prohibitions:
• No best-effort unreliable semantics; either delivered deterministically or dropped due to deterministic overflow.

6.4 dom_sim_network_thermal.[hc]
Purpose: simplified heat and environmental diffusion.
Header responsibilities:
• Define thermal cell and node representations.
• Provide periodic lattice update.
Types:
typedef dom_u32 DomThermalNodeId;

typedef struct DomThermalNodeState {
    dom_q16_16 temp;
} DomThermalNodeState;
Public API:
DomResult dom_sim_thermal_init(void);
void      dom_sim_thermal_reset(void);

DomThermalNodeId dom_sim_thermal_register_node(dom_u64 entity);
void             dom_sim_thermal_unregister_node(DomThermalNodeId node);

/* Periodic update (every M ticks) called from networks phase. */
void             dom_sim_thermal_phase_networks(void);

const DomThermalNodeState *dom_sim_thermal_get_state(DomThermalNodeId node);
Implementation:
• Deterministic stencil diffusion on grid or graph.
• No floats.

7. dom_sim_orbit.[hc] — Orbital / space “on rails” mechanics
Purpose: deterministic “on rails” orbital mechanics for ships, stations, and bodies, using discrete states and pre-computed paths, not real physics integration.
Header: dom_sim_orbit.h
Responsibilities:
• Define IDs for orbital bodies (stars, planets, moons, stations).
• Define simplified orbital elements (integer/fixed point).
• Provide transform from orbital position to spatial frame.
• Provide tick update for orbital states.
Types:
typedef dom_u32 DomOrbitBodyId;

typedef struct DomOrbitElements {
    dom_q32_32 semi_major_axis;
    dom_q32_32 eccentricity;
    dom_q32_32 inclination;
    dom_q32_32 arg_periapsis;
    dom_q32_32 long_ascending;
    dom_q32_32 mean_anomaly_at_epoch;
    DomTickId  epoch_tick;
} DomOrbitElements;

typedef struct DomOrbitBody {
    DomOrbitBodyId id;
    DomOrbitBodyId parent;     /* 0 = root (star) */
    DomOrbitElements elems;
} DomOrbitBody;
Public API:
DomResult dom_sim_orbit_init(void);
void      dom_sim_orbit_reset(void);

DomOrbitBodyId dom_sim_orbit_register_body(const DomOrbitBody *body);
const DomOrbitBody *dom_sim_orbit_get_body(DomOrbitBodyId id);

/* Per-tick update: recompute positions in parent frame. */
void      dom_sim_orbit_phase_networks(void);

/* Query position at current tick in integer space coordinates. */
void      dom_sim_orbit_get_position(DomOrbitBodyId id,
                                     dom_i64 *out_x,
                                     dom_i64 *out_y,
                                     dom_i64 *out_z);
Implementation:
• “Orbital mechanics on rails”: use pre-computed or approximated curves updated deterministically per tick (no live Kepler solver with floats).
Prohibitions:
• No double/float trig here.
• No N-body interactions.

8. dom_sim_economy.[hc] — Macro economy + markets
Purpose: deterministic property/company/world economic model and markets.
Header: dom_sim_economy.h
Responsibilities:
• Define basic economic aggregates.
• Provide tick-driven updates at low frequency.
• Provide price indices accessible by game systems.
Types:
typedef struct DomEconomyGlobal {
    dom_u64  tick_last_update;
    dom_q32_32 price_index[64];   /* commodity buckets */
    dom_q32_32 demand_index[64];
    dom_q32_32 supply_index[64];
} DomEconomyGlobal;
Public API:
DomResult dom_sim_economy_init(void);
void      dom_sim_economy_reset(void);

/* Called from networks or post-process phase every K ticks. */
void      dom_sim_economy_phase_update(void);

/* Queries. */
const DomEconomyGlobal *dom_sim_economy_get_global(void);

/* Hooks for game systems to report production/consumption. */
void dom_sim_economy_report_production(dom_u32 commodity_id, dom_q32_32 amount);
void dom_sim_economy_report_consumption(dom_u32 commodity_id, dom_q32_32 amount);
Implementation:
• Integer/fixed-point trend updates.
• No stochastic noise.
• All updates are based on deterministic formulas.
Prohibitions:
• No random shocks.
• No floating-point regressions.

That’s the contract for engine/sim/. Next directory will build on this (engine/ecs/).
You said:
Next
ChatGPT said:
Thought for 18s
GPT-5.1 Thinking • build 2025-12-03
This message is the dev spec for engine/spatial/ only.
engine/
└── spatial/
    ├── dom_spatial_types.h
    ├── dom_spatial_grid.h
    ├── dom_spatial_grid.c
    ├── dom_spatial_chunk.h
    ├── dom_spatial_chunk.c
    ├── dom_spatial_voxel.h
    ├── dom_spatial_voxel.c
    ├── dom_spatial_region.h
    ├── dom_spatial_region.c
    ├── dom_spatial_index.h
    ├── dom_spatial_index.c
    ├── dom_spatial_query.h
    └── dom_spatial_query.c
Global rules for this directory:
• Language: C89 only.
• Includes allowed:
o dom_core_types.h, dom_core_bits.h, dom_core_fp.h, dom_core_log.h
o dom_sim_world.h (for surface IDs)
o No platform headers, no rendering headers, no physics headers.
• No floats.
• No dynamic allocation in tick-path functions.
• No simulation rules here (no time, no jobs, no power/fluid/economy logic).
• This layer provides: coordinate types, grid hierarchy, chunk/subchunk structures, terrain/voxel storage, and generic spatial indices/queries.

1. dom_spatial_types.h — Coordinate hierarchy and constants
Purpose: single authority for spatial units and coordinate types. All other modules use these typedefs and constants.
Responsibilities:
• Define integer types for:
o tile coordinates (1 m units)
o sub-grid coordinates (subtile, submini, submicro, subnano)
• Define macro constants for the hierarchy you specified.
• Define world-space extents and safe ranges.
• No function implementations here.
Required includes:
#include "dom_core_types.h"
Types and constants:
/* Base integer coordinate type for tiles. */
typedef dom_i64 DomTileCoord;      /* 1 tile = 1 metre */

/* Subdivisions (powers of two): */
#define DOM_SUBNANO_PER_M     65536  /* 1/65536 m  */
#define DOM_SUBMICRO_PER_M     4096  /* 1/4096 m   */
#define DOM_SUBMINI_PER_M       256  /* 1/256 m    */
#define DOM_SUBTILE_PER_M        16  /* 1/16 m     */

/* Higher-level grid extents: */
#define DOM_TILE_PER_SUBCHUNK    16    /* 16 m      */
#define DOM_TILE_PER_CHUNK      256    /* 256 m     */
#define DOM_TILE_PER_SUBREGION 4096    /* 4096 m    */
#define DOM_TILE_PER_REGION    65536   /* 65536 m   */
#define DOM_TILE_PER_SUBCONT   1048576 /* 1,048,576 */
#define DOM_TILE_PER_CONT      16777216/* 16,777,216 */
#define DOM_TILE_PER_SUPERCONT 268435456/* 268,435,456 */
#define DOM_TILE_PER_SURFACE   4294967296ULL /* 4,294,967,296 */

/* 3D tile coordinate vector. */
typedef struct DomTile3 {
    DomTileCoord x;
    DomTileCoord y;
    DomTileCoord z;
} DomTile3;
Optional sub-unit coordinate types:
typedef dom_i64 DomSubnanoCoord;
typedef dom_i64 DomSubmicroCoord;
typedef dom_i64 DomSubminiCoord;
typedef dom_i64 DomSubtileCoord;
This file must not contain functions or static data.
Prohibitions:
• No references to chunks or surfaces (that’s in other headers).
• No world IDs or simulation types.

2. dom_spatial_grid.[hc] — Integer grid conversions and helpers
Purpose: pure math helpers mapping between coordinate spaces (tile, subgrid, chunk indices, etc.) and enforcing the hierarchy.
Header: dom_spatial_grid.h
Responsibilities:
• Provide inline-safe conversion functions: tile ↔ chunk/subchunk indices, tile ↔ subgrid units.
• Provide clamping and modulo helpers for tile coordinates.
• Provide surface-local vs “global” (surface-relative) conversions in cooperation with dom_sim_world.
Required includes:
#include "dom_spatial_types.h"
#include "dom_sim_world.h"
Key types:
typedef dom_i32 DomChunkCoord;     /* index in chunk grid */
typedef dom_i32 DomSubchunkCoord;  /* index in subchunk grid */

typedef struct DomChunk3 {
    DomChunkCoord cx;
    DomChunkCoord cy;
    DomChunkCoord cz; /* optional; usually 0 */
} DomChunk3;

typedef struct DomSubchunk3 {
    DomSubchunkCoord sx;
    DomSubchunkCoord sy;
    DomSubchunkCoord sz;
} DomSubchunk3;
Public API (examples, non-exhaustive but you must keep semantics fixed):
/* Convert tile coordinate to chunk + tile-in-chunk. */
void dom_spatial_tile_to_chunk(DomTileCoord tx, DomTileCoord ty,
                               DomChunkCoord *out_cx, DomChunkCoord *out_cy,
                               dom_i32       *out_local_x, dom_i32 *out_local_y);
/* Convert chunk+local to tile coordinate. */
void dom_spatial_chunk_to_tile(DomChunkCoord cx, DomChunkCoord cy,
                               dom_i32 local_x, dom_i32 local_y,
                               DomTileCoord *out_tx, DomTileCoord *out_ty);

/* Subchunk variants at 16×16 tiles. */
void dom_spatial_tile_to_subchunk(DomTileCoord tx, DomTileCoord ty,
                                  DomSubchunkCoord *out_sx, DomSubchunkCoord *out_sy,
                                  dom_i32 *out_local_x, dom_i32 *out_local_y);

void dom_spatial_subchunk_to_tile(DomSubchunkCoord sx, DomSubchunkCoord sy,
                                  dom_i32 local_x, dom_i32 local_y,
                                  DomTileCoord *out_tx, DomTileCoord *out_ty);

/* Subgrid conversions (tile <-> subtile, submini, submicro, subnano). */
DomSubtileCoord  dom_spatial_tile_to_subtile(DomTileCoord t);
DomTileCoord     dom_spatial_subtile_to_tile(DomSubtileCoord s);

DomSubminiCoord  dom_spatial_tile_to_submini(DomTileCoord t);
DomTileCoord     dom_spatial_submini_to_tile(DomSubminiCoord s);

/* Surface-relative coordinates. */
DomResult dom_spatial_world_to_surface_tiles(DomSurfaceId surface,
                                             DomTileCoord wx, DomTileCoord wy,
                                             DomTileCoord *out_sx, DomTileCoord *out_sy);

DomResult dom_spatial_surface_to_world_tiles(DomSurfaceId surface,
                                             DomTileCoord sx, DomTileCoord sy,
                                             DomTileCoord *out_wx, DomTileCoord *out_wy);
Implementation: dom_spatial_grid.c
• All operations must be pure integer arithmetic.
• Must never overflow valid range for defined extents (check and clamp deterministically).
• No dynamic memory.
Prohibitions:
• No storage of global state.
• No knowledge of ECS or chunks contents.

3. dom_spatial_chunk.[hc] — Chunk/subchunk registry and metadata
Purpose: manage logical chunks/subchunks as containers for terrain, microgrids, and entities. No heavy data here, just registry and metadata.
Header: dom_spatial_chunk.h
Responsibilities:
• Define IDs and metadata for chunks and subchunks.
• Provide registration and lookup of chunk structures per surface.
• Provide iteration over existing chunks/subchunks.
Required includes:
#include "dom_spatial_types.h"
#include "dom_spatial_grid.h"
#include "dom_sim_world.h"
Types:
typedef dom_u32 DomChunkId;
typedef dom_u32 DomSubchunkId;

typedef struct DomChunkMeta {
    DomChunkId   id;
    DomSurfaceId surface;
    DomChunkCoord cx;
    DomChunkCoord cy;
    dom_u32      flags;       /* has_terrain, has_structures, dirty, etc. */
    dom_u32      subchunk_count;
} DomChunkMeta;

typedef struct DomSubchunkMeta {
    DomSubchunkId id;
    DomChunkId    parent_chunk;
    DomSubchunkCoord sx;
    DomSubchunkCoord sy;
    dom_i32      z_layer;     /* vertical layer index */
    dom_u32      flags;       /* underground, water, etc. */
} DomSubchunkMeta;
Public API:
Initialisation/reset:
DomResult dom_spatial_chunk_init(void);
void      dom_spatial_chunk_reset(void);
Chunk registration:
DomResult dom_spatial_chunk_ensure(DomSurfaceId surface,
                                   DomChunkCoord cx, DomChunkCoord cy,
                                   DomChunkId *out_chunk);

const DomChunkMeta *dom_spatial_chunk_get(DomChunkId id);

/* Iterate all chunks on a surface in deterministic order. */
typedef void (*DomChunkIterFn)(const DomChunkMeta *meta, void *user);
void dom_spatial_chunk_for_each(DomSurfaceId surface,
                                DomChunkIterFn fn, void *user);
Subchunk support:
DomResult dom_spatial_subchunk_ensure(DomChunkId chunk,
                                      DomSubchunkCoord sx, DomSubchunkCoord sy,
                                      dom_i32 z_layer,
                                      DomSubchunkId *out_subchunk);

const DomSubchunkMeta *dom_spatial_subchunk_get(DomSubchunkId id);

typedef void (*DomSubchunkIterFn)(const DomSubchunkMeta *meta, void *user);
void dom_spatial_subchunk_for_each_in_chunk(DomChunkId chunk,
                                            DomSubchunkIterFn fn, void *user);
Lookup helpers:
DomResult dom_spatial_chunk_find_by_tile(DomSurfaceId surface,
                                         DomTileCoord tx, DomTileCoord ty,
                                         DomChunkId *out_chunk,
                                         DomSubchunkId *out_subchunk_optional);
Implementation: dom_spatial_chunk.c
• Uses fixed-size or growable arrays allocated at startup/load (not per tick).
• Chunk IDs and subchunk IDs increment monotonically; no randomization.
• Maintains deterministic order (sorted by surface, cx, cy, layer).
Prohibitions:
• No terrain/voxel data stored here (that’s dom_spatial_voxel).
• No entity lists here (ECS or other modules can keep chunk-local lists separately).
• No network or physics data.

4. dom_spatial_voxel.[hc] — Terrain and voxel/microgrid storage
Purpose: store and manipulate terrain voxels, cut/fill masks, underground vs overground, and microgrid “logical terrain” inside subchunks.
Header: dom_spatial_voxel.h
Responsibilities:
• Define voxel/tile material IDs and per-tile flags.
• Provide APIs to query/write terrain types for tiles within a subchunk.
• Provide RLE/sparse compressed representations for storage.
• Provide support for “logical microgrids” that overlay the base terrain.
Required includes:
#include "dom_spatial_types.h"
#include "dom_spatial_chunk.h"
Types:
typedef dom_u16 DomMaterialId;

typedef struct DomVoxelTile {
    DomMaterialId material;
    dom_u16       flags;   /* solid, liquid, passable, cut, fill, etc. */
} DomVoxelTile;

typedef struct DomSubchunkVoxelInfo {
    DomSubchunkId subchunk;
    dom_u32       width;   /* usually 16 */
    dom_u32       height;  /* usually 16 */
    dom_u32       layers;  /* vertical slice count in this subchunk */
    /* opaque pointer to compressed storage, internal to .c file */
} DomSubchunkVoxelInfo;
Public API:
Initialise/reset:
DomResult dom_spatial_voxel_init(void);
void      dom_spatial_voxel_reset(void);
Attach voxel storage to a subchunk:
DomResult dom_spatial_voxel_alloc_for_subchunk(DomSubchunkId subchunk);
void      dom_spatial_voxel_free_for_subchunk(DomSubchunkId subchunk);

DomResult dom_spatial_voxel_get_info(DomSubchunkId subchunk,
                                     DomSubchunkVoxelInfo *out_info);
Tile-level access (must be efficient and deterministic):
/* z_layer is relative layer index within subchunk microgrid. */
DomResult dom_spatial_voxel_get_tile(DomSubchunkId subchunk,
                                     dom_i32 local_x, dom_i32 local_y, dom_i32 z_layer,
                                     DomVoxelTile *out_tile);

DomResult dom_spatial_voxel_set_tile(DomSubchunkId subchunk,
                                     dom_i32 local_x, dom_i32 local_y, dom_i32 z_layer,
                                     const DomVoxelTile *tile);
Terrain height query per tile (fast path):
/* Return topmost solid or top-of-ground height within subchunk for a local x,y. */
DomResult dom_spatial_voxel_get_height(DomSubchunkId subchunk,
                                       dom_i32 local_x, dom_i32 local_y,
                                       dom_i32 *out_z_layer);
Cut/fill overlays (logical modifications without altering “base” terrain):
DomResult dom_spatial_voxel_apply_cut(DomSubchunkId subchunk,
                                      dom_i32 local_x, dom_i32 local_y,
                                      dom_i32 from_layer, dom_i32 to_layer);

DomResult dom_spatial_voxel_apply_fill(DomSubchunkId subchunk,
                                       dom_i32 local_x, dom_i32 local_y,
                                       dom_i32 from_layer, dom_i32 to_layer,
                                       DomMaterialId material);
Implementation: dom_spatial_voxel.c
• Internally uses RLE or small-fixed-block compression; compression details must be deterministic and stable across versions or mediated via format versioning.
• Ensure tile updates update compressed representation deterministically.
• No dynamic memory allocation in the in-tick API; allocate at load/map generation.
Prohibitions:
• No ECS or building logic.
• No pathfinding.
• No physics impulses.

5. dom_spatial_region.[hc] — Higher-level region/subregion containers
Purpose: manage higher-order groupings (subregions, regions, continents, etc.) for map organisation, LOD, region-based simulation grouping.
Header: dom_spatial_region.h
Responsibilities:
• Define IDs and metadata for subregions/regions per surface.
• Map chunk coordinates to subregion/region IDs.
• Provide iteration over regions.
Required includes:
#include "dom_spatial_types.h"
#include "dom_sim_world.h"
Types:
typedef dom_u32 DomSubregionId;
typedef dom_u32 DomRegionId;

typedef struct DomSubregionMeta {
    DomSubregionId id;
    DomSurfaceId   surface;
    dom_i32        sx;     /* subregion grid index */
    dom_i32        sy;
    dom_u32        flags;  /* climate, ownership, etc. */
} DomSubregionMeta;

typedef struct DomRegionMeta {
    DomRegionId  id;
    DomSurfaceId surface;
    dom_i32      rx;
    dom_i32      ry;
    dom_u32      flags;
} DomRegionMeta;
Public API:
DomResult dom_spatial_region_init(void);
void      dom_spatial_region_reset(void);

/* Map tile to subregion/region. */
DomResult dom_spatial_region_of_tile(DomSurfaceId surface,
                                     DomTileCoord tx, DomTileCoord ty,
                                     DomSubregionId *out_subregion,
                                     DomRegionId    *out_region);

/* Lookup meta. */
const DomSubregionMeta *dom_spatial_get_subregion(DomSubregionId id);
const DomRegionMeta    *dom_spatial_get_region(DomRegionId id);

/* Iteration. */
typedef void (*DomRegionIterFn)(const DomRegionMeta *meta, void *user);
void dom_spatial_region_for_each(DomSurfaceId surface,
                                 DomRegionIterFn fn, void *user);
Implementation: dom_spatial_region.c
• Coordinates quantised using the constants in dom_spatial_types.h.
• Uses simple integer division to compute indices.
• Maintains arrays of metas with deterministic IDs and ordering.
Prohibitions:
• No climate simulation or economy here (those call into this).
• No ownership logic; just a place to store flags as simple bitfields.

6. dom_spatial_index.[hc] — Wide grid + BVH indexing
Purpose: shared acceleration structures for “what’s near this?” queries, broad-phase collision partners, and high-level spatial indexing, without implementing physics.
Header: dom_spatial_index.h
Responsibilities:
• Implement wide uniform grid index (e.g. 4×4×4 m cells).
• Provide an abstract BVH / spatial tree for arbitrary AABBs.
• Provide registration and update of indexed objects, keyed by entity or ID.
• Provide queries: cell iteration, AABB-overlap scanning, etc.
Required includes:
#include "dom_spatial_types.h"
#include "dom_tile_aabb.h" /* optional: we can define simple AABB here instead */
(If you don’t have dom_tile_aabb.h, define AABB here.)
Types:
typedef dom_u32 DomSpatialObjectId;

typedef struct DomAABB {
    DomTileCoord min_x, min_y, min_z;
    DomTileCoord max_x, max_y, max_z;
} DomAABB;

typedef struct DomSpatialObject {
    DomSpatialObjectId id;
    dom_u64            owner_entity;  /* 0 if none */
    DomAABB            bounds;
    dom_u32            flags;         /* type bits, collision class, etc. */
} DomSpatialObject;
Public API:
Init/reset:
DomResult dom_spatial_index_init(void);
void      dom_spatial_index_reset(void);
Object registration (grid + BVH):
DomSpatialObjectId dom_spatial_index_register(const DomSpatialObject *obj);
void                dom_spatial_index_unregister(DomSpatialObjectId id);

/* Update object bounds (e.g. building growth). */
DomResult dom_spatial_index_update(DomSpatialObjectId id,
                                   const DomAABB *new_bounds,
                                   dom_u32 new_flags);
Rebuild BVH (only in post-process phase):
void dom_spatial_index_rebuild_bvh(void);
Query API:
/* Cell-based approximate query. */
typedef void (*DomSpatialObjectFn)(DomSpatialObjectId id,
                                   const DomSpatialObject *obj,
                                   void *user);

void dom_spatial_index_query_aabb(const DomAABB *region,
                                  dom_u32 mask_flags,
                                  DomSpatialObjectFn fn,
                                  void *user);

/* Point query. */
void dom_spatial_index_query_point(DomTileCoord x, DomTileCoord y, DomTileCoord z,
                                   dom_u32 mask_flags,
                                   DomSpatialObjectFn fn,
                                   void *user);
Implementation: dom_spatial_index.c
• Maintains:
o wide grid index mapping grid cell to small fixed list of object IDs.
o BVH built from those objects for expensive queries (raycast, broad-phase).
• Rebuild is deterministic: sort objects by ID, build BVH in fixed algorithm order.
Prohibitions:
• No physics collision resolution here.
• No lane logic; this is global. Physics module may partition per-lane using this.

7. dom_spatial_query.[hc] — High-level terrain and topology queries
Purpose: provide reusable, read-only query functions combining grid, chunk, voxel, and index modules for game and physics layers.
Header: dom_spatial_query.h
Responsibilities:
• Expose read-only operations needed by:
o pathfinding
o construction placement
o building and track alignment
o cutting/filling checks
o long-platform alignment
o tunnels/bridges interaction with terrain
Required includes:
#include "dom_spatial_types.h"
#include "dom_spatial_chunk.h"
#include "dom_spatial_voxel.h"
#include "dom_spatial_index.h"
Public API (examples):
Ground sampling:
/* Get ground height at a world tile (surface-local). */
DomResult dom_spatial_query_ground_height(DomSurfaceId surface,
                                          DomTileCoord tx, DomTileCoord ty,
                                          dom_i32 *out_z_layer);

/* Test if tile is solid at (x,y,z). */
dom_bool8 dom_spatial_query_is_solid(DomSurfaceId surface,
                                     DomTileCoord tx, DomTileCoord ty,
                                     dom_i32 z_layer);
Line/raycast over terrain:
typedef struct DomRayHit {
    DomTileCoord x, y;
    dom_i32      z_layer;
    DomVoxelTile voxel;
} DomRayHit;

dom_bool8 dom_spatial_query_ray_terrain(DomSurfaceId surface,
                                        DomTileCoord x0, DomTileCoord y0, dom_i32 z0,
                                        DomTileCoord x1, DomTileCoord y1, dom_i32 z1,
                                        DomRayHit *out_hit);
Placement feasibility:
/* Check if a rectangular footprint at ground level can be placed. */
dom_bool8 dom_spatial_query_can_place_rect(DomSurfaceId surface,
                                           DomTileCoord x_min, DomTileCoord y_min,
                                           DomTileCoord x_max, DomTileCoord y_max,
                                           dom_i32      base_z,
                                           dom_u32      flags /* e.g. allow_cut, require_flat */);

/* Sample average slope of area. */
DomResult dom_spatial_query_area_slope(DomSurfaceId surface,
                                       DomTileCoord x_min, DomTileCoord y_min,
                                       DomTileCoord x_max, DomTileCoord y_max,
                                       dom_i32 *out_dx, dom_i32 *out_dy);
Neighbourhood scan:
typedef void (*DomSpatialTileFn)(DomSurfaceId surface,
                                 DomTileCoord tx, DomTileCoord ty,
                                 dom_i32 z_layer,
                                 const DomVoxelTile *tile,
                                 void *user);

void dom_spatial_query_for_each_tile_in_rect(DomSurfaceId surface,
                                             DomTileCoord x_min, DomTileCoord y_min,
                                             DomTileCoord x_max, DomTileCoord y_max,
                                             DomSpatialTileFn fn, void *user);
Implementation: dom_spatial_query.c
• Strictly read-only operations into voxel/chunk/index.
• No state mutated here (except optional perf caches that are not sim-state and are recomputable).
• Uses integer DDA for raycasts; must be deterministic.
Prohibitions:
• No pathfinding; only basic geometry and occupancy tests.
• No job creation or events.
• No multi-threading primitives here.

That covers engine/spatial/.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for engine/physics/.
This subsystem is not a real physics engine.
It is a deterministic integer kinematics and constraint resolver used for:
• vehicle movement along splines
• track/road/path alignment
• grid–vector interfacing
• broad-phase + narrow-phase occupancy checks
• clearance envelopes
• collision class tests
• slope/grade constraints
• bridge/tunnel passability
• structure–terrain overlap resolution
No continuous forces.
No floats.
No nondeterminism.
Directory:
engine/
└── physics/
    ├── dom_physics_types.h
    ├── dom_physics_aabb.h
    ├── dom_physics_aabb.c
    ├── dom_physics_motion.h
    ├── dom_physics_motion.c
    ├── dom_physics_shape.h
    ├── dom_physics_shape.c
    ├── dom_physics_collision.h
    ├── dom_physics_collision.c
    ├── dom_physics_query.h
    ├── dom_physics_query.c
    ├── dom_physics_vehicle.h
    ├── dom_physics_vehicle.c
    ├── dom_physics_spline.h
    └── dom_physics_spline.c

0. GLOBAL RULES FOR engine/physics
• C89 only
• No floats anywhere
• Only integer and fixed-point (dom_q16_16, dom_q32_32)
• No dynamic allocation in tick-phase functions
• Must not depend on rendering or platform
• May depend on:
o core/*
o spatial/*
o sim/world
o sim/lanes
• Physics never mutates simulation state directly.
• Physics never emits jobs or events.
• Physics returns proposals; systems decide how to apply them.

1. dom_physics_types.h
Purpose: the type authority for all physics objects.
Includes allowed:
#include "dom_core_types.h"
#include "dom_core_fp.h"
#include "dom_spatial_types.h"
Defines:
typedef dom_u32 DomPhysicsObjId;

typedef dom_u32 DomCollisionClass;  /* bits controlling allowed interactions */
typedef dom_u32 DomPhysicsFlags;    /* generic flags */

typedef struct DomPhysicsMass {
    dom_q32_32 inv_mass;     /* fixed point, 0 = immovable */
} DomPhysicsMass;
Define kinematic state:
typedef struct DomPhysicsKinematic {
    DomTileCoord x, y, z;   /* integer world tile coords */
    dom_q32_32 vx, vy, vz;  /* fixed-point velocity */
    dom_q32_32 ax, ay, az;  /* fixed acceleration (scripted) */
} DomPhysicsKinematic;
Defines movement result for a tick:
typedef struct DomPhysicsMove {
    DomTileCoord nx, ny, nz; /* proposed new tile coords */
    dom_bool8    collided;
    DomPhysicsObjId hit_obj;
} DomPhysicsMove;
Prohibitions:
• No orientation or quaternions (handled by vehicles & splines, not core physics).
• No rotational inertia.

2. dom_physics_aabb.[hc] — Axis-Aligned Bounding Boxes
Purpose: smallest possible AABB utility layer, deterministic.
Header responsibilities
• Define AABB type
• Provide expand/contract/union
• Provide containment & overlap tests
• All integer ops only
Types:
typedef struct DomAABB {
    DomTileCoord min_x, min_y, min_z;
    DomTileCoord max_x, max_y, max_z;
} DomAABB;
Public API:
/* Construct box from min/max (caller guarantees min <= max). */
DomAABB dom_physics_aabb_make(DomTileCoord min_x, DomTileCoord min_y, DomTileCoord min_z,
                              DomTileCoord max_x, DomTileCoord max_y, DomTileCoord max_z);

/* Expand box by integer deltas. */
DomAABB dom_physics_aabb_expand(const DomAABB *a, DomTileCoord dx,
                                DomTileCoord dy, DomTileCoord dz);

/* A ∪ B */
DomAABB dom_physics_aabb_union(const DomAABB *a, const DomAABB *b);

/* Overlap test (inclusive). */
dom_bool8 dom_physics_aabb_overlaps(const DomAABB *a, const DomAABB *b);

/* Containment test. */
dom_bool8 dom_physics_aabb_contains(const DomAABB *outer, const DomAABB *inner);
Implementation rules:
• No multiplications that could overflow; clamp deterministically.
• Overlap logic must be strictly integer-safe.

3. dom_physics_shape.[hc] — Collision shapes
Purpose: shapes used by vehicles/buildings for clearance envelopes.
Header responsibilities
Defines supported shapes:
typedef enum {
    DOM_SHAPE_AABB = 1,
    DOM_SHAPE_CYL  = 2,
    DOM_SHAPE_CAPSULE = 3
} DomShapeType;

typedef struct DomShapeAABB {
    DomAABB box;
} DomShapeAABB;

typedef struct DomShapeCylinder {
    dom_i32 radius;  /* in subtile units */
    dom_i32 height;
} DomShapeCylinder;

typedef struct DomShapeCapsule {
    dom_i32 radius;
    dom_i32 height;
} DomShapeCapsule;
Unified shape container:
typedef struct DomPhysicsShape {
    DomShapeType type;
    union {
        DomShapeAABB aabb;
        DomShapeCylinder cyl;
        DomShapeCapsule capsule;
    } v;
    DomCollisionClass collision_class;
} DomPhysicsShape;
Public API:
dom_bool8 dom_physics_shape_test(const DomPhysicsShape *a,
                                 DomTileCoord ax, DomTileCoord ay, DomTileCoord az,
                                 const DomPhysicsShape *b,
                                 DomTileCoord bx, DomTileCoord by, DomTileCoord bz);
Implementation rules:
• For cylinder/capsule, use Manhattan or Chebyshev distance (no sqrt, no float).
• Capsule test approximated with fixed-point squared radius.

4. dom_physics_motion.[hc] — Kinematic integrator
Purpose: deterministic integer movement update.
Header responsibilities
void dom_physics_motion_integrate(const DomPhysicsKinematic *kin,
                                  DomPhysicsKinematic *out_next);
Steps:
1. vx += ax
2. vy += ay
3. vz += az
4. x += floor(vx)
5. y += floor(vy)
6. z += floor(vz)
All fixed-point.
Velocity & accel clamped via core fp rules.
Collision is done separately, not inside integrator.

5. dom_physics_collision.[hc] — Grid + object collision test
Purpose: determine if proposed movement hits terrain or other objects.
Header responsibilities
Terrain test:
dom_bool8 dom_physics_collision_test_terrain(const DomAABB *box,
                                             DomSurfaceId surface);
Object test:
dom_bool8 dom_physics_collision_test_objects(const DomAABB *box,
                                             DomCollisionClass mask,
                                             DomPhysicsObjId *out_hit_obj);
Full movement test:
DomPhysicsMove dom_physics_collision_resolve(const DomPhysicsKinematic *curr,
                                             const DomPhysicsKinematic *next,
                                             const DomPhysicsShape *shape,
                                             DomSurfaceId surface);
Behaviour:
• Build swept AABB from curr→next integer delta.
• Sample terrain via spatial_query.
• Query object BVH via spatial_index.
• If collision:
o find minimal separating axis using integer DDA
o slide or stop depending on shape flags
o always deterministic
Prohibitions:
• No impulses or bouncing.
• No partial tick subdividing.

6. dom_physics_query.[hc] — Higher-level queries
Purpose: used by construction, AI, placement, roads/rails, tunnels/bridges.
API examples
Clearance envelope:
dom_bool8 dom_physics_query_clearance(const DomAABB *box,
                                      DomSurfaceId surface,
                                      DomCollisionClass mask);
Slope test:
dom_bool8 dom_physics_query_slope_ok(DomSurfaceId surface,
                                     DomTileCoord x0, DomTileCoord y0,
                                     DomTileCoord x1, DomTileCoord y1,
                                     dom_i32 max_grade_permille);
Tunnel/bridge feasibility:
dom_bool8 dom_physics_query_can_tunnel(DomSurfaceId surface,
                                       DomTileCoord x0, DomTileCoord y0,
                                       DomTileCoord x1, DomTileCoord y1,
                                       dom_i32 z_layer,
                                       dom_u32 flags);
Clear span for platforms:
dom_bool8 dom_physics_query_span_clear(DomSurfaceId surface,
                                       const DomAABB *span_region,
                                       dom_i32 min_height,
                                       dom_i32 max_height);
Prohibitions:
• No tile mutation.
• No voxel editing.

7. dom_physics_vehicle.[hc] — Vehicle kinematic envelope
Purpose: 100% deterministic movement for rolling stock, cars, aircraft (ground roll), etc.
Header responsibilities
Vehicle state type:
typedef struct DomVehicleState {
    DomTileCoord x, y, z;
    DomTileCoord dir_x, dir_y;  /* unit step direction */
    dom_q32_32 speed;           /* m/tick fixed point */
    DomPhysicsShape shape;
    DomSurfaceId surface;
} DomVehicleState;
Public API:
/* Given a guide path (spline arc), compute next point. */
DomResult dom_physics_vehicle_follow_spline(const DomVehicleState *vs,
                                            DomSurfaceId surface,
                                            dom_u32 path_id,
                                            DomVehicleState *out_next);

/* Perform collision-aware update. */
DomResult dom_physics_vehicle_step(const DomVehicleState *vs,
                                   DomVehicleState *out_next);
Implementation rules:
• Spline sample uses fixed-point parameter t.
• No drift; vehicles snap to spline tangent.
• For trains: dir_x/dir_y must align with track tangent each tick.

8. dom_physics_spline.[hc] — Deterministic spline sampler
Purpose: unify all vector transport ways (roads, rails, canals, pipelines, power lines).
Header responsibilities
Spline type:
typedef dom_u32 DomSplineId;
typedef dom_u16 DomSplinePointId;

typedef struct DomSplinePoint {
    DomTileCoord x, y, z;
    dom_q32_32   dx, dy, dz; /* control tangent */
} DomSplinePoint;

typedef struct DomSpline {
    DomSplineId id;
    DomSurfaceId surface;
    dom_u32 point_count;
    DomSplinePoint *points;  /* allocated at build/load time */
} DomSpline;
Public API:
Creation & lookup:
DomResult dom_physics_spline_register(const DomSpline *spline);
const DomSpline *dom_physics_spline_get(DomSplineId id);
Evaluation:
/* Evaluate spline at integer/FP param t in [0..1]. */
void dom_physics_spline_eval(const DomSpline *sp,
                             dom_q16_16 t,
                             DomTileCoord *out_x,
                             DomTileCoord *out_y,
                             DomTileCoord *out_z);

/* Get tangent vector at param t. */
void dom_physics_spline_tangent(const DomSpline *sp,
                                dom_q16_16 t,
                                dom_q32_32 *dx,
                                dom_q32_32 *dy,
                                dom_q32_32 *dz);
Length estimation:
dom_q32_32 dom_physics_spline_estimate_length(const DomSpline *sp);
Implementation rules:
• Use cubic Hermite (integer coefficients).
• Precompute segment coefficients at load time.
• No floats, no adaptive sampling.
Prohibitions:
• No dynamic editing during tick.

Summary
This directory provides every deterministic geometric/kinematic primitive the engine needs:
• Shapes
• AABBs
• Collision
• Kinematics
• Spline-following
• Vehicle envelopes
It integrates cleanly with:
• engine/spatial/* (read-only terrain/voxel/index data)
• engine/sim/* (for lane IDs and world/surface IDs)
• engine/ecs (but only via entity IDs, not direct access)
Next directory: engine/pathfinding/ unless you direct otherwise.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for engine/pathfinding/.
This layer is the deterministic routing kernel for:
• workers/robots walking on tiles
• vehicles on roads/rails/canals
• ships across water grids
• aircraft along discrete waypoints / air corridors
• elevators, ramps, stairs, tunnels, bridges
• multi-floor and underground movement
No floats.
No randomness.
No direct world mutation.
Directory:
engine/
└── pathfinding/
    ├── dom_path_types.h
    ├── dom_path_grid.h
    ├── dom_path_grid.c
    ├── dom_path_navmesh.h
    ├── dom_path_navmesh.c
    ├── dom_path_cost.h
    ├── dom_path_cost.c
    ├── dom_path_astar.h
    ├── dom_path_astar.c
    ├── dom_path_traffic.h
    ├── dom_path_traffic.c
    ├── dom_path_route.h
    ├── dom_path_route.c
    ├── dom_path_cache.h
    └── dom_path_cache.c
Global rules for this directory:
• C89 only.
• No floats; use dom_q16_16/dom_q32_32 where needed.
• Must not allocate memory in simulation tick hot-path functions.
• Must not know about job system, economy, research, UI.
• Reads from spatial/* and physics/* but only via their public APIs.
• Exposes pure path results + route abstractions; actual movement is handled by simulation systems.

1. dom_path_types.h — Basic types and enums
Purpose: global type definitions and constants for all pathfinding modules.
Includes:
#include "dom_core_types.h"
#include "dom_spatial_types.h"
#include "dom_sim_world.h"
Types:
typedef dom_u32 DomPathId;        /* ID for cached routes */
typedef dom_u32 DomNavLayerId;    /* nav layer (surface, floor, mode) */
typedef dom_u32 DomPathMask;      /* bitfield: allowed modes / layers */

typedef dom_u16 DomPathCost;      /* local edge cost, small integer */
typedef dom_u32 DomPathCostAccum; /* accumulated cost (A*) */

typedef dom_u16 DomPathHeuristic; /* heuristic estimate (scaled) */
typedef dom_u32 DomPathHeuristicAccum;

/* Tile node (grid) */
typedef struct DomPathNode {
    DomSurfaceId surface;
    DomTileCoord x;
    DomTileCoord y;
    dom_i16      z_layer;   /* vertical index in voxel/microgrid */
    DomNavLayerId nav_layer;/* walking / road / rail / air corridor layer */
} DomPathNode;
Movement mode flags:
enum {
    DOM_PATH_MODE_WALK   = 1 << 0,
    DOM_PATH_MODE_ROAD   = 1 << 1,
    DOM_PATH_MODE_RAIL   = 1 << 2,
    DOM_PATH_MODE_WATER  = 1 << 3,
    DOM_PATH_MODE_AIR    = 1 << 4,
    DOM_PATH_MODE_TUNNEL = 1 << 5,
    DOM_PATH_MODE_ELEV   = 1 << 6
    /* extendable */
};
Result code:
typedef enum {
    DOM_PATH_RESULT_OK = 0,
    DOM_PATH_RESULT_NO_PATH,
    DOM_PATH_RESULT_TIMEOUT,
    DOM_PATH_RESULT_INVALID,
    DOM_PATH_RESULT_INTERNAL_ERROR
} DomPathResult;
Prohibitions:
• No data structures (no arrays, no queues).
• No function definitions.

2. dom_path_grid.[hc] — Grid adjacency + walkability
Purpose: define how tiles connect for each nav mode; grid-level graph queries.
Header: dom_path_grid.h
Includes:
#include "dom_path_types.h"
#include "dom_spatial_query.h"
#include "dom_physics_query.h"
Responsibilities:
• Define neighbour patterns (4/8-direction, vertical neighbours, ramps).
• Expose functions to test walkability / drivable / rail-able between nodes.
• Expose functions to generate neighbours for A*.
Public API:
Walkability:
dom_bool8 dom_path_grid_is_walkable(const DomPathNode *node,
                                    DomPathMask modes);

dom_bool8 dom_path_grid_is_passable_edge(const DomPathNode *from,
                                         const DomPathNode *to,
                                         DomPathMask modes);
Neighbour enumeration:
typedef struct DomPathNeighbour {
    DomPathNode node;
    DomPathCost edge_cost;
} DomPathNeighbour;

#define DOM_PATH_MAX_NEIGHBOURS 16

dom_u32 dom_path_grid_get_neighbours(const DomPathNode *from,
                                     DomPathMask modes,
                                     DomPathNeighbour *out_neighbours,
                                     dom_u32 max_neighbours);
Responsibilities in implementation:
• Use spatial_query for height/solid checks.
• Use physics_query for clearance and slope constraints.
• Encode:
o adjacency on same z-layer
o ramps/stairs (±1 layer) when slopes are acceptable
o tunnel/bridge transitions with appropriate nav_layer changes
• All decisions must be deterministic and purely function of world state.
Prohibitions:
• No search algorithm here.
• No global mutable state except static config tables (e.g. neighbour offsets).

3. dom_path_navmesh.[hc] — Logical nav-layers and special graphs
Purpose: support non-trivial movement graphs beyond simple grid adjacency:
• conduit networks (elevators, conveyors, pipelines routing workers)
• staircases, ladders, teleport pads, airlocks
• layer switches (surface ↔ building interior ↔ underground microgrid)
Header: dom_path_navmesh.h
Includes:
#include "dom_path_types.h"
#include "dom_spatial_types.h"
#include "dom_spatial_chunk.h"
Types:
typedef dom_u32 DomNavNodeId;

typedef struct DomNavNode {
    DomNavNodeId id;
    DomSurfaceId surface;
    DomTileCoord x, y;
    dom_i16      z_layer;
    DomNavLayerId nav_layer;
    DomPathMask  allowed_modes;
} DomNavNode;

typedef struct DomNavEdge {
    DomNavNodeId from;
    DomNavNodeId to;
    DomPathCost  cost;
    DomPathMask  modes;      /* which modes can use this link */
    dom_u32      flags;      /* one-way, elevator, portal, etc. */
} DomNavEdge;
Public API:
Init/reset:
DomResult dom_path_navmesh_init(void);
void      dom_path_navmesh_reset(void);
Registration (called by building/track/road systems at post-process):
DomNavNodeId dom_path_navmesh_register_node(const DomNavNode *node);
DomResult    dom_path_navmesh_register_edge(const DomNavEdge *edge);
Lookup / queries:
DomResult dom_path_navmesh_find_nodes_near(DomSurfaceId surface,
                                           DomTileCoord x, DomTileCoord y,
                                           dom_i16 z_layer,
                                           DomPathMask modes,
                                           DomNavNodeId *out_ids,
                                           dom_u32 max_ids,
                                           dom_u32 *out_count);

DomResult dom_path_navmesh_get_node(DomNavNodeId id,
                                    DomNavNode *out_node);

DomResult dom_path_navmesh_get_edges_from(DomNavNodeId from,
                                          DomNavEdge *out_edges,
                                          dom_u32 max_edges,
                                          dom_u32 *out_count);
Implementation rules:
• Nodes/edges stored in dense arrays; IDs are indices.
• Edges grouped by from node, sorted by to ID for determinism.
• Navmesh is global and updated in post-process only; A* uses it read-only.
Prohibitions:
• No A* here.
• No references to particular ECS archetypes; buildings register nodes via a higher-level system.

4. dom_path_cost.[hc] — Cost models and heuristics
Purpose: centralised path cost/heuristic functions, independent of specific path algorithm.
Header: dom_path_cost.h
Includes:
#include "dom_path_types.h"
#include "dom_spatial_types.h"
Responsibilities:
• Define per-mode base movement cost (walk, road, rail, etc.).
• Define slope penalties, terrain penalties, congestion penalties (input via external scalars).
• Implement the heuristic function used by A*.
Public API:
/* Base cost of moving one grid step given mode mask. */
DomPathCost dom_path_cost_step(const DomPathNode *from,
                               const DomPathNode *to,
                               DomPathMask modes);

/* Heuristic: lower-bound estimate from node → goal. */
DomPathHeuristic dom_path_cost_heuristic(const DomPathNode *from,
                                         const DomPathNode *to,
                                         DomPathMask modes);
Configuration:
void dom_path_cost_set_mode_base_cost(DomPathMask mode,
                                      DomPathCost cost);

void dom_path_cost_set_slope_penalty(dom_i32 permille, DomPathCost extra_cost);
Implementation rules:
• Use Manhattan distance (|dx|+|dy|+|dz|) or Chebyshev (max of |dx|,|dy|) with mode-dependent scaling.
• Heuristic must never overestimate true minimal cost (admissible) to keep A* optimal.
• All config uses integer/fixed-point; no floats.
Prohibitions:
• No direct access to congestion or dynamic traffic; traffic module passes its penalty inputs in.

5. dom_path_astar.[hc] — Deterministic A* and variants
Purpose: the actual search algorithm engine, parameterised by:
• neighbour provider (grid-only, navmesh-only, hybrid)
• cost + heuristic callbacks
• limits on expansions
Header: dom_path_astar.h
Includes:
#include "dom_path_types.h"
#include "dom_path_grid.h"
#include "dom_path_navmesh.h"
#include "dom_path_cost.h"
Types:
typedef struct DomPathSearchLimits {
    dom_u32 max_nodes_expanded;
    dom_u32 max_open_size;
} DomPathSearchLimits;

typedef struct DomPathSearchParams {
    DomPathNode start;
    DomPathNode goal;
    DomPathMask modes;
    DomPathSearchLimits limits;
} DomPathSearchParams;
Path output:
#define DOM_PATH_MAX_STEPS 1024  /* hard cap per query; tuned later */

typedef struct DomPathStep {
    DomTileCoord x, y;
    dom_i16      z_layer;
    DomNavLayerId nav_layer;
} DomPathStep;

typedef struct DomPathResultData {
    DomPathResult result;
    DomPathStep   steps[DOM_PATH_MAX_STEPS];
    dom_u16       step_count;
    DomPathCostAccum total_cost;
} DomPathResultData;
Public API:
Single-shot path:
DomPathResult dom_path_astar_find_path(const DomPathSearchParams *params,
                                       DomPathResultData *out_path);
Incremental search (for async worker):
typedef struct DomPathSearchHandle DomPathSearchHandle;

DomPathSearchHandle *dom_path_astar_begin(const DomPathSearchParams *params);
DomPathResult        dom_path_astar_step(DomPathSearchHandle *handle,
                                         dom_u32 max_iterations,
                                         DomPathResultData *out_path);
void                 dom_path_astar_cancel(DomPathSearchHandle *handle);
Implementation rules:
• Priority queue implemented via fixed-size binary heap over array; tie-breaking must use:
o lowest f = g + h
o if equal, lowest g
o if still equal, lexicographically smallest node (surface,x,y,z,nav_layer).
• Open/closed sets must be bounded by limits; when hit, return DOM_PATH_RESULT_TIMEOUT deterministically.
• Allocations for DomPathSearchHandle come from preallocated pools, not malloc inside tick (used by worker lanes/job thread, not direct sim tick).
Prohibitions:
• No dynamic resizing of the open list at runtime beyond configured max.
• No non-deterministic containers (no hash tables for core algorithm; if used, must be deterministic probing with fixed capacity).

6. dom_path_traffic.[hc] — Traffic load and congestion model
Purpose: feed extra costs into path cost model based on current or recent traffic; used to route around jams deterministically.
Header: dom_path_traffic.h
Includes:
#include "dom_path_types.h"
#include "dom_spatial_types.h"
Types:
typedef struct DomTrafficSample {
    DomSurfaceId surface;
    DomTileCoord x, y;
    DomNavLayerId nav_layer;
    dom_u16 load;   /* e.g. vehicles per time window */
} DomTrafficSample;
Public API:
Init/reset:
DomResult dom_path_traffic_init(void);
void      dom_path_traffic_reset(void);
Sampling:
/* Called by movement systems to report usage. */
void dom_path_traffic_add_sample(const DomTrafficSample *sample);
Query congestion penalty:
DomPathCost dom_path_traffic_penalty(const DomPathNode *node,
                                     DomPathMask modes);
Tick update:
/* Run at multi-rate (e.g. every N ticks). */
void dom_path_traffic_tick(void);
Implementation rules:
• Use fixed-size grid buckets (e.g. 4×4 tiles aggregated) stored in arrays keyed by surface + chunk or similar.
• Decay load counts over time deterministically (e.g. subtract constant per dom_path_traffic_tick).
• No per-vehicle state here; purely aggregated.
Prohibitions:
• No access to ECS or jobs.
• No real-time or wallclock time; only tick-based.

7. dom_path_route.[hc] — Route abstraction and reuse
Purpose: turn static path solutions into reusable “routes” with IDs that AI/vehicles/workers can follow.
Header: dom_path_route.h
Includes:
#include "dom_path_types.h"
#include "dom_path_astar.h"
Types:
typedef struct DomRoute {
    DomPathId      id;
    DomSurfaceId   surface;
    DomPathMask    modes;
    DomPathStep    steps[DOM_PATH_MAX_STEPS];
    dom_u16        step_count;
    DomPathCostAccum total_cost;
    dom_u32        ref_count; /* usage count; for cleanup */
} DomRoute;
Public API:
Creating and retrieving routes:
DomResult dom_path_route_init(void);
void      dom_path_route_reset(void);

DomPathId dom_path_route_create_from_result(const DomPathResultData *path);
const DomRoute *dom_path_route_get(DomPathId id);
void            dom_path_route_add_ref(DomPathId id);
void            dom_path_route_release(DomPathId id);
Helpers for following routes:
/* Get the next step index given current approximate position. */
dom_u16 dom_path_route_find_step_index(const DomRoute *route,
                                       DomTileCoord x,
                                       DomTileCoord y,
                                       dom_i16 z_layer);

/* Clamp index to valid range, returns final tile. */
DomPathStep dom_path_route_step_at(const DomRoute *route, dom_u16 idx);
Implementation rules:
• Routes stored in dense array or slab; IDs monotonic.
• No path recomputation inside this module.
• Ref counting used for automatic eviction; eviction policy deterministic (e.g. lowest ID with ref_count==0 and oldest last_used tick).
Prohibitions:
• No reading from spatial/physics here; route data is self-contained once created.
• No multi-threading primitives; concurrency is handled by higher layers.

8. dom_path_cache.[hc] — Path and heuristic cache
Purpose: avoid recomputing similar paths; keep a small bounded cache keyed by (origin-region, dest-region, mode).
Header: dom_path_cache.h
Includes:
#include "dom_path_types.h"
#include "dom_path_route.h"
#include "dom_spatial_region.h"
Key type:
typedef struct DomPathCacheKey {
    DomSurfaceId  surface;
    DomRegionId   region_src;
    DomRegionId   region_dst;
    DomPathMask   modes;
} DomPathCacheKey;
Entry:
typedef struct DomPathCacheEntry {
    DomPathCacheKey key;
    DomPathId       route_id;  /* 0 if empty */
    dom_u32         last_used_tick;
} DomPathCacheEntry;
Public API:
Init/reset:
DomResult dom_path_cache_init(void);
void      dom_path_cache_reset(void);
Lookup:
DomPathId dom_path_cache_lookup(const DomPathCacheKey *key);
Insert/update:
void dom_path_cache_store(const DomPathCacheKey *key,
                          DomPathId route_id,
                          dom_u32 current_tick);
Maintenance:
void dom_path_cache_tick(dom_u32 current_tick);
Implementation rules:
• Fixed-size table (e.g. 256 entries) with deterministic replacement policy:
o choose entry with lowest last_used_tick among those with route_id != 0
o or first empty slot in ascending index order.
• Key comparison is lexicographic; no hash maps unless you implement deterministic open-addressing with bounded size and fixed probe order.
Prohibitions:
• No eviction based on randomness.
• No dynamic growth.

Summary:
engine/pathfinding/ provides:
• Grid + navmesh adjacency (grid, navmesh)
• Deterministic cost + heuristic (cost)
• Core A* search (astar) with incremental option
• Traffic-aware routing (traffic)
• Reusable routes (route)
• Region-level cache (cache)
All purely integer-based, deterministic, and driven by higher-level systems that:
• update navmesh from roads/rails/buildings
• query for paths for workers/vehicles
• execute movement via physics and sim layers.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the full deterministic dev-spec for engine/ecs/.
This is one of the most critical directories in the entire engine.
It defines how all entities, components, and systems exist and interact inside the deterministic simulation kernel.
It must never change unpredictably, and all higher-level systems depend on it.

Directory Layout
engine/
└── ecs/
    ├── dom_ecs_types.h
    ├── dom_ecs_entity.h
    ├── dom_ecs_entity.c
    ├── dom_ecs_component.h
    ├── dom_ecs_component.c
    ├── dom_ecs_query.h
    ├── dom_ecs_query.c
    ├── dom_ecs_system.h
    ├── dom_ecs_system.c
    ├── dom_ecs_storage.h
    ├── dom_ecs_storage.c
    ├── dom_ecs_archetype.h
    ├── dom_ecs_archetype.c
    ├── dom_ecs_iter.h
    └── dom_ecs_iter.c

0. GLOBAL RULES FOR engine/ecs
• C89 only.
• No floats anywhere.
• No dynamic memory per tick; only at load/startup.
• 100% deterministic.
• No platform includes.
• No rendering, audio, or UI.
• No job/event posting from internal ECS functions; systems handle messaging.
• All memory layouts must be stable and version-controlled.
• No pointer invalidation; only handles/IDs are exposed externally.
This ECS is a hybrid:
• Dense component arrays
• Archetype-based grouping
• Lane-affinity for simulation concurrency

1. dom_ecs_types.h — Fundamental ECS types
Purpose: authoritative definitions for entity IDs, component IDs, system IDs, masks, and limits.
Includes:
#include "dom_core_types.h"
Types:
typedef dom_u64 DomEntity;     /* 32-bit index + 32-bit generation */
typedef dom_u16 DomComponentId;
typedef dom_u16 DomSystemId;
typedef dom_u64 DomArchetypeId;
typedef dom_u64 DomSignature;   /* bitmask of components present */
Generation encoding:
#define DOM_ENTITY_INDEX(e) ((dom_u32)((e) & 0xFFFFFFFFULL))
#define DOM_ENTITY_GEN(e)   ((dom_u32)((e) >> 32))
#define DOM_ENTITY_MAKE(idx, gen) \
    ((((dom_u64)(gen)) << 32) | ((dom_u64)(idx)))
Component limits:
#define DOM_ECS_MAX_COMPONENTS 256
#define DOM_ECS_SIGNATURE_BITS 256
Prohibitions:
• No structs with pointers to component memory here.

2. dom_ecs_entity.[hc] — Entity allocation & lifecycle
Purpose: deterministic creation, destruction, and validation of entity handles.
Header includes
#include "dom_ecs_types.h"
Public API
Init/reset:
DomResult dom_ecs_entity_init(void);
void      dom_ecs_entity_reset(void);
Create/destroy:
DomEntity dom_ecs_entity_create(void);         /* Always returns valid handle */
void      dom_ecs_entity_destroy(DomEntity e); /* Marks for delete at merge-phase */
dom_bool8 dom_ecs_entity_is_alive(DomEntity e);
Generation management:
dom_u32 dom_ecs_entity_generation(DomEntity e);
dom_u32 dom_ecs_entity_index(DomEntity e);
Deferred deletion:
• Bodies destroyed this tick persist until the merge-phase.
• Component removal happens before deletion.
Implementation rules:
• Dense index table entity_gen[] storing current generation.
• Free list for unused indices.
• No gaps after deletions; destruction queues reused indices with generation++.
Prohibitions:
• No immediate hard deletion inside tick-phase.
• No per-entity dynamic memory.

3. dom_ecs_component.[hc] — Component registration and metadata
Purpose: global registry of component types.
Header responsibilities
Component descriptor:
typedef struct DomComponentInfo {
    DomComponentId id;
    const char    *name;
    dom_u32        size;
    dom_u32        align;
    dom_u32        flags;  /* POD, zero-init, replicated, networked */
} DomComponentInfo;
Public API:
DomComponentId dom_ecs_component_register(const DomComponentInfo *ci);

const DomComponentInfo *dom_ecs_component_info(DomComponentId id);

dom_u32 dom_ecs_component_count(void);
Persistent table with capacity 256.
Implementation rules:
• Component IDs monotonic 1..N.
• All components must be POD (no pointers, no ownership).
• Size & alignment fixed per engine version; changes require migration logic in serialization.
Prohibitions:
• No per-component constructors/destructors.
• No component-specific logic here.

4. dom_ecs_storage.[hc] — Component memory storage (dense arrays)
Purpose: maintain flat arrays for each component type, but keyed by archetypes.
Includes:
#include "dom_ecs_types.h"
#include "dom_ecs_component.h"
#include "dom_ecs_archetype.h"
Responsibilities:
• Provide low-level component array storage.
• Support add/remove/move operations used by archetypes.
Public API (internal-ish):
void *dom_ecs_storage_alloc(DomComponentId cid, dom_u32 capacity);
void  dom_ecs_storage_free(DomComponentId cid, void *ptr);

void *dom_ecs_storage_get_array(DomComponentId cid);

dom_u32 dom_ecs_storage_capacity(DomComponentId cid);

/* Called when entities move between archetypes. */
void dom_ecs_storage_move_component(DomComponentId cid,
                                    void *dst, dom_u32 dst_index,
                                    void *src, dom_u32 src_index);
Implementation:
• At startup, allocate all component arrays up to max entities (configurable).
• Memory contiguous; index corresponds to entity slot within archetype grouping.
• Zero-initialised by rule unless declared otherwise.
Prohibitions:
• No malloc per entity.
• No per-tick realloc.

5. dom_ecs_archetype.[hc] — Archetype signatures and entity distribution
Purpose: central grouping mechanism: entities with identical component sets go into the same archetype.
Header: dom_ecs_archetype.h
Types:
typedef struct DomArchetype {
    DomArchetypeId id;
    DomSignature   sig;        /* bitmask of components */
    dom_u32        count;      /* number of entities */
    dom_u32        capacity;
    dom_u32        *entity_indices; /* mapping to global entity table */
} DomArchetype;
Public API:
Init/reset:
DomResult dom_ecs_archetype_init(void);
void      dom_ecs_archetype_reset(void);
Lookup/create:
DomArchetypeId dom_ecs_archetype_ensure(DomSignature sig);
const DomArchetype *dom_ecs_archetype_get(DomArchetypeId id);
Add/remove entity:
DomResult dom_ecs_archetype_add_entity(DomArchetypeId id, DomEntity e);
DomResult dom_ecs_archetype_remove_entity(DomArchetypeId id, DomEntity e);
Signature manipulation:
DomSignature dom_ecs_signature_add(DomSignature sig, DomComponentId cid);
DomSignature dom_ecs_signature_remove(DomSignature sig, DomComponentId cid);
dom_bool8    dom_ecs_signature_has(DomSignature sig, DomComponentId cid);
Implementation rules:
• Archetypes kept in sorted array by signature value.
• Entity moves between archetypes on component add/remove.
• Move operation invokes storage_move_component for each component in signature.
Prohibitions:
• No sparse storage.
• No dynamic chaining of archetypes mid-tick (all moves deferred to merge-phase unless explicitly allowed).

6. dom_ecs_entity + dom_ecs_component + dom_ecs_archetype integration
Critical tick-phase requirement:
All structural changes (add/remove components, create/destroy entities) are collected by command buffers via dom_sim_events.
Then executed deterministically in MERGE phase:
• Apply entity deletions.
• Apply component removals.
• Apply component additions.
• Move entities to new archetypes.
• Rebuild any archetype-local ordering if needed (stable lexicographic).
This keeps simulation stable and prevents mid-system inconsistency.

7. dom_ecs_query.[hc] — Read-only component access
Purpose: allow systems to get pointers to component arrays in their archetype groups.
Header includes
#include "dom_ecs_archetype.h"
Types:
typedef struct DomEcsQueryIter {
    const DomArchetype *arch;
    dom_u32 index;
    dom_u32 end;
} DomEcsQueryIter;
Public API:
Archetype-level query:
void dom_ecs_query_begin(DomSignature sig,
                         DomEcsQueryIter *it);

dom_bool8 dom_ecs_query_next(DomEcsQueryIter *it,
                             DomEntity *out_e,
                             void **out_component_ptrs /* array aligned to signature */);
Alternate system-level access:
void *dom_ecs_query_component(DomComponentId cid, DomEntity e);
Implementation rules:
• Query iteration is deterministic: archetypes in ascending ID order; entities inside archetype in stored order.
• Component pointers are direct pointers into dense arrays.
Prohibitions:
• No mutation here.
• No allocation; all pointers stable during a tick.

8. dom_ecs_iter.[hc] — High-level iteration helpers
Purpose: helper API used by simulation systems that need to iterate over a specific set of components quickly.
Public API:
Simple iteration:
typedef void (*DomEcsIterCallback)(DomEntity e,
                                   void **components,
                                   void *ctx);

void dom_ecs_iter_components(DomSignature sig,
                             DomEcsIterCallback cb,
                             void *ctx);
Lane-aware iteration:
void dom_ecs_iter_components_lane(DomSignature sig,
                                  DomLaneId lane,
                                  DomEcsIterCallback cb,
                                  void *ctx);
Implementation rules:
• For lane filtering, simply check (entity_id % num_lanes) == lane.
• No per-entity dynamic branching; use signature masks to restrict iteration early.

9. dom_ecs_system.[hc] — System registration & execution metadata
Purpose: register systems into phases and lanes so the simulation tick controller knows which to call.
Header: dom_ecs_system.h
Types:
typedef void (*DomSystemFn)(DomLaneId lane);

typedef struct DomSystemInfo {
    DomSystemId id;
    const char *name;
    DomSystemFn fn;
    dom_u8      phase;  /* simulation-phase index */
    dom_u8      lane_policy; /* all lanes, single lane, etc. */
} DomSystemInfo;
Public API:
DomSystemId dom_ecs_system_register(const DomSystemInfo *info);

const DomSystemInfo *dom_ecs_system_info(DomSystemId id);

void dom_ecs_system_run_phase(dom_u8 phase, DomLaneId lane);
Implementation rules:
• Systems sorted by ID in each phase.
• Phase IDs correspond strictly to your tick pipeline:
o INPUT
o PRE_STATE
o SIMULATION
o NETWORKS
o MERGE
o POST
o FINALIZE
Prohibitions:
• No simulation logic here.
• No random order; stable ordering only.

10. ECS LIFECYCLE (MANDATORY CONTRACT)
Tick flow handling within ECS:
1. Systems run (SIMULATION phase)
o Read components
o Emit events/commands
o DO NOT modify archetypes/components directly
2. MERGE phase:
o Apply entity create/destroy
o Apply component add/remove
o Move entities between archetypes
o Rebuild ordering
3. POST phase:
o Validate invariants
o Reindex spatial objects if required
o Clear transient buffers
No system may mutate ECS state outside MERGE unless explicitly allowed.

11. Summary
engine/ecs/ provides a deterministic, archetype-based, POD-component, lane-aware entity system with:
• strict lifecycle
• fixed memory layouts
• deferred structural updates
• dense storage
• deterministic iteration
• system registration and scheduling
It binds simulation systems to data and ensures stable, cross-platform correctness.

Next directory: engine/network/ unless you specify otherwise.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the deterministic dev-spec for engine/net/.
This layer defines all simulation-visible networking: lockstep protocol, message packing, channels, and replay hooks. It does not decide sockets, OS I/O, or encryption; those live in the platform layer.

Directory Layout
engine/
└── net/
    ├── dom_net_types.h
    ├── dom_net_config.h
    ├── dom_net_lockstep.h
    ├── dom_net_lockstep.c
    ├── dom_net_proto.h
    ├── dom_net_proto.c
    ├── dom_net_channel.h
    ├── dom_net_channel.c
    ├── dom_net_serialize.h
    ├── dom_net_serialize.c
    ├── dom_net_replay.h
    ├── dom_net_replay.c
    ├── dom_net_client.h
    ├── dom_net_client.c
    ├── dom_net_server.h
    └── dom_net_server.c
Global rules for this directory:
• C89 only.
• No floats.
• No direct OS calls (send, recv, select, etc.). All I/O goes through engine/platform.
• Deterministic, tick-based lockstep only. No “approximate” sync.
• No direct access to ECS internals. All simulation state passes through serialization layer APIs.
• No randomness in protocol behaviour; no adaptive timeouts that change semantics.
• All wire formats explicitly versioned and endian-independent.

1. dom_net_types.h — Core network types and IDs
Purpose: shared base types for all networking modules.
Includes:
#include "dom_core_types.h"
#include "dom_sim_time.h"     /* tick numbers, UPS */
Types:
typedef dom_u32 DomNetPeerId;     /* index in peer table */
typedef dom_u32 DomNetChannelId;  /* logical channel ID (reliable, input, debug, etc.) */
typedef dom_u32 DomNetMsgType;    /* message type enum */
typedef dom_u64 DomNetSessionId;  /* unique session identifier */
typedef dom_u64 DomNetWorldId;    /* world/universe ID for cross-server */

typedef dom_u32 DomNetTick;       /* simulation tick index */
typedef dom_u32 DomNetSeq;        /* sequence number per channel */
Session and role:
typedef enum {
    DOM_NET_ROLE_NONE = 0,
    DOM_NET_ROLE_SERVER,
    DOM_NET_ROLE_CLIENT
} DomNetRole;

typedef enum {
    DOM_NET_CONN_STATE_DISCONNECTED = 0,
    DOM_NET_CONN_STATE_HANDSHAKE,
    DOM_NET_CONN_STATE_SYNCING,
    DOM_NET_CONN_STATE_RUNNING,
    DOM_NET_CONN_STATE_ERROR
} DomNetConnState;
Result codes:
typedef enum {
    DOM_NET_OK = 0,
    DOM_NET_ERR_GENERIC,
    DOM_NET_ERR_VERSION_MISMATCH,
    DOM_NET_ERR_PROTOCOL,
    DOM_NET_ERR_TIMEOUT,
    DOM_NET_ERR_BUFFER_OVERFLOW,
    DOM_NET_ERR_NOT_READY
} DomNetResult;
Prohibitions:
• No structs with internal pointers to OS socket state.
• No platform includes.

2. dom_net_config.h — Static configuration constants
Purpose: tuneable constants for packet size, buffer counts, timeouts, but all deterministic and compile-time or config-file driven.
Contains defines only, no functions:
#define DOM_NET_MAX_PEERS             64
#define DOM_NET_MAX_CHANNELS          8
#define DOM_NET_MAX_MSG_SIZE          1400    /* bytes payload */
#define DOM_NET_MAX_PACKET_SIZE       1500    /* bytes including headers */
#define DOM_NET_MAX_PENDING_PACKETS   256
#define DOM_NET_RESEND_WINDOW         64      /* seq numbers */
#define DOM_NET_INPUT_BUFFER_TICKS    8       /* how many future ticks to queue */
#define DOM_NET_REPLAY_BUFFER_TICKS   1024
#define DOM_NET_HEARTBEAT_INTERVAL    30      /* ticks */
#define DOM_NET_TIMEOUT_TICKS         600     /* ticks until disconnect */
Prohibitions:
• No dynamic reconfiguration at runtime that changes semantics mid-session.
• No platform-dependent values here.

3. dom_net_proto.[hc] — Wire protocol structure
Purpose: define the actual on-wire packet format, headers, message types, and assembly/disassembly helpers.
Header: dom_net_proto.h
Includes:
#include "dom_net_types.h"
#include "dom_net_config.h"
Packet header:
#define DOM_NET_MAGIC 0x444F4D4E  /* 'DOMN' */

typedef struct DomNetPacketHeader {
    dom_u32 magic;          /* DOM_NET_MAGIC */
    dom_u16 version_major;  /* protocol version */
    dom_u16 version_minor;
    DomNetSessionId session_id;
    DomNetWorldId   world_id;
    DomNetRole      role;         /* sender role */
    DomNetTick      tick;         /* sender current tick */
    dom_u8          flags;        /* compression, ack-only, etc. */
    dom_u8          reserved[7];
} DomNetPacketHeader;
Per-message header inside packet:
typedef struct DomNetMsgHeader {
    DomNetChannelId channel_id;
    DomNetMsgType   type;
    DomNetSeq       seq;
    dom_u16         payload_size; /* bytes */
    dom_u16         flags;        /* reliability, etc. */
} DomNetMsgHeader;
Public API:
Packing:
DomNetResult dom_net_proto_begin_packet(DomNetPacketHeader *hdr,
                                        DomNetRole role,
                                        DomNetSessionId session_id,
                                        DomNetWorldId world_id,
                                        DomNetTick tick);

DomNetResult dom_net_proto_append_message(dom_u8 *buf,
                                          dom_u32 buf_size,
                                          dom_u32 *inout_offset,
                                          const DomNetMsgHeader *mhdr,
                                          const void *payload);
Unpacking:
DomNetResult dom_net_proto_read_header(const dom_u8 *buf,
                                       dom_u32 buf_size,
                                       DomNetPacketHeader *out_hdr);

DomNetResult dom_net_proto_next_message(const dom_u8 *buf,
                                        dom_u32 buf_size,
                                        dom_u32 *inout_offset,
                                        DomNetMsgHeader *out_mhdr,
                                        void *out_payload,
                                        dom_u32 max_payload);
Implementation rules:
• Strict bounds checking; never read/write beyond buffer.
• All multibyte fields little-endian on wire.
• Version mismatch must yield DOM_NET_ERR_VERSION_MISMATCH and force disconnect.
Prohibitions:
• No compression algorithms here; just flags. Compression is a separate module if ever added.
• No encryption; handled outside this layer.

4. dom_net_channel.[hc] — Logical channels and reliability
Purpose: manage per-channel sequencing, acking, and message buffering on top of UDP-like unreliable transport.
Header: dom_net_channel.h
Includes:
#include "dom_net_types.h"
#include "dom_net_proto.h"
Channel kind:
typedef enum {
    DOM_NET_CH_RELIABLE_ORDERED = 0,
    DOM_NET_CH_UNRELIABLE,
    DOM_NET_CH_INPUT_LOCKSTEP   /* special for input commands */
} DomNetChannelKind;
Channel state:
typedef struct DomNetChannel {
    DomNetChannelId   id;
    DomNetChannelKind kind;
    DomNetSeq         next_send_seq;
    DomNetSeq         next_expect_seq;
    DomNetSeq         last_acked_seq;

    /* Fixed-size outgoing window for reliable messages */
    dom_u8   send_window[DOM_NET_RESEND_WINDOW][DOM_NET_MAX_MSG_SIZE];
    dom_u16  send_window_size[DOM_NET_RESEND_WINDOW];
    DomNetSeq send_window_seq[DOM_NET_RESEND_WINDOW];

    /* Fixed-size receive buffer for ordered delivery */
    dom_u8   recv_window[DOM_NET_RESEND_WINDOW][DOM_NET_MAX_MSG_SIZE];
    dom_u16  recv_window_size[DOM_NET_RESEND_WINDOW];
    DomNetSeq recv_window_seq[DOM_NET_RESEND_WINDOW];

    dom_u32  last_activity_tick;
} DomNetChannel;
Public API:
Init:
void dom_net_channel_init(DomNetChannel *ch,
                          DomNetChannelId id,
                          DomNetChannelKind kind);
Outgoing:
DomNetResult dom_net_channel_enqueue(DomNetChannel *ch,
                                     DomNetMsgType type,
                                     const void *payload,
                                     dom_u16 payload_size,
                                     DomNetSeq *out_seq);

/* Called when building a packet; returns messages to send. */
DomNetResult dom_net_channel_collect_send(DomNetChannel *ch,
                                          DomNetTick current_tick,
                                          dom_u8 *packet_buf,
                                          dom_u32 packet_size,
                                          dom_u32 *inout_offset);
Incoming:
DomNetResult dom_net_channel_receive(DomNetChannel *ch,
                                     const DomNetMsgHeader *mhdr,
                                     const void *payload);

/* Poll for next delivered message in order. */
DomNetResult dom_net_channel_dequeue(DomNetChannel *ch,
                                     DomNetMsgHeader *out_mhdr,
                                     void *out_payload,
                                     dom_u16 max_payload);
Implementation rules:
• For RELIABLE_ORDERED, missing seqs buffer out-of-order until gap filled; on overflow, oldest entries drop with deterministic policy.
• For UNRELIABLE, no buffering: accept or drop based on space.
• For INPUT_LOCKSTEP, enforce exactly one input per player per tick; missing inputs cause pause/wait in lockstep controller (see lockstep module).
Prohibitions:
• No dynamic allocation in enqueue/receive.
• No per-platform behaviour differences.

5. dom_net_lockstep.[hc] — Deterministic lockstep controller
Purpose: enforce the tick-synchronous model described in the determinism spec: all peers must have all inputs for tick N before simulating tick N.
Header: dom_net_lockstep.h
Includes:
#include "dom_net_types.h"
#include "dom_net_channel.h"
#include "dom_sim_time.h"
#include "dom_sim_input.h"    /* canonical input command format */
Types:
typedef struct DomNetLockstepPeer {
    DomNetPeerId id;
    DomNetConnState state;
    DomNetTick last_confirmed_tick;
    DomNetTick last_recv_tick;
    DomNetTick last_send_tick;
    dom_bool8  has_input_for_tick[DOM_NET_INPUT_BUFFER_TICKS];
} DomNetLockstepPeer;
Controller:
typedef struct DomNetLockstep {
    DomNetRole role;
    DomNetSessionId session_id;
    DomNetWorldId   world_id;
    DomNetTick      current_tick;
    dom_u32         peer_count;
    DomNetLockstepPeer peers[DOM_NET_MAX_PEERS];

    /* Channel dedicated to lockstep inputs */
    DomNetChannel   input_channel;
} DomNetLockstep;
Public API:
Init/reset:
DomResult dom_net_lockstep_init(DomNetLockstep *ls,
                                DomNetRole role,
                                DomNetSessionId session_id,
                                DomNetWorldId world_id);

void      dom_net_lockstep_reset(DomNetLockstep *ls);
Tick control:
/* Called once per simulation tick BEFORE sim step. */
DomNetResult dom_net_lockstep_before_tick(DomNetLockstep *ls,
                                          DomNetTick tick,
                                          const DomSimInputFrame *local_input);

/* Returns whether it is safe to advance to tick N (all inputs present). */
dom_bool8 dom_net_lockstep_can_advance(const DomNetLockstep *ls,
                                       DomNetTick tick);
Input retrieval:
/* Collects authoritative input frame for given tick and peer. */
DomResult dom_net_lockstep_get_input(const DomNetLockstep *ls,
                                     DomNetTick tick,
                                     DomNetPeerId peer_id,
                                     DomSimInputFrame *out_input);
Packet integration:
/* Called for each received packet's messages on input channel. */
DomResult dom_net_lockstep_on_input_message(DomNetLockstep *ls,
                                            DomNetPeerId peer_id,
                                            const DomNetMsgHeader *mhdr,
                                            const void *payload);
Implementation rules:
• Lockstep runs entirely in tick-space; no real-time concept.
• If any peer lacks input for tick N, can_advance must return false and the sim must stall.
• Inputs older than current_tick - DOM_NET_INPUT_BUFFER_TICKS can be discarded once confirmed.
• Host is authoritative for tick progression; clients must follow host’s current_tick announcements.
Prohibitions:
• No prediction or rollback here. Prediction is an optional layer elsewhere, not in deterministic kernel.
• No auto-skip of slow peers; network policy decides disconnection.

6. dom_net_serialize.[hc] — Deterministic state and message serialization
Purpose: pack/unpack simulation-visible constructs into network messages or logs.
Header: dom_net_serialize.h
Includes:
#include "dom_net_types.h"
#include "dom_sim_snapshot.h"   /* snapshot descriptor(s) */
#include "dom_sim_input.h"
Public API:
Input serialization:
dom_u16 dom_net_serialize_input(const DomSimInputFrame *frame,
                                dom_u8 *buf,
                                dom_u16 buf_size);

DomResult dom_net_deserialize_input(DomSimInputFrame *frame,
                                    const dom_u8 *buf,
                                    dom_u16 size);
Snapshot serialization (for join/sync):
dom_u16 dom_net_serialize_snapshot_header(const DomSimSnapshotHeader *hdr,
                                          dom_u8 *buf,
                                          dom_u16 buf_size);

dom_u16 dom_net_serialize_snapshot_chunk(const DomSimSnapshotChunk *chunk,
                                         dom_u8 *buf,
                                         dom_u16 buf_size);

DomResult dom_net_deserialize_snapshot_header(DomSimSnapshotHeader *hdr,
                                              const dom_u8 *buf,
                                              dom_u16 size);

DomResult dom_net_deserialize_snapshot_chunk(DomSimSnapshotChunk *chunk,
                                             const dom_u8 *buf,
                                             dom_u16 size);
Implementation rules:
• Never serialize pointers. Only IDs, indices, fixed-size structs.
• Use fixed endian (little) and fixed field ordering.
• No schema discovery at runtime: formats are compile-time defined and versioned.
Prohibitions:
• No compression inside these functions.
• No direct file I/O (replay uses the same functions but writes via separate layer).

7. dom_net_replay.[hc] — Replay capture and playback over network layer
Purpose: capture all simulation-relevant inputs and network ticks for deterministic replay, and feed them back to the engine.
Header: dom_net_replay.h
Includes:
#include "dom_net_types.h"
#include "dom_sim_input.h"
#include "dom_sim_time.h"
Types:
typedef enum {
    DOM_NET_REPLAY_MODE_OFF = 0,
    DOM_NET_REPLAY_MODE_RECORD,
    DOM_NET_REPLAY_MODE_PLAYBACK
} DomNetReplayMode;

typedef struct DomNetReplay {
    DomNetReplayMode mode;
    DomNetTick       start_tick;
    DomNetTick       current_tick;
    /* Internal fixed-size buffers or streaming handle; opaque to callers */
} DomNetReplay;
Public API:
Init:
DomResult dom_net_replay_init(DomNetReplay *rp);
void      dom_net_replay_reset(DomNetReplay *rp);
Mode control:
DomResult dom_net_replay_begin_record(DomNetReplay *rp,
                                      DomNetTick start_tick);

DomResult dom_net_replay_begin_playback(DomNetReplay *rp,
                                        DomNetTick start_tick);

void      dom_net_replay_stop(DomNetReplay *rp);
Recording:
DomResult dom_net_replay_record_input(DomNetReplay *rp,
                                      DomNetTick tick,
                                      DomNetPeerId peer_id,
                                      const DomSimInputFrame *frame);
Playback:
DomResult dom_net_replay_get_input(DomNetReplay *rp,
                                   DomNetTick tick,
                                   DomNetPeerId peer_id,
                                   DomSimInputFrame *out_frame);
Implementation rules:
• Uses deterministic binary format identical across systems (same serialization helpers as network).
• No compression that depends on platform-specific libraries; if added, must be deterministic and stable.
• Cannot change behaviour based on real time; only tick.
Prohibitions:
• No partial replay editing here.
• No random sampling or trimming; full record only, or pre-defined trimming logic strictly defined.

8. dom_net_client.[hc] — Client-side network state machine
Purpose: wraps proto + channels + lockstep into a client logic unit. Does not do sockets; only consumes/produces packets as raw byte arrays.
Header: dom_net_client.h
Includes:
#include "dom_net_types.h"
#include "dom_net_lockstep.h"
#include "dom_net_channel.h"
#include "dom_net_proto.h"
#include "dom_net_serialize.h"
Types:
typedef struct DomNetClient {
    DomNetConnState  state;
    DomNetSessionId  session_id;
    DomNetWorldId    world_id;
    DomNetPeerId     server_peer_id;

    DomNetTick       local_tick;
    DomNetTick       server_tick_hint;

    DomNetLockstep   lockstep;

    DomNetChannel    channels[DOM_NET_MAX_CHANNELS];

    dom_u32          last_recv_tick;
    dom_u32          last_send_tick;
} DomNetClient;
Public API:
Init/reset:
DomResult dom_net_client_init(DomNetClient *c);
void      dom_net_client_reset(DomNetClient *c);
Connect/session management (logic-level):
DomResult dom_net_client_start(DomNetClient *c,
                               DomNetWorldId world_id);

void      dom_net_client_disconnect(DomNetClient *c);
Tick update:
/* Called once per engine tick. Produces a packet if one should be sent. */
DomNetResult dom_net_client_tick(DomNetClient *c,
                                 const DomSimInputFrame *local_input,
                                 dom_u8 *out_packet,
                                 dom_u32 out_packet_size,
                                 dom_u32 *out_packet_len,
                                 DomNetTick *out_tick_to_simulate);
Packet receive:
DomNetResult dom_net_client_on_packet(DomNetClient *c,
                                      const dom_u8 *packet,
                                      dom_u32 packet_len);
Simulation integration:
• dom_net_client_tick sets *out_tick_to_simulate only when lockstep_can_advance.
• Caller must not advance sim tick unless a valid tick index is provided.
Prohibitions:
• No direct calls to OS or sockets.
• No UI-specific logic.

9. dom_net_server.[hc] — Server-side network state machine
Purpose: authoritative host managing multiple clients, driving lockstep tick progression, and providing snapshot/sync.
Header: dom_net_server.h
Includes:
#include "dom_net_types.h"
#include "dom_net_lockstep.h"
#include "dom_net_channel.h"
#include "dom_net_proto.h"
#include "dom_net_serialize.h"
#include "dom_sim_snapshot.h"
Types:
typedef struct DomNetServerPeer {
    DomNetPeerId id;
    DomNetConnState state;
    DomNetTick last_recv_tick;
    DomNetTick last_send_tick;
    DomNetTick last_confirmed_tick;
    DomNetChannel channels[DOM_NET_MAX_CHANNELS];
} DomNetServerPeer;

typedef struct DomNetServer {
    DomNetSessionId session_id;
    DomNetWorldId   world_id;
    DomNetTick      current_tick;
    DomNetConnState state;

    dom_u32         peer_count;
    DomNetServerPeer peers[DOM_NET_MAX_PEERS];

    DomNetLockstep  lockstep;
} DomNetServer;
Public API:
Init/reset:
DomResult dom_net_server_init(DomNetServer *s,
                              DomNetWorldId world_id);

void      dom_net_server_reset(DomNetServer *s);
Peer management (logic-level; platform layer decides when to call):
DomNetPeerId dom_net_server_add_peer(DomNetServer *s);
void         dom_net_server_remove_peer(DomNetServer *s,
                                        DomNetPeerId id);
Per-tick:
/* Called once per server tick. Fills array of packets to send. */
DomNetResult dom_net_server_tick(DomNetServer *s,
                                 dom_u8 out_packets[][DOM_NET_MAX_PACKET_SIZE],
                                 dom_u32 out_packet_sizes[],
                                 DomNetPeerId out_packet_peers[],
                                 dom_u32 max_packets,
                                 dom_u32 *out_packet_count,
                                 DomNetTick *out_tick_to_simulate);
Packet receive:
DomNetResult dom_net_server_on_packet(DomNetServer *s,
                                      DomNetPeerId peer_id,
                                      const dom_u8 *packet,
                                      dom_u32 packet_len);
Snapshot/sync helpers:
DomResult dom_net_server_build_snapshot(const DomNetServer *s,
                                        DomNetPeerId peer_id,
                                        DomSimSnapshotHeader *out_hdr);

DomResult dom_net_server_on_snapshot_ack(DomNetServer *s,
                                         DomNetPeerId peer_id,
                                         const DomSimSnapshotHeader *hdr);
Implementation rules:
• server_tick is the authoritative tick; clients follow it.
• Server only advances tick when all connected peers in RUNNING state have input for tick N (lockstep).
• On timeouts, server marks peer as disconnected and can continue with remaining peers.
Prohibitions:
• No server-side prediction of clients.
• No dynamic tick speed changes based on real time.

Summary:
engine/net/ defines a deterministic, lockstep-only, protocol-stable networking core:
• types/config: common IDs and constants.
• proto: packet and message packing/unpacking.
• channel: reliable/unreliable channels with bounded windows.
• lockstep: tick gating and input distribution.
• serialize: deterministic input/snapshot packing.
• replay: record/playback of inputs.
• client and server: high-level state machines that glue all of the above.
All socket/OS concerns are deferred to the platform layer, which sees only raw packet buffers and peer IDs.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the deterministic dev-spec for engine/render/.
This directory is the lowest-level, platform-agnostic rendering layer.
It defines one abstract rendering API used by the engine and game, and multiple backend implementations:
• Software (fallback)
• Vector2D (pure analytical/vector)
• OpenGL1.1
• OpenGL2.0
• DirectX 9
• DirectX 11
• Optional: Vulkan, Metal (future)
All rendering occurs outside the deterministic simulation; the sim only produces stable render commands.

Directory Layout
engine/
└── render/
    ├── dom_render_api.h
    ├── dom_render_state.h
    ├── dom_render_state.c
    ├── dom_render_commands.h
    ├── dom_render_commands.c
    ├── dom_render_backend.h
    ├── dom_render_backend_null.c
    ├── gl1/
    │    ├── dom_render_gl1.h
    │    └── dom_render_gl1.c
    ├── gl2/
    │    ├── dom_render_gl2.h
    │    └── dom_render_gl2.c
    ├── dx9/
    │    ├── dom_render_dx9.h
    │    └── dom_render_dx9.c
    ├── dx11/
    │    ├── dom_render_dx11.h
    │    └── dom_render_dx11.c
    ├── vector2d/
    │    ├── dom_render_vec2d.h
    │    └── dom_render_vec2d.c
    └── software/
         ├── dom_render_soft.h
         └── dom_render_soft.c
Global rules for this directory:
• C89/C98 only.
• No simulation logic.
• No game logic.
• No allocation inside the hot loop; all buffer and atlas sizes fixed at init.
• One abstract API, many interchangeable backends.
• Deterministic render commands: the same input must produce identical command buffers across platforms.

1. dom_render_api.h — Abstract public rendering API
Purpose: The rest of the engine and game use only this header; never directly include backend headers.
Includes:
#include "dom_core_types.h"
#include "dom_render_state.h"
#include "dom_render_commands.h"
Types:
typedef enum {
    DOM_RENDER_BACKEND_NULL = 0,
    DOM_RENDER_BACKEND_GL1,
    DOM_RENDER_BACKEND_GL2,
    DOM_RENDER_BACKEND_DX9,
    DOM_RENDER_BACKEND_DX11,
    DOM_RENDER_BACKEND_VEC2D,
    DOM_RENDER_BACKEND_SOFTWARE
} DomRenderBackendKind;
Renderer object:
typedef struct DomRenderer {
    DomRenderBackendKind backend;
    void *backend_state; /* opaque pointer to backend's state struct */

    /* Dimensions provided by platform layer */
    dom_u32 width;
    dom_u32 height;

    /* Fixed command buffer for this frame */
    DomRenderCommandBuffer cmd;
} DomRenderer;
Public API:
Initialization:
DomResult dom_render_create(DomRenderer *r,
                            DomRenderBackendKind backend,
                            dom_u32 width,
                            dom_u32 height);

void dom_render_destroy(DomRenderer *r);
Resize:
void dom_render_resize(DomRenderer *r, dom_u32 width, dom_u32 height);
Frame lifecycle:
void dom_render_begin(DomRenderer *r);    /* Clear command buffer */
void dom_render_submit(DomRenderer *r);   /* Submit commands to backend */
void dom_render_present(DomRenderer *r);  /* Flip/backbuffer command */
Drawing primitives (enqueue commands):
void dom_render_rect(DomRenderer *r, const DomRect *rc, DomColor c);
void dom_render_line(DomRenderer *r, dom_i32 x0, dom_i32 y0,
                                   dom_i32 x1, dom_i32 y1,
                                   DomColor c);
void dom_render_poly(DomRenderer *r, const DomVec2i *pts, dom_u32 count, DomColor c);
void dom_render_sprite(DomRenderer *r, DomSpriteId id,
                                      dom_i32 x, dom_i32 y);
void dom_render_text(DomRenderer *r, DomFontId font,
                                    const char *text,
                                    dom_i32 x, dom_i32 y,
                                    DomColor c);
Prohibitions:
• This API never speaks in floats; all coords integers (screen-space after projection).
• This API is backend-independent; absolutely no GL/DX types allowed here.
• No pointers to game data (sprites, fonts) except ID handles.

2. dom_render_state.[hc] — Shared fixed render state structures
Purpose: shared state definitions used by command generation and all backends.
Header: dom_render_state.h
Types:
typedef struct {
    dom_i32 x, y, w, h;
} DomRect;

typedef dom_u32 DomColor;      /* ARGB: 0xAARRGGBB */

typedef dom_u32 DomSpriteId;
typedef dom_u32 DomFontId;

/* Runtime global state, independent from backend */
typedef struct DomRenderState {
    DomColor clear_color;
    DomColor default_color;
    DomSpriteId default_sprite;
} DomRenderState;
Public API:
void dom_render_state_init(DomRenderState *s);
Implementation rules:
• clear_color is used by all backends to clear the frame.
• Integer-only transforms; projection handled outside this layer.
Prohibitions:
• No dynamic loading of textures/fonts here.
• No backend interaction here.

3. dom_render_commands.[hc] — Deterministic command buffer
Purpose: This is the only path from the simulation/game logic to the backend.
Header: dom_render_commands.h
Includes:
#include "dom_core_types.h"
#include "dom_render_state.h"
Types:
Command kinds:
typedef enum {
    DOM_CMD_NONE = 0,
    DOM_CMD_RECT,
    DOM_CMD_LINE,
    DOM_CMD_POLY,
    DOM_CMD_SPRITE,
    DOM_CMD_TEXT
} DomRenderCmdKind;
Command payload:
typedef struct {
    dom_i32 x, y, w, h;
    DomColor color;
} DomCmdRect;

typedef struct {
    dom_i32 x0, y0, x1, y1;
    DomColor color;
} DomCmdLine;

typedef struct {
    dom_u32 count;
    DomVec2i pts[16];  /* fixed */
    DomColor color;
} DomCmdPoly;

typedef struct {
    DomSpriteId id;
    dom_i32 x, y;
} DomCmdSprite;

typedef struct {
    DomFontId font;
    DomColor color;
    char text[256];   /* fixed */
    dom_i32 x, y;
} DomCmdText;
Command entry:
typedef struct {
    DomRenderCmdKind kind;
    union {
        DomCmdRect rect;
        DomCmdLine line;
        DomCmdPoly poly;
        DomCmdSprite sprite;
        DomCmdText text;
    } u;
} DomRenderCmd;
Command buffer:
#define DOM_RENDER_CMD_MAX 8192

typedef struct {
    dom_u32 count;
    DomRenderCmd cmds[DOM_RENDER_CMD_MAX];
} DomRenderCommandBuffer;
Public API:
void dom_render_cmd_init(DomRenderCommandBuffer *cb);

DomResult dom_render_cmd_push(DomRenderCommandBuffer *cb,
                              const DomRenderCmd *cmd);
Implementation rules:
• Sequential, deterministic ordering.
• Hard cap (DOM_RENDER_CMD_MAX).
• Overflow returns a deterministic error and discards extra commands for that frame.
Prohibitions:
• No dynamic lists.
• No pointer storage except trivial fixed-length arrays.

4. dom_render_backend.h — Backend interface contract
Purpose: define functions each backend must implement.
Header: dom_render_backend.h
Functions every backend must provide:
typedef struct DomRenderBackendAPI {
    DomResult (*init)(DomRenderer *r);
    void      (*shutdown)(DomRenderer *r);
    void      (*resize)(DomRenderer *r, dom_u32 w, dom_u32 h);

    /* Process command buffer */
    void      (*submit)(DomRenderer *r, const DomRenderCommandBuffer *cb);

    /* Flip/draw-present call */
    void      (*present)(DomRenderer *r);
} DomRenderBackendAPI;
Backend selection:
const DomRenderBackendAPI *
dom_render_backend_get(DomRenderBackendKind k);
Rules:
• Must draw exactly what command buffer describes — no deviation.
• No “extra” transforms; camera/projection handled at a higher level.
• Backends must convert integer screen-space to their native API coordinates deterministically.
Prohibitions:
• No global GL/DX state pollution outside the backend.

5. Backends
Each backend directory has one state struct and one implementation file.
5.1 gl1/ — OpenGL 1.1 backend
Header:
typedef struct {
    /* GL1 handles */
    dom_u32 tex_ids[1024];
    dom_u32 font_ids[64];
} DomRenderGL1State;
Responsibilities:
• Uses immediate mode (glBegin/glEnd).
• Only integer-to-float conversion allowed is deterministic exact cast.
• No shaders.
Initialization:
• Create GL context (via platform layer).
• Load textures using engine asset loaders (IDs only).
Prohibitions:
• No VAOs/VBOs.
• No modern OpenGL features.

5.2 gl2/ — OpenGL 2.0 backend
State struct includes shader programs, VBOs, and atlas texture handles.
Rules:
• Single orthographic shader fixed in this backend.
• All shader constants deterministic and integer-driven.
• VBOs preallocated.
Prohibitions:
• No runtime shader compilation from external files.
• No GL extension variation.

5.3 dx9/ — DirectX 9 backend
State:
• Device pointer (opaque to engine).
• Prebuilt vertex formats.
• Texture atlas pool.
Rules:
• Pre-transformed vertices (XYZRHW) only.
• No fixed-function lighting.

5.4 dx11/ — DirectX 11 backend
State:
• Device + context
• Mesh buffers
• Constant buffers (orthographic projection derived from screen size)
Rules:
• No dynamic buffer resizing.
• No external shader files at runtime; ship embedded bytecode.

5.5 vector2d/ — Pure vector math backend
Purpose: minimal backend for ultra-old systems or for dev builds where texturing unavailable.
Rules:
• Only draws lines and filled polys; sprite/text become wireframe boxes or outline glyph approximations.
• Must match command buffer output shape.

5.6 software/ — CPU rasterizer backend
Purpose: fallback for DOS, Win9x, very old macOS, or safe mode.
Rules:
• One pixel buffer.
• Deterministic Bresenham.
• Deterministic scanline fill.
• Blitting functions integer-only.

6. Behavioural Guarantees
6.1 Determinism
• Render commands produced by sim/game are deterministic.
• Render backend execution timing may vary, but output pixels for a given command buffer are guaranteed identical per backend.
6.2 No simulation influence
Renderers cannot ever feed information back into the sim.
6.3 Hard failure rules
• Any illegal command (unsupported type, overflow) is discarded with an error code but must never crash the engine.
• Backends must treat unknown commands as NO-OP.

7. Summary
engine/render/ defines a stable, deterministic, backend-independent rendering pipeline:
• dom_render_api.h — the only header engine/game code touches.
• Command buffer — deterministic, integer, fixed-size operations.
• Backends — plug-in GL1/GL2/DX9/DX11/Vector/Software implementations.
• Platform-agnostic — platform layer supplies window/GL context/DX device.
This guarantees cross-platform stability from DOS-class machines up to modern hardware.

Next directory will be engine/platform/ unless you specify otherwise.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the deterministic dev-spec for engine/platform/.
This is the only directory allowed to depend on OS APIs (Win32, POSIX, macOS, X11, Cocoa, ALSA, PulseAudio, CoreAudio, etc.).
Everything here exists behind stable cross-platform interfaces.
No simulation, rendering, audio, or game logic is allowed in these files.

Directory Layout
engine/
└── platform/
    ├── dom_platform.h
    ├── dom_platform.c
    ├── win32/
    │    ├── dom_platform_win32.h
    │    └── dom_platform_win32.c
    ├── linux/
    │    ├── dom_platform_linux.h
    │    └── dom_platform_linux.c
    ├── macos/
    │    ├── dom_platform_macos.h
    │    └── dom_platform_macos.c
    ├── dos/
    │    ├── dom_platform_dos.h
    │    └── dom_platform_dos.c
    ├── win9x/
    │    ├── dom_platform_win9x.h
    │    └── dom_platform_win9x.c
    ├── macos_classic/
    │    ├── dom_platform_macos_classic.h
    │    └── dom_platform_macos_classic.c
    └── wasm/
         ├── dom_platform_wasm.h
         └── dom_platform_wasm.c
Global rules:
• C89/C98 only for core, but platform subdirs may include OS headers.
• No determinism inside this layer matters; determinism is guaranteed above.
• No complex logic: thin wrappers only.
• All I/O must go through this.
• No direct dependency from sim/ecs/render/audio/game to OS headers.
• No allocations above this layer may escape into simulation state.

1. dom_platform.h — Master abstract platform API
This is the only platform header visible to the entire engine.
Includes:
#include "dom_core_types.h"
Defines a large abstract interface broken into functional sub-APIs:
• Filesystem
• Time
• Windowing
• Input
• Threading
• Networking (socket transport only)
• Dynamic library loading (optional)
• Logging sink redirection
All OS-specific implementations must populate a DomPlatformAPI struct with function pointers.

1.1 Core platform types
typedef struct DomPlatformWindow DomPlatformWindow;
typedef struct DomPlatformFileHandle DomPlatformFileHandle;
typedef struct DomPlatformSocket DomPlatformSocket;
typedef struct DomPlatformThread DomPlatformThread;
typedef struct DomPlatformMutex DomPlatformMutex;
typedef struct DomPlatformCond DomPlatformCond;
Abstract enums:
typedef enum {
    DOM_KEY_NONE = 0,
    DOM_KEY_A, DOM_KEY_B, /* ... */
    DOM_KEY_LSHIFT, DOM_KEY_CTRL,
    DOM_MOUSE_LEFT, DOM_MOUSE_RIGHT,
    /* … full scancode map */
} DomKey;

typedef enum {
    DOM_FS_SEEK_SET = 0,
    DOM_FS_SEEK_CUR,
    DOM_FS_SEEK_END
} DomSeek;

typedef enum {
    DOM_SOCKET_UDP = 0,
    DOM_SOCKET_TCP
} DomSocketKind;

2. Filesystem API
Exposed through:
struct DomPlatformFilesystem {
    DomPlatformFileHandle *(*open)(const char *path, const char *mode);
    dom_u32 (*read)(DomPlatformFileHandle *, void *buf, dom_u32 bytes);
    dom_u32 (*write)(DomPlatformFileHandle *, const void *buf, dom_u32 bytes);
    dom_bool8 (*seek)(DomPlatformFileHandle *, dom_i64 offset, dom_i32 whence);
    dom_i64 (*tell)(DomPlatformFileHandle *);
    dom_bool8 (*flush)(DomPlatformFileHandle *);
    void (*close)(DomPlatformFileHandle *);

    dom_bool8 (*exists)(const char *path);
    dom_bool8 (*mkdir)(const char *path);
    dom_bool8 (*remove)(const char *path);
    dom_bool8 (*rename)(const char *oldp, const char *newp);

    dom_bool8 (*list_directory)(const char *path,
                                void (*cb)(const char *name, dom_bool8 is_dir, void *ctx),
                                void *ctx);
};
Rules:
• All file reads and writes are non-buffered beyond OS defaults.
• No memory-mapped files; must not depend on virtual memory.
• UTF-8 filenames externally; platform layer converts internally.
Prohibitions:
• No non-deterministic caching.
• No global working-directory changes except explicitly requested.

3. Time API
Strict separation between:
• Simulation time (deterministic, provided by engine/sim)
• Platform wallclock time (non-deterministic, used for IO/events)
struct DomPlatformTime {
    dom_u64 (*now_msec)(void);
    void    (*sleep_msec)(dom_u32);
};
Rules:
• never mix simulation tick time with wallclock here.
• Allowed to be nondeterministic; engine ignores it for sim.

4. Windowing + Context Creation API
Responsible only for:
• Creating a window
• Managing GL/DX contexts
• Handling resize events
• Passing keyboard/mouse input events
Header:
struct DomPlatformWindowAPI {
    DomPlatformWindow *(*create)(const char *title,
                                 dom_u32 w, dom_u32 h,
                                 dom_bool8 fullscreen);
    void (*destroy)(DomPlatformWindow *);
    void (*poll_events)(DomPlatformWindow *);
    dom_bool8 (*should_close)(DomPlatformWindow *);

    void (*swap_buffers)(DomPlatformWindow *);

    /* Backend creation */
    void *(*create_gl_context)(DomPlatformWindow *);
    void (*destroy_gl_context)(DomPlatformWindow *, void *);
    void *(*create_dx9_device)(DomPlatformWindow *);
    void *(*create_dx11_device)(DomPlatformWindow *);
};
Event callbacks (engine registers them):
typedef void (*DomPlatformInputCallback)(DomKey key, dom_bool8 down);
typedef void (*DomPlatformMouseMoveCallback)(dom_i32 x, dom_i32 y);
typedef void (*DomPlatformMouseClickCallback)(DomKey btn, dom_bool8 down);

void dom_platform_set_key_callback(DomPlatformInputCallback);
void dom_platform_set_mouse_move_callback(DomPlatformMouseMoveCallback);
void dom_platform_set_mouse_click_callback(DomPlatformMouseClickCallback);
Rules:
• Must map platform scancodes → canonical DomKey.
• Must deliver event order exactly as OS produces them.
Prohibitions:
• No filtering/throttling here.
• No text-input IME handling beyond raw key events.

5. Input Device API
struct DomPlatformInput {
    dom_bool8 (*key_down)(DomKey key);
    dom_bool8 (*mouse_down)(DomKey button);
    void (*mouse_pos)(dom_i32 *x, dom_i32 *y);
};
Rules:
• Cached state must update only during poll_events.

6. Networking (Transport Layer Only)
All higher networking logic is in engine/net/.
Platform provides only:
struct DomPlatformNet {
    DomPlatformSocket *(*socket_create)(DomSocketKind kind);
    void (*socket_destroy)(DomPlatformSocket *);
    dom_bool8 (*socket_bind)(DomPlatformSocket *, dom_u16 port);
    dom_bool8 (*socket_connect)(DomPlatformSocket *, const char *ip, dom_u16 port);

    dom_i32 (*socket_send)(DomPlatformSocket *, const void *buf, dom_i32 len);
    dom_i32 (*socket_recv)(DomPlatformSocket *, void *buf, dom_i32 max_len);
    dom_bool8 (*socket_set_nonblocking)(DomPlatformSocket *, dom_bool8 nonblock);
};
Rules:
• UDP sockets recommended for lockstep.
• Must return 0 or -1 for no data; no exceptions or OS errors propagate upward except numeric codes.
Prohibitions:
• No DNS resolves here.
• No TCP-specific handshake logic (other than OS connect).

7. Threading & Synchronization API
Used only by engine subsystems that need background IO, loaders, or async compression.
struct DomPlatformThreading {
    DomPlatformThread *(*thread_create)(void (*fn)(void *ctx), void *ctx);
    void (*thread_join)(DomPlatformThread *);

    DomPlatformMutex *(*mutex_create)(void);
    void (*mutex_destroy)(DomPlatformMutex *);
    void (*mutex_lock)(DomPlatformMutex *);
    void (*mutex_unlock)(DomPlatformMutex *);

    DomPlatformCond *(*cond_create)(void);
    void (*cond_destroy)(DomPlatformCond *);
    void (*cond_wait)(DomPlatformCond *, DomPlatformMutex *);
    void (*cond_signal)(DomPlatformCond *);
    void (*cond_broadcast)(DomPlatformCond *);
};
Rules:
• Cannot be used in deterministic simulation.
• Must not use platform thread pools; engine decides.

8. Dynamic Library Loading (optional)
struct DomPlatformDynlib {
    void *(*open)(const char *path);
    void (*close)(void *handle);
    void *(*sym)(void *handle, const char *name);
};
Rules:
• Only used by modding subsystem on platforms that allow it.
• Disabled entirely on DOS/Win3.x/etc.

9. Platform Logging Sink
struct DomPlatformLog {
    void (*write)(const char *msg);
};
Rules:
• Minimal filtering.
• Used by core log implementation.

10. dom_platform.c — API wiring
Responsible for exposing:
extern DomPlatformAPI dom_platform;
Where:
typedef struct DomPlatformAPI {
    struct DomPlatformFilesystem fs;
    struct DomPlatformTime time;
    struct DomPlatformWindowAPI win;
    struct DomPlatformInput input;
    struct DomPlatformNet net;
    struct DomPlatformThreading thread;
    struct DomPlatformDynlib dyn;
    struct DomPlatformLog log;
} DomPlatformAPI;
Each OS backend calls:
void dom_platform_install_backend(const DomPlatformAPI *impl);

11. Per-platform directories (win32/, linux/, etc.)
Each contains:
• A private header: dom_platform_<os>.h
• An implementation file: dom_platform_<os>.c
Each must:
• Include OS headers (windows.h, <X11/Xlib.h>, <unistd.h>, Carbon/Cocoa).
• Populate a static DomPlatformAPI struct with OS-specific functions.
• Provide:
void dom_platform_<os>_install(void);
Which calls:
dom_platform_install_backend(&backend_api);
Backends override entire sub-APIs as required.

12. Behavioural Constraints
12.1 Determinism boundary
The platform layer is explicitly nondeterministic.
Simulation code must never use platform time, RNG, or input directly.
12.2 Thread model
Threads may not touch ECS or deterministic subsystems.
Only safe actions:
• File IO
• Socket IO
• Asset loading
• Logging
• Shader/texture/audio loading
12.3 Memory model
No platform allocator may return memory used by sim directly; all sim memory is allocated by deterministic allocators in engine/core.
12.4 Window + GL/DX context
Platform layer owns the window and graphics context; rendering backend only receives the context pointer.

13. Summary
engine/platform is the single abstraction wall between Dominium and the host OS. It defines stable, minimal interfaces for:
• Filesystem
• Timing
• Windowing
• Input
• GL/DX context setup
• Sockets
• Threads
• Dynamic libs
• Logging
Every OS implementation supplies a complete backend via function pointers.
The engine’s deterministic simulation never touches any nondeterministic API directly.

Next directory: engine/audio/ unless you want to jump elsewhere.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the deterministic dev-spec for engine/audio/.
The audio layer is fully abstracted and backend-agnostic.
The simulation does not produce waveforms — it emits audio events (start sound, stop sound, set volume).
The render/audio subsystem transforms those events into backend-specific buffered audio output.
This directory defines:
• The abstract audio API seen by the engine/game
• Deterministic audio command buffers (similar to render)
• Backend drivers (SDL_mixer, OpenAL, DirectSound, XAudio2, software mixer)
• A fixed-rate mixer contract
• A platform-agnostic soundbank loader format
• A deterministic, fixed-point envelope and panner
No floats are used in command construction or in any deterministic subsystem.
Backends may use floats internally (OpenAL/XAudio) but the API boundary always consumes integer or fixed-point values.

Directory Layout
engine/
└── audio/
    ├── dom_audio_api.h
    ├── dom_audio_state.h
    ├── dom_audio_state.c
    ├── dom_audio_commands.h
    ├── dom_audio_commands.c
    ├── dom_audio_mixer.h
    ├── dom_audio_mixer.c
    ├── dom_audio_backend.h
    ├── dom_audio_backend_null.c
    ├── sdl/
    │    ├── dom_audio_sdl.h
    │    └── dom_audio_sdl.c
    ├── openal/
    │    ├── dom_audio_openal.h
    │    └── dom_audio_openal.c
    ├── xaudio2/
    │    ├── dom_audio_xa2.h
    │    └── dom_audio_xa2.c
    ├── directsound/
    │    ├── dom_audio_ds.h
    │    └── dom_audio_ds.c
    └── software/
         ├── dom_audio_soft.h
         └── dom_audio_soft.c
Global rules:
• C89/C98 only
• No audio simulation inside deterministic tick
• All audio events must be deterministic
• Audio playback latency is nondeterministic and irrelevant to sim
• All backends consume the same command buffer format
• No runtime allocation in play-loops

1. dom_audio_api.h — Abstract audio API
This is the only audio header the rest of the engine includes.
Includes:
#include "dom_core_types.h"
#include "dom_audio_state.h"
#include "dom_audio_commands.h"
Types:
typedef enum {
    DOM_AUDIO_BACKEND_NULL = 0,
    DOM_AUDIO_BACKEND_SDL,
    DOM_AUDIO_BACKEND_OPENAL,
    DOM_AUDIO_BACKEND_DS,    /* DirectSound */
    DOM_AUDIO_BACKEND_XA2,   /* XAudio2 */
    DOM_AUDIO_BACKEND_SOFT   /* software mixer */
} DomAudioBackendKind;
Main object:
typedef struct DomAudioDevice {
    DomAudioBackendKind backend;
    void *backend_state;

    DomAudioCommandBuffer cmd;

    dom_u32 sample_rate;   /* backend may adjust (fallback) */
    dom_u8  channels;      /* 1 = mono, 2 = stereo only */
} DomAudioDevice;
Public API:
Initialization:
DomResult dom_audio_create(DomAudioDevice *d,
                           DomAudioBackendKind backend,
                           dom_u32 preferred_sample_rate,
                           dom_u8 channels);

void dom_audio_destroy(DomAudioDevice *d);
Per-frame:
void dom_audio_begin(DomAudioDevice *d);     /* Clear command buffer */
void dom_audio_submit(DomAudioDevice *d);    /* Submit commands to backend */
Commands dispatched by engine/game:
void dom_audio_play(DomAudioDevice *d,
                    DomAudioSoundId sid,
                    dom_i32 volume,  /* 0–255 */
                    dom_i32 pan,     /* -128 left .. 127 right */
                    dom_i32 pitch);  /* fixed-point 24.8 pitch multiplier */

void dom_audio_stop(DomAudioDevice *d,
                    DomAudioSoundId sid);

void dom_audio_set_volume(DomAudioDevice *d,
                          DomAudioSoundId sid,
                          dom_i32 volume);

void dom_audio_set_listener(DomAudioDevice *d,
                            dom_i32 x, dom_i32 y, dom_i32 z,
                            dom_i32 vx, dom_i32 vy, dom_i32 vz);
Prohibitions:
• No floats across API boundary.
• No spatialisation beyond integer parameters (backends may convert).
• No streaming decode here — only event dispatch.

2. dom_audio_state.[hc] — Active sound state tracking
Purpose: deterministic tracking of which sounds are “currently active” from the simulation’s perspective.
This determines which commands appear in the audio buffer each frame.
Header includes:
#include "dom_core_types.h"
Types:
typedef dom_u32 DomAudioSoundId;

typedef struct DomAudioSoundInstance {
    DomAudioSoundId id;
    dom_i32 volume; /* 0–255 */
    dom_i32 pan;    /* -128 .. 127 */
    dom_i32 pitch;  /* fixed-point 24.8 */
    dom_bool8 playing;
} DomAudioSoundInstance;
Global state:
#define DOM_AUDIO_MAX_ACTIVE 1024

typedef struct DomAudioState {
    dom_u32 count;
    DomAudioSoundInstance slots[DOM_AUDIO_MAX_ACTIVE];
} DomAudioState;
Public API:
void dom_audio_state_init(DomAudioState *s);

DomAudioSoundInstance *
dom_audio_state_get(DomAudioState *s, DomAudioSoundId sid);

DomResult dom_audio_state_start(DomAudioState *s, DomAudioSoundId sid,
                                dom_i32 vol, dom_i32 pan, dom_i32 pitch);

DomResult dom_audio_state_stop(DomAudioState *s, DomAudioSoundId sid);

DomResult dom_audio_state_set_volume(DomAudioState *s, DomAudioSoundId sid, dom_i32 vol);
DomResult dom_audio_state_set_pan   (DomAudioState *s, DomAudioSoundId sid, dom_i32 pan);
DomResult dom_audio_state_set_pitch (DomAudioState *s, DomAudioSoundId sid, dom_i32 pitch);
Rules:
• Completely deterministic.
• No real audio playback; purely tracks sim state.
• No per-frame allocation.
Prohibitions:
• No sound loading here.
• No backend calls here.

3. dom_audio_commands.[hc] — Deterministic audio command buffer
Patterns exactly like render commands.
Header: dom_audio_commands.h
Types:
typedef enum {
    DOM_AUDIO_CMD_NONE = 0,
    DOM_AUDIO_CMD_PLAY,
    DOM_AUDIO_CMD_STOP,
    DOM_AUDIO_CMD_SET_VOLUME,
    DOM_AUDIO_CMD_SET_PAN,
    DOM_AUDIO_CMD_SET_PITCH,
    DOM_AUDIO_CMD_SET_LISTENER
} DomAudioCmdKind;
Command payloads:
typedef struct {
    DomAudioSoundId sid;
    dom_i32 volume;
    dom_i32 pan;
    dom_i32 pitch;
} DomAudioCmdPlay;

typedef struct {
    DomAudioSoundId sid;
} DomAudioCmdStop;

typedef struct {
    DomAudioSoundId sid;
    dom_i32 value;
} DomAudioCmdSetVolume;

typedef struct {
    DomAudioSoundId sid;
    dom_i32 value;
} DomAudioCmdSetPan;

typedef struct {
    DomAudioSoundId sid;
    dom_i32 value;
} DomAudioCmdSetPitch;

typedef struct {
    dom_i32 x, y, z;
    dom_i32 vx, vy, vz;
} DomAudioCmdSetListener;
Command entry:
typedef struct {
    DomAudioCmdKind kind;
    union {
        DomAudioCmdPlay play;
        DomAudioCmdStop stop;
        DomAudioCmdSetVolume vol;
        DomAudioCmdSetPan pan;
        DomAudioCmdSetPitch pitch;
        DomAudioCmdSetListener listener;
    } u;
} DomAudioCmd;
Command buffer:
#define DOM_AUDIO_CMD_MAX 4096

typedef struct DomAudioCommandBuffer {
    dom_u32 count;
    DomAudioCmd cmds[DOM_AUDIO_CMD_MAX];
} DomAudioCommandBuffer;
Public API:
void dom_audio_cmd_init(DomAudioCommandBuffer *);
DomResult dom_audio_cmd_push(DomAudioCommandBuffer *, const DomAudioCmd *);
Rules:
• FIFO, deterministic order.
• Hard cap enforces stable memory/perf.

4. dom_audio_mixer.[hc] — Optional deterministic software mixer
Even though real playback is nondeterministic, the game may occasionally require:
• Deterministic audio preview
• Offline rendering for tools
• Very old platforms (DOS, Win9x)
Header contents
Includes:
#include "dom_audio_state.h"
#include "dom_audio_commands.h"
Mixer configuration:
typedef struct {
    dom_u32 sample_rate;  /* required */
    dom_u8  channels;     /* 1 or 2 */
} DomAudioMixerConfig;
Mixer state:
typedef struct {
    DomAudioMixerConfig cfg;
    dom_i16 *mix_buffer;     /* fixed-size per tick */
    dom_u32 mix_buffer_size; /* samples */
} DomAudioMixer;
Public API:
DomResult dom_audio_mixer_init(DomAudioMixer *m, DomAudioMixerConfig cfg);
void      dom_audio_mixer_shutdown(DomAudioMixer *m);

/* Render deterministic mix for current frame */
void dom_audio_mixer_mix(DomAudioMixer *m,
                         const DomAudioState *s,
                         const DomAudioCommandBuffer *cmd,
                         dom_i16 *outbuf,
                         dom_u32 outbuf_samples);
Rules:
• Must be bit-identical across platforms.
• No floating point anywhere.
• Uses integer resampling, integer envelopes, integer panning.

5. dom_audio_backend.h — Backend interface
Backends must implement:
typedef struct DomAudioBackendAPI {
    DomResult (*init)(DomAudioDevice *dev);
    void      (*shutdown)(DomAudioDevice *dev);
    void      (*submit)(DomAudioDevice *dev,
                        const DomAudioCommandBuffer *cmd);
} DomAudioBackendAPI;
Backend lookup:
const DomAudioBackendAPI *dom_audio_backend_get(DomAudioBackendKind k);
Rules:
• Backends interpret commands and trigger OS/native audio playback.
• Backends may use floats, but must treat integer parameters exactly.

6. Backends
6.1 sdl/ — SDL_mixer backend
• Uses SDL2 audio subsystem.
• Converts integer pan/vol/pitch into SDL representation.
• Preloads WAV/OGG into SDL chunks (static).
Rules:
• No streaming decode inside sim tick; decode only on load.
• Latency acceptable and nondeterministic.

6.2 openal/
• Creates OpenAL device+context.
• Each sound ID has matching AL buffer.
• pitch fixed-point converted to AL float.
• Listener and sources updated per command.

6.3 xaudio2/
Windows-only.
Uses IXAudio2SourceVoice objects for each active sound.
Rules:
• Fixed-size circular buffer per sound.
• Strict check for buffer underruns (reportable errors but don’t break determinism).

6.4 directsound/
Legacy path for Win9x/XP.
Simple buffer playback using IDirectSoundBuffer.
Rules:
• Fade envelopes implemented manually.

6.5 software/
• Pure deterministic integer mixer.
• Used for DOS, Win3.x, emscripten, and offline rendering.

7. Behavioural Guarantees
7.1 Deterministic commands
The command buffer is fully deterministic.
Backends can be nondeterministic but cannot influence sim.
7.2 Backend choice nondeterministic
The backend does not affect the simulation or the resulting command buffer.
The player can choose any backend.
7.3 Audio asset loading
Loading occurs in tools or in engine startup; the runtime audio system never decodes files.
7.4 No multi-threaded mixing inside backend
Threading handled by platform, backends may run audio callback thread, but must not modify sim-visible state.

8. Summary
engine/audio/ defines:
• Deterministic audio state
• Deterministic audio commands
• Backend-agnostic audio device API
• Software mixer for deterministic offline playback
• Real backends for SDL/OpenAL/DX/XA2
The simulation emits pure events; the audio subsystem plays them nondeterministically but predictably in type and order.

Next directory: engine/ui/ unless you prefer another branch.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for engine/ui/.
UI here is engine-level, game-agnostic: widgets, layout, skins, and input plumbing.
No Dominium-specific logic. No simulation logic. No platform APIs directly (go through engine/platform and engine/render).
The game layer (/game/client) builds actual menus/HUD on top of this.

Directory Layout
engine/
└── ui/
    ├── dom_ui_core.h
    ├── dom_ui_core.c
    ├── dom_ui_layout.h
    ├── dom_ui_layout.c
    ├── dom_ui_widgets.h
    ├── dom_ui_widgets.c
    ├── dom_ui_skin.h
    ├── dom_ui_skin.c
    ├── dom_ui_commands.h
    ├── dom_ui_commands.c
    ├── dom_ui_debug.h
    └── dom_ui_debug.c
Global rules:
• C89 (C89-with-// comments) for implementation.
• No platform headers. Use dom_platform.h only indirectly via game/client.
• No simulation reads/writes. UI only talks to engine/game via commands/events.
• No floats in layout core; use fixed-point or ints.
• Determinism not required for UI visuals, but input → command sequence must be stable for a given input stream.

1. dom_ui_core.[hc] — UI tree, IDs, lifecycle
This is the core UI object model and update pipeline.
1.1 Types
#include "dom_core_types.h"

typedef dom_u32 DomUIWidgetId;
typedef dom_u32 DomUILayerId;
typedef dom_u32 DomUIStyleId;

typedef struct DomUIRect {
    dom_i32 x, y;
    dom_i32 w, h;
} DomUIRect;

typedef enum {
    DOM_UI_EVENT_NONE = 0,
    DOM_UI_EVENT_MOUSE_MOVE,
    DOM_UI_EVENT_MOUSE_DOWN,
    DOM_UI_EVENT_MOUSE_UP,
    DOM_UI_EVENT_MOUSE_SCROLL,
    DOM_UI_EVENT_KEY_DOWN,
    DOM_UI_EVENT_KEY_UP,
    DOM_UI_EVENT_TEXT_INPUT
} DomUIEventKind;

typedef struct DomUIEvent {
    DomUIEventKind kind;
    dom_i32 mouse_x, mouse_y;
    dom_i32 scroll_delta;
    dom_u32 key;        /* DomKey or char code */
    dom_u32 utf32;      /* text input; 0 if none */
    dom_u32 mods;       /* ctrl/alt/shift bitmask */
} DomUIEvent;
Widget types (game-agnostic):
typedef enum {
    DOM_UI_WIDGET_NONE = 0,
    DOM_UI_WIDGET_ROOT,
    DOM_UI_WIDGET_CONTAINER,
    DOM_UI_WIDGET_LABEL,
    DOM_UI_WIDGET_BUTTON,
    DOM_UI_WIDGET_TOGGLE,
    DOM_UI_WIDGET_SLIDER,
    DOM_UI_WIDGET_PROGRESS,
    DOM_UI_WIDGET_SCROLL,
    DOM_UI_WIDGET_IMAGE,
    DOM_UI_WIDGET_TEXTBOX,
    DOM_UI_WIDGET_LIST,
    DOM_UI_WIDGET_CUSTOM  /* for game/client-registered draw callbacks */
} DomUIWidgetKind;
Widget node:
#define DOM_UI_MAX_CHILDREN 32

typedef struct DomUIWidget {
    DomUIWidgetId id;
    DomUIWidgetKind kind;
    DomUIRect rect;         /* final screen rect after layout */
    DomUIRect content_rect; /* inner rect (after padding) */

    DomUIWidgetId parent;
    DomUIWidgetId children[DOM_UI_MAX_CHILDREN];
    dom_u8 child_count;

    DomUIStyleId style;
    dom_u32 flags;          /* visible, enabled, clip, focusable */

    dom_u32 state_flags;    /* hovered, pressed, focused, etc. */

    dom_u32 user_tag;       /* game/client identifier */
    void *user_ptr;         /* opaque pointer for game/client (NEVER serialized) */
} DomUIWidget;
UI root:
#define DOM_UI_MAX_WIDGETS 4096

typedef struct DomUIRoot {
    DomUIWidget widgets[DOM_UI_MAX_WIDGETS];
    dom_u32     widget_count;

    DomUIWidgetId root_id;

    DomUIWidgetId focused;
    DomUIWidgetId hovered;

    DomUILayerId layer_id;      /* for multi-layer UI (HUD, menus, overlay) */

    dom_i32 screen_w, screen_h;
} DomUIRoot;
1.2 Public API
void dom_ui_init_root(DomUIRoot *ui, dom_i32 screen_w, dom_i32 screen_h);

DomUIWidgetId dom_ui_create_widget(DomUIRoot *ui,
                                   DomUIWidgetKind kind,
                                   DomUIWidgetId parent);

void dom_ui_destroy_widget(DomUIRoot *ui, DomUIWidgetId id);

DomUIWidget *dom_ui_get_widget(DomUIRoot *ui, DomUIWidgetId id);

void dom_ui_set_rect(DomUIRoot *ui, DomUIWidgetId id, DomUIRect r);
void dom_ui_set_style(DomUIRoot *ui, DomUIWidgetId id, DomUIStyleId style);
void dom_ui_set_flags(DomUIRoot *ui, DomUIWidgetId id, dom_u32 flags, dom_u32 mask);

void dom_ui_set_user_tag(DomUIRoot *ui, DomUIWidgetId id, dom_u32 tag);
void dom_ui_set_user_ptr(DomUIRoot *ui, DomUIWidgetId id, void *ptr);
Input + update:
/* Push raw input events (from game/client) into UI */
void dom_ui_push_event(DomUIRoot *ui, const DomUIEvent *ev);

/* Per-frame: process events, update focus/hover, propagate to widgets */
void dom_ui_update(DomUIRoot *ui);
Rules:
• Widget IDs are stable indices; 0 reserved as “invalid/none”.
• Parent/child relations must form a tree rooted at root_id.
• dom_ui_update handles only focus/hover, not layout or drawing.
Prohibitions:
• No rendering calls here.
• No game logic; only UI state transitions.

2. dom_ui_layout.[hc] — Layout engine
Responsible for computing rect and content_rect for every widget.
Layout is purely integer-based.
2.1 Types
typedef enum {
    DOM_UI_LAYOUT_ABSOLUTE = 0,
    DOM_UI_LAYOUT_VERTICAL,
    DOM_UI_LAYOUT_HORIZONTAL,
    DOM_UI_LAYOUT_GRID
} DomUILayoutMode;

typedef struct DomUILayout {
    DomUILayoutMode mode;
    dom_i32 padding_left, padding_top, padding_right, padding_bottom;
    dom_i32 spacing;        /* gap between children */
    dom_i32 grid_cols;      /* for GRID */
} DomUILayout;
We don’t store layout on the widget directly here; game/client uses user_ptr or separate mapping, or we add a simple layout component:
typedef struct DomUILayoutEntry {
    DomUIWidgetId id;
    DomUILayout  layout;
} DomUILayoutEntry;

#define DOM_UI_MAX_LAYOUTS DOM_UI_MAX_WIDGETS

typedef struct DomUILayoutState {
    DomUILayoutEntry entries[DOM_UI_MAX_LAYOUTS];
    dom_u32 count;
} DomUILayoutState;
2.2 Public API
void dom_ui_layout_init(DomUILayoutState *ls);

DomResult dom_ui_layout_set(DomUILayoutState *ls,
                            DomUIWidgetId id,
                            DomUILayout layout);

/* Compute layout for entire tree */
void dom_ui_layout_apply(DomUIRoot *ui,
                         DomUILayoutState *ls);
Rules:
• dom_ui_layout_apply must be called once per frame after UI root update and before drawing.
• Layout algorithm must be deterministic given widget tree and layout state.
Prohibitions:
• No floating point metrics; all ints in pixels.
• No direct calls to render or platform.

3. dom_ui_widgets.[hc] — Logic for basic widget types
Encapsulates generic behavior: hit-testing, click handling, value changes.
3.1 Types
Per-widget data structs (these are not stored in DomUIWidget, but referenced via user_ptr or separate arrays):
typedef struct {
    const char *text; /* immutable storage owned by game/client */
} DomUILabelData;

typedef struct {
    const char *text;
    dom_bool8 pressed;
} DomUIButtonData;

typedef struct {
    dom_bool8 value;
} DomUIToggleData;

typedef struct {
    dom_i32 min_value;
    dom_i32 max_value;
    dom_i32 value;
    dom_i32 step;
} DomUISliderData;

/* etc. */
For engine-level library, we keep a generic per-kind handler:
typedef struct DomUIWidgetHandlers {
    void (*on_event)(DomUIRoot *ui, DomUIWidget *w, const DomUIEvent *ev);
    void (*on_update)(DomUIRoot *ui, DomUIWidget *w);  /* per frame */
} DomUIWidgetHandlers;
Global table:
extern DomUIWidgetHandlers dom_ui_widget_handlers[DOM_UI_WIDGET_CUSTOM + 1];
3.2 Public API
void dom_ui_widgets_init(void);

/* Called from dom_ui_update per widget */
void dom_ui_widget_handle_event(DomUIRoot *ui,
                                DomUIWidget *w,
                                const DomUIEvent *ev);

void dom_ui_widget_update(DomUIRoot *ui,
                          DomUIWidget *w);
Rules:
• Default handlers for LABEL/IMAGE are no-op.
• BUTTON toggles pressed state on MOUSE_DOWN+UP and emits UI command (see commands).
• SLIDER tracks drags and updates integer value.
• No game-specific actions, only emitting standardized UI commands to dom_ui_commands.

4. dom_ui_skin.[hc] — Abstract visual style descriptors
Skin = way to draw widgets with no game-specific assets hardcoded.
4.1 Types
typedef struct DomUIColor {
    dom_u8 r, g, b, a;
} DomUIColor;

typedef struct DomUIFontId {
    dom_u16 index;
} DomUIFontId;

typedef struct DomUIBorder {
    dom_i32 thickness;
    DomUIColor color;
} DomUIBorder;

typedef struct DomUIStyle {
    DomUIColor bg_color;
    DomUIColor fg_color;
    DomUIBorder border;
    DomUIFontId font;
    dom_i32 padding_left, padding_top, padding_right, padding_bottom;
} DomUIStyle;
Style table:
#define DOM_UI_MAX_STYLES 256

typedef struct DomUISkin {
    DomUIStyle styles[DOM_UI_MAX_STYLES];
    dom_u32    style_count;
} DomUISkin;
4.2 Public API
void dom_ui_skin_init(DomUISkin *skin);

/* returns style id or -1 on fail */
DomUIStyleId dom_ui_skin_add(DomUISkin *skin, const DomUIStyle *style);

const DomUIStyle *dom_ui_skin_get(const DomUISkin *skin, DomUIStyleId id);
Rendering integration (for game/client):
/* Convert widget + style to draw commands; doesn't talk to renderer directly */
void dom_ui_skin_build_drawlist(DomUIRoot *ui,
                                const DomUISkin *skin,
                                /* opaque drawlist struct owned by game/client */
                                void *drawlist_ctx,
                                void (*emit_rect)(void *ctx, DomUIRect r, DomUIColor c),
                                void (*emit_text)(void *ctx, DomUIRect r, DomUIFontId font, const char *text));
Rules:
• No direct GL/DX calls here.
• Deterministic: same tree + skin → same drawlist.

5. dom_ui_commands.[hc] — UI → game command buffer
UI should not call gameplay directly.
It produces UI commands, which /game/client consumes and maps to actions.
5.1 Types
typedef enum {
    DOM_UI_CMD_NONE = 0,
    DOM_UI_CMD_CLICK,      /* button or clickable region */
    DOM_UI_CMD_TOGGLE,     /* toggle changed */
    DOM_UI_CMD_SLIDER,     /* slider value changed */
    DOM_UI_CMD_TEXT_ENTER, /* text confirmed */
    DOM_UI_CMD_FOCUS_GAIN,
    DOM_UI_CMD_FOCUS_LOST
} DomUICmdKind;

typedef struct DomUICmdClick {
    DomUIWidgetId id;
    dom_u32 user_tag;  /* from widget */
} DomUICmdClick;

typedef struct DomUICmdToggle {
    DomUIWidgetId id;
    dom_u32 user_tag;
    dom_bool8 value;
} DomUICmdToggle;

typedef struct DomUICmdSlider {
    DomUIWidgetId id;
    dom_u32 user_tag;
    dom_i32 value;
} DomUICmdSlider;

typedef struct DomUICmdText {
    DomUIWidgetId id;
    dom_u32 user_tag;
    const char *text; /* pointer into external buffer; lifetime owned by game/client */
} DomUICmdText;

typedef struct DomUICmdFocus {
    DomUIWidgetId id;
    dom_u32 user_tag;
} DomUICmdFocus;

typedef struct DomUICmd {
    DomUICmdKind kind;
    union {
        DomUICmdClick  click;
        DomUICmdToggle toggle;
        DomUICmdSlider slider;
        DomUICmdText   text;
        DomUICmdFocus  focus;
    } u;
} DomUICmd;
Command buffer:
#define DOM_UI_CMD_MAX 1024

typedef struct DomUICommandBuffer {
    dom_u32 count;
    DomUICmd cmds[DOM_UI_CMD_MAX];
} DomUICommandBuffer;
5.2 Public API
void dom_ui_cmd_init(DomUICommandBuffer *b);
DomResult dom_ui_cmd_push(DomUICommandBuffer *b, const DomUICmd *cmd);
Integration with core:
• dom_ui_core and dom_ui_widgets must have access to a global or passed-in DomUICommandBuffer * and push commands whenever widget interaction triggers.
Rules:
• Commands must be queued in deterministic order (entity ID, widget ID, input index).
• DomUIRoot does not interpret these; only /game/client does.

6. dom_ui_debug.[hc] — Debug overlay and instrumentation
Optional but useful and self-contained.
6.1 Types
Debug flags:
typedef struct DomUIDebugConfig {
    dom_bool8 show_bounds;
    dom_bool8 show_ids;
    dom_bool8 show_focus;
    dom_bool8 show_layout;
} DomUIDebugConfig;
6.2 Public API
void dom_ui_debug_init(DomUIDebugConfig *cfg);

void dom_ui_debug_draw(DomUIRoot *ui,
                       const DomUISkin *skin,
                       const DomUIDebugConfig *cfg,
                       void *drawlist_ctx,
                       void (*emit_rect)(void *ctx, DomUIRect r, DomUIColor c),
                       void (*emit_text)(void *ctx, DomUIRect r, DomUIFontId font, const char *text));
Rules:
• Debug draw uses same emit_* callbacks as normal skin.
• No ties to game logic.

7. Integration Summary
• /engine/platform → raw input events (keys, mouse, window size) go to /game/client.
• /game/client converts platform events into DomUIEvent and calls dom_ui_push_event.
• Per frame, /game/client does:
• dom_ui_update(&ui_root);
• dom_ui_layout_apply(&ui_root, &layout_state);
• 
• dom_ui_cmd_init(&ui_cmd_buffer);
• /* dom_ui_widgets + core push into ui_cmd_buffer during update */
• 
• /* Now game/client reads ui_cmd_buffer and applies actual game actions. */
• 
• /* For rendering: */
• build_drawlist_from_skin(&ui_root, &skin, ...);
• submit drawlist to engine/render.
• No simulation code down in UI tree.
• UI does not know about Dominium-specific entities or transports; it only knows generic widgets and user tags.

8. Prohibitions
• No dependency on /game or /data.
• No GL/DX/SDL/OpenAL includes.
• No long-lived allocations beyond static arrays and POD structs.
• No “immediate mode GUI” macros that mix layout, input, and draw; keep retained model.

Next directory in engine layer would typically be engine/net/ or **engine/physics/engine/sim subtrees, depending on where you want to go.
You said:
Next
ChatGPT said:
Thought for 25s
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for game/client/.
This layer is the front-end application shell for Dominium:
• Talks “upwards” to platform (window, input, OS integration).
• Talks “downwards” to engine (sim, render, audio, net, UI).
• Owns cameras, views (2D/3D), menus, HUD, in-world placement previews.
• Translates human input + UI commands → deterministic sim commands.
• Handles local vs remote simulation modes (single-player vs multiplayer).
No simulation rules live here. No rendering backends live here. No platform-specific OS calls live here directly (must route via /engine/platform or dedicated /ports adapters if needed).

Directory Layout
game/
└── client/
    ├── dom_client_app.h
    ├── dom_client_app.c
    ├── dom_client_state.h
    ├── dom_client_state.c
    ├── dom_client_input.h
    ├── dom_client_input.c
    ├── dom_client_view.h
    ├── dom_client_view.c
    ├── dom_client_ui_bridge.h
    ├── dom_client_ui_bridge.c
    ├── dom_client_sim_bridge.h
    ├── dom_client_sim_bridge.c
    ├── dom_client_render_pipe.h
    ├── dom_client_render_pipe.c
    ├── dom_client_audio_pipe.h
    ├── dom_client_audio_pipe.c
    ├── dom_client_console.h
    ├── dom_client_console.c
    ├── dom_client_config.h
    └── dom_client_config.c
You can split or merge some of these later, but this structure forces clean boundaries.
Global rules:
• C or C++98 (your call; spec assumes C89/C99 flavour).
• No direct OpenGL/DirectX/SDL calls — go through /engine/render and /engine/platform.
• No simulation state mutation except via deterministic sim commands (through dom_client_sim_bridge).
• No UI widgets defined here; uses /engine/ui.
• No actual OS entrypoint here; that lives in small platform-specific “launchers” that call dom_client_app_*.

1. dom_client_app.[hc] — Top-level application shell
This is the canonical entrypoint for “a Dominium client instance”.
Header
#include "dom_core_types.h"

typedef enum {
    DOM_CLIENT_MODE_SINGLEPLAYER = 0,
    DOM_CLIENT_MODE_MULTIPLAYER_CLIENT,
    DOM_CLIENT_MODE_MULTIPLAYER_HOST
} DomClientMode;

typedef struct DomClientAppConfig {
    DomClientMode mode;
    const char *initial_save_path;    /* optional */
    const char *server_address;       /* for client mode */
    dom_u16     server_port;
    dom_i32     window_width;
    dom_i32     window_height;
    dom_bool8   fullscreen;
} DomClientAppConfig;

typedef struct DomClientApp DomClientApp;
Opaque struct defined in .c holds:
• DomClientState
• Pointers/handles to:
o DomSimWorld / sim driver
o DomRenderDevice
o DomAudioDevice
o DomUIRoot, DomUILayoutState, DomUISkin
o DomPlatformWindow / platform context handle
• Current tick/frame counters.
Public API:
/* Called from OS-specific launcher main() */
DomClientApp *dom_client_app_create(const DomClientAppConfig *cfg);

void dom_client_app_destroy(DomClientApp *app);

/* Main loop step: drive one iteration of client loop */
void dom_client_app_tick(DomClientApp *app);
Rules:
• dom_client_app_tick is the only per-frame driver for client logic.
• It must call, in fixed order:
1. Poll platform → DomClientInputFrame
2. Update DomClientState (mode, menus, etc)
3. Build and dispatch UI events
4. Map UI events + input → sim commands (via sim_bridge)
5. Step sim (or fetch remote state) deterministically
6. Build render/audio command streams
7. Submit to engine/render + engine/audio
8. Swap buffers
Prohibitions:
• No OS-specific code (no SDL_PollEvent, GetMessage, etc).
• No file IO beyond config-handling; sim loads via engine layer.

2. dom_client_state.[hc] — Client-side session state
This stores visual and interaction state that is not part of the sim:
• Current camera(s).
• Active view mode (2D ortho, 2D iso, 3D).
• Zoom levels.
• Which UI screens are active (main menu, world view, editor).
• Current build/placement “ghost” selection.
• Currently selected entities.
• Local user profile preferences (FOV, keybind profile ID, UI scale).
Header
#include "dom_core_types.h"
#include "dom_ui_core.h" /* for widget ids if needed */

typedef enum {
    DOM_VIEW_MODE_2D_ORTHO = 0,
    DOM_VIEW_MODE_2D_ISO,
    DOM_VIEW_MODE_3D
} DomClientViewMode;

typedef enum {
    DOM_CLIENT_SCREEN_NONE = 0,
    DOM_CLIENT_SCREEN_MAIN_MENU,
    DOM_CLIENT_SCREEN_LOAD_SAVE,
    DOM_CLIENT_SCREEN_SETTINGS,
    DOM_CLIENT_SCREEN_IN_GAME,
    DOM_CLIENT_SCREEN_EDITOR
} DomClientScreen;

typedef struct DomClientCamera {
    dom_i64 world_x, world_y, world_z;   /* tile/voxel origin centre */
    dom_i32 zoom_level;                  /* integer zoom index, not ratio */
    dom_i32 yaw_deg;                     /* for 3D */
    dom_i32 pitch_deg;                   /* for 3D */
} DomClientCamera;

typedef struct DomClientSelection {
    dom_u32 count;
    dom_u64 entity_ids[256]; /* or handles */
} DomClientSelection;

typedef struct DomClientBuildGhost {
    dom_bool8 active;
    dom_u64   prefab_id;
    dom_i64   world_x, world_y, world_z;
    dom_i32   rotation;
} DomClientBuildGhost;

typedef struct DomClientState {
    DomClientViewMode view_mode;
    DomClientScreen   screen;

    DomClientCamera   camera;
    DomClientSelection selection;
    DomClientBuildGhost build_ghost;

    dom_bool8 pause_requested;
    dom_bool8 step_requested;

    dom_i32 ui_scale;     /* integer zoom for UI */
    dom_i32 keybind_profile_id;
} DomClientState;
Public API:
void dom_client_state_init(DomClientState *st);

void dom_client_state_set_screen(DomClientState *st, DomClientScreen s);
void dom_client_state_set_view_mode(DomClientState *st, DomClientViewMode m);

/* Camera helpers */
void dom_client_camera_pan(DomClientState *st, dom_i32 dx, dom_i32 dy);
void dom_client_camera_zoom(DomClientState *st, dom_i32 delta_zoom);
void dom_client_camera_orbit(DomClientState *st, dom_i32 dyaw, dom_i32 dpitch);
Rules:
• Purely client-side; not serialized as part of deterministic sim saves.
• Data should be easily resettable when changing user/profile.
Prohibitions:
• No sim mutating calls in here.
• No coupling to renderer-specific units.

3. dom_client_input.[hc] — Input mapping and frame capture
This module bridges platform events → high-level, game-agnostic input.
Header
#include "dom_core_types.h"

typedef enum {
    DOM_CLIENT_ACTION_NONE = 0,
    DOM_CLIENT_ACTION_SELECT_PRIMARY,
    DOM_CLIENT_ACTION_SELECT_SECONDARY,
    DOM_CLIENT_ACTION_BUILD_CONFIRM,
    DOM_CLIENT_ACTION_BUILD_CANCEL,
    DOM_CLIENT_ACTION_PAN_CAMERA,
    DOM_CLIENT_ACTION_ROTATE_CAMERA,
    DOM_CLIENT_ACTION_ZOOM_CAMERA,
    DOM_CLIENT_ACTION_TOGGLE_PAUSE,
    DOM_CLIENT_ACTION_QUICK_SAVE,
    DOM_CLIENT_ACTION_QUICK_LOAD,
    DOM_CLIENT_ACTION_TOGGLE_UI_MODE,
    /* ... extendable ... */
} DomClientAction;

typedef struct DomClientInputFrame {
    dom_i32 mouse_x, mouse_y;
    dom_i32 mouse_dx, mouse_dy;
    dom_i32 wheel_delta;

    dom_bool8 mouse_left_down;
    dom_bool8 mouse_right_down;
    dom_bool8 mouse_middle_down;

    dom_bool8 key_states[256];  /* DomKey -> bool */
    dom_bool8 key_pressed[256]; /* this frame edge */

    /* Action mapping results */
    dom_bool8 action_pressed[64]; /* DomClientAction size */
    dom_bool8 action_held[64];
} DomClientInputFrame;
Public API:
void dom_client_input_clear(DomClientInputFrame *f);

/* Called by platform/launcher to fill low-level fields (mouse/keys) */
void dom_client_input_from_platform(DomClientInputFrame *dst,
                                    const DomPlatformInputFrame *src);

/* Map key/mouse state to high-level actions based on current keybind config */
void dom_client_input_map_actions(DomClientInputFrame *frame,
                                  const DomClientState *state,
                                  const DomClientConfig *cfg);
Rules:
• Mapping from physical keys/mouse to DomClientAction is deterministic and table-driven (config).
• No UI decisions here; just “action X pressed/held this frame”.
Prohibitions:
• No direct sim calls; this is pure data transform.
• No knowledge of UI widget IDs or layouts.

4. dom_client_view.[hc] — World-to-screen and view logic
This module converts from world coordinates to view coordinates for each mode:
• 2D orthographic (Factorio-ish).
• 2D isometric (ISO-like).
• 3D perspective (optional).
Header
#include "dom_core_types.h"
#include "dom_client_state.h"

typedef struct DomClientViewProj2D {
    dom_i32 screen_w, screen_h;
    dom_i64 world_x0, world_y0; /* world coord at screen origin */
    dom_i32 pixels_per_tile;
} DomClientViewProj2D;

typedef struct DomClientViewProj3D {
    /* simple integer-based camera/frustum description; ultimately produces view-projection matrices
       for render backends, but the math is encoded in ints/fixed-point */
    dom_i32 screen_w, screen_h;
    dom_i32 fov_deg;
    dom_i32 near_mm;
    dom_i32 far_mm;
} DomClientViewProj3D;

typedef struct DomClientViewProj {
    DomClientViewMode mode;
    union {
        DomClientViewProj2D v2d;
        DomClientViewProj3D v3d;
    } u;
} DomClientViewProj;
Public API:
void dom_client_view_build(const DomClientState *st,
                           dom_i32 screen_w,
                           dom_i32 screen_h,
                           DomClientViewProj *out);

/* World (tile) -> screen pixel */
void dom_client_view_world_to_screen(const DomClientViewProj *vp,
                                     dom_i64 wx, dom_i64 wy, dom_i64 wz,
                                     dom_i32 *sx, dom_i32 *sy);

/* Screen pixel -> world (tile) ray for picking/build cursor */
void dom_client_view_screen_to_world_ray(const DomClientViewProj *vp,
                                         dom_i32 sx, dom_i32 sy,
                                         dom_i64 *wx, dom_i64 *wy, dom_i64 *wz);
Rules:
• Must use integer/fixed-point only.
• Deterministic mapping for same camera/settings.
Prohibitions:
• No rendering calls here.
• No sim state reads; camera + world origin only.

5. dom_client_ui_bridge.[hc] — Connecting /engine/ui with client logic
This module:
• Creates the initial widget tree (menus, HUD, overlays).
• Binds widget user_tag values so /game/client can interpret UI commands.
• Routes UI commands to client actions, which then become sim commands or client-state mutations.
Header
#include "dom_core_types.h"
#include "dom_ui_core.h"
#include "dom_ui_layout.h"
#include "dom_ui_skin.h"
#include "dom_ui_commands.h"
#include "dom_client_state.h"
#include "dom_client_input.h"

typedef struct DomClientUI {
    DomUIRoot          root;
    DomUILayoutState   layout;
    DomUISkin          skin;
    DomUICommandBuffer cmd;
} DomClientUI;
Public API:
void dom_client_ui_init(DomClientUI *ui,
                        dom_i32 screen_w,
                        dom_i32 screen_h);

/* Rebuild full UI tree when screen changes (e.g. resolution change) */
void dom_client_ui_rebuild(DomClientUI *ui,
                           const DomClientState *st);

/* Called once per frame: push input → update root → generate commands */
void dom_client_ui_frame(DomClientUI *ui,
                         const DomClientState *st,
                         const DomClientInputFrame *input);

/* Process UI commands into client state changes and sim commands */
void dom_client_ui_process_commands(DomClientUI *ui,
                                    DomClientState *st,
                                    DomClientSimBridge *sim_bridge);
Notes:
• DomClientSimBridge is forward-declared; actual header included in .c.
• dom_client_ui_init builds root menu, HUD placeholders, etc.
• dom_client_ui_process_commands is the only place where UI-driven sim commands are created.
Prohibitions:
• No direct calls into sim; must go via DomClientSimBridge.
• No engine-level UI widget implementations; use /engine/ui/widgets.

6. dom_client_sim_bridge.[hc] — Client ↔ simulation interface
This module is critical for determinism: it maps client actions → canonical sim commands and handles result ingestion (for local sim) or net traffic (for remote sim).
Header
#include "dom_core_types.h"
#include "dom_client_state.h"
#include "dom_client_input.h"

typedef struct DomSimWorld DomSimWorld;   /* from engine/sim */
typedef struct DomNetClient DomNetClient; /* from engine/net */

typedef enum {
    DOM_SIM_RUN_LOCAL = 0,
    DOM_SIM_RUN_REMOTE_HOST,
    DOM_SIM_RUN_REMOTE_CLIENT
} DomSimRunMode;

typedef struct DomClientSimBridge {
    DomSimRunMode mode;

    DomSimWorld *local_world;   /* NULL if remote-only */
    DomNetClient *net_client;   /* NULL if local-only */

    /* tick counters for client-side */
    dom_u64 sim_tick;
} DomClientSimBridge;
Public API:
void dom_client_sim_bridge_init_local(DomClientSimBridge *b,
                                      DomSimWorld *world);

void dom_client_sim_bridge_init_remote_host(DomClientSimBridge *b,
                                            DomSimWorld *world,
                                            DomNetClient *net);

void dom_client_sim_bridge_init_remote_client(DomClientSimBridge *b,
                                              DomNetClient *net);

/* Map high-level client actions into sim input stream */
void dom_client_sim_bridge_apply_input(DomClientSimBridge *b,
                                       const DomClientState *st,
                                       const DomClientInputFrame *input);

/* Step simulation or pull next state from network */
void dom_client_sim_bridge_step(DomClientSimBridge *b);
Rules:
• apply_input must be fully deterministic: for identical st + input, same sequence of sim commands.
• step calls into engine/sim lockstep functions or updates local proxies from net snapshot.
• Prediction (if ever added) must still be consistent and rewindable.
Prohibitions:
• No UI-specific knowledge here (no widget IDs).
• No rendering/audio logic here.

7. dom_client_render_pipe.[hc] — View → render commands
This module takes:
• DomClientState
• DomSimWorld read-only snapshot or queries
• DomClientViewProj
• DomClientUI drawlist
and builds render command buffers for engine/render.
Header
#include "dom_core_types.h"
#include "dom_client_state.h"
#include "dom_client_view.h"

typedef struct DomRenderDevice DomRenderDevice; /* from engine/render */

typedef struct DomClientRenderPipe {
    DomRenderDevice *device;
    DomClientViewProj view_proj;
} DomClientRenderPipe;
Public API:
void dom_client_render_pipe_init(DomClientRenderPipe *rp,
                                 DomRenderDevice *dev);

/* Called per frame after sim step + UI update */
void dom_client_render_pipe_build(DomClientRenderPipe *rp,
                                  const DomClientState *st,
                                  const DomClientUI *ui,
                                  const DomSimWorld *world);

/* Actually submits to engine/render */
void dom_client_render_pipe_submit(DomClientRenderPipe *rp);
Inside build, you:
• Query visible chunks/entities from sim (read-only).
• Project world positions via view_proj.
• Emit render commands (tiles, sprites, meshes, overlays).
• Append UI draw commands last (HUD over world).
Rules:
• Strict order: world background → terrain → structures → units → overlays → UI.
• All ordering deterministic given the same world state and camera.
Prohibitions:
• No sim mutation.
• No OS/window logic.
• No direct GL/DX function calls; only engine/render API.

8. dom_client_audio_pipe.[hc] — Events → audio commands
Similar pattern to render pipe but for audio.
Header
#include "dom_core_types.h"

typedef struct DomAudioDevice DomAudioDevice;
typedef struct DomSimWorld DomSimWorld;

typedef struct DomClientAudioPipe {
    DomAudioDevice *device;
} DomClientAudioPipe;
Public API:
void dom_client_audio_pipe_init(DomClientAudioPipe *ap,
                                DomAudioDevice *dev);

void dom_client_audio_pipe_build(DomClientAudioPipe *ap,
                                 const DomClientState *st,
                                 const DomSimWorld *world);

/* Submit to engine/audio */
void dom_client_audio_pipe_submit(DomClientAudioPipe *ap);
Implementation:
• Read only sim snapshot: which machines running, alarms, ambient zones.
• Map each to audio events (loop start/stop, one-shot events).
• Maintain small client-side transient audio state (which loops currently playing) to avoid re-starting constantly.
Rules:
• Build is deterministic given world state; actual playback latency irrelevant.
Prohibitions:
• No decoding/streaming here; only events.

9. dom_client_console.[hc] — In-game debug/command console
Lightweight developer console and possibly player cheat console.
Header
#include "dom_core_types.h"

typedef struct DomClientConsoleLine {
    const char *text; /* references external buffer pool managed elsewhere */
} DomClientConsoleLine;

#define DOM_CLIENT_CONSOLE_MAX_LINES 128

typedef struct DomClientConsole {
    dom_bool8 visible;
    DomClientConsoleLine lines[DOM_CLIENT_CONSOLE_MAX_LINES];
    dom_u32 head;
} DomClientConsole;
Public API:
void dom_client_console_init(DomClientConsole *c);

void dom_client_console_toggle(DomClientConsole *c);

/* Append text line (for logs, warnings, etc.) */
void dom_client_console_log(DomClientConsole *c, const char *text);

/* Process input line (runs commands via sim_bridge or client state) */
void dom_client_console_execute(DomClientConsole *c,
                                const char *cmdline,
                                DomClientSimBridge *bridge,
                                DomClientState *st);
Rules:
• Command set must be deterministic (e.g. “set_speed 2.0” modifies sim constant via defined API).
• Console text may not modify sim except via well-defined commands.
Prohibitions:
• No direct engine-internals access; all commands must go through stable APIs.

10. dom_client_config.[hc] — Client configuration and keybinds
Stores user preferences, key mappings, UI scale etc.
May be loaded/saved from a config file, but file IO sits in /game/launcher or /scripts; this module is purely in-memory representation + parsing/serializing helpers.
Header
#include "dom_core_types.h"
#include "dom_client_input.h"

typedef struct DomClientKeybind {
    dom_u32 key;           /* physical key code */
    DomClientAction action;
    dom_u32 mods;          /* modifier mask */
} DomClientKeybind;

#define DOM_CLIENT_MAX_KEYBINDS 128

typedef struct DomClientConfig {
    DomClientKeybind keybinds[DOM_CLIENT_MAX_KEYBINDS];
    dom_u32 keybind_count;

    dom_i32 ui_scale;
    dom_i32 master_volume;   /* 0–255 */
    dom_i32 music_volume;
    dom_i32 sfx_volume;

    dom_bool8 invert_pan;
} DomClientConfig;
Public API:
void dom_client_config_init_default(DomClientConfig *cfg);

DomClientAction dom_client_config_lookup_action(const DomClientConfig *cfg,
                                               dom_u32 key, dom_u32 mods);

/* Optional: serialize/deserialize to a generic key=value representation */
void dom_client_config_serialize(const DomClientConfig *cfg,
                                 void *writer_ctx,
                                 void (*write_line)(void *ctx, const char *line));

void dom_client_config_apply_kv(DomClientConfig *cfg,
                                const char *key,
                                const char *value);
Rules:
• No file IO in this module, just generic read/write hooks.
• Default config must be deterministic and consistent.

11. Integration Summary
Per frame, the call stack from launcher should look like:
void dom_client_app_tick(DomClientApp *app) {
    // 1. Platform → client input
    DomPlatformInputFrame pframe;
    dom_platform_poll_input(&pframe);

    DomClientInputFrame cframe;
    dom_client_input_clear(&cframe);
    dom_client_input_from_platform(&cframe, &pframe);
    dom_client_input_map_actions(&cframe, &app->state, &app->config);

    // 2. UI frame
    dom_client_ui_frame(&app->ui, &app->state, &cframe);

    // 3. Process UI → sim commands
    dom_client_ui_process_commands(&app->ui, &app->state, &app->sim_bridge);

    // 4. Input-driven sim commands (camera, selection, build, etc.)
    dom_client_sim_bridge_apply_input(&app->sim_bridge, &app->state, &cframe);

    // 5. Step sim (local or net)
    dom_client_sim_bridge_step(&app->sim_bridge);

    // 6. Build view projection
    dom_client_view_build(&app->state,
                          app->window_w, app->window_h,
                          &app->render_pipe.view_proj);

    // 7. Build & submit render commands
    dom_client_render_pipe_build(&app->render_pipe,
                                 &app->state, &app->ui,
                                 app->sim_bridge.local_world_or_proxy);
    dom_client_render_pipe_submit(&app->render_pipe);

    // 8. Build & submit audio commands
    dom_client_audio_pipe_build(&app->audio_pipe, &app->state,
                                app->sim_bridge.local_world_or_proxy);
    dom_client_audio_pipe_submit(&app->audio_pipe);
}
Every mutation of the simulation happens via dom_client_sim_bridge using the deterministic engine APIs.
The client layer remains a pure orchestrator, UI host, and view/camera manager.

Next directory in order is game/server/ (dedicated server / host logic).
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for game/server/.
This directory contains the authoritative simulation host for multiplayer and automated worlds.
The server:
• Runs deterministic simulation using /engine/sim.
• Provides networking (lockstep or state-delta) via /engine/net.
• Maintains the authoritative timeline, replays, and snapshotting.
• Performs save/load of universe state.
• Contains no rendering, audio, UI, or client-side logic.
• Contains no OS-specific code—only via /engine/platform.
All game logic here is Dominium-specific, but constrained to proper engine interfaces.

Directory Layout
game/
└── server/
    ├── dom_server_app.h
    ├── dom_server_app.c
    ├── dom_server_state.h
    ├── dom_server_state.c
    ├── dom_server_tick.h
    ├── dom_server_tick.c
    ├── dom_server_net_bridge.h
    ├── dom_server_net_bridge.c
    ├── dom_server_worldio.h
    ├── dom_server_worldio.c
    ├── dom_server_admin.h
    └── dom_server_admin.c

1. dom_server_app.[hc] — Dedicated server top-level application
This mirrors game/client/dom_client_app as the high-level driver, but without UI or rendering.
Header
#include "dom_core_types.h"

typedef struct DomSimWorld DomSimWorld;
typedef struct DomNetServer DomNetServer;

typedef struct DomServerAppConfig {
    const char *load_path;    /* optional save file */
    const char *bind_address;
    dom_u16     port;
    dom_u32     max_clients;
    dom_bool8   enable_replays;
    dom_bool8   auto_save;
    dom_u32     autosave_interval_ticks;
} DomServerAppConfig;

typedef struct DomServerApp DomServerApp;
Public API
DomServerApp *dom_server_app_create(const DomServerAppConfig *cfg);

void dom_server_app_destroy(DomServerApp *app);

/* Drive one tick of the server (called from launcher main loop) */
void dom_server_app_tick(DomServerApp *app);
Internals of the opaque struct:
• Pointer to DomSimWorld
• Pointer to DomNetServer
• DomServerState
• DomServerNetBridge
• DomServerTickContext
• DomServerWorldIO
• Tick counters, timers for autosave, replay log writer.
Rules:
• The server must not stall the tick rate; if clients lag, they get state snapshots or prediction cues, but the server clock is authoritative.
• All user actions come as deterministic packets → converted to sim commands in a tick-indexed input stream.
Prohibitions:
• No rendering or audio.
• No platform calls beyond time, sockets, threads via /engine/platform.

2. dom_server_state.[hc] — Server metadata and administration state
This stores non-simulation but server-relevant state such as:
• Connected clients and authentication state.
• Permissions and admin flags.
• Ban lists, mutes.
• Universe metadata (seed, version, mod list).
Header
#include "dom_core_types.h"
#include "dom_net_proto.h"

#define DOM_SERVER_MAX_CLIENTS 128

typedef struct DomServerClientEntry {
    dom_bool8 connected;
    dom_u64   client_id;        /* stable id for this session */
    dom_u32   protocol_version;
    dom_u32   last_ack_tick;
    dom_bool8 is_admin;
    dom_bool8 is_spectator;
} DomServerClientEntry;

typedef struct DomServerState {
    DomServerClientEntry clients[DOM_SERVER_MAX_CLIENTS];
    dom_u32 client_count;

    dom_u64 universe_seed;
    dom_u32 engine_version;
    dom_u32 game_version;

    dom_bool8 read_only_mode; /* prevent sim changes */
} DomServerState;
Public API
void dom_server_state_init(DomServerState *s, dom_u64 universe_seed);

DomServerClientEntry *dom_server_state_add_client(DomServerState *s,
                                                  dom_u64 client_id,
                                                  dom_u32 proto);

void dom_server_state_remove_client(DomServerState *s,
                                    dom_u64 client_id);

DomServerClientEntry *dom_server_state_get(DomServerState *s,
                                           dom_u64 client_id);
Rules:
• Universe seed here is just metadata; actual terrain generation is sim-side.
• Client entries must be fully deterministic (sorted or stable indexing by arrival).
Prohibitions:
• No simulation ticking here.
• No networking inside these functions.

3. dom_server_tick.[hc] — Simulation tick coordinator
This module encapsulates all per-tick deterministic behaviour:
• Aggregate player inputs for tick T
• Feed inputs into /engine/sim
• Advance simulation
• Produce world delta or snapshot for clients
• Update replay logs
• Trigger autosave intervals
Header
#include "dom_core_types.h"

typedef struct DomSimWorld DomSimWorld;
typedef struct DomServerState DomServerState;
typedef struct DomServerNetBridge DomServerNetBridge;
typedef struct DomServerWorldIO DomServerWorldIO;

typedef struct DomServerTickContext {
    dom_u64 tick;
    dom_bool8 is_autosave_tick;
    dom_bool8 replay_recording_enabled;
} DomServerTickContext;
Public API
void dom_server_tick_init(DomServerTickContext *ctx);

void dom_server_tick_step(DomServerTickContext *ctx,
                          DomSimWorld *world,
                          DomServerState *state,
                          DomServerNetBridge *net,
                          DomServerWorldIO *io);
Inside step:
1. Gather input packets from bridge → input buffer indexed by tick.
2. Validate input deterministically (bounds check, permissions).
3. Feed canonical input frame to engine/sim.
4. Call dom_sim_tick(world).
5. Determine which deltas to send out.
6. Notify worldio if autosave or replay events needed.
Rules:
• Server tick increment must never skip or rewind except in rollback protocols (if supported).
• Processing order must be deterministic: sort client actions by client index, then by arrival order if needed.
Prohibitions:
• No network writes here. Only call functions on net_bridge.
• No disk writes here except replay append via worldio.

4. dom_server_net_bridge.[hc] — Interface between server and /engine/net
This module adapts between raw network packets and structured sim inputs / snapshots.
Header
#include "dom_core_types.h"
#include "dom_net_proto.h"
#include "dom_server_state.h"

typedef struct DomNetServer DomNetServer;
typedef struct DomSimInputFrame DomSimInputFrame;

typedef struct DomServerNetBridge {
    DomNetServer *net;
    DomServerState *state;

    /* input buffer per tick */
    DomSimInputFrame *pending_inputs;  /* [tick % window] */
    dom_u32 input_window;              /* tick ring size */

    /* snapshot compression options */
    dom_bool8 send_full_snapshots;
} DomServerNetBridge;
Public API
void dom_server_net_bridge_init(DomServerNetBridge *b,
                                DomNetServer *net,
                                DomServerState *state,
                                dom_u32 input_window);

void dom_server_net_bridge_poll(DomServerNetBridge *b,
                                DomServerTickContext *ctx);

/* Extract deterministic input frame for tick T */
void dom_server_net_bridge_build_input(DomServerNetBridge *b,
                                       dom_u64 tick,
                                       DomSimInputFrame *out);

/* Send delta/snapshot to all clients */
void dom_server_net_bridge_broadcast_state(DomServerNetBridge *b,
                                           const DomSimWorld *world,
                                           dom_u64 tick);

/* Send targeted responses (admin messages etc.) */
void dom_server_net_bridge_send_to(DomServerNetBridge *b,
                                   dom_u64 client_id,
                                   const DomNetPacket *pkt);
Rules:
• All inbound events must be validated with protocol version check.
• For each tick, missing client inputs must default to “no action”.
Prohibitions:
• No sim mutation.
• No world save/load here.

5. dom_server_worldio.[hc] — Save/load & replay
This module handles:
• Saving the deterministic world state.
• Loading an existing state.
• Writing replay logs (input stream logs).
• Optional delta compression of world snapshots.
Header
#include "dom_core_types.h"

typedef struct DomSimWorld DomSimWorld;

typedef struct DomServerWorldIO {
    const char *save_path;     /* may be NULL */
    const char *replay_path;   /* may be NULL */

    dom_bool8 enable_replays;

    /* internal buffers */
    void *tmp_buf;
    dom_u32 tmp_buf_size;
} DomServerWorldIO;
Public API
void dom_server_worldio_init(DomServerWorldIO *io,
                             const char *save_path,
                             const char *replay_path,
                             dom_bool8 enable_replays);

/* Load world into sim state */
DomResult dom_server_worldio_load(DomServerWorldIO *io,
                                  DomSimWorld *world);

/* Save world snapshot (full state) */
DomResult dom_server_worldio_save(DomServerWorldIO *io,
                                  const DomSimWorld *world);

/* Append inputs for replay logs */
DomResult dom_server_worldio_append_replay(DomServerWorldIO *io,
                                           dom_u64 tick,
                                           const DomSimInputFrame *frame);
Rules:
• File format must be versioned and platform-agnostic.
• Replays must be append-only and purely deterministic log of sim input frames.
• No partial writes; use temp-file → atomic rename.
Prohibitions:
• No rendering or network code.
• No sim stepping.

6. dom_server_admin.[hc] — Admin commands and permissions
Dedicated server needs admin tools to:
• Kick/ban clients.
• Modify server flags.
• Change game speed or simulation parameters.
• Trigger save/load, announce messages.
Header
#include "dom_core_types.h"
#include "dom_server_state.h"
#include "dom_server_net_bridge.h"
#include "dom_server_worldio.h"

typedef struct DomServerAdminContext {
    DomServerState *state;
    DomServerNetBridge *net;
    DomServerWorldIO *io;
} DomServerAdminContext;
Public API
/* Execute admin commands (from console or authorised network messages) */
DomResult dom_server_admin_execute(DomServerAdminContext *ctx,
                                   dom_u64 requesting_client_id,
                                   const char *cmdline);

/* Predefined commands:
   - kick <id>
   - ban <id>
   - unban <id>
   - save
   - load
   - set-speed <n>
   - announce <text>
   - list-clients
*/
Rules:
• Deterministic: admin commands must resolve to deterministic state transitions.
• Permissions must match “is_admin” flag in DomServerClientEntry.
Prohibitions:
• No direct disk or network writes; call worldio or net_bridge.

Integration Summary (Server Runtime Loop)
A dedicated server main loop (in /game/launcher) calls:
void dom_server_app_tick(DomServerApp *app) {
    // 1. Poll network for inbound packets
    dom_server_net_bridge_poll(app->net_bridge, app->tick_ctx);

    // 2. Build input frame for tick T
    DomSimInputFrame frame;
    dom_server_net_bridge_build_input(app->net_bridge,
                                      app->tick_ctx->tick,
                                      &frame);

    // 3. Step simulation
    dom_sim_tick(app->world, &frame);

    // 4. Broadcast state snapshot/delta
    dom_server_net_bridge_broadcast_state(app->net_bridge,
                                          app->world,
                                          app->tick_ctx->tick);

    // 5. Autosave / replay
    if (app->tick_ctx->is_autosave_tick) {
        dom_server_worldio_save(app->worldio, app->world);
    }
    if (app->worldio->enable_replays) {
        dom_server_worldio_append_replay(app->worldio,
                                         app->tick_ctx->tick,
                                         &frame);
    }

    // 6. Advance tick
    app->tick_ctx->tick++;
}
Everything the server does must be repeatable = deterministic given the same input and config.

Prohibitions Across game/server
• No rendering, UI, audio.
• No floating-point affecting simulation; all integer math.
• No OS-specific logic; always use /engine/platform for I/O, timers, sockets.
• No simulation logic duplicated; always use /engine/sim.
• No mod loading here; mods are loaded by engine/data layer before world creation.

Next directory in your sequencing is game/launcher/.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for game/launcher/.
This directory contains the only OS-facing executable entrypoints for Dominium.
A launcher’s job is extremely small:
• Create a window and renderer/audio backend via /engine/platform
• Initialise a DomClientApp or DomServerApp
• Feed the main loop
• Provide hardware detection and configuration selection
• Handle command-line arguments and file pickers
• Provide version information and logging bootstrap
The launcher must not contain simulation logic, rendering logic, UI logic, or game rules.
It is a thin wrapper between the OS and the game/client or game/server app layers.

Directory Layout
game/
└── launcher/
    ├── dom_launcher_main.h
    ├── dom_launcher_main.c
    ├── dom_launcher_platform.h
    ├── dom_launcher_platform.c
    ├── dom_launcher_config.h
    ├── dom_launcher_config.c
    ├── dom_launcher_args.h
    ├── dom_launcher_args.c
    ├── dom_launcher_detect.h
    ├── dom_launcher_detect.c
    ├── dom_launcher_select.h
    ├── dom_launcher_select.c
    ├── dom_launcher_server.h
    └── dom_launcher_server.c
Some platforms may provide alternative entrypoints under /ports, but all mainstream builds go through this directory.

1. dom_launcher_main.[hc] — Cross-platform launcher entry
This file defines the canonical launcher entry API that platform-specific mains will call.
Header
#include "dom_core_types.h"

typedef enum {
    DOM_LAUNCH_MODE_CLIENT = 0,
    DOM_LAUNCH_MODE_SERVER
} DomLaunchMode;

typedef struct DomLaunchContext {
    DomLaunchMode mode;
    void *platform_window;  /* opaque handle */
    dom_i32 window_w;
    dom_i32 window_h;
    dom_bool8 fullscreen;

    /* pointers to engine devices */
    DomRenderDevice *render_dev;
    DomAudioDevice  *audio_dev;
} DomLaunchContext;
Public API
/* Called by platform-specific main() */
int dom_launcher_run(int argc, char **argv);

/* Internals: not called outside this directory */
DomResult dom_launcher_init(DomLaunchContext *ctx,
                            int argc, char **argv);

void dom_launcher_loop_client(DomLaunchContext *ctx);
void dom_launcher_loop_server(DomLaunchContext *ctx);
Responsibilities:
• Parse CLI → mode selection
• Select platform device backends
• Initialise config
• Create ClientApp or ServerApp
• Enter main loop
Prohibitions:
• No simulation stepping here (belongs to client/server apps)
• No rendering calls except buffer swaps + device init/destroy

2. dom_launcher_platform.[hc] — Window, input, device creation
This module abstracts platform details but uses /engine/platform internally.
It is NOT platform-specific — it picks which backend to use per platform, but does not implement the backends.
Header
#include "dom_core_types.h"

typedef struct {
    void *window;
    dom_i32 width;
    dom_i32 height;
    dom_bool8 fullscreen;
} DomLauncherWindow;

typedef struct {
    DomLauncherWindow window;
    DomRenderDevice *render_dev;
    DomAudioDevice *audio_dev;
} DomLauncherPlatform;
Public API
DomResult dom_launcher_platform_init(DomLauncherPlatform *p,
                                     dom_i32 width,
                                     dom_i32 height,
                                     dom_bool8 fullscreen);

void dom_launcher_platform_shutdown(DomLauncherPlatform *p);

void dom_launcher_platform_poll_input(DomPlatformInputFrame *dst);
Rules:
• Must choose backend based on OS + availability:
o Win32 → DX9 or DX11
o Linux → GL1 or GL2
o macOS → GL2 (or Metal via engine-port)
o Retro ports → custom renderer selection
• Must not include any OS headers directly; leave that to /engine/platform/<os>.
Prohibitions:
• No UI code, no simulation code.
• No persistent config loading here.

3. dom_launcher_config.[hc] — Load/save boot configuration
Stores launcher-level settings (resolution, fullscreen, last-used renderer, audio backend, profile).
This is distinct from client config (keybinds, UI scale), which lives in /game/client.
Header
#include "dom_core_types.h"

typedef struct DomLauncherConfig {
    dom_i32 window_w;
    dom_i32 window_h;
    dom_bool8 fullscreen;
    char renderer[32];
    char audio_backend[32];
} DomLauncherConfig;
Public API
void dom_launcher_config_init_default(DomLauncherConfig *cfg);

DomResult dom_launcher_config_load(DomLauncherConfig *cfg,
                                   const char *path);

DomResult dom_launcher_config_save(const DomLauncherConfig *cfg,
                                   const char *path);
Rules:
• Launcher config file format must be simple key=value pairs.
• Paths must be determined by /engine/platform (user data dirs).
Prohibitions:
• No simulation or renderer interaction.
• No UI.

4. dom_launcher_args.[hc] — CLI args
Handles parsing of meaningful command line arguments:
• --server
• --load <file>
• --connect <addr:port>
• --fullscreen
• --renderer <backend>
• --audio <backend>
• --safe-mode
Header
typedef struct DomLauncherArgs {
    dom_bool8 server_mode;
    const char *load_path;
    const char *connect_addr;
    dom_u16 connect_port;
    dom_bool8 fullscreen_override;
    const char *renderer_name;
    const char *audio_name;
    dom_bool8 safe_mode;
} DomLauncherArgs;
Public API
void dom_launcher_args_parse(DomLauncherArgs *out,
                             int argc, char **argv);
Rules:
• Parsing must be deterministic.
• Args override config values.
Prohibitions:
• No side effects except filling struct.

5. dom_launcher_detect.[hc] — Hardware detection
Determines:
• GPU family
• Supported renderer backends
• Supported audio backends
• CPU instruction features (SSE2, AVX, NEON, etc)
• Memory availability
• OS version
Header
typedef struct DomLauncherDetect {
    dom_bool8 have_dx9;
    dom_bool8 have_dx11;
    dom_bool8 have_gl1;
    dom_bool8 have_gl2;
    dom_bool8 have_software;

    dom_bool8 have_openal;
    dom_bool8 have_sdl_mixer;

    dom_u32 system_mem_mb;
    dom_u32 cpu_features;
} DomLauncherDetect;
Public API
void dom_launcher_detect_run(DomLauncherDetect *d);
Rules:
• Must rely on /engine/platform queries (no direct OS calls).
• Use feature flags not GPU strings.
Prohibitions:
• No device creation here. Only detection.

6. dom_launcher_select.[hc] — Choose renderer/audio backends
Combines:
• Config file
• Command-line arguments
• Hardware detection
And selects:
• Renderer backend (GL1, GL2, DX9, DX11, Software)
• Audio backend (OpenAL, SDL_Mixer, Silent)
Header
#include "dom_launcher_detect.h"
#include "dom_launcher_config.h"
#include "dom_launcher_args.h"

typedef struct DomLauncherSelection {
    const char *renderer;
    const char *audio;
} DomLauncherSelection;
Public API
void dom_launcher_select_backends(DomLauncherSelection *sel,
                                  const DomLauncherDetect *det,
                                  const DomLauncherConfig *cfg,
                                  const DomLauncherArgs *args);
Rules:
• Must fallback gracefully and deterministically.
• If --safe-mode, always force the simplest backend (software + no audio).
Prohibitions:
• No device creation; only select names/identifiers.

7. dom_launcher_server.[hc] — Dedicated server entry
Launcher for server mode (no window, no render device).
Header
#include "dom_core_types.h"
#include "dom_server_app.h"

typedef struct DomLauncherServer {
    DomServerApp *app;
    dom_bool8 running;
} DomLauncherServer;
Public API
void dom_launcher_server_init(DomLauncherServer *srv,
                              const DomLauncherArgs *args);

void dom_launcher_server_loop(DomLauncherServer *srv);

void dom_launcher_server_shutdown(DomLauncherServer *srv);
Responsibilities:
• Construct DomServerAppConfig.
• Handle signals (shutdown, reload) via /engine/platform.
• Provide minimal console logs (timestamped, deterministic, append-only format).
Rules:
• Server loop must not sleep arbitrarily—use tick-rate timer from /engine/platform.
• Must handle autosave intervals.
Prohibitions:
• No rendering or UI.

8. Launcher Runtime Flow (Client)
Pseudo-flow showing how dom_launcher_run() works:
int dom_launcher_run(int argc, char **argv) {
    DomLauncherArgs args;
    dom_launcher_args_parse(&args, argc, argv);

    DomLauncherConfig cfg;
    dom_launcher_config_init_default(&cfg);
    dom_launcher_config_load(&cfg, "user/config/launcher.cfg");

    DomLauncherDetect det;
    dom_launcher_detect_run(&det);

    DomLauncherSelection sel;
    dom_launcher_select_backends(&sel, &det, &cfg, &args);

    DomLaunchContext ctx;
    dom_launcher_platform_init(&ctx.platform, cfg.window_w, cfg.window_h, cfg.fullscreen);

    dom_launcher_init(&ctx, argc, argv);

    if (args.server_mode) {
        dom_launcher_loop_server(&ctx);
    } else {
        dom_launcher_loop_client(&ctx);
    }

    dom_launcher_platform_shutdown(&ctx.platform);
    return 0;
}
This design forces:
• Deterministic selection of runtime components
• Clean separation from client/server logic
• No dependency on simulation in launcher

9. Prohibitions Across game/launcher
• No simulation logic
• No UI construction or widget handling
• No rendering calls except abstract device init/shutdown and buffer swap
• No per-frame heavy logic
• No third-party library includes except through /engine/platform
• No mod loading — handled at /game and /engine level

Next target directory is the data/ subtree, starting with data/base/ unless you prefer beginning at the root of /data.
You said:
Next
ChatGPT said:
Thought for 9s
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /data (top-level game data subtree), not the engine or game code.
/data holds all first-party content that is loaded as “data packs” on top of the deterministic engine:
• Base game definitions
• Official DLCs
• First-party graphics/sound/music packs
• Example templates and demo universes
No C/C++ code lives here. Only data, schemas, and manifests.

0. Structure recap
/data
├─ README.md
├─ data_manifest.json
├─ schema/
│  ├─ data_schema.json
│  ├─ prefab_schema.json
│  ├─ tech_schema.json
│  ├─ network_schema.json
│  └─ locale_schema.json
├─ base/
├─ dlc/
├─ packs/
└─ templates/
Later messages will drill into /data/base, /data/dlc, /data/packs, /data/templates.
This message defines what /data as a whole does and what its files must guarantee.

1. /data/README.md
Short human-facing description of data layout and rules.
Mandatory sections:
• Data philosophy (deterministic, schema-driven, no code)
• Directory overview (base, dlc, packs, templates)
• Versioning and compat guarantees
• Modding notes (how mods mirror /data structure under /mods)
No technical authority here; specs live in /docs/spec.

2. /data/data_manifest.json — Global data index
Single source of truth for what data packs exist, their IDs, load order, and compatibility.
Format (top-level)
{
  "format_version": 1,
  "engine_min_version": "3.0.0",
  "engine_max_version": "3.x",
  "packs": [
    {
      "id": "base",
      "type": "base",
      "path": "base",
      "version": "1.0.0",
      "priority": 0,
      "dependencies": [],
      "description": "Dominium base game content"
    },
    {
      "id": "dlc_interstellar",
      "type": "dlc",
      "path": "dlc/interstellar",
      "version": "1.0.0",
      "priority": 10,
      "dependencies": ["base"]
    },
    {
      "id": "pack_default_graphics",
      "type": "gfx_pack",
      "path": "packs/gfx_default",
      "version": "1.0.0",
      "priority": 100,
      "dependencies": ["base"]
    }
  ]
}
Semantics
• format_version – version of this manifest structure.
• packs – ordered list telling the engine what to load:
o id – global string ID (stable).
o type – "base" | "dlc" | "gfx_pack" | "sfx_pack" | "music_pack" | "template_pack" | "other".
o path – relative to /data.
o priority – load-overwrite order; higher overrides lower for same resource IDs.
o dependencies – other pack IDs required.
Engine rules:
• base must exist and load first.
• DLCs must list base or others they extend.
• Packs may override resources but never change binary format.
• Engine must reject inconsistent dependency graphs deterministically.
Prohibitions:
• No script or code embedded.
• No runtime config here; purely data-pack references.

3. /data/schema/ — JSON schemas for all data types
This directory defines authoritative machine-readable schemas for every structured data file type used under /data (and mirrored under /mods).
Files:
/data/schema/
├─ data_schema.json           # root schema that references the others
├─ prefab_schema.json         # buildings, machines, rolling stock, items
├─ tech_schema.json           # research tree, prerequisites, costs
├─ network_schema.json        # power/fluids/data/rail/road definitions
├─ worldgen_schema.json       # planet templates, terrain generators
├─ economy_schema.json        # commodities, markets, pricing models
├─ locale_schema.json         # localisation entries
└─ ui_schema.json             # optional UI layout data
3.1 data_schema.json
• Master schema that references each data category.
• For validation tools and CI.
• Defines $id base and $ref targets for sub-schemas.
Usage:
• /tools/devkit runs a validator over all JSON in /data and /mods against these schemas.
3.2 prefab_schema.json
Defines structure of prefab JSONs for entities:
• prefab_id (string; mapped to uint64 at load)
• category (building, vehicle, item, worker, terrain_feature, orbital_structure, ship, station_module, etc.)
• components – typed dict of component payloads (matching ECS component IDs)
• footprint – tile/grid footprint (2D or 3D)
• ports – utility connection points (power/fluid/data/rail/road/pipe)
• construction – stages, costs, jobs, prerequisites
• flags – destructible, explosive, atmospheric, orbital-only, surface-only, etc.
Rules:
• All numeric values use integers or rational encoding (no bare floats).
• Component payloads must match component IDs and their static formats defined in /docs/spec.
3.3 tech_schema.json
Defines structure for technology and research:
• tech_id, name, description
• tier, category
• prerequisites (array of tech_ids)
• unlocks (prefab_ids, components, recipes)
• cost (science packs or resource tokens)
• time (ticks or research points)
Determinism:
• Tech unlock order computed from this graph must be deterministic given same inputs.
3.4 network_schema.json
For base definitions of:
• Rail gauges and rail types
• Road classes
• Power line voltages/insulation classes
• Fluids/pipes diameters
• Data cable types, fibre, wireless bands
Structure:
• Each network element has:
o id (string)
o category (rail, road, power, fluid, data)
o parameters (integers only: capacity, speed_limit, loss_per_km, etc)
o constraints (where it can be placed, what it connects to)
These definitions feed the sim network modules.
3.5 worldgen_schema.json
For procedural world and planet templates:
• planet_id, seed, radius, gravity, atmosphere, biomes, ore_distributions, sea_level, etc.
• surface_tiling parameters linking to your subtile/chunk/region system.
Important: worldgen is deterministic integer math, seeds are integers, no floats.
3.6 economy_schema.json
For commodities and economic configuration:
• Commodity IDs, units, density
• Base prices and elasticity
• Market groups and supply/demand curves (lookup tables)
Prices computed in sim from these discrete tables, not from JSON floats.
3.7 locale_schema.json
Defines the structure for localisation packs:
• language_code (e.g. en-AU)
• entries map: key -> translated string
• Meta: plural rules, fonts fallback, text direction.
Prohibitions: no embedded control codes outside your safely-defined markup.

4. /data/base/ — Base game content root
Only overview here; its own message will define file-by-file spec.
High-level layout:
/data/base/
├─ manifest.json
├─ prefabs/
├─ tech/
├─ networks/
├─ worldgen/
├─ economy/
├─ locale/
└─ scripts/      # if you allow deterministic Lua helpers; optional
Contract:
• manifest.json must conform to data/schema/data_schema.json pack fragment.
• All structured files must pass schema validation.
• No code other than pure data or pure deterministic scripts if allowed.

5. /data/dlc/ — Official DLC roots
Each DLC is a pack extending /data/base.
Example layout:
/data/dlc/
├─ interstellar/
│  ├─ manifest.json
│  ├─ prefabs/
│  ├─ tech/
│  ├─ worldgen/
│  └─ locale/
└─ wargames/
   ├─ manifest.json
   └─ ...
Each DLC directory:
• Must contain a manifest.json referencing its pack ID (e.g. dlc_interstellar) and dependencies.
• Must not redefine fundamental formats, only extend/override objects.
Engine must:
• Load base first, then DLCs by priority.
• Detect conflicting IDs and handle via override rules (no ambiguity).

6. /data/packs/ — Graphics/SFX/Music packs
These are cosmetic packs that do not change simulation.
Example:
/data/packs/
├─ gfx_default/
│  ├─ manifest.json
│  ├─ sprites/
│  ├─ tilesets/
│  └─ ui/
├─ sfx_default/
│  ├─ manifest.json
│  └─ sounds/
└─ music_default/
   ├─ manifest.json
   └─ music/
6.1 GFX pack constraints
• All images must be in deterministic, cross-platform formats (PNG, indexed BMP for retro).
• All animation/tile meta is stored in JSON, governed by ui_schema or a separate gfx_schema.
No engine logic here.
6.2 SFX/Music pack constraints
• Sound assets as WAV/OGG/FLAC.
• Music playlists defined in JSON.
• No random playlist semantics; playlists are deterministic sequences with optional weighted selection but configured via integers (engine chooses deterministically from a seed).

7. /data/templates/ — Example universes and demo saves
Example layout:
/data/templates/
├─ manifest.json
├─ tutorial_property/
│  ├─ meta.json
│  ├─ save.dom
│  └─ readme.md
└─ mega_factory/
   ├─ meta.json
   ├─ save.dom
   └─ readme.md
• manifest.json lists built-in templates.
• meta.json describes each template: name, description, recommended difficulty, version, required DLCs.
Engine behaviour:
• Templates are read-only masters; using one creates a copy in user save space.
• The .dom save files must conform to the deterministic serialization spec from your V3 docs.
Prohibitions:
• Templates must not depend on mods.
• No executable scripts except deterministic world scripts embedded via engine’s safe scripting channels.

8. Determinism and versioning guarantees for /data
The data layer must obey:
1. Schema-validated, versioned formats.
2. No floating-point numbers in any file; use integers or fixed-point encoded as ints.
3. Stable IDs: once a prefab/tech/resource ID is published, it must not be repurposed.
4. Backward compatibility:
o For each broke-change schema bump, provide migration rules or drop old saves intentionally.
5. Load order defined strictly by data_manifest.json → no file system ordering.

9. Prohibitions across /data
• No C/C++/binary code.
• No compiled scripts or bytecode.
• No platform-specific paths or line endings assumptions.
• No random numbers baked as behaviour; use seeds and engine-level PRNG.
• No reliance on directory listing order; everything must be explicitly listed in manifests.

Next message will define /data/base/ and its internal directories and files in dev-spec detail.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /data/base/.
/data/base is the canonical base content pack.
If this pack is missing or invalid, the game cannot run.
It defines all simulation-facing content for the vanilla game:
• Base prefabs (buildings, machines, vehicles, items, orbital structures)
• Tech tree and research data
• Network classes (rail, road, power, fluids, data, etc.)
• Worldgen templates (Earth, Sol, Milky Way default property)
• Economy (commodities, markets, prices)
• Localisation (English baseline; others optional)
• Optional deterministic helper scripts
No engine logic here, but every file is considered authoritative game content.

Directory Layout
/data/base/
├─ manifest.json
├─ prefabs/
│  ├─ prefabs_buildings.json
│  ├─ prefabs_machines.json
│  ├─ prefabs_vehicles_surface.json
│  ├─ prefabs_vehicles_orbital.json
│  ├─ prefabs_items.json
│  ├─ prefabs_infrastructure.json
│  ├─ prefabs_rails.json
│  ├─ prefabs_roads.json
│  ├─ prefabs_utilities.json
│  └─ tags.json
├─ tech/
│  ├─ tech_tree.json
│  ├─ tech_categories.json
│  └─ tech_science_packs.json
├─ networks/
│  ├─ rails.json
│  ├─ roads.json
│  ├─ power.json
│  ├─ fluids.json
│  ├─ data.json
│  └─ logistics.json
├─ worldgen/
│  ├─ planets.json
│  ├─ systems.json
│  ├─ galaxies.json
│  ├─ biomes.json
│  └─ resources.json
├─ economy/
│  ├─ commodities.json
│  ├─ markets.json
│  └─ recipes.json
├─ locale/
│  ├─ en-AU.json
│  └─ en-US.json
└─ scripts/        # optional deterministic helpers
   └─ base_helpers.lua  (or similar, if scripting is allowed)
Each .json file must conform to a schema under /data/schema.
All numeric fields must be integers or integer-encoded fixed-point values.

1. manifest.json — Base pack declaration
This file declares the base pack to the engine.
Structure
{
  "id": "base",
  "type": "base",
  "version": "1.0.0",
  "engine_min_version": "3.0.0",
  "engine_max_version": "3.x",
  "description": "Dominium base content pack",
  "dependencies": [],
  "provides": [
    "prefabs",
    "tech_tree",
    "networks",
    "worldgen",
    "economy",
    "locale"
  ],
  "content_index": {
    "prefabs": [
      "prefabs/prefabs_buildings.json",
      "prefabs/prefabs_machines.json",
      "prefabs/prefabs_vehicles_surface.json",
      "prefabs/prefabs_vehicles_orbital.json",
      "prefabs/prefabs_items.json",
      "prefabs/prefabs_infrastructure.json",
      "prefabs/prefabs_rails.json",
      "prefabs/prefabs_roads.json",
      "prefabs/prefabs_utilities.json",
      "prefabs/tags.json"
    ],
    "tech": [
      "tech/tech_tree.json",
      "tech/tech_categories.json",
      "tech/tech_science_packs.json"
    ],
    "networks": [
      "networks/rails.json",
      "networks/roads.json",
      "networks/power.json",
      "networks/fluids.json",
      "networks/data.json",
      "networks/logistics.json"
    ],
    "worldgen": [
      "worldgen/planets.json",
      "worldgen/systems.json",
      "worldgen/galaxies.json",
      "worldgen/biomes.json",
      "worldgen/resources.json"
    ],
    "economy": [
      "economy/commodities.json",
      "economy/markets.json",
      "economy/recipes.json"
    ],
    "locale": [
      "locale/en-AU.json",
      "locale/en-US.json"
    ]
  }
}
Engine behaviour:
• Treats /data/base/manifest.json as special.
• Validates version and schemas on load.
• Uses content_index as the only source of which files to load; does not rely on directory listing.
Prohibitions:
• No executable scripts in this file.
• No environment-specific overrides.

2. /data/base/prefabs/ — Simulation entities and components
This subdirectory defines all entity templates for the base game.
Each prefab ID maps to a deterministic internal uint64 resource ID.
2.1 prefabs_buildings.json
Static or mostly-static structures on surfaces and in orbital environments that are not vehicles:
• Foundations, floors, walls, roofs
• Houses, factories, depots, stations
• Storage warehouses, tanks
• Control rooms, admin buildings
• Orbital station modules (if not in separate orbital file)
Structure per prefab:
{
  "prefabs": [
    {
      "id": "building_foundation_basic",
      "category": "building",
      "tags": ["foundation", "surface_only"],
      "components": {
        "transform": {
          "size": [1, 1, 1],
          "anchor": "bottom_center"
        },
        "structure": {
          "hp": 1000,
          "fire_resistance": 10,
          "explosion_resistance": 5
        },
        "grid_occupancy": {
          "footprint": [[0, 0]],
          "height": 1
        },
        "buildable": {
          "allowed_surface": ["surface_default"],
          "required_tech": "tech_construction_1",
          "construction_jobs": 1,
          "construction_time_ticks": 60
        },
        "power_interface": { "mode": "none" }
      }
    }
  ]
}
All components must match ECS component definitions in /docs/spec.
2.2 prefabs_machines.json
Active machines:
• Power plants, generators, transformers
• Refineries, assemblers, smelters
• Pumps, compressors, reactors
• Radars, telecom nodes, servers
Fields to expose:
• I/O ports for power/fluid/data/logistics
• Processing recipes references (recipe_ids)
• Operational states, capacity, throughput
• Safety flags and emergency behaviours
All machine behaviours are implemented in /engine/sim, not data; data only configures parameters.
2.3 prefabs_vehicles_surface.json
Vehicles operating on surfaces:
• Rail vehicles (locomotives, wagons, trams)
• Road vehicles (trucks, buses, cars)
• Construction equipment
• Ships and boats (for waterways) if they operate on surface grids
Key fields:
• Vehicle category (rail, road, water_surface)
• Required network type (rail_type_id, road_type_id, etc.)
• Length and coupling points (important for trains)
• Allowed grades and curves
• Max speed, acceleration, braking
2.4 prefabs_vehicles_orbital.json
Orbital vehicles and structures:
• Rockets, stages, landers, shuttles
• Orbital tugs, cargo ferries
• Station docking modules if they are treated as vehicles
• Drop pods for surface–orbit logistics
Fields:
• Environment constraints (surface_only, orbital_only, both)
• Docking interface definitions (types, alignment)
• Δv-equivalent discrete parameters (engine thrust, fuel mass in integer units)
• Launch/landing constraints (runway pad type, launch tower required, etc.)
2.5 prefabs_items.json
Inventory items:
• Raw ores, intermediate materials
• Components (wires, rails, sleepers, beams)
• Fuel types, science packs, tools
• Data tokens or licences in the economy
Fields:
• Stack size
• Mass and volume in integer units
• Value reference to commodity ID
• Category for UI filtering
2.6 prefabs_infrastructure.json
Non-machine but functional infrastructure:
• Foundations, roads/railway infrastructure pieces
• Pipes, cables, ducts, conduits
• Platforms, stairs, ramps, ladders
• Platforms and ramps for rail/road/water/air integration
2.7 prefabs_rails.json
Rail-specific prefab pieces:
• Track segments (straight, curved, switches, crossings)
• Platforms, buffers, signals, points motors
• Bridge and tunnel entries
Each track piece references:
• gauge_class from networks/rails.json
• weight_class or rail type
• Allowed speeds
• Intended usage (mainline, yard, miniature, heavy-haul, maglev, etc.)
2.8 prefabs_roads.json
Road pieces:
• Lanes, intersections, ramps, toll booths
• Bridges and tunnels for road networks
• Special surfaces (runways, taxiways, parking)
Each road piece references road classes from networks/roads.json.
2.9 prefabs_utilities.json
Utility components:
• Power poles, substations
• Transformers, rectifiers
• Fluid pumps, valves, meters
• Data cabinets, routers, access points
• Lighting, signalling equipment
2.10 tags.json
Global tag registry:
{
  "tags": [
    {"id": "surface_only", "description": "Cannot exist in orbital space"},
    {"id": "orbital_only", "description": "Cannot exist on surfaces"},
    {"id": "rail_vehicle", "description": "Uses rail network"},
    {"id": "road_vehicle", "description": "Uses road network"},
    {"id": "miniature_gauge", "description": "Applies to miniature rail items"},
    ...
  ]
}
Tags are used across prefabs, tech, UI, and mods for filtering and behaviour gating.
Prohibitions in /prefabs:
• No script code.
• No floats.
• No references to undefined components, networks, or tech IDs.
• No circular dependencies in construction requirements.

3. /data/base/tech/ — Research tree
3.1 tech_tree.json
Defines all base-game technologies and their relationships.
Structure example:
{
  "technologies": [
    {
      "id": "tech_construction_1",
      "name_key": "tech.construction_1.name",
      "desc_key": "tech.construction_1.desc",
      "tier": 1,
      "category": "infrastructure",
      "prerequisites": [],
      "cost": {
        "science_pack_basic": 50
      },
      "time_per_unit_ticks": 600,
      "unlocks_prefabs": [
        "building_foundation_basic",
        "machine_basic_assembler"
      ],
      "unlocks_recipes": [
        "recipe_foundation_basic"
      ]
    }
  ]
}
Rules:
• Graph must form a DAG (no cycles).
• Unlocks must reference existing IDs.
• Costs expressed in integer units of science packs.
3.2 tech_categories.json
Defines tech categories for UI grouping and gating:
{
  "categories": [
    { "id": "infrastructure", "name_key": "tech.category.infrastructure" },
    { "id": "transport", "name_key": "tech.category.transport" },
    { "id": "orbital", "name_key": "tech.category.orbital" },
    { "id": "data", "name_key": "tech.category.data" }
  ]
}
3.3 tech_science_packs.json
Defines science pack item IDs and their properties:
• Which prefab item they map to
• Relative difficulty and cost
• Required infrastructure to produce them

4. /data/base/networks/ — Network classes
4.1 rails.json
Defines rail gauge classes, rail types and usage:
{
  "gauges": [
    { "id": "gauge_miniature", "width_mm": 184, "display_name_key": "rail.gauge.miniature" },
    { "id": "gauge_minimum", "width_mm": 381, "display_name_key": "rail.gauge.minimum" },
    { "id": "gauge_narrow", "width_mm": 610, "display_name_key": "rail.gauge.narrow" },
    { "id": "gauge_metre", "width_mm": 1000, "display_name_key": "rail.gauge.metre" },
    { "id": "gauge_standard", "width_mm": 1435, "display_name_key": "rail.gauge.standard" },
    { "id": "gauge_broad", "width_mm": 1600, "display_name_key": "rail.gauge.broad" },
    { "id": "gauge_maximum", "width_mm": 2134, "display_name_key": "rail.gauge.maximum" },
    { "id": "gauge_massive", "width_mm": 3000, "display_name_key": "rail.gauge.massive" }
  ],
  "rail_types": [
    {
      "id": "rail_light_miniature",
      "gauge_id": "gauge_miniature",
      "weight_class": "light",
      "max_speed_kph": 30,
      "max_axle_load_tonnes": 4
    }
  ]
}
These definitions are consumed by the sim’s rail network module and by prefabs_rails.json and vehicles.
4.2 roads.json
Defines road classes:
• lane_width_cm
• max_speed_kph
• target_vehicle_types
• surface_type (dirt, gravel, sealed, reinforced, runway, taxiway)
4.3 power.json
Defines power network classes:
• Voltage levels, phases (DC, AC1P, AC3P)
• Line types (overhead, underground, busbar)
• Capacity per segment, losses per distance
• Insulation and clearance rules used by sim
4.4 fluids.json
Defines fluid pipe classes:
• Diameters, materials
• Pressure limits
• Flow capacity per section
4.5 data.json
Defines data network cables and wireless types:
• Cable categories (Cat5–8, coax, fibre)
• Max segment length, bandwidth, latency
• Wireless bands (UHF, SHF, microwaves, optical)
4.6 logistics.json
Defines:
• Conveyor types
• Belt speeds
• Inserter/loader classes
Things like buffer capacities and layout rules come from sim; these files only define static parameters.

5. /data/base/worldgen/ — World and universe templates
5.1 planets.json
Includes the default Earth planet and configuration for others.
{
  "planets": [
    {
      "id": "planet_earth",
      "name_key": "planet.earth.name",
      "radius_m": 6371000,
      "gravity_mm_s2": 9810,
      "atmosphere": {
        "pressure_pa": 101325,
        "composition": {
          "n2": 780000,
          "o2": 210000,
          "ar": 9000,
          "co2": 400
        }
      },
      "biome_map": "biome_earth",
      "default_surface": "surface_earth_default"
    }
  ]
}
5.2 systems.json
Solar system templates:
• system_sol with planet_earth, planet_mars, etc.
• Orbital distances and environment meta.
5.3 galaxies.json
Galactic structures:
• galaxy_milky_way as the default
• Possibly meta for star distribution and rare systems
5.4 biomes.json
Biome definitions per planet:
• Terrain types
• Ground composition and depth
• Vegetation and hazard distribution
• Climate patterns (temperature ranges, rainfall indices)
5.5 resources.json
Defines ore and resource distributions:
• resource_id
• Depth and richness by biome
• Cluster size, frequency
• Access difficulty
All worldgen uses integer-based RNG seeded by universe_seed and IDs from these files.

6. /data/base/economy/ — Economic layer
6.1 commodities.json
Defines all commodities that appear in markets:
• IDs, names
• Physical mapping (item/fluids IDs)
• Base prices (integer)
• Categories (raw, intermediate, finished, service)
6.2 markets.json
Defines market groups:
• Local property markets
• Regional, planetary, interstellar markets (future DLC)
Fields:
• Which commodities trade in which market
• Fee structures
• Taxes, tariffs (if applicable)
• Limits and caps
6.3 recipes.json
Production recipes:
• Inputs (items/fluids/power/time)
• Outputs (items/fluids, byproducts)
• Required machine/tech
Each recipe references:
• Prefab IDs of machines able to perform it
• Tech IDs that unlock it

7. /data/base/locale/ — Localisation
Baseline localisations for English variants.
7.1 en-AU.json
Preferred base locale:
{
  "language_code": "en-AU",
  "entries": {
    "ui.menu.start": "Start",
    "tech.construction_1.name": "Basic Construction",
    "tech.construction_1.desc": "Allows simple foundations and basic factories.",
    "planet.earth.name": "Earth",
    "rail.gauge.standard": "Standard gauge (1435 mm)"
  }
}
7.2 en-US.json
Fallback or alternate locale for US English. Keys must be identical to en-AU.json where present.
Rules:
• Localisation keys must be stable and unique.
• No formatting logic; just plain strings or minimal markup (e.g. {value} placeholders).
• No arbitrary scripting inside strings.

8. /data/base/scripts/ — Optional deterministic Lua helpers
Only present if you allow scripting; if not, this dir is absent or empty.
Purpose:
• Provide safe helper functions for UI and worldgen only.
• No direct authority over simulation rules; only parameter expansions or UI customisations.
Example: base_helpers.lua
• Functions to compute tech tree layout for UI.
• Functions to classify prefabs into UI categories.
Constraints:
• Script API must be deterministic, no access to OS, wallclock, or random sources beyond engine’s deterministic RNG.
• Must not load other arbitrary Lua from outside /data.

9. Global constraints and prohibitions for /data/base
• All JSON must validate against /data/schema before shipping.
• No floats: encode rational numbers as numerators/denominators or scaled integers.
• No references to undefined IDs (prefab, tech, network, planet, item, etc.).
• No resource ID reuse: once published, an ID should not change semantics in breaking ways.
• No arbitrary relative paths: all references must be via IDs or manifest-listed paths.
• No code, except optional deterministic scripts in /scripts.

Next message will define the dev-spec for /data/dlc/ and its expected files and contracts.
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /data/dlc/.
/data/dlc holds first-party DLC packs that extend /data/base without changing engine code or core formats.
Each DLC is:
• Its own self-contained pack directory.
• Declared in /data/data_manifest.json.
• Versioned, schema-validated, and strictly deterministic.
• Loaded after base and possibly after other DLCs, using explicit dependencies + priorities.

0. Directory layout
Canonical structure:
/data/dlc/
├─ README.md
├─ interstellar/
│  ├─ manifest.json
│  ├─ prefabs/
│  ├─ tech/
│  ├─ networks/
│  ├─ worldgen/
│  ├─ economy/
│  ├─ locale/
│  └─ scripts/         # optional
├─ extras/
│  ├─ manifest.json
│  ├─ prefabs/
│  ├─ tech/
│  ├─ locale/
│  └─ ...
└─ wargames/
   ├─ manifest.json
   ├─ prefabs/
   ├─ tech/
   ├─ worldgen/
   ├─ economy/
   ├─ locale/
   └─ scripts/
Names (interstellar, extras, wargames) are examples; actual DLCs can differ.
Each DLC dir must be self-consistent and individually loadable on top of /data/base.

1. /data/dlc/README.md
Human-facing description of:
• DLC philosophy.
• Expected structure of each DLC directory.
• How load order and dependency resolution work (link back to /docs/spec).
• Rules about what DLCs may and may not change.
No technical authority; just orientation.

2. DLC root directory spec (e.g. /data/dlc/interstellar/)
Every DLC directory follows the same structure contract.
2.1 Required top-level files and dirs
Minimal:
/data/dlc/<dlc_name>/
├─ manifest.json       # required
├─ prefabs/            # required if DLC adds content
├─ tech/               # required if DLC adds techs
├─ locale/             # required
└─ (optional others)
If a DLC doesn’t add a category, it can omit that subdir, but manifest.json must not list it in content_index.

3. manifest.json — DLC pack descriptor
Each DLC’s manifest.json describes:
• DLC identity
• Version and compatibility
• Dependencies
• Content files (absolute list; engine must not scan directory)
Example:
{
  "id": "dlc_interstellar",
  "type": "dlc",
  "version": "1.0.0",
  "engine_min_version": "3.0.0",
  "engine_max_version": "3.x",
  "description": "Interstellar expansion: orbital and deep-space content.",
  "dependencies": ["base"],
  "load_priority": 10,
  "tags": ["official", "interstellar"],
  "content_index": {
    "prefabs": [
      "prefabs/prefabs_orbital_structures.json",
      "prefabs/prefabs_interstellar_ships.json",
      "prefabs/prefabs_space_infrastructure.json",
      "prefabs/prefabs_items_interstellar.json"
    ],
    "tech": [
      "tech/tech_tree_interstellar.json",
      "tech/tech_categories_interstellar.json"
    ],
    "networks": [
      "networks/power_interstellar.json",
      "networks/data_interstellar.json"
    ],
    "worldgen": [
      "worldgen/planets_interstellar.json",
      "worldgen/systems_interstellar.json",
      "worldgen/galaxies_interstellar.json",
      "worldgen/resources_interstellar.json"
    ],
    "economy": [
      "economy/commodities_interstellar.json",
      "economy/markets_interstellar.json",
      "economy/recipes_interstellar.json"
    ],
    "locale": [
      "locale/en-AU_interstellar.json",
      "locale/en-US_interstellar.json"
    ],
    "scripts": [
      "scripts/interstellar_helpers.lua"
    ]
  }
}
Engine rules:
• id must match data_manifest.json entry.
• type must be "dlc".
• dependencies must be a list of pack IDs (e.g. "base", "dlc_other").
• load_priority must be an integer; engine resolves collisions deterministically using (priority, id).
Prohibitions:
• No cyclic dependencies across DLC packs.
• No missing files in content_index.
• No implicit directory scans; everything must be declared in content_index.

4. /prefabs/ in DLC — extending the entity set
Each DLC’s /prefabs directory mirrors /data/base/prefabs semantics:
/data/dlc/interstellar/prefabs/
├─ prefabs_orbital_structures.json
├─ prefabs_interstellar_ships.json
├─ prefabs_space_infrastructure.json
└─ prefabs_items_interstellar.json
All prefab JSONs use the same schema (/data/schema/prefab_schema.json).
4.1 DLC-prefab requirements
• Prefab IDs must be globally unique across base + all DLCs present.
o Use namespacing: "orbital_station_core_interstellar", "ship_freighter_03", "item_helium3_canister".
• DLCs may override existing base prefabs only if explicitly allowed in spec:
o Recommended practice: no behavioural overrides, only additional variants.
• Prefabs may reference:
o New techs defined in this DLC’s tech directory.
o Existing base techs and networks.
o New network types defined in this DLC’s networks.
4.2 Example: orbital structure prefab in DLC
{
  "prefabs": [
    {
      "id": "orbital_station_core_t1",
      "category": "orbital_structure",
      "tags": ["orbital_only", "habitat"],
      "components": {
        "transform": {
          "size": [4, 4, 2],
          "anchor": "center"
        },
        "structure": {
          "hp": 10000,
          "fire_resistance": 50,
          "explosion_resistance": 40
        },
        "orbital_env": {
          "requires_life_support": 1,
          "max_crew": 20
        },
        "docking_ports": {
          "ports": [
            { "type": "ship_medium", "position": [2, 0, 1] },
            { "type": "tug_small", "position": [-2, 0, 1] }
          ]
        },
        "buildable": {
          "allowed_surface": ["orbital_shell_low_earth"],
          "required_tech": "tech_orbital_foundations",
          "construction_jobs": 50,
          "construction_time_ticks": 36000
        },
        "power_interface": {
          "mode": "consumer",
          "max_kw": 2000
        }
      }
    }
  ]
}
No DLC code here; only data.

5. /tech/ in DLC — extending the research tree
DLC tech files augment the base tech graph.
Typical layout:
/data/dlc/interstellar/tech/
├─ tech_tree_interstellar.json
└─ tech_categories_interstellar.json
5.1 tech_tree_interstellar.json
• Adds new technologies with IDs that are distinct from base ones.
• May depend on base techs (prerequisites).
• May unlock both base and DLC prefabs/recipes.
Rules:
• The combined tech graph (base + all DLCs) must remain a DAG.
• Costs, times, and dependencies encoded as integers.
• No DLC is allowed to “remove” a base tech; at most it can:
o Add new techs whose unlocks supersede base content.
o Add new upgrade paths.
Example:
{
  "technologies": [
    {
      "id": "tech_orbital_foundations",
      "name_key": "tech.orbital_foundations.name",
      "desc_key": "tech.orbital_foundations.desc",
      "tier": 4,
      "category": "orbital",
      "prerequisites": ["tech_rocketry_advanced"],
      "cost": {
        "science_pack_adv": 500,
        "science_pack_orbital": 200
      },
      "time_per_unit_ticks": 7200,
      "unlocks_prefabs": [
        "orbital_station_core_t1",
        "orbital_dock_tug_small"
      ],
      "unlocks_recipes": [
        "recipe_station_frame_t1"
      ]
    }
  ]
}
5.2 tech_categories_interstellar.json
Adds categories only:
• orbital, deep_space, exotic_energy, etc.
No category removal from base.

6. /networks/ in DLC — new network classes or extensions
Some DLCs need specialised networks:
• High-power space grids.
• Inter-orbital data links.
• Exotic fluids (cryogenic propellants).
• Ship docking “lanes”.
Example:
/data/dlc/interstellar/networks/
├─ power_interstellar.json
├─ data_interstellar.json
└─ fluids_interstellar.json
Each file must follow the same schemas as /data/base/networks/*.json.
6.1 Overlays vs new definitions
There are two patterns:
1. Additive (recommended):
o Add new IDs: power_orbital_bus_120kV, data_laser_link_orbit_ground.
o No changes to base network element semantics.
2. Override (if spec explicitly supports):
o Provide a record with same id as a base network, and a well-defined override rule in engine:
• e.g. DLC may increase max allowed cable length for deep-space behaviour.
o Must be deterministic: engine must choose which record wins based on load order/priority.
Prohibitions:
• DLCs must not silently change core safety limits if that breaks base maps.
• If behaviour changes, marking in versioned patch notes and spec is required.

7. /worldgen/ in DLC — new planets/systems/galaxies/biomes/resources
DLCs like “interstellar” define additional:
• Planet templates (e.g. Mars, Titan-like, super-Earths).
• Systems (binary stars, special orbital configurations).
• Galaxies (other than Milky Way).
• Biome sets and unique resources.
Example layout:
/data/dlc/interstellar/worldgen/
├─ planets_interstellar.json
├─ systems_interstellar.json
├─ galaxies_interstellar.json
├─ biomes_interstellar.json
└─ resources_interstellar.json
These files follow the same schemas as base worldgen, but:
• Must not alter base IDs.
• Can reference new surface IDs, new biome IDs, new resource IDs.
• Can be gated behind DLC-specific settings in world creation UI.

8. /economy/ in DLC — economic extensions
DLCs may add:
• New commodities (e.g. helium-3, exotic alloys, data tokens).
• New markets (orbital trade, interstellar shipping).
• New recipes (ship building, station expansion).
Example:
/data/dlc/interstellar/economy/
├─ commodities_interstellar.json
├─ markets_interstellar.json
└─ recipes_interstellar.json
Rules:
• Commodity IDs must be unique; do not redefine base IDs.
• Recipe IDs must be unique.
• Markets may bridge base and DLC commodities if allowed by design.

9. /locale/ in DLC — DLC-specific strings
Each DLC provides its own locale files:
/data/dlc/interstellar/locale/
├─ en-AU_interstellar.json
└─ en-US_interstellar.json
Structure:
• Same schema as base locale.
• Only DLC-specific keys.
• Must not redefine base keys.
• May define descriptions for:
o New prefabs
o New techs
o New network types
o New planets/systems/galaxies
o New commodities/markets/recipes
The engine merges locale maps in deterministic order (base then DLC).

10. /scripts/ in DLC — optional deterministic scripts
If deterministic scripting is enabled, DLCs may have:
/data/dlc/interstellar/scripts/
└─ interstellar_helpers.lua
Allowed uses:
• Procedural worldgen tweaks specific to DLC.
• UI helper functions to lay out new tech branches.
• Presentation logic for DLC-only UI panels.
Prohibitions:
• No direct access to OS, time, random.
• No modification of core sim invariants.
• Must use the same restricted API as /data/base/scripts.
If scripting is disabled for your engine, this directory is absent or unused.

11. DLC interaction and determinism rules
1. Load order is explicit
Determined by data_manifest.json → packs[*].priority → id tiebreaker.
2. No hidden overrides
Any override of base resources must be predictable and described in docs; otherwise, DLCs should use new IDs only.
3. Combined content graph is deterministic
Prefabs, techs, networks, worldgen, economy; all integer-based, no random semantics.
4. Schema alignment
DLC data must pass the same schemas as base data. No DLC-specific JSON shape.
5. Savefile integrity
Savefiles record active DLC IDs and versions. Loading requires matching DLC sets; DLC removal or addition after save is only allowed under explicit migration paths.

12. Prohibitions across /data/dlc
• No engine C/C++ or binaries.
• No arbitrary scripting outside /scripts.
• No altered schemas living inside DLC; all schemas stay under /data/schema.
• No environment-conditional data (“if Windows, else Linux”); DLC content must be universal.

Next message will define the dev-spec for /data/packs/ (graphics/sound/music packs) and their file-level contracts.
You said:
Next
ChatGPT said:
Thought for 9s
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /data/packs/.
/data/packs provides first-party graphics, sound, and music packs, loaded like OpenTTD-style asset packs.
They change how the game looks and sounds, but never how it simulates.
Each pack is:
• Self-contained.
• Versioned.
• Deterministic (no procedural randomness at runtime).
• Optional: base game must run with at least one default pack.

0. Directory layout
Canonical structure:
/data/packs/
├─ README.md
├─ packs_manifest.json          # index of known packs
├─ base_gfx/
│  ├─ manifest.json
│  ├─ gfx/
│  │  ├─ tiles/
│  │  ├─ sprites/
│  │  ├─ ui/
│  │  └─ vector/
│  ├─ models/
│  ├─ shaders/
│  ├─ fonts/
│  └─ metadata/
├─ base_audio/
│  ├─ manifest.json
│  ├─ sfx/
│  ├─ music/
│  └─ metadata/
└─ minimal_vector/
   ├─ manifest.json
   ├─ gfx/
   └─ fonts/
Pack root names (base_gfx, base_audio, minimal_vector) are examples; you’ll pick your own.

1. /data/packs/README.md
Human-facing explanation:
• What a “pack” is.
• Difference between data packs (/data/base, /data/dlc) and asset packs (/data/packs).
• How packs are selected at runtime (launcher, in-game options).
• Determinism constraints: packs must not alter simulation behaviour.
No executable content, no authoritative spec here.

2. packs_manifest.json — global asset pack index
This file enumerates all ship-ready asset packs that ship with the game.
Example:
{
  "packs": [
    {
      "id": "base_gfx",
      "type": "graphics",
      "priority": 10,
      "path": "base_gfx",
      "default": true
    },
    {
      "id": "base_audio",
      "type": "audio",
      "priority": 10,
      "path": "base_audio",
      "default": true
    },
    {
      "id": "minimal_vector",
      "type": "graphics",
      "priority": 5,
      "path": "minimal_vector",
      "default": false
    }
  ]
}
Engine obligations:
• Always load at least one graphics pack and one audio pack.
• default: true indicates what to use when user has not selected one.
• Packs with higher priority override lower ones for the same resource ID, if both active.
• Paths are relative to /data/packs.
Prohibitions:
• No wildcard directories; engine must not “discover” packs by scanning the filesystem in shipping builds.
• No executable code referenced here.

3. Generic pack directory structure
Every pack under /data/packs/<pack_id>/ has:
/data/packs/<pack_id>/
├─ manifest.json      # required
├─ gfx/               # required for graphics packs
├─ sfx/               # required for audio packs (if audio)
├─ music/             # optional
├─ models/            # optional, renderer-dependent
├─ shaders/           # optional, renderer-dependent
├─ fonts/             # optional but recommended
└─ metadata/          # optional (palettes, style guides, atlases)
Not all subdirs appear for all packs; the pack’s manifest.json determines what it provides.

4. Pack manifest.json — core pack descriptor
Example for a graphics pack:
{
  "id": "base_gfx",
  "kind": "graphics",
  "version": "1.0.0",
  "engine_min_version": "3.0.0",
  "engine_max_version": "3.x",
  "description": "Default Dominium tile, sprite, and UI graphics.",
  "author": "Dominium Team",
  "license": "Proprietary",
  "provides": {
    "tiles": "gfx/tiles/tiles.json",
    "sprites": "gfx/sprites/sprites.json",
    "ui": "gfx/ui/ui.json",
    "vector_sets": "gfx/vector/vector_sets.json",
    "fonts": "fonts/fonts.json",
    "models": "models/models.json",
    "shaders": "shaders/shaders.json"
  },
  "overrides": {
    "packs": [],
    "base_assets": true
  },
  "tags": [
    "official",
    "default"
  ]
}
Example for an audio pack:
{
  "id": "base_audio",
  "kind": "audio",
  "version": "1.0.0",
  "engine_min_version": "3.0.0",
  "engine_max_version": "3.x",
  "description": "Default sound effects and music.",
  "author": "Dominium Team",
  "license": "Proprietary",
  "provides": {
    "sfx": "sfx/sfx.json",
    "music": "music/music.json"
  },
  "overrides": {
    "packs": [],
    "base_assets": true
  },
  "tags": [
    "official",
    "default"
  ]
}
Engine behaviour:
• Uses kind to enforce compatibility (graphics vs audio vs mixed; you can allow mixed but must document rules).
• Uses provides keys to locate index JSONs that define actual resources.
• Uses overrides to decide how this pack interacts with others:
o overrides.base_assets: true means “if another pack isn’t active, I cover base visuals/sfx”.
o overrides.packs: [] can list other pack IDs whose assets this pack deliberately masks.
Prohibitions:
• No references to /engine, /game, /mods paths.
• No scripting or code references.
• No behaviour knobs that change simulation (only visual/audio representation).

5. Graphics packs — /gfx/, /models/, /shaders/, /fonts/
5.1 Tiles — /gfx/tiles/
Tiles define how the world grid is visually represented.
/data/packs/base_gfx/gfx/tiles/
├─ tiles.json
├─ ground/
│  ├─ grass_01.png
│  ├─ dirt_01.png
│  └─ ...
├─ buildings/
│  ├─ foundation_basic.png
│  └─ ...
└─ overlays/
   ├─ selection_box.png
   └─ ...
tiles.json maps logical resource IDs (defined by /data/base) to image paths and parameters:
{
  "tile_sets": [
    {
      "id": "ground_grass_default",
      "resource_id": "tile.ground.grass",
      "image": "ground/grass_01.png",
      "size_px": [32, 32],
      "scale": {
        "pixels_per_meter": 32
      },
      "variants": [
        { "id": "v1", "image": "ground/grass_01.png" },
        { "id": "v2", "image": "ground/grass_02.png" }
      ],
      "auto_tile": {
        "mode": "simple_4way"
      }
    }
  ]
}
Determinism rule:
• Any variant selection must be derived deterministically (e.g. tile coordinates hashed with world seed) — no random picks at draw time.
5.2 Sprites — /gfx/sprites/
Sprites for entities, vehicles, workers, etc.:
/data/packs/base_gfx/gfx/sprites/
├─ sprites.json
├─ vehicles/
├─ workers/
└─ fx/
sprites.json:
{
  "sprites": [
    {
      "id": "vehicle_train_small_diesel",
      "resource_id": "sprite.vehicle.train_small_diesel",
      "image": "vehicles/train_small_diesel_strip.png",
      "frame_size_px": [64, 32],
      "directions": 8,
      "frames_per_direction": 4,
      "render_layer": "vehicles",
      "offset_px": [0, -8]
    }
  ]
}
The engine bridges prefab IDs to sprite resource IDs via a mapping table (likely in /engine/ui or /game/client). This pack only defines the sprite parameters.
5.3 UI graphics — /gfx/ui/
UI skinning and icons:
/data/packs/base_gfx/gfx/ui/
├─ ui.json
├─ windows/
├─ icons/
└─ widgets/
ui.json:
• Defines base “theme” (colors, border images, margins).
• Maps logical UI widget types to textures:
o e.g. "ui.window.background" → windows/background.png
o "ui.icon.rail" → icons/rail.png
Non-simulation-critical.
5.4 Vector sets — /gfx/vector/
Resources for vector rendering mode:
/data/packs/base_gfx/gfx/vector/
└─ vector_sets.json
Contains symbolic definitions: shapes, stroke widths, layers.
Example:
{
  "vector_sets": [
    {
      "id": "rail_standard",
      "resource_id": "vector.rail.standard",
      "primitives": [
        { "type": "line", "from": [0, 0], "to": [1, 0], "width": 0.1, "layer": "rails" },
        { "type": "rect", "pos": [-0.5, -0.1], "size": [1.0, 0.2], "layer": "sleepers" }
      ]
    }
  ]
}
Engine-side rasterisation or scaled vector rendering uses integer/fixed-point; this file just defines the primitives.
5.5 Models — /models/
3D model assets for 3D view modes:
/data/packs/base_gfx/models/
├─ models.json
├─ buildings/
├─ vehicles/
└─ misc/
models.json maps logical resource IDs to model files and LODs:
{
  "models": [
    {
      "id": "building_factory_small",
      "resource_id": "model.building.factory_small",
      "mesh": "buildings/factory_small.mesh",
      "lods": [
        { "mesh": "buildings/factory_small_lod1.mesh", "screen_height_px": 80 },
        { "mesh": "buildings/factory_small_lod2.mesh", "screen_height_px": 40 }
      ]
    }
  ]
}
Mesh format is engine-defined (binary or text).
No physics data here; collision is defined in sim data.
5.6 Shaders — /shaders/
Renderer-specific shader definitions:
/data/packs/base_gfx/shaders/
├─ shaders.json
├─ gl2/
│  ├─ terrain.vert
│  ├─ terrain.frag
│  └─ ...
└─ dx9/
   ├─ terrain.hlsl
   └─ ...
shaders.json:
• Lists shader programs by logical ID.
• Associates each with backend-specific source files.
Example:
{
  "shaders": [
    {
      "id": "terrain_basic",
      "resource_id": "shader.terrain.basic",
      "backends": {
        "gl2": { "vertex": "gl2/terrain.vert", "fragment": "gl2/terrain.frag" },
        "dx9": { "file": "dx9/terrain.hlsl", "entry_vs": "VSMain", "entry_ps": "PSMain" }
      }
    }
  ]
}
Determinism note:
• Shader differences must not alter simulation results, only visuals.
• Backends may render differently but must not change logic.
5.7 Fonts — /fonts/
Fonts for UI and possibly vector overlays:
/data/packs/base_gfx/fonts/
├─ fonts.json
├─ DejaVuSansM-NF.ttf
└─ ...
fonts.json:
{
  "fonts": [
    {
      "id": "ui_primary",
      "file": "DejaVuSansM-NF.ttf",
      "size_px_default": 14,
      "ranges": [
        ["U+0020", "U+007F"],
        ["U+00A0", "U+00FF"]
      ]
    }
  ]
}
Engine:
• Pre-bakes glyph atlases deterministically (using fixed rasterization settings across builds).
• Avoid font-specific behaviour in the sim.

6. Audio packs — /sfx/, /music/
6.1 Sound effects — /sfx/
/data/packs/base_audio/sfx/
├─ sfx.json
├─ ui/
├─ vehicles/
├─ environment/
└─ machines/
sfx.json maps logical SFX IDs to audio files:
{
  "sfx": [
    {
      "id": "ui_click",
      "resource_id": "sfx.ui.click",
      "file": "ui/click_01.ogg",
      "volume_db": -6,
      "pitch_cents": 0
    },
    {
      "id": "train_start",
      "resource_id": "sfx.vehicle.train_start",
      "file": "vehicles/train_start.ogg",
      "volume_db": 0,
      "pitch_cents": 0
    }
  ]
}
The simulation emits symbolic events (event_train_start) which the audio system maps to SFX IDs; packs only provide audio for those IDs.
6.2 Music — /music/
/data/packs/base_audio/music/
├─ music.json
├─ tracks/
│  ├─ track_01.ogg
│  ├─ track_02.ogg
│  └─ ...
└─ playlists/
   ├─ calm.json
   └─ intense.json
music.json:
{
  "tracks": [
    {
      "id": "track_main_theme",
      "file": "tracks/main_theme.ogg",
      "length_seconds": 240,
      "tags": ["menu", "calm"]
    }
  ],
  "playlists": [
    {
      "id": "playlist_default",
      "tracks": [
        "track_main_theme",
        "track_exploration_01"
      ]
    }
  ]
}
Music selection logic lives in /engine/audio / /game/client.
Packs only define what tracks exist and how they group.

7. /metadata/ — atlases, palettes, style guides
Optional, but useful:
/data/packs/base_gfx/metadata/
├─ atlas_terrain.json
├─ atlas_ui.json
└─ palettes.json
Examples:
• Texture atlas definitions (for batching).
• Color palettes for palette-based modes.
• Layering hints (z-order groups).
These files are read by rendering backend and tooling, not the sim.

8. Determinism and prohibitions for /data/packs
Determinism constraints:
• No asset pack may introduce or influence simulation logic; only visual/audio representation.
• Any randomness in visuals (e.g. sprite variant choice, ambient SFX) must be:
o Derived from deterministic seeds (coordinates, entity IDs, ticks).
o Implemented in /engine/render or /engine/audio, not in pack data.
Prohibited:
• Scripting in packs (no .lua, .js, etc.) — scripting belongs only under /data/base/scripts or /data/dlc/*/scripts with strict API.
• Platform-specific conditionals inside pack data (“if Windows use this file, if Linux use that”).
• Embedding engine or game binaries.
• Using asset packs to sneak in extra game logic (e.g. encoding rules in filenames).

9. Interactions with /data/base and /data/dlc
• Logical resource IDs (like tile.ground.grass, sprite.vehicle.train_small_diesel, sfx.ui.click) are defined by data packs (/data/base, /data/dlc), not by /data/packs.
• Asset packs bind those logical IDs to actual assets.
• Multiple packs can provide assets for the same logical ID:
o Selection is determined by active pack set and their priorities.
o Engine must resolve collisions deterministically (priority, then pack id).

Next message will define the dev-spec for /data/templates/ (sample universes, example saves, demo worlds, etc.).
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /data/templates/.
/data/templates provides shipped example content:
• Example universes and maps.
• Starter savegames and demo worlds.
• Scenario definitions and challenge modes.
• Blueprint libraries and build templates.
It is not authoritative for engine behaviour. It is consumed by the engine and /tools to create or load worlds in a known configuration.

0. Directory layout
Canonical structure:
/data/templates/
├─ README.md
├─ templates_manifest.json
├─ worlds/
│  ├─ starter_worlds.json
│  ├─ demo_worlds.json
│  └─ *.dom               # optional pre-baked save files (if shipped)
├─ scenarios/
│  ├─ scenarios_manifest.json
│  ├─ campaign/
│  │  ├─ campaign_01.json
│  │  └─ ...
│  └─ challenges/
│     ├─ challenge_rail_mega_hub.json
│     └─ ...
├─ blueprints/
│  ├─ blueprints_manifest.json
│  ├─ factory/
│  ├─ logistics/
│  └─ utilities/
└─ presets/
   ├─ worldgen_presets.json
   ├─ difficulty_presets.json
   └─ ui_presets.json
Subdirs can be extended, but these are the baseline.

1. /data/templates/README.md
Human-facing documentation:
• Explains what templates are.
• Explains difference between:
o Full savefiles (*.dom under /worlds).
o Scenario descriptors (/scenarios JSON).
o Blueprint libraries (/blueprints).
o Preset configs (/presets).
• Explains determinism constraints:
o Templates must be fully definable in terms of engine spec.
o Any “randomness” must be seeded and reproducible.
No technical authority; spec lives elsewhere.

2. templates_manifest.json — global template index
Defines the set of officially shipped templates and how they appear in UI.
Example:
{
  "world_sets": [
    {
      "id": "starter_worlds",
      "file": "worlds/starter_worlds.json",
      "default": true
    },
    {
      "id": "demo_worlds",
      "file": "worlds/demo_worlds.json",
      "default": false
    }
  ],
  "scenario_sets": [
    {
      "id": "campaign",
      "file": "scenarios/scenarios_manifest.json"
    }
  ],
  "blueprint_sets": [
    {
      "id": "core_blueprints",
      "file": "blueprints/blueprints_manifest.json"
    }
  ],
  "preset_sets": [
    {
      "id": "worldgen_presets",
      "file": "presets/worldgen_presets.json"
    },
    {
      "id": "difficulty_presets",
      "file": "presets/difficulty_presets.json"
    }
  ]
}
Engine obligations:
• Use this file as the only entry point for template discovery.
• No arbitrary directory scanning in shipping builds.
• All referenced files must exist; invalid references are hard errors in dev mode.
Prohibitions:
• No runtime-generated paths.
• No environment-dependent templates.

3. /worlds/ — predefined worlds and starter saves
This directory provides:
• World descriptors that define initial world/universe configurations.
• Optional pre-baked savefiles for demo purposes.
3.1 starter_worlds.json
Defines worlds exposable in “New Game → Starter Worlds”.
Example:
{
  "worlds": [
    {
      "id": "starter_flat_valley",
      "name_key": "starter.flat_valley.name",
      "desc_key": "starter.flat_valley.desc",
      "worldgen_preset": "worldgen_flat_easy",
      "seed": 123456789,
      "starting_property_template": "property_basic_industry",
      "difficulty_preset": "difficulty_normal",
      "dlc_required": [],
      "universe_layout": {
        "universe_id": "local_universe",
        "galaxy": "milky_way",
        "system": "sol",
        "planet": "earth",
        "surface": "earth_main_surface"
      }
    },
    {
      "id": "starter_mountainous",
      "name_key": "starter.mountainous.name",
      "desc_key": "starter.mountainous.desc",
      "worldgen_preset": "worldgen_mountain_hard",
      "seed": 987654321,
      "starting_property_template": "property_rail_mining",
      "difficulty_preset": "difficulty_hard",
      "dlc_required": [],
      "universe_layout": {
        "universe_id": "local_universe",
        "galaxy": "milky_way",
        "system": "sol",
        "planet": "earth",
        "surface": "earth_main_surface"
      }
    }
  ]
}
Engine usage:
• When a player selects starter_flat_valley, engine:
o Loads worldgen_preset from /data/templates/presets/worldgen_presets.json.
o Uses seed in deterministic worldgen.
o Spawns initial property from starting_property_template (see blueprints).
o Applies difficulty multipliers from /presets/difficulty_presets.json.
All of this is deterministic.
3.2 demo_worlds.json
Defines worlds used for:
• Tutorials.
• Marketing/demos.
• Benchmark replays.
These may reference pre-baked savefiles:
{
  "worlds": [
    {
      "id": "demo_large_factory",
      "name_key": "demo.large_factory.name",
      "desc_key": "demo.large_factory.desc",
      "savefile": "worlds/demo_large_factory.dom",
      "dlc_required": [],
      "read_only": true
    }
  ]
}
Rules:
• savefile must be a .dom created by the engine’s official save process.
• read_only: true means:
o UI treats this as a demo; overwriting is discouraged or forbidden by default.

4. /scenarios/ — campaign and challenge descriptors
Scenario descriptors layer constraints and goals on top of the base sim.
4.1 scenarios_manifest.json
Index into scenarios:
{
  "campaign": [
    "campaign/campaign_01.json",
    "campaign/campaign_02.json"
  ],
  "challenges": [
    "challenges/challenge_rail_mega_hub.json",
    "challenges/challenge_power_grid_balancing.json"
  ]
}
Engine:
• Uses this to populate scenario menus.
• Loads scenario descriptors on demand.
4.2 Scenario descriptor schema
Example campaign scenario:
{
  "id": "campaign_01_bootstrap",
  "name_key": "campaign.01.name",
  "desc_key": "campaign.01.desc",
  "world_template": "starter_flat_valley",
  "starting_tick": 0,
  "starting_resources": {
    "money": 200000,
    "items": {
      "iron_plate": 5000,
      "copper_plate": 3000
    }
  },
  "constraints": {
    "research_disabled": false,
    "combat_disabled": true,
    "time_limit_ticks": 0,
    "building_blacklist": [
      "orbital_station_core_t1"
    ]
  },
  "victory_conditions": [
    {
      "type": "produce_item",
      "item_id": "steel_plate",
      "amount": 100000,
      "within_ticks": 0
    }
  ],
  "failure_conditions": [
    {
      "type": "bankrupt",
      "threshold": 0
    }
  ],
  "dlc_required": []
}
Scenario engine behaviour:
• Uses world_template from /worlds.
• Applies scenario-specific starting state and constraints at tick 0.
• Uses only deterministic conditions (no random objectives).
Challenge example:
{
  "id": "challenge_rail_mega_hub",
  "name_key": "challenge.rail_mega_hub.name",
  "desc_key": "challenge.rail_mega_hub.desc",
  "world_template": "starter_flat_valley",
  "constraints": {
    "fixed_seed": true,
    "max_trains": 50,
    "max_pollution": 500000,
    "allowed_buildings": [
      "rail_station_t1",
      "rail_signal_basic",
      "train_small_diesel"
    ]
  },
  "victory_conditions": [
    {
      "type": "throughput",
      "metric": "items_per_second",
      "item_id": "iron_ore",
      "threshold": 1000,
      "time_window_ticks": 36000
    }
  ],
  "failure_conditions": [
    {
      "type": "gridlock",
      "metric": "stalled_trains",
      "threshold": 10,
      "duration_ticks": 1200
    }
  ],
  "dlc_required": []
}
Constraints and conditions are declarative.
No imperative scripting here; all logic in /engine/sim and /game/server.

5. /blueprints/ — built-in blueprint library
Blueprints are deterministic construction templates for in-game structures.
Layout:
/data/templates/blueprints/
├─ blueprints_manifest.json
├─ factory/
│  ├─ basic_smelter_line.json
│  └─ ...
├─ logistics/
│  ├─ main_bus_4_lane.json
│  └─ ...
└─ utilities/
   ├─ substation_cluster.json
   └─ ...
5.1 blueprints_manifest.json
Index for blueprint libraries:
{
  "categories": [
    {
      "id": "factory",
      "name_key": "blueprints.category.factory",
      "files": [
        "factory/basic_smelter_line.json",
        "factory/advanced_smelter_block.json"
      ]
    },
    {
      "id": "logistics",
      "name_key": "blueprints.category.logistics",
      "files": [
        "logistics/main_bus_4_lane.json"
      ]
    }
  ]
}
5.2 Blueprint descriptor schema
Blueprints essentially pre-pack a set of entities, prefabs, and network connections in local coordinates.
Example:
{
  "id": "basic_smelter_line",
  "name_key": "blueprint.basic_smelter_line.name",
  "desc_key": "blueprint.basic_smelter_line.desc",
  "size_tiles": [32, 8],
  "anchor": [0, 0],
  "dlc_required": [],
  "entities": [
    {
      "prefab_id": "smelter_basic",
      "local_pos": [4, 2, 0],
      "rotation": 0
    },
    {
      "prefab_id": "smelter_basic",
      "local_pos": [8, 2, 0],
      "rotation": 0
    }
  ],
  "networks": {
    "power": [
      { "type": "pole_small", "local_pos": [2, 1, 0] },
      { "type": "pole_small", "local_pos": [10, 1, 0] }
    ],
    "belts": [
      { "type": "belt_basic", "path": [[0, 4, 0], [31, 4, 0]] }
    ]
  },
  "metadata": {
    "intended_throughput": {
      "item_id": "iron_plate",
      "items_per_second": 30
    }
  }
}
Engine:
• Applies blueprint by converting local_pos to world grid coordinates at placement time.
• Uses prefab_id defined under /data/base or /data/dlc.
• No logic here; purely structural.

6. /presets/ — worldgen, difficulty, UI presets
6.1 worldgen_presets.json
Defines named world generation presets:
{
  "presets": [
    {
      "id": "worldgen_flat_easy",
      "name_key": "preset.worldgen.flat_easy.name",
      "desc_key": "preset.worldgen.flat_easy.desc",
      "world_size": {
        "surface": "earth_main_surface",
        "width_chunks": 32,
        "height_chunks": 32
      },
      "terrain_params": {
        "height_noise_scale": 0.5,
        "mountain_density": 0.1,
        "water_level_m": 0,
        "river_density": 0.2
      },
      "resource_params": {
        "ore_richness": 1.5,
        "ore_density": 1.2,
        "oil_density": 1.0
      },
      "climate_params": {
        "temperature_mean_c": 20,
        "rainfall_factor": 1.0
      }
    }
  ]
}
All knobs must map to deterministic worldgen functions in /engine/sim.
6.2 difficulty_presets.json
Defines global difficulty multipliers:
{
  "presets": [
    {
      "id": "difficulty_normal",
      "name_key": "preset.difficulty.normal.name",
      "desc_key": "preset.difficulty.normal.desc",
      "modifiers": {
        "build_cost_multiplier": 1.0,
        "research_speed_multiplier": 1.0,
        "maintenance_multiplier": 1.0,
        "disaster_frequency": 0.0
      }
    },
    {
      "id": "difficulty_hard",
      "name_key": "preset.difficulty.hard.name",
      "desc_key": "preset.difficulty.hard.desc",
      "modifiers": {
        "build_cost_multiplier": 1.5,
        "research_speed_multiplier": 0.75,
        "maintenance_multiplier": 1.5,
        "disaster_frequency": 0.2
      }
    }
  ]
}
Values must be fixed-point and deterministic.
No random difficulty adjustments.
6.3 ui_presets.json (optional)
Defines UI layout presets:
{
  "presets": [
    {
      "id": "ui_minimal",
      "name_key": "preset.ui.minimal.name",
      "panels": {
        "main_toolbar": { "visible": true, "position": "top" },
        "minimap": { "visible": false },
        "event_log": { "visible": true, "position": "bottom" }
      }
    }
  ]
}
Only client-side; no influence on simulation.

7. Determinism and versioning rules for /data/templates
1. No floats in persistent templates
Values should be representable as integers or fixed-point when loaded into sim.
2. Seeds are explicit
Any “random” worldgen must use explicit seeds from templates, not OS RNG.
3. Templates are versioned indirectly
Actual binary formats are defined by engine spec; templates reference:
o engine_min_version
o engine_max_version
if needed (you can add version fields later).
4. Savefile templates remain engine-encoded
.dom files must stay strictly in engine save format; templates must not define their own.

8. Prohibitions across /data/templates
• No engine C/C++ files.
• No scripting. Scenarios, presets, and templates are declarative JSON only.
• No runtime-dependent paths (like C:\Users\... or $HOME).
• No referencing mods or DLC that are not declared in dlc_required.

Next message will define the dev-spec for /mods/ (third-party and local mods: structure, manifests, allowed capabilities, and prohibitions).
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /mods/.
/mods is the only place third-party and local gameplay/content modifications live.
Engine, base game, DLC, and first-party packs must never live here.

0. Top-level layout
Canonical structure:
/mods/
├─ README.md
├─ mods_manifest.json        # global index of installed mods (optional but recommended)
├─ local/                    # user-installed mods (manual or via in-game UI)
│  └─ <mod_id>/
│     ├─ mod.json
│     ├─ data/
│     ├─ scripts/
│     ├─ gfx/
│     ├─ audio/
│     ├─ docs/
│     └─ tests/
├─ workshop/                 # content from external distribution (e.g. Steam Workshop)
│  └─ <mod_id>/
│     ├─ mod.json
│     └─ ...
└─ disabled/                 # physically present, but never auto-loaded
   └─ <mod_id>/
      ├─ mod.json
      └─ ...
Engine loads mods only from /mods/local and /mods/workshop by default, and never from /disabled.

1. /mods/README.md
Human doc:
• Explains mod folder layout.
• Explains that mod.json is the canonical manifest.
• States determinism and safety constraints:
o Mods cannot break deterministic kernel.
o Mods cannot use wallclock, OS RNG, networking directly.
o Mods cannot ship native binaries that are auto-executed.
Not authoritative; actual rules live in engine spec and in this contract.

2. mods_manifest.json — optional global installed-mod index
This is a convenience index for launcher/UI; engine must treat it as advisory, not authoritative.
Example:
{
  "mods": [
    {
      "id": "my_railpack",
      "path": "local/my_railpack",
      "source": "local",
      "enabled": true,
      "order": 100
    },
    {
      "id": "huge_industry_overhaul",
      "path": "workshop/1234567890",
      "source": "workshop",
      "enabled": false,
      "order": 200
    }
  ]
}
Rules:
• id must match mod.json.id inside the mod dir.
• path is relative to /mods/.
• enabled is a convenience flag for UI; final active set is decided at world load (world’s mod list wins).
• order is a soft ordering hint; engine still resolves hard dependencies and conflicts by rules in mod.json.
Engine must not rely solely on this file; if missing/invalid, engine falls back to scanning /mods/local and /mods/workshop for mod.json.

3. Single mod directory layout
Canonical, for <mod_root> = /mods/local/<mod_id> or /mods/workshop/<mod_id>:
<mod_root>/
├─ mod.json             # REQUIRED
├─ data/                # game data additions/overrides (entities, recipes, tech, etc.)
│  ├─ entities/
│  ├─ recipes/
│  ├─ tech/
│  └─ ...
├─ scripts/             # OPTIONAL, sandboxed logic (Lua or similar)
│  ├─ init.lua
│  ├─ control.lua
│  └─ modules/*.lua
├─ gfx/                 # OPTIONAL, mod-specific graphics (sprites, tiles, icons)
│  ├─ tiles/
│  ├─ sprites/
│  └─ ui/
├─ audio/               # OPTIONAL, mod-specific sfx/music
│  ├─ sfx/
│  └─ music/
├─ locale/              # OPTIONAL, localization files
│  ├─ en/
│  ├─ de/
│  └─ ...
├─ docs/                # OPTIONAL, readme, license, design notes
└─ tests/               # OPTIONAL, mod-level tests, replay scripts, etc.
Prohibitions:
• No /engine, /game, /build, /packaging, /third_party inside a mod.
• No .dll, .so, .dylib, .exe etc. shipped as something the engine auto-loads.

4. mod.json — canonical mod manifest
This is mandatory and the single source of truth for:
• Identity
• Versioning
• Dependencies
• Capabilities
• Determinism mode
Example:
{
  "id": "my_railpack",
  "name": "My Rail Pack",
  "description": "Adds new rail types, trains, and signals for Dominium.",
  "version": "0.3.1",
  "engine_version_min": "3.0.0",
  "engine_version_max": "3.x",
  "author": "Railfan",
  "license": "MIT",
  "tags": [
    "gameplay",
    "transport",
    "rails"
  ],
  "dependencies": [
    {
      "id": "base",
      "version_min": "3.0.0"
    }
  ],
  "optional_dependencies": [
    {
      "id": "official_interstellar",
      "version_min": "1.0.0"
    }
  ],
  "conflicts": [
    {
      "id": "other_rail_pack"
    }
  ],
  "load_order": {
    "after": ["base"],
    "before": []
  },
  "determinism": {
    "affects_simulation": true,
    "network_safe": true,
    "pure_ui_mod": false
  },
  "capabilities": {
    "data": true,
    "scripts": true,
    "gfx": true,
    "audio": false
  }
}
Requirements:
• id must be unique across all mods + base/dlc IDs.
• version must follow a defined scheme (semantic or your spec, but consistent).
• dependencies must include "base" for nearly all gameplay mods.
• determinism.affects_simulation is explicit:
o If false, mod must not introduce or modify simulation entities/rules.
o If true, mod must obey deterministic kernel rules by construction.
Engine-side:
• Validates mod manifests before load.
• Computes mod load order by:
o Resolving dependencies.
o Applying load_order.after/before.
o Breaking ties deterministically by id.
No dynamic or random ordering.

5. /data/ within a mod — data extensions
<mod_root>/data mirrors parts of /data/base and /data/dlc, but limited and sandboxed.
Allowed categories (examples):
data/
├─ entities/         # new building, machine, vehicle, item definitions
│  ├─ entities.json
│  └─ *.json
├─ recipes/
│  ├─ recipes.json
│  └─ *.json
├─ tech/
│  ├─ tech_tree.json
│  └─ *.json
├─ signals/
├─ networks/
└─ balance/
The exact JSON schemas are governed by your core spec, but rules:
1. Namespacing
Every mod-defined resource ID must be namespaced with the mod ID or a unique prefix. For example:
o my_railpack.rail_type.2ft_heavy
o my_railpack.vehicle.train_light_shunter
Engine enforces uniqueness of IDs across all loaded mods.
2. No floats
Data that eventually reaches simulation must be representable as integers or fixed-point. JSON can use decimal syntax if the loader converts deterministically to fixed-point, but avoid ambiguous floats.
3. No imperative logic
Mod /data is declarative: definitions, tuning, structures. Logic is in /engine/sim and optional /scripts via a constrained API.
4. Overrides
Mods may override existing definitions only if explicitly allowed by engine policy (e.g., per-field override, or “replace entire definition” flagged in data). Overrides must be declared, not accidental.
Example override construct:
{
  "override": true,
  "target_id": "base.rail_type.standard",
  "fields": {
    "max_speed_kph": 160
  }
}
Engine must reject silent overrides lacking override: true.
Prohibitions:
• No references to raw file paths outside the mod root.
• No runtime introspection of engine internals via data.

6. /scripts/ within a mod — controlled scripting
<mod_root>/scripts is for scripting (Lua or similar) under a strict API.
Canonical files:
scripts/
├─ init.lua      # optional: setup, registration of prototypes, etc.
├─ control.lua   # optional: runtime callbacks
└─ modules/*.lua # helper modules
Engine’s scripting environment:
• Sandboxed VM (no direct OS, file, network, or wallclock access).
• Deterministic APIs only.
• No global RNG — engine exposes deterministic PRNG seeded from world + tick when allowed, or not at all for “strict deterministic” servers.
Typical allowed call patterns:
• on_world_init(world_context)
• on_tick(tick_context)
• on_event(event_context) for filtered events (construction, research completed, etc.)
• Data registration during load: register_entity(proto_table) etc., if you choose to expose this.
Hard constraints:
1. No simulation kernel violation
Scripts must not bypass the core determinism rules:
o No direct thread creation.
o No network I/O.
o No access to system time.
o No floating-point operations that influence sim (you can sandbox this by not exposing FP at all).
2. No uncontrolled side effects
All world modifications must go through engine-provided APIs that internally use deterministic command buffers/events.
3. Tick-bound execution
All script execution is scheduled in simulation phases:
o Data registration at load time (before world start).
o Event handlers at deterministic locations in the tick pipeline.
If you expose pathfinding, building placement, etc., script APIs must themselves be deterministic.

7. /gfx/ within a mod — mod-specific graphics
Same philosophy as /data/packs, but scoped to the mod and to mod-defined resource IDs.
Example:
gfx/
├─ tiles/
│  ├─ tiles.json
│  └─ ...
├─ sprites/
│  ├─ sprites.json
├─ ui/
│  ├─ icons.json
└─ vector/
   └─ vector_sets.json
Rules:
• Graphics definitions reference logical resource IDs (usually the same ones defined in mod /data).
• Packs and mods can both supply graphics for the same logical ID; your override resolution rules must be deterministic and clearly defined:
o Example policy: mod gfx > activated pack gfx > base gfx.
• Mod graphics must not introduce simulation parameters; only appearance.

8. /audio/ within a mod — mod-specific audio
Like graphics, but for SFX/music:
audio/
├─ sfx/
│  ├─ sfx.json
└─ music/
   ├─ music.json
Rules:
• SFX IDs are mod-scoped (my_railpack.sfx.train_brake).
• Engine maps simulation events to SFX IDs; mods only supply extra sounds for those IDs.
• Music tracks and playlists can be offered but must not control game logic or pacing.

9. /locale/ within a mod — localization files
Localization structure might follow your engine’s global locale spec:
locale/
├─ en/
│  └─ strings.json
├─ de/
│  └─ strings.json
└─ ...
strings.json:
{
  "entities.my_railpack.rail_type.2ft_heavy.name": "2 ft Heavy Rail",
  "entities.my_railpack.rail_type.2ft_heavy.desc": "Heavy-duty narrow gauge rail for industrial routes."
}
Engine:
• Merges localization tables from all active mods, with deterministic priority (base < DLC < mods by order).
• No impact on simulation.

10. /docs/ and /tests/ within a mod
• /docs/ is arbitrary human documentation, design notes, changelogs.
• /tests/ can contain:
o Scripted test harnesses.
o Example replay setups referencing this mod.
o Data validation files.
Engine doesn’t load anything from these automatically; they are for tooling and developers.

11. Determinism, safety, and prohibitions for /mods
11.1 Determinism levels
You will eventually need at least three classes:
1. Pure UI mods
o determinism.affects_simulation = false
o Only touches UI, graphics, overlays, audio.
o Safe in all multiplayer and replay contexts.
2. Simulation-safe deterministic mods
o affects_simulation = true, network_safe = true
o All logic goes through deterministic APIs.
o Allowed in multiplayer and deterministic replays.
3. Unsafe/sandbox mods (optional, maybe dev only)
o network_safe = false
o Might violate determinism or use non-deterministic features.
o Never allowed in authoritative multiplayer or deterministic replays.
The manifest flags must reflect this, and engine must enforce restrictions.
11.2 Hard prohibitions
• No native code auto-loading: .dll/.so/.dylib/.exe ignored or blocked.
• No direct file I/O beyond mod-local, and even that should be heavily constrained or forbidden.
• No direct OS calls, environment variables, or process management.
• No network sockets from scripts.
• No access to wallclock or monotonic clock for simulation decisions.
• No altering core engine/determinism constants at runtime from mods.
11.3 Loading order and conflict resolution
Engine guaranteed behaviour:
• Collect candidate mods from /mods/local, /mods/workshop, plus world-requested mod list.
• Resolve dependencies:
o If missing required dependency → world fails to load or mod disabled deterministically.
• Apply conflicts rules:
o If two conflicting mods enabled, either:
• Hard error, or
• Deterministic priority decision (e.g. user-specified or mod load order).
• Final load order is:
o Base
o DLC
o Mods, ordered by:
• dependency constraints,
• load_order.after/before,
• tie-break by ID.
No hidden or random influences.

12. World save and mods
World savefiles must include:
• Full list of active mods.
• Version of each mod (plus hash if you want strictness).
• Load order.
On loading:
• Engine verifies the exact mod set (IDs, versions, counts).
• If mismatch:
o Strict deterministic mode: refuse to load.
o Relaxed mode: allow with warning and mark world as “non-deterministic”.
Mods must not attempt to “force-load” themselves into worlds where they weren’t present.

Next message will define the dev-spec for /tools/ (editors, devkits, asset pipelines: responsibilities, subdirs, and constraints).
You said:
Next
ChatGPT said:
GPT-5.1 Thinking • build 2025-12-03
This message is the dev-spec for /tools/ — the non-runtime toolkit layer of the Dominium project.
/tools contains editors, devkits, asset pipelines, validators, converters, generators, and debugging utilities.
No code here runs in the simulation thread of the game runtime; these tools operate offline or in editor environments.
They must never contain authoritative game logic.
They also must never break determinism: the runtime sim must not depend on anything inside /tools.

0. Directory layout
Canonical:
/tools/
├─ README.md
├─ editor/
│  ├─ world_editor/
│  ├─ blueprint_editor/
│  ├─ asset_inspector/
│  ├─ editor_common/
│  └─ plugins/
├─ devkit/
│  ├─ schema/
│  ├─ codegen/
│  ├─ mod_sdk/
│  ├─ validators/
│  └─ generators/
├─ pipeline/
│  ├─ images/
│  ├─ audio/
│  ├─ models/
│  ├─ shaders/
│  └─ packager/
├─ debug/
│  ├─ profilers/
│  ├─ inspectors/
│  └─ replay_tools/
└─ scripts/
   ├─ helper_python/
   ├─ helper_shell/
   └─ helper_batch/
This general form is binding, though subdirectories may grow.

1. /tools/README.md
Explains:
• Tools are never shipped in runtime distributions unless intentionally bundled.
• Tools must not contain simulation-critical code.
• Tools may contain:
o Editor GUI code (SDL/OpenGL/Qt/etc.).
o Asset processing command-line tools.
o Validation scripts.
o Generators for schema, code stubs, documentation.
Also clarifies:
• Tools may use floats, nondeterminism, and OS features freely, so long as their outputs are deterministic when given fixed inputs (e.g., seeded generators).
• Tools never participate in runtime tick execution.

2. /tools/editor/ — official editors
Editors are applications or toolkits that:
• Allow world/blueprint/asset editing.
• Are allowed to be non-deterministic internally (UI interactions, mouse locations, OS timestamps), but their saved outputs must be deterministic.
Editor binaries do not enforce retro compatibility; they can be modern C++ with GUI frameworks.

2.1 /tools/editor/world_editor/
Purpose:
• Edit surfaces, terrain, heightmaps.
• Place prefabs, roads, rails, utilities, blueprints.
• Adjust worldgen seeds and presets.
• Validate terrain against engineering constraints.
Contains:
world_editor/
├─ src/
│  ├─ editor_main.cpp
│  ├─ ui_panels.cpp
│  ├─ ui_panels.h
│  ├─ world_ops.cpp
│  ├─ world_ops.h
│  ├─ terrain_ops.cpp
│  ├─ terrain_ops.h
│  ├─ asset_browser.cpp
│  ├─ asset_browser.h
│  └─ io/
│     ├─ save_export.cpp
│     └─ save_import.cpp
├─ resources/
│  ├─ icons/
│  ├─ ui_layouts/
│  └─ themes/
└─ plugins/
Required API endpoints exposed via tools libraries:
• editor_load_world(path)
• editor_save_world(path)
• editor_apply_heightmap(surface_id, height_data)
• editor_place_prefab(surface_id, prefab_id, pos, rot)
• editor_delete_entity(entity_id)
• editor_validate_world(surface_id) → returns structured errors/warnings
Prohibitions:
• No simulation stepping in the editor.
• No engine tick.
• Editor only manipulates data via the engine’s deterministic world format.

2.2 /tools/editor/blueprint_editor/
Purpose:
• Create blueprint templates (local coordinates only).
• Manage anchor, orientation rules.
• Manage entity arrays and network paths.
• Export blueprint.json under /data/templates/blueprints.
Contains:
• Visual grid editor.
• Snapping tools.
• Prefab palette browser.
Exports:
• blueprint_export(path, blueprint_struct)
• blueprint_validate(blueprint_struct) → structured error set.
Prohibitions:
• No worldgen functions.
• No collision with /data/base ID space; editor must require mod namespace for new prefabs.

2.3 /tools/editor/asset_inspector/
Purpose:
• Inspect packed assets (tiles, sprites, models).
• Display metadata, slices, atlases.
• Visualize shader parameters.
No simulation logic.

2.4 /tools/editor/editor_common/
Library code shared by all editors:
• GUI widgets (if not using external frameworks).
• Scene graph and camera manip.
• File import/export utilities.
This code must not leak into /engine.

2.5 /tools/editor/plugins/
Editor plug-ins:
• Implemented as shared libs or loadable scripts.
• Extend UI only.
• Must never alter game runtime or determinism rules.
Engine never loads editor plugins.

3. /tools/devkit/ — SDK, schemas, validators, generators
This is the most important part for modders, designers, and CI.

3.1 /tools/devkit/schema/
Holds machine-readable schemas for all data formats:
schema/
├─ prefab_schema.json
├─ tech_schema.json
├─ network_schema.json
├─ worldgen_schema.json
├─ economy_schema.json
├─ blueprint_schema.json
├─ scenario_schema.json
└─ pack_asset_schema.json
Rules:
• No floats except where the format explicitly accepts fixed-point.
• No ambiguous field types.
• Schemas must match /docs/spec/DATA_FORMATS.md.
Tools in /tools/devkit/validators consume these schemas.

3.2 /tools/devkit/codegen/
Tools that generate:
• C89/C++98 header stubs for ECS components.
• Serialization/deserialization code.
• Deterministic hashing tables for resource IDs.
• Lua API stubs for mod scripting.
Files:
codegen/
├─ gen_components.py
├─ gen_resource_ids.py
├─ gen_lua_api.py
└─ templates/
Outputs go to /engine/* or /game/* but code here is tools-only.
Rules:
• Generated code must be deterministic.
• Templates must be version controlled.
• Running codegen must never break compatibility without version bump.

3.3 /tools/devkit/mod_sdk/
Provides:
• Documentation templates.
• Starter mod folder structure.
• Example mod.json.
• Sample scripts: init.lua, control.lua.
• Validation helpers for mod authors.
Engine does not load anything from this directory.
Editors and external documentation tools do.

3.4 /tools/devkit/validators/
Validation tools:
validators/
├─ validate_prefabs.py
├─ validate_tech.py
├─ validate_networks.py
├─ validate_worldgen.py
├─ validate_recipes.py
├─ validate_blueprints.py
└─ validate_mod.py
These validate the entire tree of:
• /data/base,
• /data/dlc/*,
• /mods/…,
• any template world or scenario.
Outputs:
• JSON or text error reports.
• Optional CI summary.
Rules:
• Must strictly enforce determinism constraints.
• Missing references (bad prefab ID, bad tech ID) must error out.
• Tools may use floats for analysis but must output deterministic results.

3.5 /tools/devkit/generators/
Procedural generation tools:
• Heightmap generators (noise, erosion, river placement) for world seeds.
• Road/rail auto-lay generators for templates.
• Asset atlas generators.
Example:
generators/
├─ gen_heightmap.py
├─ gen_resource_map.py
└─ gen_asset_atlas.py
These tools output files under /data/templates/worlds or /data/packs.
They may use nondeterministic algorithms internally, but should accept explicit seeds for reproducibility.

4. /tools/pipeline/ — asset import/export pipeline
These tools convert raw materials (images, audio, models, shaders) to runtime formats.

4.1 /tools/pipeline/images/
Tools:
• png_to_tileatlas.py
• sprite_strip_slicer.py
• vector_rasterizer.py
• compress_textures.py
Outputs:
• .png, .dds, or whatever internal format.
• JSON atlases for /data/packs.
Rules:
• Lossy compression must be deterministic per input + flags.
• Pipeline must be versioned; changes require bumping pack asset version.

4.2 /tools/pipeline/audio/
Tools:
• OGG/FLAC/WAV converters.
• Normalization and batching.
• Loop point injectors.
Outputs:
• .ogg or .wav files.
• sfx.json, music.json entries for packs.
No runtime audio logic.

4.3 /tools/pipeline/models/
Tools:
• Mesh import/export (OBJ → engine mesh).
• LOD generator.
• Normal/tangent calculator.
Outputs:
• Engine-compatible mesh files → consumed by /data/packs/<pack>/models.

4.4 /tools/pipeline/shaders/
Tools:
• Shader compiler frontends (GLSL → SPIR-V, HLSL → DX9 shader binary).
• Reflection generators (uniforms, attributes).
Outputs:
• Shader binaries grouped in /data/packs/<pack>/shaders.
Rules:
• Must produce deterministic binaries on same compiler version.
• Compiler versions must be pinned in CI.

4.5 /tools/pipeline/packager/
Builds full asset packs:
• Collects images/models/audio.
• Generates manifest.json.
• Builds atlases and bundles.
• Produces a .dpack (Dominium Pack) or directory tree.
Used by CI and developers.
Outputs go to /data/packs.

5. /tools/debug/ — analyzers, profilers, replay inspectors
Debug tools do not ship with release build unless you choose to.

5.1 /tools/debug/profilers/
• Flame graph generator for engine functions.
• Memory pool inspector.
• Hotspot analyzers.
Must not run in shipping “deterministic lockstep” mode.
Tools are for developers.

5.2 /tools/debug/inspectors/
• ECS inspector.
• Network graph viewer (rail/road/power/data).
• Entity footprint renderer.
• Pathfinding visualizer.
Reads save files or running instances in offline mode; no simulation mutation.

5.3 /tools/debug/replay_tools/
Replay utilities:
• Replay diffing (compare two replays for determinism).
• Replay timeline scrubber.
• Tick-to-tick state auditor.
Used heavily in deterministic engine CI.

6. /tools/scripts/ — generic helper scripts
Support scripts in Python, Bash, Powershell:
scripts/
├─ helper_python/
│  ├─ bump_version.py
│  ├─ asset_checksum.py
│  └─ generate_license_list.py
├─ helper_shell/
│  ├─ build_all.sh
├─ helper_batch/
│  ├─ build_all.bat
└─ ...
Allowed:
• Build orchestration.
• Data validation.
• Repo maintenance.
Not allowed:
• Anything that changes runtime behaviour directly.
• Anything nondeterministic unless clearly isolated from core data output.

7. Global prohibitions for /tools
• /tools must not contain or depend on /engine runtime code directly, except through clearly-separated headers/interfaces.
• No tool may generate runtime-dependent behaviour (e.g. “dynamic rule updates”).
• No tool may silently write into /engine, /game, or /data/base without CI checks.
• No scripts here run automatically inside runtime; all tools are developer-invoked only.

8. Summary
/tools provides:
• Editors: world, blueprint, asset inspector.
• SDK: schemas, validators, codegenerators, modkit.
• Pipelines: import/export/packaging for assets.
• Debug tools: profilers and replay inspectors.
• Helper scripts: repo-automation utilities.
It is the universe of offline tooling, strictly isolated from deterministic runtime logic.

Next message will define the dev-spec for /tests/, covering unit tests, integration tests, deterministic replays, and perf tests with full structure and requirements.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
This message defines the dev-spec for /tests/ — the entire deterministic verification and validation framework for Dominium.
/tests is authoritative for correctness, stability, determinism, and regression control.
Nothing in /tests is shipped with the normal runtime, but CI executes this directory aggressively.

0. Directory layout
Canonical structure:
/tests/
├─ README.md
├─ unit/
│  └─ <module>_tests.c
├─ integration/
│  ├─ world_load/
│  ├─ network_lockstep/
│  ├─ economy/
│  ├─ networks_power/
│  └─ ...
├─ replay/
│  ├─ scenarios/
│  ├─ baselines/
│  ├─ fuzz/
│  └─ tools/
└─ perf/
   ├─ microbench/
   ├─ macrobench/
   └─ soak/
Each folder enforces distinct semantics.

1. /tests/README.md
Clarifies:
• Tests MUST NOT use OS randomness unless explicitly using deterministic seeds.
• Tests MUST NOT touch external filesystem except approved fixtures.
• Tests MUST NOT depend on system clock or local environment.
• Tests MUST NOT depend on GPU or audio hardware — headless engine only.
States that:
• Standard runtime uses the same deterministic simulation binaries as tests.
• Tests must run identically on all supported platforms.
Also describes how to run:
cmake --build . --target run_tests
And how to update baselines when intentional breaking changes occur.

2. /tests/unit/ — granular C89/C++98 module tests
Unit tests validate engine core modules in isolation.
Typical hierarchy:
/tests/unit/
├─ core_mem_tests.c
├─ core_rng_tests.c
├─ core_fp_tests.c
├─ sim_network_tests.c
├─ sim_pathfinding_tests.c
├─ sim_tick_tests.c
├─ serialization_tests.c
└─ ecs_component_tests.c
2.1 Requirements
1. Language restrictions
If the tested module is C89, the test must also be pure C89.
No platform headers except through /engine/platform mocks.
2. Determinism
Tests must operate on deterministic RNG seeds. Example:
3. dom_rng_seed(&rng, 12345u);
4. Memory discipline
Unit tests must check:
o Bounds correctness
o Allocation/ownership behaviour
o No implicit mallocs unless expected
5. Pure logic testing
Unit tests cannot:
o Load textures
o Use rendering API
o Use blockers (threads, waits)
6. Mock engine components
Some systems (network, serialization, tick) depend on stubs provided in:
7. /tests/unit/mocks/
8. Assert behaviour
The test harness provides:
9. TEST_ASSERT(expr)
10. TEST_ASSERT_EQ(a,b)
11. TEST_ASSERT_NEQ(a,b)
12. TEST_ASSERT_INT_EQ(a,b)
13. TEST_ASSERT_MEM_EQ(ptr1,ptr2,len)

3. /tests/integration/ — whole-engine functional tests
Integration tests validate that engine subsystems work together.
Structure:
/tests/integration/
├─ sim_tick/
│  ├─ simple_tick_run.c
│  └─ multi_actor_tick.c
├─ world_load/
│  ├─ load_minimal_world.c
│  ├─ load_maximal_world.c
│  └─ load_with_mods.c
├─ networks_power/
│  ├─ ac_dc_convert_test.c
│  ├─ load_balance_test.c
│  └─ blackout_recover_test.c
├─ networks_data/
│  └─ routing_large_topology_test.c
├─ economy/
│  └─ price_equilibrium_test.c
└─ transport/
   ├─ rail_signalling_test.c
   ├─ road_pathfinder_test.c
   └─ air_traffic_layers_test.c
3.1 Requirements
1. Full headless engine
Integration tests launch the deterministic engine backend without rendering/audio.
2. Well-controlled fixtures
Input data (worlds, prefabs, techs, recipes) are placed under:
3. /tests/fixtures/<name>
Fixtures must not reference /mods unless the test explicitly loads mods.
4. Precise step execution
Example:
sim_init(&engine, &world);
for (int t = 0; t < 10000; ++t) {
    sim_tick(&engine);
}
5. Hash validation
Integration tests verify stable deterministic outputs via world-state hashing:
uint64_t h = world_hash(&world);
TEST_ASSERT_EQ(h, 0xCF42A1F3B29ADEFFULL);
If the expected hash changes legitimately, the developer must update the baseline hash and document the reason.
6. No floating-point nondeterminism
Integration tests must use integer/fixed-point pathways.
If float math is used in non-critical renderer-only code, integration tests ignore it.

4. /tests/replay/ — deterministic simulation replay validation
This is the most critical directory for long-term stability.
Subdirs:
/tests/replay/
├─ scenarios/
│  ├─ small_factory/
│  ├─ huge_transport_network/
│  ├─ interstellar_logistics/
│  └─ warfare/
├─ baselines/
│  └─ <scenario_name>.hash         # 128-bit deterministic hash
├─ fuzz/
│  ├─ random_inputs/
│  └─ malformed_commands/
└─ tools/
   ├─ replay_runner.c
   ├─ replay_diff.c
   └─ replay_hash.c
4.1 Replay requirements
1. Replay format is canonical
Replays contain tick-by-tick command streams, not deltas.
2. Deterministic tick pipeline
Engine must execute replays identically across:
o All operating systems
o All CPUs
o All render backends (since headless runs bypass rendering)
3. Baseline enforcement
Running:
run_replay --scenario small_factory
Must produce exactly the hash stored in:
/tests/replay/baselines/small_factory.hash
4. Replay diffing
Tools can compare state by tick:
replay_diff file1.replay file2.replay
Output includes entity divergence history.
5. Fuzz testing
Commands generated under seeded RNGs stress unusual edge cases:
o Queueing thousands of build commands
o Simultaneous removals/additions
o Network overloads
o Mass pathfinder invalidation
The engine must never crash or desync; state must remain consistent.

5. /tests/perf/ — performance, scalability, and soak tests
Performance tests measure execution time of stable APIs.
Subdirs:
/tests/perf/
├─ microbench/
│  ├─ pathfinder_bench.c
│  ├─ ecs_iteration_bench.c
│  └─ rng_bench.c
├─ macrobench/
│  ├─ million_entities_bench.c
│  ├─ global_network_bench.c
│  └─ multi_surface_bench.c
└─ soak/
   ├─ 24h_sim_soak.c
   └─ memory_pressure.c
5.1 Requirements
1. Deterministic seed
Perf tests must initialize RNG and world with fixed seeds.
2. Time measurement constraints
Perf tests measure relative, not absolute performance.
They compare:
o Ticks-per-second
o Nanoseconds per pathfinding invocation
o Memory footprint changes
3. Soak tests
Execute tens of millions of ticks.
Should detect:
o Memory leaks
o Slow drifts
o Integer overflows
o Network topology degenerations
4. No floating-point reliance
Perf tests do not assert on exact FP values.

6. Cross-cutting constraints for all /tests
6.1 No nondeterminism leakage
No test may depend on:
• time(NULL)
• rand()
• System clock
• Number of CPU cores
• GPU behavior
• Thread scheduling
• Unordered hash maps (must use stable hashing)
6.2 No external network access
Tests may not:
• Reach out to HTTP APIs
• Attempt to open sockets
• Depend on OS locale or codepage
6.3 CI safety
• All tests must run in under fixed timeouts.
• All tests must produce machine-readable outputs.
• All replay baselines must be updated explicitly with commit messages explaining differences.
6.4 Retro-compatibility
Where required:
• Some tests validate compatibility with retro build modes (DOS, Win9x, macOS Classic).
• These tests must simulate constraints but not necessarily run under the retro OS.

7. Summary
/tests provides:
• Unit tests for engine modules (pure deterministic logic).
• Integration tests for world/engine multi-system behaviour.
• Replay tests ensuring deterministic stability across versions and platforms.
• Perf tests ensuring that regressions are caught early.
This directory is the backbone of correctness, determinism, regression stability, and long-term maintainability.

Next: dev-spec for /third_party/ — vendored libs, their structure, isolation rules, licensing constraints, and update workflow.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
This message defines the dev-spec for /third_party/ — the authoritative structure and rules for vendored external libraries, headers, assets, and licences within Dominium.
/third_party must behave as a hermetically controlled dependency depot.
It ensures:
• Determinism: external code cannot change without explicit review.
• Reproducibility: all vendored libraries are version-pinned and immutable.
• Isolation: no foreign code leaks into engine, game, mods, or tools.

0. Directory layout
Canonical structure:
/third_party/
├─ README.md
├─ src/
│  ├─ <libname>/
│  │  ├─ upstream/
│  │  ├─ patches/
│  │  ├─ dominium_integration/
│  │  └─ BUILD_INSTRUCTIONS.md
│  └─ ...
├─ include/
│  ├─ <libname>/
│  └─ ...
├─ assets/
│  ├─ test/
│  ├─ reference/
│  └─ fonts/
├─ licenses/
│  ├─ <libname>.LICENSE
│  └─ THIRD_PARTY_NOTICES.md
└─ pin/
   ├─ versions.json
   └─ hashes/
This structure is binding unless extended via /docs/spec and approved.

1. /third_party/README.md
Must explain:
• Purpose: contain all non-Dominium code or data.
• Policy: vendoring only, no dynamic fetching.
• Workflow: update requires approval, license check, reproducible hash, and patch audit.
• Separation: engine code must never be mixed into vendor folders.
• Allowed languages: C, C++, headers, specific asset types.
Also documents:
• Which external libs are mandatory (e.g., zlib, stb_image, Lua VM if embedded).
• Which libs are optional (editor GUI libs, codecs, etc.).

2. /third_party/src/ — source code of vendored dependencies
Structure under each library:
/third_party/src/<libname>/
├─ upstream/                # untouched from official source release
│  ├─ <original files>
│  └─ VERSION
├─ patches/                 # minimal patch files only
│  ├─ 0001-dominium-fix-int-overflow.patch
│  ├─ 0002-remove-io-syscalls.patch
│  └─ SERIES
├─ dominium_integration/    # thin wrappers or glue code
│  ├─ <libname>_shim.c
│  ├─ <libname>_shim.h
│  └─ BUILD_NOTES.md
└─ BUILD_INSTRUCTIONS.md
2.1 upstream/ rules
• MUST reflect a verbatim release of the upstream library.
• May not be modified or rearranged.
• Must contain a VERSION file with upstream version + checksum:
version: 1.2.11
sha256: <hash>
source_url: https://...
• Must be exactly reproducible across machines and commits.
2.2 patches/ rules
• Only patches that cannot be avoided may appear here.
• Patches must be:
o Minimal
o Documented
o Reversible
o Justified in the SERIES file
• Patch types allowed:
o Remove OS syscalls (filesystem/network).
o Strip nondeterministic operations.
o Fix UB or memory violations.
o Remove float/time randomness.
o Add a shim to expose fixed-point interfaces.
Forbidden patch types:
• Adding new features unrelated to Dominium integration.
• Invasive rewrites.
• Changing library licensing or metadata.
• Depending on Dominium’s engine code.
2.3 dominium_integration/
Contains only:
• Wrapper headers
• Deterministic wrappers
• Fixed-point replacement of float APIs
• Build flags
• Bridge interfaces used by the engine’s build system
Must never contain partial re-implementations of the library.

3. /third_party/include/
Contains public headers from dependencies that engine/game may include.
Structure:
/third_party/include/<libname>/
│  ├─ <public headers>
Rules:
• These files mirror upstream headers after patches.
• May not contain Dominium engine headers.
• No circular dependency may appear between include/<libname> and engine/.

4. /third_party/assets/
Contains external data used for tests, editors, or examples:
/third_party/assets/
├─ test/
│  ├─ sample_images/
│  ├─ sample_audio/
│  └─ sample_meshes/
├─ reference/
│  ├─ benchmark_worlds/
│  └─ regression_inputs/
└─ fonts/
   └─ dejavu/
Rules:
• Asset licenses must permit redistribution.
• These assets must not become base game content.
• Can be used by /tests, /tools, and /docs.
• Not used by /game except in explicit debug builds.

5. /third_party/licenses/
Contains:
• Explicit license texts for each vendored library
• THIRD_PARTY_NOTICES.md which enumerates:
o Library name
o Version
o SPDX license
o URL
o Notes about modifications (patches applied)
Example entry:
zlib 1.2.11
License: Zlib
Modifications:
  - 0002-remove-file-io.patch
  - 0003-fixed-point-adapter.patch
Rules:
• Must pass CI license audit.
• Must not contain ambiguous or missing licenses.
• Library licence must allow static linking and redistribution with the engine.
Forbidden:
• Any library requiring copyleft linking over closed parts of Dominium.
• GPL libraries (unless fully isolated in a tool only, not in engine/game).

6. /third_party/pin/ — version locking
This is critical for reproducibility.
/third_party/pin/
├─ versions.json
└─ hashes/
   ├─ <libname>-<version>.sha256
6.1 versions.json
Defines the canonical versions in use:
{
  "libs": {
    "zlib":  { "version": "1.2.11", "hash": "abc123..." },
    "stb_image": { "version": "2.28", "hash": "def456..." },
    "lua": { "version": "5.4.6", "hash": "789abc..." },
    "tinyxml2": { "version": "9.0.0", "hash": "..." }
  }
}
CI policy:
• If hash mismatches, refuse build.
• If version changes, require maintainer review.
• If patchset changes, require review + update to SERIES file.

7. General rules & prohibitions
7.1 Hard prohibitions
• No code in /third_party may include engine headers.
• No mod content in /third_party.
• No unlicensed or unverifiable code.
• No auto-updating or build-time network fetching.
• No circular dependency between libraries.
• No mixing of two different versions of the same upstream library.
7.2 Determinism requirements
Libraries used within the runtime engine should satisfy:
• No hidden randomness
• No wallclock time reads
• No filesystem or network IO except via shims
• No thread creation or mutexes unless explicitly wrapped
If the library cannot satisfy determinism, it must be used only in:
• Tools
• Editors
• Offline asset pipelines
Never engine/sim runtime.
7.3 Build/Integration constraints
• Build system must never build directly from upstream:
Only from upstream + patches + integration.
• All build flags must be recorded in /third_party/src/<libname>/BUILD_INSTRUCTIONS.md.
• No inline source modifications are allowed; changes must be patches.

8. Updating workflow (high-level)
1. Download upstream release.
2. Verify checksum.
3. Place in upstream/.
4. Produce new patches under patches/.
5. Update SERIES file.
6. Update licence file under /third_party/licenses.
7. Update versions.json & hashes.
8. Run determinism tests.
9. Run integration tests & replays.
10. Submit for maintainer review.

9. Summary
/third_party ensures:
• Controlled, deterministic vendoring
• Strict version pinning
• License compliance
• Isolation from engine logic
• Reproducible builds across all platforms
• A single source of truth for all external code
It is not a dumping ground.
It is a curated, audited subsystem with exact constraints.

Next message will define the dev-spec for /build/, including build scripts, CMake modules, output directories, and deterministic compilation rules.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
This message defines the dev-spec for /build/ — the complete structure, constraints, and responsibilities for the Dominium build system.
/build is not a place for source code, game logic, assets, or documentation.
It is strictly:
• Build scripts
• CMake modules
• Toolchain configs
• Build output staging
• CI integration helpers
Nothing here is authoritative for game behaviour — only /engine + /game + /data + /docs/spec are.

0. Directory layout
Canonical:
/build/
├─ README.md
├─ cmake/
│  ├─ toolchains/
│  │  ├─ linux_x86_64.cmake
│  │  ├─ windows_msvc.cmake
│  │  ├─ macos_clang.cmake
│  │  ├─ dos_watcom.cmake
│  │  └─ win9x_mingw32.cmake
│  ├─ modules/
│  │  ├─ DominiumPlatform.cmake
│  │  ├─ DominiumDeterminism.cmake
│  │  ├─ DominiumThirdParty.cmake
│  │  ├─ DominiumTesting.cmake
│  │  └─ LegacySupport.cmake
│  └─ presets/
│     ├─ debug.preset.json
│     ├─ release.preset.json
│     ├─ retro_lowmem.preset.json
│     └─ headless.preset.json
├─ scripts/
│  ├─ build_all.sh
│  ├─ build_all.bat
│  ├─ package_release.py
│  ├─ generate_version_header.py
│  ├─ lint_sources.py
│  └─ ci_hooks/
│     ├─ check_patches.py
│     ├─ verify_hashes.py
│     └─ validate_specs.py
└─ output/               # ignored by version control
   ├─ linux/
   ├─ win/
   ├─ mac/
   ├─ retro/
   └─ logs/
Everything under /build/output/ is ephemeral and gitignored.

1. /build/README.md
Document must state:
• /build is not part of the engine; it is scaffolding around it.
• All deterministic behaviour happens in runtime, not here.
• Build scripts must not modify canonical source-of-truth directories.
• CI relies on /build for reproducible builds across OSes.
Also:
• Lists supported targets and compilers.
• Notes cross-compilation constraints (DOS, Win9x, macOS Classic).
• Defines required build steps for developers and CI.

2. /build/cmake/ — main build system backbone
CMake is the canonical configuration layer.
All platform and determinism rules flow through here.

2.1 /build/cmake/toolchains/
Purpose: cross-platform compiler configurations.
Each toolchain file must:
• Set compiler + linker executable paths
• Configure architecture (x86, x86_64, PowerPC, ARM)
• Define platform macros (DOM_PLATFORM_WIN32, DOM_PLATFORM_LINUX, etc.)
• Enforce C89/C++98 constraint for /engine
• Enforce no exceptions in engine unless explicitly allowed
• Control floating-point mode:
o -ffloat-store for deterministic retro builds
o Fixed-point overrides
• Disable all undefined-behaviour optimisations for deterministic modules
Example responsibilities inside:
set(CMAKE_SYSTEM_NAME Windows)
set(CMAKE_C_COMPILER x86_64-w64-mingw32-gcc)
set(CMAKE_C_STANDARD 89)
add_definitions(-DDOM_DETERMINISTIC)
Forbidden in toolchain files:
• Enabling link-time optimisation for deterministic builds unless proven stable.
• Auto-fetching dependencies (use /third_party only).
• Hardcoding user paths.

2.2 /build/cmake/modules/
These define reusable CMake logic.
Modules include:
DominiumPlatform.cmake
• Selects platform abstraction layer
• Verifies /engine/platform/* bindings exist
• Prevents missing platform API symbols at link-time
DominiumDeterminism.cmake
• Enforces:
o C89/C++98 compliance tests
o Fixed-point math compilation flags
o Deterministic RNG default
o Disabling SIMD unless deterministic
• Validates prohibited compiler flags (-ffast-math, -march=native)
DominiumThirdParty.cmake
• Declares all vendor libs via deterministic import
• Validates patch hashes
• Disallows system-installed libs
• Ensures no external fetches
• Controls whether each library is compiled static or included as headers-only
DominiumTesting.cmake
• Adds test executables per /tests/unit and /tests/integration
• Registers replay tests with expected hashes
• Provides macros:
o dom_add_unit_test(name files...)
o dom_add_integration_test(name files...)
o dom_add_replay_test(scenario baseline_hash)
LegacySupport.cmake
• Extra constraints for:
o Win9x toolchains
o DOS toolchains (OpenWatcom)
o macOS Classic (CodeWarrior or MPW)
• Ensures use of SFN (8.3) filenames when generating packages for /packaging/retro.

2.3 /build/cmake/presets/
JSON presets for typical configurations:
debug.preset.json
• Debug symbols
• Assertions enabled
• Runtime diagnostics On
release.preset.json
• Full optimisation
• Determinism-proven flags only
• Stripped binaries
retro_lowmem.preset.json
• 16–64 MB RAM simulated constraints
• No dynamic allocations
• 8.3 filename enforcement
• No modern rendering backends
headless.preset.json
• Used by CI
• No rendering or audio backends
• Determinism-oriented compiler flags only

3. /build/scripts/
Utility scripts.
All must be side-effect limited: no modifying /engine, /game, /data/base without strict CI approval.

3.1 build_all.sh / build_all.bat
• Performs multi-target builds (Linux, Win, Mac, Retro).
• Ensures toolchain versions are locked.
• Validates that /third_party/pin hashes match downloaded libs.
Prohibitions:
• No auto-updating toolchains.
• No silent fallback compilers.

3.2 package_release.py
Generates packaging outputs into /packaging layouts.
Must:
• Respect platform differences
• Embed correct manifest version
• Exclude debug symbols from release builds
• Include modding API docs when configured
Must not:
• Modify /engine or /game code
• Pull dependencies from the internet

3.3 generate_version_header.py
Produces /engine/core/dom_version.h.
Outputs deterministic metadata:
• Engine version
• Git commit hash
• Build timestamp (must be optional to preserve determinism)
• Build configuration (debug/release/headless)
Deterministic mode must omit timestamps, include only semantic version + commit ID.

3.4 lint_sources.py
Performs static checks:
• No forbidden includes (<windows.h> in engine code)
• No floating-point operations in deterministic modules
• No dynamic memory in tight loops
• No recursion in engine code
• No banned keywords (auto, decltype, std::thread, etc.)
CI must reject if lint fails.

3.5 /build/scripts/ci_hooks/
check_patches.py
• Validates that /third_party/src/*/patches/*.patch match upstream hashes.
• Ensures no stray modifications.
verify_hashes.py
• Validates /third_party/pin/versions.json against actual upstream sources.
validate_specs.py
• Ensures /docs/spec is consistent:
o No broken references
o No stale schema IDs
o No contradictions between SPEC-core.md and schemas
All CI hooks must exit nonzero on failure.

4. /build/output/ — ephemeral artifacts
Ignored in VCS. Structure:
/build/output/
├─ linux/
│  └─ <binaries and logs>
├─ win/
│  └─ <binaries and logs>
├─ mac/
├─ retro/
│  ├─ dos/
│  ├─ win9x/
│  └─ mac_classic/
└─ logs/
   ├─ build.log
   └─ test_results.xml
Rules:
• Nothing here is source-of-truth.
• All files may be deleted at any time.
• No handwritten files allowed here.

5. Deterministic build requirements (critical)
Dominium must be bit-for-bit repeatable across machines for deterministic builds.
Requirements:
1. Compiler version pinning
All compilers must be version-defined in /docs/spec/BULDING.md.
2. No nondeterministic flags
Disallow:
o -ffast-math
o -march=native
o -flto for deterministic builds
o Any optimization known to reorder FP ops unpredictably
3. Fixed order of file inclusion
CMake must enumerate sources deterministically.
4. Deterministic archives
Static libs must be created with deterministic timestamps and file order.
5. Platform-stable macros
No macros allowed that embed build time or OS hostname into binary unless in debug-only sections.
6. Separation of debug/release IDs
Debug builds need not be bitwise-deterministic; release deterministic builds must.
7. Cross-platform reproduction
For deterministic replays, Linux vs Windows vs macOS builds must produce identical simulation behaviour even if not identical binaries.

6. Prohibitions for /build
Strictly forbidden:
• Fetching libraries during configuration or build
• Generating source files outside of controlled generators
• Putting actual source code inside /build
• Allowing /build scripts to modify /engine or /game
• Shipping files from /build/output

7. Summary
/build contains:
• CMake architecture
• Toolchains and presets
• Determinism-enforcing modules
• Build + package scripts
• CI validation tools
• Ephemeral outputs
It guarantees reproducible builds, validated dependencies, and a strict deterministic execution model.

Next message: dev-spec for /packaging/ — installers, media images, retro constraints, multi-platform layout, metadata, and build-time validation.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Below is the full dev-spec for /packaging/ — the directory responsible for creating installers, distributable archives, physical media images, retro formats, and launcher metadata for every supported platform.
/packaging never contains engine/game logic.
It contains instructions and layouts used by build scripts to assemble redistributables.
This directory must not influence runtime determinism.
It is purely a distribution layer.

0. Directory Layout (Canonical)
/packaging/
├─ README.md
├─ common/
│  ├─ layout/
│  │  ├─ directory_layout.json
│  │  ├─ metadata_schema.json
│  │  └─ manifest_schema.json
│  ├─ assets/
│  │  ├─ icons/
│  │  ├─ splash/
│  │  └─ branding/
│  └─ scripts/
│     ├─ validate_distribution.py
│     ├─ verify_relocatable_paths.py
│     └─ inject_manifest.py
├─ windows/
│  ├─ nsis/
│  │  ├─ dominium_installer.nsi
│  │  ├─ include/
│  │  └─ resources/
│  ├─ inno/
│  │  ├─ dominium.iss
│  │  └─ resources/
│  ├─ manifest/
│  │  ├─ app_manifest.xml
│  │  └─ file_associations.xml
│  └─ scripts/
│     ├─ bundle_msvc_redistributables.py
│     ├─ generate_shortcuts.py
│     └─ sign_binaries.ps1
├─ linux/
│  ├─ deb/
│  │  ├─ control
│  │  ├─ postinst
│  │  ├─ prerm
│  │  └─ triggers
│  ├─ rpm/
│  │  ├─ dominium.spec
│  ├─ flatpak/
│  │  ├─ manifest.json
│  │  └─ sandbox-permissions.txt
│  ├─ appimage/
│  │  ├─ AppRun
│  │  ├─ dominium.desktop
│  │  └─ dominium.png
│  └─ scripts/
│     ├─ build_deb.py
│     ├─ build_rpm.py
│     ├─ build_flatpak.py
│     └─ build_appimage.py
├─ macos/
│  ├─ bundle/
│  │  ├─ Dominium.app/
│  │  │  ├─ Contents/
│  │  │  │  ├─ Info.plist
│  │  │  │  ├─ MacOS/dominium
│  │  │  │  ├─ Resources/
│  │  │  │  └─ Frameworks/
│  │  └─ resources/
│  ├─ dmg/
│  │  ├─ layout.json
│  │  └─ background.png
│  └─ scripts/
│     ├─ sign_app.sh
│     ├─ notarize_app.sh
│     └─ create_dmg.sh
├─ retro/
│  ├─ dos/
│  │  ├─ floppy_1440k_layout/
│  │  ├─ cdrom_iso9660/
│  │  └─ dos_installer.bat
│  ├─ win3x/
│  │  ├─ setup.inf
│  │  ├─ cab_files/
│  │  └─ win16_installer.rtf
│  ├─ win9x/
│  │  ├─ setup.iss
│  │  └─ uninstall.inf
│  └─ mac_classic/
│     ├─ disk_image.smi
│     ├─ Finder_metadata/
│     └─ CFBundleInfo
└─ scripts/
   ├─ full_release_pipeline.py
   ├─ checksum_release.py
   ├─ verify_retro_format.py
   └─ generate_release_notes.py

1. /packaging/README.md
Must explain:
• What /packaging is for: installers, images, archives.
• It must never contain:
o Engine code
o Game logic
o Mods
o Runtime determinism decisions
• Release pipeline is:
/build → /packaging/scripts/full_release_pipeline.py → platform packages.
• Retro packaging is fully isolated and must obey 8.3 filenames and memory constraints.

2. /packaging/common/
Shared schemas, branding, validation tools.
2.1 /common/layout/
directory_layout.json
Defines canonical install directory structure for all platforms:
{
  "bin": ["dominium", "dominium_server", "domedit"],
  "data": ["base/", "dlc/", "packs/"],
  "docs": ["manual/", "licences/"],
  "mods": [],
  "saves": [],
  "config": []
}
Rules:
• Installer must place binaries & data exactly as this schema dictates.
• Paths must be relocatable on Linux and macOS.
• Windows requires registry + Start Menu shortcuts but must not hardcode data paths.
metadata_schema.json
Defines structure of the final metadata file bundled with each release:
{
  "app_id": "dominium",
  "engine_version": "3.0.0",
  "git_commit": "abc123",
  "build_config": "release",
  "date": "YYYY-MM-DD",
  "supported_platforms": ["linux", "win", "mac"],
  "content_hash": "sha256:..."
}
manifest_schema.json
Defines the optional manifest attached to the install:
• File list
• Hashes
• Optional signatures
• DLC + mods included
Used for validating integrity post-installation.

2.2 /common/assets/
Branding assets for installers:
• Icons
• Splash screens
• Default wallpapers
• Launch screen backgrounds
Rules:
• Must follow branding guidelines in /docs/design.
• Never used by runtime game.
• Must support multiple resolutions.

2.3 /common/scripts/
Tools shared by all platform packagers:
validate_distribution.py
Runs checks:
• Directory layout compliance
• Manifest correctness
• Hash consistency
• No dev-only files included (debug symbols, tests, source)
verify_relocatable_paths.py
Ensures:
• No absolute paths in packaged files
• No hardcoded C:\Program Files or /usr/share paths
• No baked-in developer usernames or home paths
inject_manifest.py
Packs runtime metadata into the release directory.

3. /packaging/windows/
Contains installer definitions and Windows-specific distribution tooling.
3.1 /windows/nsis/
• .nsi installer script templates
• Icon resources
• Branding
• Shortcut definitions
Installer capabilities:
• Optional components (client, server, editor, tools)
• Registry entries for uninstall
• Correct setting of %APPDATA%/Dominium config path
• Hash verification post-install
Prohibitions:
• No installation of MSVC redistributables unless explicitly declared in your licensing.
3.2 /windows/inno/
Alternative installer engine (.iss).
Same prohibitions as NSIS.
3.3 /windows/manifest/
Defines Windows application manifests:
• DPI awareness
• OS compatibility settings
• File association definitions
• UAC execution levels
Must not:
• Use deprecated manifests
• Hardcode 32/64-bit decisions into shared files
3.4 /windows/scripts/
• Bundling redistributables
• Code signing
• Shortcut creation
Cannot modify game content.

4. /packaging/linux/
Supports Debian, RPM, Flatpak, and AppImage.
4.1 /linux/deb/
Contains:
• control file
• postinst, prerm, triggers scripts
• Service files if server is packaged as a systemd service (optional)
Rules:
• Must respect FHS:
o /usr/bin/dominium
o /usr/share/dominium/data
o /usr/share/doc/dominium
o /var/lib/dominium for server autosaves
Prohibitions:
• Must not write into user home during install.
4.2 /linux/rpm/
dominium.spec determines:
• Provided/Required packages
• Install locations
• Scripts (post-install, pre-remove)
Testing must ensure:
• rpm build is reproducible
• No file conflicts
4.3 /linux/flatpak/
manifest.json defines:
• Sandbox permissions
• Runtime version
• File structure
• Gnome/KDE integration if needed
Rules:
• No elevated permissions without justification (e.g. network).
• Allow user mod directory under $HOME.
4.4 /linux/appimage/
Includes:
• AppRun script
• .desktop file
• Icons
Rule:
• Entire runtime must be self-contained.

5. /packaging/macos/
5.1 /macos/bundle/
Defines .app bundle layout:
Dominium.app/
├─ Contents/
│  ├─ Info.plist
│  ├─ MacOS/dominium
│  ├─ Resources/
│  └─ Frameworks/
Rules:
• Must follow Apple bundle structure strictly.
• Icons, plist metadata must match brand spec.
• Bundle IDs must be stable across versions.
5.2 /macos/dmg/
Defines DMG appearance:
• Background
• Icon positions
• Volume name
layout.json determines internal representation.
5.3 /macos/scripts/
sign_app.sh
Code-signs .app with developer certificate.
notarize_app.sh
Uploads for notarization.
create_dmg.sh
Builds DMG image reproducibly.

6. /packaging/retro/ — DOS, Win3.x, Win9x, Mac Classic
Critical for your requirement of full retro compatibility.
6.1 /retro/dos/
Contains:
• Floppy image layouts (1.44MB, 720KB).
• ISO-9660 tables for CD-ROM builds.
• dos_installer.bat with SFN names only.
• Optional compression tools (PKZIP-compatible).
Rules:
• 8.3 filenames only.
• MAX DIR DEPTH: 8 levels.
• No long filenames or mixed case.
• CONTENT MUST FIT MEMORY CONSTRAINTS:
o 16 MB typical DOS extenders
o No dynamic linking
6.2 /retro/win3x/
• .INF setup scripts
• .CAB file lists
• Win16-compatible Installer RTF
Rules:
• No long filenames.
• Must rely on Win16 loader conventions.
• Must support installation to arbitrary paths.
6.3 /retro/win9x/
• Inno or custom setup.iss
• 32-bit installer
• Optional DirectX 7 redistributable
Rules:
• Long filenames allowed, but avoid Unicode.
• Installer must check for missing VC++ 6.0 runtimes.
• Must not overwrite system DLLs.
6.4 /retro/macos_classic/
• .smi self-mounting disk image
• Finder alias metadata
• System 7/8/9 layout constraints
Prohibitions:
• No Carbon-only APIs referenced in metadata.
• All files must include resource forks correctly.

7. /packaging/scripts/ — cross-platform release pipelines
7.1 full_release_pipeline.py
Coordinates:
1. Build across all platforms.
2. Collect outputs.
3. Construct package folders.
4. Insert manifests.
5. Generate installer images.
6. Produce checksums.
7. Prepare upload artifacts.
Must be deterministic with fixed inputs.
7.2 checksum_release.py
Computes SHA-256 or BLAKE3 checksums:
• For binaries
• For package directories
• For manifests
Stores results in release metadata.
7.3 verify_retro_format.py
Ensures:
• All DOS/Win3.x Win9x bundles obey constraints.
• No filename exceeds 8.3.
• No file >2GB in ISO.
• All resource forks intact (Mac Classic).
7.4 generate_release_notes.py
Produces human-readable release notes using:
• Changelog fragments
• Build metadata
• DLC/mod lists
Never modifies the game logic.

8. Global Prohibitions
Hard prohibitions:
• No engine/game code in /packaging.
• No mods or DLC content.
• No unlicensed branding assets.
• No installer actions that write into protected system paths without justification.
• No absolute paths within packaged files.
• No platform-specific hacks that alter runtime determinism (e.g. injecting command-line flags).
Determinism rules:
Packaging must not influence simulation determinism.
Two builds of identical version + commit must produce the same simulation behaviour regardless of installer differences.
Security rules:
• No embedded scripts that execute downloaded files.
• No network access required for installation except macOS notarization.
• No elevation without user permission.

9. Summary
/packaging is the authoritative directory for producing official distributables:
• Windows installers (NSIS/Inno)
• Linux DEB/RPM/Flatpak/AppImage
• macOS .app bundles and DMGs
• Retro images (DOS, Win3.x, Win9x, Mac Classic)
• Branding, manifests, metadata schemas
• Release packaging scripts
It must adhere to strict reproducibility, stability, retro constraints, and cross-platform correctness.

Next message: dev-spec for /scripts/ — meta-automation, repository maintenance, analysis tools, and CI helpers that are not build system code.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Below is the dev-spec for /scripts/, the repository’s meta-automation layer.
This directory is not part of the deterministic runtime, the build system, or the packaging pipeline; it is the home of:
• Repo maintenance tools
• Workspace automation
• Analysis and linting utilities
• CI helpers
• Documentation generators
• Source-tree inspectors
Nothing in /scripts ever ships with any game runtime.
Nothing here may modify simulation behaviour.

0. Directory layout (canonical)
/scripts/
├─ README.md
├─ maintenance/
│  ├─ clean_repo.py
│  ├─ prune_artifacts.py
│  ├─ verify_symlinks.py
│  └─ validate_headers.py
├─ analysis/
│  ├─ scan_includes.py
│  ├─ dependency_graph.py
│  ├─ measure_loc.py
│  ├─ detect_cycles.py
│  └─ api_compat_check.py
├─ docs/
│  ├─ build_docs.py
│  ├─ check_md_links.py
│  ├─ extract_public_api.py
│  └─ generate_html_docs.py
├─ ci/
│  ├─ premerge_checks.py
│  ├─ verify_license_headers.py
│  ├─ detect_untracked_files.py
│  ├─ check_directory_contracts.py
│  └─ ensure_determinism_constraints.py
├─ format/
│  ├─ clang_format_all.sh
│  ├─ normalize_whitespace.py
│  ├─ license_header_inject.py
│  └─ remove_trailing_space.sh
├─ mod_tools/
│  ├─ mod_scaffold.py
│  ├─ mod_lint.py
│  ├─ validate_mod_json.py
│  └─ convert_legacy_mod.py
└─ helpers/
   ├─ grep_todo.sh
   ├─ find_large_files.py
   ├─ file_hash_tree.py
   └─ search_string_ci.py
All subdirectories are purely optional tooling; they do not influence runtime logic, determinism, or user gameplay.

1. /scripts/README.md
Must explain:
• This directory contains repository-level automation scripts only.
• Nothing inside /scripts is required to run the game or editor.
• Scripts must not write to /engine, /game, /data/base automatically unless invoked explicitly by a maintainer.
• Scripts may use any modern language (Python 3 recommended).
• Scripts must never be executed by the engine or modding environment.
Also clarifies:
• Scripts are allowed FLOPs, nondeterminism, timestamps, network access (for dev workflows only).
• Scripts must not silently modify tracked files unless the user explicitly intends to run a maintenance or reformat.

2. /scripts/maintenance/ — repository housekeeping
clean_repo.py
Removes:
• Orphaned temp files
• Editor swap files
• Local build folders outside /build/output
• Redundant caches
Must not touch:
• /engine
• /game
• /data/base
• /mods
prune_artifacts.py
Finds:
• Large, accidental binary commits
• Misplaced assets
• Non-source files outside approved directories
verify_symlinks.py
Ensures symlinks:
• Point only inside repo
• Are valid on all platforms supporting symlinks
• Are not accidentally used in deterministic runtime
validate_headers.py
Checks:
• Include guards
• License headers
• No forbidden headers in deterministic modules (<random>, <chrono>, <thread>)

3. /scripts/analysis/ — repo-wide static analysis
scan_includes.py
Builds a tree of include relationships:
• Detects platform leakage (windows.h in wrong places)
• Highlights layering violations – e.g., /engine including /game
dependency_graph.py
Produces a .dot graph of:
• Engine module dependencies
• Game module dependencies
• Cross-layer coupling
Used to enforce clean architecture.
measure_loc.py
Counts lines of code by module:
• C89/C++98 compliance stats
• Tests vs engine proportions
detect_cycles.py
Detects circular dependencies:
• Between C modules
• Between script modules
• Between data definitions (e.g., tech tree references)
Must fail CI if cycles violate architectural rules.
api_compat_check.py
Ensures:
• Public engine APIs have not broken without explicit version bump
• Lua/mod API changes are correctly noted in /docs/spec

4. /scripts/docs/ — documentation generation
build_docs.py
Converts:
• Markdown → HTML, PDF (via Pandoc or internal tooling)
• Code comments → API reference
Must never rewrite /docs/spec itself.
check_md_links.py
Ensures:
• No dead links within /docs/
• No external URLs pointing to non-canonical sources
extract_public_api.py
Parses header files under /engine:
• Generates lists of symbols exposed to scripts, mods, or game layer
• Detects undocumented exported APIs
generate_html_docs.py
Builds standalone documentation site:
• Deterministic output for CI diffs
• Uses a pinned version of documentation theme

5. /scripts/ci/ — CI-enforced policy scripts
These scripts must run automatically on merge request pipelines.
premerge_checks.py
Runs:
• Code style
• Directory contract checks
• Basic lint
• Dependency scans
Fails if any violations occur.
verify_license_headers.py
Confirms:
• Every code file has correct license header
• Third-party license notices are accurate
• No missing/invalid SPDX tags
detect_untracked_files.py
Ensures the repo contains:
• No stray build outputs
• No generated files outside permitted directories
check_directory_contracts.py
Checks adherence to the directory rules defined in:
• /docs/spec/DIRECTORY_CONTRACT.md
• The canonical directory rules you provided earlier
Flags violations:
• Engine code in /game
• Data in /engine
• Mods inside /data
ensure_determinism_constraints.py
Validates:
• No use of floats in deterministic engine modules
• No nondeterministic libc functions
• No usage of timers or threads
• No unordered containers unless stable wrappers
If any determinism violation is detected → pipeline fails.

6. /scripts/format/ — code formatting and normalization
clang_format_all.sh
Runs clang-format using pinned .clang-format file.
Engine C89/C++98 must use conservative formatting rules (avoid rewriting signatures).
normalize_whitespace.py
Enforces:
• No tab/space inconsistency
• No Unicode whitespace in code files
• No trailing spaces
• Normalized end-of-line conventions (LF everywhere except retro ports)
license_header_inject.py
Batch tool to inject or update license headers across source tree.
remove_trailing_space.sh
Simple sh utility to ensure trailing whitespace is removed before commit.

7. /scripts/mod_tools/ — modder support tools
mod_scaffold.py
Generates a new mod folder with:
• Standard structure
• Example mod.json
• Example /data and /scripts dirs
• Namespacing templates
mod_lint.py
Validates:
• Illegal overrides
• Invalid field values
• Broken references
• Missing localized strings
Fails if schema violations occur.
validate_mod_json.py
Checks for manifest correctness:
• id rules
• dependency correctness
• determinism flags
• versioning
convert_legacy_mod.py
Upgrades old mod formats to new schema (if you introduce versioned mod APIs).
Prohibitions:
• Must not auto-fix breaking changes silently.
• Must never modify the canonical game data.

8. /scripts/helpers/
Small, optional convenience utilities:
grep_todo.sh
Finds TODO/HACK/FIXME lines for audits.
find_large_files.py
Identifies files exceeding project size thresholds.
file_hash_tree.py
Prints tree of SHA-256 of all files — used for offline integrity checks.
search_string_ci.py
CI-safe grep that fails if matches are found (useful for enforcing bans).
These tools must never be used by the game runtime.

9. Cross-cutting rules & prohibitions
9.1 Hard prohibitions
• No files in /scripts may:
o Influence deterministic simulation
o Modify core assets silently
o Introduce new build steps that fetch remote dependencies
o Insert code into /engine automatically
o Embed private keys or credentials
9.2 Repository hygiene constraints
• All scripts must be self-contained.
• Python scripts must be Python 3 only.
• Scripts must be platform-portable unless explicitly OS-specific.
• Scripts must include clear usage instructions.
9.3 Interaction with CI
• CI may call scripts in this directory.
• Scripts must return nonzero exit codes on failure.
• Scripts must support quiet mode (--ci) to suppress noise.

10. Summary
/scripts is the meta-automation toolbox that keeps the repository clean, consistent, and maintainable.
It enforces:
• Directory contracts
• Determinism rules
• Licensing compliance
• Documentation upkeep
• Modding hygiene
• Dependency correctness
• CI integration
It is entirely separate from:
• The build system (/build)
• The packaging system (/packaging)
• The runtime (/engine / /game)
Its only mission is quality control and developer efficiency.

Next message will define the dev-spec for /ports/, covering DOS, Win9x, Win3.x, macOS Classic, WASM, and console target directories — architecture, constraints, build expectations, and isolation rules.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Below is the full dev-spec for /ports/ — the directory containing alternative, experimental, legacy, or non-primary platform targets.
Unlike /engine/platform, which holds production-grade cross-platform layers, /ports contains specialised glue code, build configurations, and shims for:
• DOS
• Win3.x
• Win9x
• macOS Classic
• WASM
• Consoles
• Any constrained or retro platform
Nothing here is authoritative for the core engine.
Nothing here may alter runtime determinism.
Every port is optional and must degrade gracefully when not built.

0. Directory Layout (Canonical)
/ports/
├─ README.md
├─ dos/
│  ├─ src/
│  │  ├─ dom_port_dos.c
│  │  ├─ dom_port_dos.asm
│  │  └─ dos_video_shim.c
│  ├─ include/
│  │  └─ dos_platform.h
│  ├─ config/
│  │  ├─ memory_model.mk
│  │  ├─ watcom_wmake.mk
│  │  └─ linker.lnk
│  ├─ tools/
│  │  ├─ pack_assets_8x8.py
│  │  └─ exe_stub_builder.py
│  └─ docs/
│     └─ DOS_PORT_NOTES.md
├─ win3x/
│  ├─ src/
│  ├─ include/
│  ├─ config/
│  └─ docs/
├─ win9x/
│  ├─ src/
│  ├─ include/
│  ├─ config/
│  └─ docs/
├─ mac_classic/
│  ├─ src/
│  ├─ include/
│  ├─ config/
│  └─ docs/
├─ wasm/
│  ├─ src/
│  ├─ include/
│  ├─ config/
│  └─ docs/
└─ console_*/               # e.g. console_ps2, console_psp, console_switch
   ├─ src/
   ├─ include/
   ├─ config/
   └─ docs/
Each port directory includes:
• src/ — platform-specific implementation files
• include/ — platform API surface used by /engine/platform
• config/ — toolchain + linker rules
• tools/ — auxiliary converters or preprocessors
• docs/ — port-specific constraints and instructions

1. /ports/README.md
Must explain:
• /ports houses non-primary platforms.
• Ports exist outside the determinism guarantee of the authoritative engine.
• Ports may have missing features due to hardware limitations.
• Ports may not change engine design; they adapt the engine to their constraints.
It must clearly state:
• Primary platforms: Windows, Linux, macOS (modern).
• Secondary ports: DOS, Win3.x, Win9x, macOS Classic, WASM.
• Experimental: consoles, handhelds.

2. Global Porting Rules
Every /ports/<target> directory must obey:
2.1 No modification of /engine logic
Ports may wrap, but never rewrite, the engine.
2.2 No nondeterminism injected
Ports must:
• Maintain deterministic simulation loop
• Avoid floating-point inconsistency
• Avoid high-precision timers
• Avoid dynamic allocation unless port allows it
2.3 Layering rules
A port may only interact with:
• /engine/platform interfaces
• /engine/render/* backends
• /engine/audio/* backends
• /third_party (as allowed)
Ports must not:
• Include game logic
• Include mod loader logic
• Encode rules about data formats
2.4 Build isolation
Port builds must:
• Use separate toolchains
• Use separate output directories
• Not contaminate main CMake build
2.5 Filename constraints
Retro ports must respect:
• 8.3 filenames (DOS, Win3.x)
• No deep directory nesting
• No Unicode
• No long paths
2.6 Memory constraints
Retro ports enforce their own memory budgets documented inside /ports/<target>/docs.

3. /ports/dos/ — MS-DOS 16/32-bit target (OpenWatcom)
This is the most constrained and the most important retro port.
3.1 /dos/src/
dom_port_dos.c
Implements:
• BIOS/VESA video interface
• Keyboard polling
• Timer interrupt override
• DOS file API shims
• Memory model bootstrap
Must obey:
• 16:16 pointer restrictions
• DPMI protocol for 32-bit extender
• No dynamic heap expansions once simulation starts
dom_port_dos.asm
Implements:
• Real-mode BIOS calls
• Protected-mode transitions
• VESA bank switching
dos_video_shim.c
Implements a minimal fixed-resolution blitter:
• 320×200, 320×240, optionally 640×480
• 8-bit paletted or 16-bit packed pixels
Cannot use:
• Full modern GPU rendering
• High-resolution textures
• Floating-point transforms

3.2 /dos/include/dos_platform.h
Provides:
• DOS-specific typedefs
• Platform capability flags
• Memory model macros
• Interrupt callback definitions
Must ensure:
• Clean separation from /engine/platform APIs
• Zero use of C99 types (must remain C89 / Watcom-compatible)

3.3 /dos/config/
memory_model.mk
Defines:
• SMALL, MEDIUM, LARGE, HUGE memory models
• DPMI extender options
• Segment allocation strategy
watcom_wmake.mk
Defines compilation rules for OpenWatcom:
• Compiler flags
• Linker script definitions
• Map file generation
linker.lnk
Watcom linker script for EXE generation.

3.4 /dos/tools/
pack_assets_8x8.py
Converts modern sprites → 8×8 or 16×16 tiles used by retro blitter.
exe_stub_builder.py
Builds DOS stub for dual-mode executable wrappers.

3.5 /dos/docs/DOS_PORT_NOTES.md
Documents:
• Max memory usage
• Video modes supported
• File IO limitations
• Input sampling latency
• Things explicitly not supported (full audio stack, high-res, mods)

4. /ports/win3x/ — Win16 target
Constraints:
• 16-bit segmented memory
• Limited stack (typically <64 KB)
• GDI-based rendering (monochrome, 8-bit, 16-bit palette)
• Cooperative multitasking
src/ implements:
• Win16 window + GDI loop
• Minimal DirectDraw-style blitting (where possible)
• File IO wrappers
include/ contains:
• Win16-compatible API shims
• MIcro-Windows support glue
config/ contains:
• MASM + VC++ 1.x project files
• 8.3 filename policies

5. /ports/win9x/ — Windows 95/98/ME
This port is more featureful:
• 32-bit
• DirectX 7 rendering path allowed
• WinMM sound subsystem
• Long filenames allowed
Limitations:
• No Unicode (must use ANSI Win32 APIs)
• No NT kernel features
• Must support 64–128 MB RAM profiles
src/ implements:
• Window creation
• DirectDraw 7 + DirectSound shims
• Minimal CPU feature detection

6. /ports/mac_classic/ — System 7/8/9
Constraints:
• Carbon API is allowed only if OS 8.6/9+ chosen
• No POSIX layer
• Cooperative threading
• No modern OpenGL versions; use QuickDraw or RAVE
src/ implements:
• Event loop
• QuickDraw blitting
• Resource fork loader (critical)
config/ holds:
• CodeWarrior project files
• MPW build scripts

7. /ports/wasm/ — WebAssembly target
This is an experiment, not primary platform.
Constraints:
• No filesystem except browser virtual FS
• No OS threads
• No native sockets
• Limited memory (128–1024MB)
• Floating point allowed but must not affect determinism
src/ contains:
• JS glue (Emscripten)
• WebGL1/2 renderer backend
• Browser input integration
include/ supplies:
• WASM-specific dom_platform_wasm.h
• Async ABI wrappers
config/ includes:
• Emscripten minimal config
• LTO rules for small bundle size
Rules:
• Deterministic simulation must run in a synchronized main loop controlled by the engine — never by requestAnimationFrame.
• Rendering may be async, but sim must not depend on render timing.

8. /ports/console_*/ — console-specific ports
Examples: console_ps2, console_psp, console_switch.
Constraints (generalised):
• Proprietary SDKs must not be stored in repository.
• Headers must be abstracted behind shims.
• Ports must not violate platform NDAs.
• Binaries may only be built locally with legal access to SDKs.
src/ implements:
• Controller input
• GPU-specific rendering
• Memory-card/flash save handling
config/ contains:
• Makefiles
• Linker scripts
• Platform ABI rules
docs/ records:
• Hardware memory budgets
• Render pipeline limits
• CPU instruction constraints

9. Global Prohibitions for /ports
Absolute rules:
• /ports must never redefine engine modules.
• /ports must not introduce platform-specific simulation logic.
• /ports must not include third-party libraries that bypass /third_party.
• /ports cannot hardcode gameplay rules or modify global constants.
• No port may require changes to /engine/sim, only to /engine/platform.
• No absolute paths or OS-dependent behaviour may leak into main build.

10. Determinism Expectations
• Simulation must remain bit-stable across ports.
• Only presentational differences (rendering, UI, audio) may vary.
• Ports must use identical fixed-point math modules as primary engine.
• Ports must respect deterministic RNG seeds.
• Ports must ensure identical tick-to-tick sequencing.
Retro ports may reduce render fidelity but never simulation fidelity.

11. Summary
/ports provides platform-specific adapters for systems that fall outside the mainline platforms:
• DOS
• Win3.x
• Win9x
• macOS Classic
• WASM
• Game consoles
Its responsibilities:
• Implement minimal runtime glue
• Honour strict determinism
• Never modify engine architecture
• Survive extreme hardware limitations
• Begin and end at the platform boundary
It is allowed to be incomplete, experimental, or reduced-feature.
But it is never allowed to compromise the engine.

If you want, next we can generate dev-specs for the top-level files themselves (e.g., LICENSE, root README, CMakeLists.txt, .clang-format, .gitattributes, versioning rules, release branch structure).
You said:
Okay next will be all of those, starting with a fully fledged maximally inclusive readme.md in a code block
ChatGPT said:
GPT-5.1 • 2025-12-03
# DOMINIUM  
## A Deterministic, Multi-Scale, Multi-Platform Simulation Engine and Game

Dominium is a **fully deterministic**, **integer-math**, **platform-agnostic**, **modular** engine and game built to run identically across:

- Modern systems (Windows, Linux, macOS)
- Legacy systems (Win9x, Win3.x, DOS, macOS Classic)
- Future systems (WASM/Web, consoles, embedded)
- Headless servers (dedicated simulation clusters)

Dominium is not “a game with an engine.”  
Dominium *is an engine*, with one official game built on top of it.  
Everything is deterministic, from physics to pathfinding to networks, across all supported targets.

This repository contains the full source tree for:
- The **Dominium Engine** (core deterministic C89/C++98 code)
- The **Dominium Game** (content-agnostic gameplay logic layer)
- The **Data Packs** (first-party assets)
- The **Tools & Editors**
- The **Ports** (retro and alternative platforms)
- The **Specification documents** (binding behaviour contract)
- The **Modding API** (deterministic, forward-compatible)

---

# 1. PROJECT VISION

Dominium aims to:

1. Provide a **universally reproducible simulation** where any two machines, of any architecture or era, produce identical results tick-for-tick.
2. Support **extreme temporal and spatial scales**, from 16th-meter microgrids up to multi-gigameter planetary surfaces and multi-system galaxies.
3. Run across decades of hardware, including ultra-constrained retro platforms.
4. Be **maximally modifiable**, without compromising determinism.
5. Support **2D and 3D vector and raster rendering**, interchangeable on the fly.
6. Support **surface and orbital simulation**, including:
   - Orbital ships and stations  
   - Docking/undocking  
   - Re-entry and ascent profiles (rails-based or approximate dynamics)  
   - Cargo tugs, drop pods, and construction of orbital infrastructure  
7. Provide a **unified construction system** using:
   - Block-based structural components  
   - Edge/face walls, floors, slabs, ramps  
   - Arbitrary vector splines (tunnels, rails, roads, bridges)  
   - Cut/fill terrain interaction  
   - Arbitrary grade or cliff formation  
8. Maintain a **clean separation** between:
   - Physical domains (surfaces)
   - Logical domains (space, orbital tracks)
9. Support a fully deterministic **multiplayer / multi-server universe** capable of coordinating many planets.

Dominium is built to last for decades and outlive the hardware it first shipped on.

---

# 2. CORE PHILOSOPHY

The entire engine is designed around the following non-negotiable principles:

### 2.1 Determinism
Every simulation result is bit-identical for:
- Same inputs  
- Same tick schedule  
- Same modset  
- Same engine version  

No floating point appears in simulation code.  
All math uses integers or fixed-point formats.

### 2.2 Strict Phasing and Ordering
The engine is structured into immutable tick phases:
1. Input  
2. Pre-state  
3. Simulation (multi-lane)  
4. Networks  
5. Merge  
6. Post-process  
7. Finalize  

No system may run outside its assigned slot.

### 2.3 Spatial Hierarchy
Worlds are structured into multi-scale grids:

Subnano = 1/65536 m
Submicro = 1/4096 m
Submini = 1/256 m
Subtile = 1/16 m
Tile = 1 m
Subchunk = 16 m
Chunk = 256 m
Subregion = 4096 m
Region = 65536 m
Subcontinent = 1,048,576 m
Continent = 16,777,216 m
Supercont. = 268,435,456 m
Surface = 4,294,967,296 m

One surface per planet.

Surfaces are **not continuous arrays**, but **collections of sparse microgrids**, enabling:
- Underground structures  
- Cut/fill  
- Multi-level buildings  
- Vector networks intersecting grids  

### 2.4 Universal Modularity
Everything is plug-and-play:
- Renderers (OpenGL, DX9, DX11, SDL vector)
- Audio backends  
- Platform backends  
- Data packs  
- Mods  
- Tools  

No engine modification required to add new content or systems.

### 2.5 Platform Breadth
The engine compiles and runs on:
- C89 compilers  
- No libc extensions  
- No platform-specific hacks in sim code  

Ports adapt to the engine, never the other way around.

---

# 3. REPOSITORY OVERVIEW

The repository is organised into top-level directories:

/docs – design and specification documents
/engine – deterministic engine core (C/C++98)
/game – game layer using engine
/data – base assets, DLCs, packs
/mods – third-party mod ecosystem
/tools – editors, devkits, pipelines
/tests – unit, integration, replay, perf tests
/third_party – vendored dependencies
/build – build scripts and outputs
/packaging – installers and retro media layouts
/scripts – automation and maintenance
/ports – DOS, Win3.x, Win9x, macOS Classic, WASM, consoles

Each directory is formally defined in the **Directory Contract** (`/docs/spec/DIRECTORY_CONTRACT.md`).

---

# 4. BUILDING

### 4.1 Modern platforms
Use CMake:

mkdir build
cd build
cmake ..
cmake --build .

### 4.2 Retro platforms
Each `/ports/<target>/config/` contains its own build instructions.

Examples:
- DOS: OpenWatcom + wmake  
- Win3.x: MASM + VC++ 1.52  
- Win9x: MSVC6 + DX7 SDK  
- macOS Classic: CodeWarrior + MPW  
- WASM: Emscripten  

These builds produce reduced-fidelity executables but identical simulation behaviour.

---

# 5. RUNNING

### 5.1 Headless server
./dominium_server --world myworld

### 5.2 Client
./dominium_client

Clients and servers communicate via deterministic lockstep protocols.

---

# 6. MODDING

Modding is deterministic and fully sandboxed.

Each mod directory contains:
- `mod.json` (manifest)
- Prefabs  
- Data packs  
- Scripts (optional, deterministic subset of Lua)  

Mod loading order:
1. Base  
2. DLC  
3. Mods sorted by UUID  

Mods may add:
- Entities  
- Blocks  
- Jobs  
- Networks  
- Graphical assets  
- UI  

Mods may not:
- Modify engine behaviour  
- Introduce nondeterministic code  
- Patch binaries  

---

# 7. DATA FORMAT BASICS

All simulation data uses:
- Integer math  
- Fixed-size structs  
- Little-endian  
- No padding  
- No floats  
- No pointers  

Save files contain:
- Entities  
- Components  
- Networks  
- Jobs  
- Messages  
- Prefab references  
- Chunk microgrids  
- World snapshot  
- Optional replay log  

Everything is CRC-verified and version-tracked.

---

# 8. SURFACE AND SPACE ARCHITECTURE

Dominium supports **two complementary domains**:

### 8.1 Physical domains  
- Planetary surfaces  
- Underground layers  
- Oceans  
- Terrain grids  
- Structural microgrids  
- Buildings  
- Vector networks (rails, roads, conveyors, pipes, tunnels)

### 8.2 Logical domains  
- Orbits  
- Transfer windows  
- Docking graphs  
- Lagrange points  
- Asteroid belts  
- Gas clouds  
- Electromagnetic hazard areas  
- Orbital stations and ships  

Space simulation is **on rails**, deterministic, integer-based:
- Discrete orbital tracks  
- Deterministic transitions  
- Docking ports as graph nodes  
- Cargo routing between orbital/logical nodes  

---

# 9. CONTRIBUTING

Contributions must follow:

- Determinism rules  
- Specification compliance  
- C89/C++98 core style  
- Strict linting (`clang-format`, `cpplint`)  
- No floating-point in simulation  
- No platform APIs outside `/engine/platform`  
- No game logic in `/engine`  

All new features require:
- Spec update  
- Tests (unit + replay)  
- Documentation  

---

# 10. LICENSE

The project is released under a tiered licensing system:

- Engine core: permissive open source licence (to be finalised)  
- Game assets: proprietary or CC-BY-NC depending on pack  
- Tools: open source  
- Mods: copyright remains with authors  

See `/docs/legal/LICENCE.md`.

---

# 11. STATUS

Dominium is under active development.

Completed:

- Deterministic kernel spec  
- ECS core foundation  
- Messaging architecture  
- Job system  
- Serialization v3  
- World chunk/subchunk format  
- Prefab system  
- Mod loader  
- Platform abstraction design  
- Rendering abstraction design  

In development:

- 2D/3D renderer integration  
- Full cut/fill terrain system  
- Orbital logistics  
- Worker/robot AI  
- Multiplayer server clusters  
- Editor suite  

---

# 12. CONTACT & COMMUNITY

- Discord: *TBD*  
- Developer Blog: *TBD*  
- Documentation Portal: `/docs/design/`  
- Issue Tracker: GitHub Issues  
- Roadmap: `/docs/spec/MILESTONES.md`  

---

# 13. ACKNOWLEDGEMENTS

Dominium stands on:
- The philosophy of deterministic simulation (Factorio, Dwarf Fortress inspirations)
- The engineering traditions of old-school C and embedded systems
- The desire to create a game that will run long after modern hardware becomes obsolete.

---

# 14. FINAL NOTE

Dominium is not a toy project.  
It is an attempt at a **universal simulation engine** that:

- Spans eras of hardware  
- Maintains perfect determinism  
- Supports planetary and orbital scales  
- Is fully extensible and moddable  
- Can run archived forever  

This README is a living document.  
All architectural detail lives in `/docs/spec`.

Welcome to Dominium.
You said:
Now a licence.md block. This should be completely restrictive, except for personal use and viewing of source only.
ChatGPT said:
GPT-5.1 • 2025-12-03
# LICENSE.md  
## DOMINIUM ENGINE AND GAME — RESTRICTED SOURCE VIEWING LICENSE  
### Version 1.0 (Draft)

This license governs all source code, data, assets, documentation, tools, and binaries contained within the Dominium repository (“the Software”).  
By obtaining, viewing, or using any portion of the Software, you agree to be bound by the terms of this License.

If you do not agree, you must immediately cease all use of the Software.

---

# 1. DEFINITIONS

**“Software”**  
All files, source code, binaries, assets, documentation, specifications, and tools contained in this repository, including derived or generated artifacts.

**“Author”**  
The copyright holder(s) of the Software.

**“You” / “User”**  
Any person who accesses, views, downloads, or executes the Software.

**“Personal Use”**  
Use exclusively by a single individual for private, non-commercial purposes on hardware owned or directly controlled by that individual.

**“Derivative Work”**  
Any modification, translation, transformation, or adaptation of the Software, including any work that uses or incorporates any part of the Software.

---

# 2. GRANT OF RIGHTS

## 2.1 Viewing Rights  
You are granted permission to **view** the source code for the sole purposes of:

- education  
- personal study  
- security review  
- compatibility evaluation  

This permission **does not** include the right to modify, compile, distribute, or publish any portion of the Software.

## 2.2 Personal Execution Rights  
You may compile and run the Software **only for Personal Use**, provided that:

1. The resulting binaries are used solely by you.  
2. They remain private and unshared.  
3. They are not distributed, transmitted, or made available to any other person.  
4. They are not used in any commercial, professional, or institutional context.  

---

# 3. RESTRICTIONS

## 3.1 No Redistribution  
You may **not** distribute, transmit, publish, or otherwise make available:

- any source code  
- any binaries  
- any modified or unmodified copies  
- any assets  
- any documentation  
- any derived materials  

This prohibition applies to all forms of distribution: public, private, commercial, non-commercial, networked, encrypted, or otherwise.

## 3.2 No Modification  
You may not modify, translate, patch, fork, or create derivative works based on the Software, except for temporary private modifications used exclusively for Personal Use and never shared or published.

## 3.3 No Incorporation  
You may not incorporate, embed, or link the Software or any portion of it into any other project, product, or codebase, regardless of purpose or scope.

## 3.4 No Commercial Use  
The Software may not be used:

- to generate revenue  
- in a business or institutional setting  
- as part of a commercial service  
- in research funded commercially or institutionally  
- for professional development or production workflows  

## 3.5 No Public Services  
You may not host any public or semi-public service (including game servers) built using the Software.

## 3.6 No Automated Extraction  
You may not use automated tools to extract data, assets, or structures from the Software for redistribution or reuse.

---

# 4. OWNERSHIP

All title, copyright, and intellectual property rights in and to the Software are retained exclusively by the Author.

You gain **no** ownership rights, license rights, or transfer rights by viewing or using the Software.

---

# 5. WARRANTY AND LIABILITY

## 5.1 No Warranty  
The Software is provided **“AS IS”** without warranty of any kind—express, implied, or statutory—including but not limited to:

- merchantability  
- fitness for a particular purpose  
- non-infringement  
- data accuracy  
- uptime or availability  

## 5.2 Limitation of Liability  
In no event shall the Author be liable for:

- direct, indirect, incidental, consequential, exemplary, or punitive damages  
- loss of data  
- loss of profit  
- business interruption  
- security breaches  
- legal claims arising from Your use of the Software  

Your sole remedy is to stop using the Software.

---

# 6. TERMINATION

This license terminates automatically and immediately if:

- You violate any term herein;  
- You distribute or publish any portion of the Software;  
- You create or distribute derivative works;  
- You use the Software for any non-personal purpose; or  
- The Author issues a written revocation.

Upon termination:

1. All permissions granted to You cease.  
2. You must delete all copies of the Software in your possession.  
3. You must destroy all derivative materials created from it.  

---

# 7. FUTURE LICENSING

The Author may release future versions of the Software under different terms, including more permissive or more restrictive licenses.  
No rights to future licenses are guaranteed.

---

# 8. GOVERNING LAW

This License is governed by the laws of the Author’s jurisdiction.  
Any disputes must be resolved exclusively in courts chosen by the Author.

---

# 9. ENTIRE AGREEMENT

This License constitutes the entire agreement between You and the Author.  
No oral or written communication modifies its terms unless published by the Author.

---

# 10. ACCEPTANCE

By downloading, viewing, compiling, or running any file in this repository, You agree to be bound by this License in full.

If You do not accept these terms, you must not use the Software.

---

© The Author. All Rights Reserved.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Provide the name of the next file or directory whose dev-spec you want generated.
You said “Next” after LICENSE.md, but there are multiple top-level files that could follow:
• README.md (done)
• LICENSE.md (done)
• CONTRIBUTING.md
• SECURITY.md
• CODE_OF_CONDUCT.md
• .gitignore
• .gitattributes
• CMakeLists.txt (root)
• VERSION
• BUILDING.md
• CHANGELOG.md
• Or begin the per-directory specs again under /docs, /engine, /game, etc.
State the next target.
You said:
Proceed in order: contributing
ChatGPT said:
GPT-5.1 • 2025-12-03
# CONTRIBUTING.md  
## Dominium — Contribution Requirements and Developer Contract  
### Version 1.0

This document defines the rules, constraints, and expectations for anyone wishing to contribute to the Dominium engine, game, tools, documentation, or related content.

Dominium is a **deterministic, integer-math, multi-platform simulation engine**.  
Contributions must preserve determinism, architecture, modularity, and long-term maintainability.

If a contribution violates these principles, it will not be accepted.

---

# 1. OVERVIEW

Dominium consists of:

- `/engine` — deterministic core engine  
- `/game` — Dominium gameplay layer  
- `/data` — first-party assets  
- `/mods` — third-party mod ecosystem  
- `/ports` — retro/alternative platform adapters  
- `/tools` — editors and pipelines  
- `/docs` — specifications and design rules  

This structure is governed by the **Directory Contract** in `/docs/spec/DIRECTORY_CONTRACT.md`.  
Contributions must comply with it exactly.

---

# 2. CONTRIBUTION TYPES

Accepted contribution categories:

1. **Bug fixes**  
2. **Deterministic correctness improvements**  
3. **Documentation improvements**  
4. **Specification updates**  
5. **Additions to tools/editor suites**  
6. **Rendering backend improvements**  
7. **Platform backend implementations**  
8. **Testing (unit, integration, replay)**  

The following categories are restricted or disallowed:

- **New gameplay features** — must be preceded by a spec update.  
- **Modding API changes** — must not break determinism or backwards compatibility.  
- **Simulation changes** — require design review and deterministic test coverage.  
- **Asset additions** — require compliance with licensing and file format rules.

---

# 3. CONTRIBUTION FLOW

Every contribution follows this sequence:

1. **Issue or Proposal Opened**  
   - Describe the problem, not the solution.  
   - Reference relevant sections of the spec.

2. **Specification Review (if needed)**  
   - Simulation-affecting changes must update `/docs/spec/SPEC-core.md` first.  
   - Rendering/platform-only changes may skip this.

3. **Pull Request**  
   Must include:
   - Exact files changed  
   - Rationale  
   - Determinism impact analysis  
   - Test coverage  
   - Code style compliance  

4. **CI Determinism Validation**  
   - Replay tests  
   - Hash-based world state comparisons  
   - Cross-platform determinism checks  

5. **Human Review**  
   Reviews focus on:
   - Architectural compliance  
   - Determinism  
   - Abstraction boundaries  
   - Maintainability  
   - Simplicity  

6. **Merge or Revision Requested**

---

# 4. CODING STANDARDS

### 4.1 Language Restrictions  
- `/engine/core` and `/engine/sim` must use **strict C89**.  
- High-level game code may use **C++98** but not beyond.  
- No exceptions, RTTI, templates, or STL.  
- No C99/C11 features.  
- No floating-point in simulation.  
- No platform headers in engine code.

### 4.2 Naming Conventions  
Everything in the engine follows:

dom_<subsystem><module><function>()
DOM_<SUBSYSTEM><CONST_NAME>
dom<structname>_t

Game code follows parallel conventions:

dg_<module>action()
dg<component>_t

### 4.3 File Structure  
Each module pair must be:

something.h
something.c

No header-only simulation code.  
All private helper functions must be `static` in `.c` files.

### 4.4 Include Rules  
- Headers include only forward declarations or minimal engine headers.  
- No circular includes.  
- No platform or OS headers in the engine.  
- No third-party headers outside `/third_party`.

### 4.5 Memory Rules  
- No malloc inside tight loops.  
- No unbounded allocations.  
- All simulation memory must be owned by a stable allocator.  
- Pointers must never be persisted across simulation frames unless explicitly guaranteed stable.

---

# 5. DETERMINISM REQUIREMENTS

Every contribution must maintain determinism across:

- CPU architectures  
- Endianness  
- Compilers  
- Operating systems  
- Rendering backends  
- Platform backends  

### Determinism Prohibitions  
- No random numbers without using `dom_core_rng`.  
- No floating-point arithmetic in simulation.  
- No time-based behaviour.  
- No OS-dependent scheduling or file operations.  
- No thread-based race conditions.  
- No reliance on undefined or implementation-defined C behaviour.  

---

# 6. TESTING REQUIREMENTS

All contributions must include:

### 6.1 Unit Tests  
Under `/tests/unit`.

### 6.2 Integration Tests  
Under `/tests/integration`.

### 6.3 Replay Determinism Tests  
Under `/tests/replay`.

Simulation bugs are not accepted without a replay test demonstrating reproducibility.

---

# 7. DIRECTORY BOUNDARY RULES (MANDATORY)

### 7.1 `/engine`  
Contains deterministic engine logic only.  
No game rules.  
No assets.  
No platform-specific code.  
No OS calls.

### 7.2 `/engine/platform`  
Contains OS-specific wrappers only.  
No simulation code.  
No rendering or audio code.

### 7.3 `/engine/render`  
Rendering backends only.  
No simulation logic.  
No gameplay rules.

### 7.4 `/game`  
Contains gameplay layer.  
Must not depend on platform code directly.

### 7.5 `/data`  
Contains assets.  
No executable code.

### 7.6 `/mods`  
User mods.  
Must not modify engine source.  
Must not introduce nondeterministic behaviour.

### 7.7 `/ports`  
Experimental or legacy platform adapters.  
Must not alter core engine architecture.

Breaking boundary rules is grounds for rejection.

---

# 8. DOCUMENTATION REQUIREMENTS

Every contribution must:

- Document all new functions in headers.  
- Update relevant sections of `/docs/spec`.  
- Provide comments explaining invariants, constraints, and determinism concerns.  
- Include diagrams or flow descriptions for complex systems.  
- Provide rationale for architectural decisions.  

Undocumented contributions will not be merged.

---

# 9. SECURITY & SAFETY REQUIREMENTS

Contributions must not introduce:

- Unsafe memory behaviour  
- Buffer overflows  
- Undefined behaviour  
- Race conditions  
- Input handling vulnerabilities  
- Unbounded loops  
- Crash-on-invalid-input scenarios  

All file formats must validate input boundaries.

---

# 10. REVIEW HIERARCHY

If a contribution touches any of the following, it requires **architectural approval**:

- Simulation tick pipeline  
- Determinism kernel  
- ECS model  
- Serialization  
- Networking  
- Rendering abstraction  
- Platform abstraction  
- Modding API  

Minor cosmetic fixes do not require full review.

---

# 11. WHAT WILL NOT BE ACCEPTED

The following contributions are automatically rejected:

- Floating-point simulation logic  
- Non-deterministic features  
- Platform-dependent behaviour in engine code  
- Refactors that degrade clarity  
- Memory-increasing changes without justification  
- C99/C11/C++11 syntax  
- Gameplay changes without corresponding spec updates  
- Engine redesign proposals outside spec boundaries  
- Attempts to bypass the Directory Contract  
- New dependencies not approved by maintainers  

---

# 12. HOW TO GET STARTED

1. Read `/docs/spec/SPEC-core.md`  
2. Read `/docs/spec/DIRECTORY_CONTRACT.md`  
3. Build the engine following `/docs/spec/BUILDING.md`  
4. Run deterministic replay tests  
5. Open an issue describing the intended contribution  
6. Await architectural approval before writing major code  

---

# 13. CONTACT

Development discussion channels will be posted after public release.  
Until then, use GitHub Issues for all proposals and discussions.

---

# 14. LEGAL

Contributions may only be accepted if the contributor agrees to assign or license the contribution to the Author under terms consistent with the project’s restrictive licensing.

No contributor gains copyright ownership of the project.

---

# 15. FINAL NOTES

Dominium is built for longevity, determinism, and correctness.  
Code must be simple, predictable, and maintainable for decades.  
Contributors are expected to uphold these principles.

Thank you for helping maintain a precise and robust simulation engine.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Below is SECURITY.md, fully specified for a deterministic, multi-platform simulation engine with restrictive licensing and strict architectural boundaries.
# SECURITY.md  
## Dominium Security, Vulnerability, and Integrity Policy  
### Version 1.0

This document defines the security expectations, threat model, vulnerability reporting process, and architectural integrity rules governing the Dominium engine, game, tools, and ecosystem.

Dominium is a deterministic, offline-first, multi-platform engine.  
Security focuses on **code integrity**, **input validation**, **determinism preservation**, **memory safety**, and **mod sandboxing**, rather than internet threat surfaces.

---

# 1. SCOPE

This policy applies to:

- All source code under this repository  
- All binaries built from this repository  
- All asset pipelines and tools  
- All modding APIs and script runtimes  
- All network protocols used by multiplayer modes  
- All build and packaging systems  

It does **not** apply to:

- Third-party mods outside `/mods`  
- Unofficial forks  
- Server infrastructures not controlled by the Author  

---

# 2. SECURITY MODEL OVERVIEW

Dominium’s security is built on three pillars:

### 2.1 Determinism Integrity  
Simulation determinism must be preserved.  
Any deviation is categorised as a **high-severity security violation**.

### 2.2 Memory and Execution Safety  
The engine targets systems ranging from DOS to modern OSes, all in C89/C++98.  
Memory safety, overflow protection, and strict bounds checking are mandatory.

### 2.3 Mod and Input Containment  
Mods and save files must not be able to:

- Break determinism  
- Execute arbitrary system-level code  
- Modify engine binaries  
- Access system files outside allowed sandbox areas  

---

# 3. THREAT CATEGORIES

Dominium defines the following classes of threats:

---

## 3.1 Determinism Breaks  
**Severity: Critical**

Examples:

- Floating-point operations in simulation  
- Use of system time  
- Non-deterministic ordering (hash tables with unstable iteration)  
- Thread races  
- Platform-dependent branch behaviour  
- Unspecified or undefined C behaviour  

Any determinism break is treated as a security vulnerability because it compromises:

- Replays  
- Multiplayer integrity  
- Save compatibility  
- Simulation correctness  

---

## 3.2 Memory Corruption  
**Severity: Critical**

Examples:

- Buffer overflows  
- Out-of-bounds array access  
- Use-after-free  
- Double frees  
- Stack corruption  
- Integer overflow or wraparound if unchecked  

Memory corruption is unacceptable on all targets, but especially critical on retro platforms with no OS protection.

---

## 3.3 Sandbox Violations  
**Severity: High**

Mods or user content must never:

- Access system files  
- Spawn processes  
- Allocate arbitrary memory  
- Escape their data sandbox  
- Modify engine binaries or platforms  
- Inject code  

Dominium modding runs inside an explicit sandbox with restricted access.

---

## 3.4 Malicious Saves, Mods, or Packs  
**Severity: High to Critical**

The engine must defend against malformed or intentionally crafted:

- Save games  
- Map files  
- Prefab files  
- Script bundles  
- Asset packs (textures, animations)  

Every loader must:

- Validate type ranges  
- Validate lengths  
- Validate magic numbers  
- Validate version fields  
- Validate CRCs  

No untrusted binary or textual data should ever be treated as trusted input.

---

## 3.5 Network Abuse (Multiplayer)  
**Severity: Medium to Critical**

Lockstep multiplayer requires:

- Strict packet validation  
- Version matching  
- CRC checks  
- Tick-range verification  
- Rejection of malformed or unexpected packets  

Clients must not be able to:

- Inject state  
- Override authoritative simulation  
- Desync others intentionally  

Any packet that cannot be validated deterministically must be dropped.

---

## 3.6 Build Integrity Problems  
**Severity: High**

Issues include:

- Unverified third-party dependencies  
- Modification of vendored libraries without documentation  
- Compiler optimisations that break determinism  
- Toolchain inconsistencies  
- Incorrect include directories resolving differently on contributors' systems  

All builds must be reproducible using:

- Documented compilers  
- Fixed toolchain versions  
- Stable CMake rules  
- Checked-in configuration files  

---

# 4. SECURITY REQUIREMENTS FOR CONTRIBUTORS

Every contribution must:

- Avoid undefined behaviour  
- Respect memory bounds  
- Maintain determinism across all platforms  
- Use only integer or fixed-point math in simulation  
- Validate all external inputs  
- Follow platform boundaries (`/engine/platform` only for OS calls)  
- Use stable file formats with versioned schemas  
- Not introduce new dependencies without review  

Violations result in immediate rejection of the contribution.

---

# 5. SECURITY REQUIREMENTS FOR ENGINE CODE

Simulation and engine core must NEVER:

- Use malloc/free unpredictably  
- Use floating-point  
- Use system time  
- Use randomness outside `dom_core_rng`  
- Load or execute external code  
- Read arbitrary paths  
- Depend on OS-specific behaviour  

All engine code must remain self-contained and deterministic.

---

# 6. SECURITY REQUIREMENTS FOR MODS

Mods must:

- Not include binary code  
- Not invoke system functions  
- Not alter engine memory  
- Not modify or replace engine binaries  
- Not exceed deterministic, sandboxed scripting API  

All mod-supplied data is untrusted until validated.

---

# 7. REPORTING VULNERABILITIES

Security issues can be reported:

- Via private email (provided upon public release)  
- Via GitHub private security reports  
- Via encrypted message (PGP key will be published)  

When reporting:

1. Describe the issue clearly  
2. Provide reproduction steps  
3. Include environment (platform, compiler, config)  
4. Provide minimal test cases  

Proof-of-concept code is acceptable.  
Malicious mods or save files must be transmitted privately.

---

# 8. DISCLOSURE POLICY

We follow **coordinated disclosure**:

- A fix is prepared internally  
- Regression tests are added  
- Maintainers coordinate with reporters  
- Patch is released with changelog notes  
- Reporter is credited unless anonymity is requested  

No details will be disclosed before a patch is available.

---

# 9. SECURITY TESTING

Before every release, the following must be executed:

### 9.1 Determinism Replays  
- Long-run deterministic tests  
- Multiple architectures  
- Cross-platform consistency checks  

### 9.2 Fuzzing  
All loaders (saves, maps, prefab files, data packs) must be fuzz-tested offline.

### 9.3 Static Analysis  
Mandatory runs of:

- clang-tidy  
- cppcheck  
- gcc/clang sanitizers (where determinism is not affected)  

### 9.4 Memory Profiling  
- Leak detection  
- Bounds checking  
- Valgrind (on supported systems)  

---

# 10. HANDLING OF RETRO PORT SECURITY

Retro systems (DOS, Win3.x, Win9x, macOS Classic) lack modern memory protection.  
Thus, they must be treated as:

- Hostile to themselves  
- Fully sandboxed by design  
- Never allowed to interpret unvalidated data  

Retro ports must degrade gracefully by:

- Disabling modding  
- Restricting asset loading  
- Using smaller maps  
- Enforcing stronger input checks  

---

# 11. LONG-TERM SECURITY MAINTENANCE

Dominium is designed to be playable decades from now.  
Security must therefore prioritise:

- Deterministic reproducibility  
- Integrity of archived binaries  
- Portability across compilers  
- No reliance on transient third-party ecosystems  

Any dependency or subsystem that threatens longevity will be removed.

---

# 12. CONTACT

Security contact information will be published with the first public release.

At present, security issues should be raised privately via the internal developer channel.

---

# 13. FINAL NOTE

Security is not separate from determinism.  
A deterministic engine is inherently more secure because:

- State cannot be manipulated unpredictably  
- Bugs appear reproducibly  
- Exploits cannot rely on timing variance  
- Replay tests expose corruption rapidly  

Preserve determinism.  
Preserve safety.  
Preserve correctness.

This is the core of Dominium’s security philosophy.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
# CODE_OF_CONDUCT.md  
## Dominium Community and Contributor Conduct Policy  
### Version 1.0

This document defines the behavioural expectations for all contributors, participants, maintainers, and collaborators interacting with the Dominium project, including issues, pull requests, discussions, documentation, tooling, and future community spaces.

Dominium is a technical project with strict determinism, architectural discipline, and long-term maintainability requirements.  
A clear conduct policy ensures that engineering work remains focused, respectful, and productive.

This Code of Conduct applies to all project spaces, including (but not limited to):

- GitHub Issues and Pull Requests  
- Code reviews  
- Documentation discussions  
- Design debates  
- Official forums, chats, or Discord (when available)  
- Mailing lists or private coordination channels  

---

# 1. CORE PRINCIPLES

### 1.1 Respect  
Treat all contributors with respect regardless of background, experience, or level of technical knowledge.

### 1.2 Technical Rigor  
Disagreements should be handled through evidence-based, technical reasoning, not personal critique.

### 1.3 Professionalism  
Maintain a professional tone.  
Hostility, sarcasm used as attack, or personal insults are not permitted.

### 1.4 Focus  
All discussion must remain productive and relevant to the goals of Dominium.

### 1.5 Inclusivity  
Anyone may participate if they follow this Code of Conduct, regardless of skill level or expertise.

### 1.6 No Gatekeeping  
Correct behaviour is enforced by adherence to standards, not personal power dynamics.

---

# 2. POSITIVE BEHAVIOURS EXPECTED

Contributors are expected to:

- Write clear, concise, technically grounded comments  
- Provide rationales in discussions and code reviews  
- Accept constructive criticism  
- Help new contributors understand architectural rules  
- Ask for clarification when specifications are unclear  
- Keep discussions factual and objective  
- Prioritise correctness over ego  
- Follow repository structures and deterministic guidelines  

---

# 3. UNACCEPTABLE BEHAVIOUR

Any of the following constitutes a violation:

## 3.1 Harassment or Abuse  
- Insults, threats, or demeaning language  
- Targeting individuals or groups  
- Racist, sexist, or otherwise discriminatory behaviour  

## 3.2 Disruption  
- Persistently derailing discussions  
- Flooding issues or PRs with off-topic content  
- Repeatedly ignoring architectural or determinism rules  

## 3.3 Aggressive Language  
- Hostility in code reviews  
- Mocking contributors  
- Dismissing others without explanation  

## 3.4 Demands or Entitlement  
- Forcing maintainers to accept contributions  
- Pressuring others for immediate responses  

## 3.5 Retaliation  
Retaliation against individuals who raise concerns or enforce the Code is strictly prohibited.

---

# 4. PROFESSIONAL CONDUCT IN TECHNICAL DISCUSSIONS

### 4.1 Assume Good Faith  
Unless proven otherwise, assume contributors are trying to help.

### 4.2 Separate People from Problems  
Critique the code, not the developer.

### 4.3 Evidence-Backed Arguments  
Claims must be supported by:

- Specification references  
- Determinism constraints  
- Architectural diagrams  
- Benchmarks or test results  

### 4.4 Technical Objectivity  
Avoid emotional or ideological reasoning.  
Decisions must follow engine philosophy and spec requirements.

---

# 5. MAINTAINER RESPONSIBILITIES

Maintainers must:

- Enforce this Code consistently  
- Review contributions fairly and impartially  
- Explain rejections clearly and with rationale  
- Escalate serious violations promptly  
- Protect the integrity of the engine architecture  

Maintainers may reject contributions on architecture or determinism grounds alone, even if behaviour is acceptable.

---

# 6. REPORTING VIOLATIONS

Violations may be reported through:

- GitHub private reports  
- Direct email to maintainers (will be published on official release)  
- Private messages in approved channels (Discord, etc.)  

Reports must include:

- Description of behaviour  
- Links or screenshots  
- Optional suggestions for resolution  

Reporters may remain anonymous.

---

# 7. ENFORCEMENT

### 7.1 Minor First-Time Violations  
Handled with a private or public reminder of expected behaviour.

### 7.2 Repeated Violations  
May result in:

- Temporary muting  
- Temporary exclusion from discussions  
- Rejection of contributions until behaviour improves  

### 7.3 Severe Violations  
May result in:

- Permanent ban from project participation  
- Removal of collaborator or maintainer privileges  
- Escalation to platform administrators (GitHub, Discord, etc.)

### 7.4 No Public Shaming  
Enforcement actions are private unless the violator chooses to publicise them.

---

# 8. APPEALS

Anyone subject to an enforcement action may file an appeal to the maintainers.  
Appeals must:

- Clearly explain why the decision was incorrect  
- Provide context or evidence not previously considered  
- Demonstrate commitment to future compliance  

The maintainers’ decision on appeals is final.

---

# 9. SCOPE AND LIMITATIONS

This Code of Conduct applies only to official Dominium spaces.  
Unofficial or third-party communities are outside its jurisdiction.

Maintainers cannot enforce rules outside the project environment.

---

# 10. MODIFICATION

The maintainers may update this Code of Conduct as the community grows.  
Any change must:

- Be documented in `CHANGELOG.md`  
- Be consistent with the project’s philosophy  
- Improve clarity and accountability  

---

# 11. ACKNOWLEDGEMENTS

This Code of Conduct incorporates principles from:

- Contributor Covenant  
- Rust Code of Conduct  
- LLVM Conduct Guidelines  
- Internal engineering culture guidelines  

Adapted to Dominium’s architectural and determinism-driven environment.

---

# 12. FINAL NOTE

Dominium aims to be a technically rigorous, respectful, and future-proof project.  
We maintain high expectations for behaviour because:

- The engine is complex  
- Collaboration requires clarity  
- Determinism requires discipline  
- The project must remain maintainable for decades  

By participating, you agree to uphold these standards.
Say Next to proceed to .gitignore or specify another file.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
Below is a complete, maximally strict and comprehensive .gitignore suitable for Dominium’s multi-platform, multi-toolchain, retro-compatible, deterministic-engine development environment.
It rejects everything that should never be committed while allowing all platform-essential and retro-essential files to remain under version control.
# =====================================================================
# DOMINIUM — GLOBAL .gitignore
# =====================================================================
# This file excludes:
# - Build outputs
# - Temporary files
# - Generated assets
# - Editor caches
# - Platform-specific clutter
# - Retro toolchain intermediates
#
# It preserves:
# - Source code
# - Determinism-critical build scripts
# - Retro project files (when non-generated)
# - Documentation
# =====================================================================


# ---------------------------------------------------------------------
# 1. CORE BUILD DIRECTORIES
# ---------------------------------------------------------------------
/build/
/build/*/
/build/output/
/dist/
/bin/
/obj/
/out/
/lib/
/tmp/
/temp/

# CMake builddirs
CMakeFiles/
CMakeCache.txt
cmake_install.cmake
Makefile

# Ninja
.ninja_deps
.ninja_log


# ---------------------------------------------------------------------
# 2. COMPILER AND TOOLCHAIN OUTPUTS
# ---------------------------------------------------------------------
*.o
*.obj
*.lo
*.a
*.la
*.lib
*.dll
*.so
*.dylib
*.exe
*.out
*.elf
*.map
*.lst
*.pdb
*.idb
*.ilk
*.manifest
*.exp


# ---------------------------------------------------------------------
# 3. RETRO TOOLCHAIN INTERMEDIATES
# (kept strict to protect determinism-critical sources)
# ---------------------------------------------------------------------
# DOS / Watcom / Borland
*.err
*.sym
*.bsc
*.cod
*.exe.err
*.map.bak
*.tr

# CodeWarrior / MPW / Classic Mac
*.xSYM
*.rsrc
*.pef
*.ppc
*.bin
*.srec

# Win3.x / Win16
*.res
*.lib16
*.exe16

# Assembly intermediates
*.asm.tmp
*.inc.tmp
*.lst.tmp


# ---------------------------------------------------------------------
# 4. GENERATED FILES
# ---------------------------------------------------------------------
# Auto-generated headers
*_autogen.h
*_generated.h
*_config.h
*_tables.h

# Generated code from scripts or tools
generated/
codegen/
autogen/

# Generated assets
assets/cache/
assets/generated/
assets/converted/
assets_compiled/


# ---------------------------------------------------------------------
# 5. PLATFORM AND IDE TRASH
# ---------------------------------------------------------------------
# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Linux
*.swp
*.swo
*~
.*.swp

# JetBrains
.idea/
*.iml

# Visual Studio
.vs/
*.vcxproj.user
*.sln.docstates
*.VC.db
*.VC.VC.opendb

# VSCode
.vscode/
.history/

# Xcode
*.xcworkspace
*.xcuserdatad/
*.xcuserdata/
*.xcsettings
DerivedData/


# ---------------------------------------------------------------------
# 6. TEST OUTPUT
# ---------------------------------------------------------------------
/tests/output/
/tests/temp/
/tests/logs/
/tests/replay_dumps/

*.testlog
*.replaydump
*.perfdata


# ---------------------------------------------------------------------
# 7. LOGS AND RUNTIME ARTIFACTS
# ---------------------------------------------------------------------
*.log
*.trace
*.old
*.bak
*.tmp
*.lock

# Crash reports
crash_*.txt
hs_err_pid*


# ---------------------------------------------------------------------
# 8. PACKAGE & MEDIA ARTIFACTS
# ---------------------------------------------------------------------
/packaging/output/
/packaging/temp/

# Installer outputs
*.msi
*.rpm
*.deb
*.flatpak
*.dmg
*.pkg
*.zip
*.tar
*.tar.gz
*.iso
*.img


# ---------------------------------------------------------------------
# 9. MOD AND DATA PACK TEMPORARY FILES
# ---------------------------------------------------------------------
/mods/local/*/temp/
/mods/local/*/build/
/mods/local/*/generated/
/mods/workshop/*/temp/
/mods/workshop/*/build/

# Pack compilation caches
/data/packs/*/compiled/
/data/packs/*/cache/


# ---------------------------------------------------------------------
# 10. TOOLING CACHES
# ---------------------------------------------------------------------
/tools/*/cache/
/tools/*/temp/
/tools/editor/cache/
/tools/editor/autosave/
/tools/pipeline/cache/

*.cache
*.tmp
*.bak


# ---------------------------------------------------------------------
# 11. SCRIPTS & PIPELINE TRASH
# ---------------------------------------------------------------------
*.pyc
__pycache__/
*.class
node_modules/
venv/
.env
.env.*


# ---------------------------------------------------------------------
# 12. SAVEGAME AND WORLD OUTPUTS
# (Never checked in to repo)
/saves/
/worlds/
/universes/
*.sav
*.world
*.universe


# ---------------------------------------------------------------------
# 13. CRITICAL RULES FOR DOMINIUM PROJECT STRUCTURE
# ---------------------------------------------------------------------
# We NEVER ignore:
# - Source code (.c, .h, .cpp)
# - Platform project files (.dsw, .dsp, CodeWarrior .mcp when not generated)
# - Deterministic tables in /engine
# - Asset source files (svg, png, wav) stored intentionally
# - Specification documents
#
# Explicit allow-list overrides follow below.


# ---------------------------------------------------------------------
# 14. NEGATION RULES (FILES TO FORCE-CHECK-IN)
# ---------------------------------------------------------------------
!/.gitignore
!/docs/
!/docs/**
!/engine/
!/engine/**
!/game/
!/game/**
!/data/base/**
!/data/dlc/**
!/data/templates/**
!/tools/editor/src/**
!/tools/devkit/**
!/tools/pipeline/scripts/**
!/mods/*/mod.json
!/packaging/scripts/**
!/build/cmake/
!/scripts/**
!/ports/**/config/**
!/ports/**/include/**
!/third_party/licenses/**


# ---------------------------------------------------------------------
# END OF FILE
# ---------------------------------------------------------------------
If you want, the next file in canonical order is:
CMakeLists.txt (root-level deterministic, multi-target build contract).
Say Next to generate it.
You said:
Next
ChatGPT said:
Thought for 12s
GPT-5.1 • 2025-12-03
# =====================================================================
# Dominium — Root CMakeLists.txt
# Deterministic, multi-target, multi-platform build configuration
# =====================================================================
cmake_minimum_required(VERSION 3.16)

# ---------------------------------------------------------------------
# 1. PROJECT METADATA
# ---------------------------------------------------------------------
project(Dominium
    VERSION 0.1.0
    LANGUAGES C CXX
)

# Enforce strict C89 / C++98 across all engine and game targets.
set(CMAKE_C_STANDARD 90)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS OFF)

set(CMAKE_CXX_STANDARD 98)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Disable in-source builds (enforce /build).
if("${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
    message(FATAL_ERROR "In-source builds are forbidden. Use a separate build directory.")
endif()

# ---------------------------------------------------------------------
# 2. GLOBAL OPTIONS / SWITCHES
# ---------------------------------------------------------------------
option(DOM_BUILD_ENGINE_ONLY          "Build engine only, no game client/server"         OFF)
option(DOM_BUILD_CLIENT               "Build game client binary"                        ON)
option(DOM_BUILD_SERVER               "Build dedicated server binary"                   ON)
option(DOM_BUILD_TOOLS                "Build tools (editor, devkit, pipelines)"         ON)
option(DOM_BUILD_TESTS                "Build tests (unit, integration, replay)"         ON)
option(DOM_ENABLE_NET                 "Enable networking support"                       ON)
option(DOM_ENABLE_AUDIO               "Enable audio backends"                           ON)
option(DOM_ENABLE_GL1                 "Enable OpenGL 1.x renderer backend"              ON)
option(DOM_ENABLE_GL2                 "Enable OpenGL 2.x renderer backend"              ON)
option(DOM_ENABLE_DX9                 "Enable DirectX 9 renderer backend (Windows)"     ON)
option(DOM_ENABLE_DX11                "Enable DirectX 11 renderer backend (Windows)"    OFF)
option(DOM_ENABLE_SOFTWARE_RENDER     "Enable software/vector renderer backend"         ON)
option(DOM_ENABLE_EDITORS             "Build map/world/blueprint editors"               ON)
option(DOM_STRICT_DETERMINISM_CHECKS  "Enable additional determinism diagnostics"       ON)
option(DOM_ENABLE_LTO                 "Enable link-time optimization where available"   OFF)

# Retro / legacy ports are built via separate build systems; CMake is for
# modern platforms only (Win32/Win64, Linux, macOS, etc).
option(DOM_BUILD_RETRO_STUBS          "Build stubs/helpers for retro ports"             ON)

# ---------------------------------------------------------------------
# 3. GLOBAL COMPILER / WARNING POLICY
# ---------------------------------------------------------------------
include(CheckCCompilerFlag)
include(CheckCXXCompilerFlag)

macro(dom_add_flag_if_supported _lang _flag)
    if("${_lang}" STREQUAL "C")
        string(REPLACE "-" "_" _safe "${_flag}")
        string(REPLACE "=" "_" _safe "${_safe}")
        set(_var "HAVE_FLAG_C_${_safe}")
        check_c_compiler_flag("${_flag}" ${_var})
        if(${_var})
            add_compile_options("$<$<COMPILE_LANGUAGE:C>:${_flag}>")
        endif()
    elseif("${_lang}" STREQUAL "CXX")
        string(REPLACE "-" "_" _safe "${_flag}")
        string(REPLACE "=" "_" _safe "${_safe}")
        set(_var "HAVE_FLAG_CXX_${_safe}")
        check_cxx_compiler_flag("${_flag}" ${_var})
        if(${_var})
            add_compile_options("$<$<COMPILE_LANGUAGE:CXX>:${_flag}>")
        endif()
    endif()
endmacro()

# Warnings: strict, but avoid compiler-specific breakage.
if(MSVC)
    add_compile_options(
        /W4           # high warning level
        /WX-          # do NOT treat warnings as errors by default
        /permissive-  # standard-conformance mode
        /D_CRT_SECURE_NO_WARNINGS
    )
else()
    dom_add_flag_if_supported(C   "-Wall")
    dom_add_flag_if_supported(C   "-Wextra")
    dom_add_flag_if_supported(C   "-Wpedantic")
    dom_add_flag_if_supported(C   "-Wshadow")
    dom_add_flag_if_supported(C   "-Wstrict-prototypes")
    dom_add_flag_if_supported(C   "-Wno-unused-parameter")

    dom_add_flag_if_supported(CXX "-Wall")
    dom_add_flag_if_supported(CXX "-Wextra")
    dom_add_flag_if_supported(CXX "-Wpedantic")
    dom_add_flag_if_supported(CXX "-Wshadow")
    dom_add_flag_if_supported(CXX "-Wnon-virtual-dtor")
endif()

# Optional LTO
if(DOM_ENABLE_LTO)
    include(CheckIPOSupported)
    check_ipo_supported(RESULT ipo_supported OUTPUT ipo_error)
    if(ipo_supported)
        set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
    else()
        message(WARNING "LTO requested but not supported: ${ipo_error}")
    endif()
endif()

# ---------------------------------------------------------------------
# 4. GLOBAL DEFINES (DETERMINISM + PLATFORM)
# ---------------------------------------------------------------------
add_compile_definitions(
    DOM_BUILD_VERSION_MAJOR=${PROJECT_VERSION_MAJOR}
    DOM_BUILD_VERSION_MINOR=${PROJECT_VERSION_MINOR}
    DOM_BUILD_VERSION_PATCH=${PROJECT_VERSION_PATCH}
)

if(DOM_STRICT_DETERMINISM_CHECKS)
    add_compile_definitions(DOM_STRICT_DETERMINISM=1)
else()
    add_compile_definitions(DOM_STRICT_DETERMINISM=0)
endif()

if(WIN32)
    add_compile_definitions(DOM_PLATFORM_WIN32=1)
elseif(APPLE)
    add_compile_definitions(DOM_PLATFORM_MACOS=1)
elseif(UNIX)
    add_compile_definitions(DOM_PLATFORM_LINUX=1)
else()
    add_compile_definitions(DOM_PLATFORM_UNKNOWN=1)
endif()

if(DOM_ENABLE_NET)
    add_compile_definitions(DOM_FEATURE_NET=1)
else()
    add_compile_definitions(DOM_FEATURE_NET=0)
endif()

if(DOM_ENABLE_AUDIO)
    add_compile_definitions(DOM_FEATURE_AUDIO=1)
else()
    add_compile_definitions(DOM_FEATURE_AUDIO=0)
endif()

# Render backend feature flags
add_compile_definitions(
    DOM_RENDER_GL1=$<BOOL:${DOM_ENABLE_GL1}>
    DOM_RENDER_GL2=$<BOOL:${DOM_ENABLE_GL2}>
    DOM_RENDER_DX9=$<BOOL:${DOM_ENABLE_DX9}>
    DOM_RENDER_DX11=$<BOOL:${DOM_ENABLE_DX11}>
    DOM_RENDER_SOFTWARE=$<BOOL:${DOM_ENABLE_SOFTWARE_RENDER}>
)

# ---------------------------------------------------------------------
# 5. GLOBAL INCLUDE PATHS
# ---------------------------------------------------------------------
include_directories(
    ${CMAKE_SOURCE_DIR}/engine
    ${CMAKE_SOURCE_DIR}/engine/core
    ${CMAKE_SOURCE_DIR}/engine/sim
    ${CMAKE_SOURCE_DIR}/engine/render
    ${CMAKE_SOURCE_DIR}/engine/audio
    ${CMAKE_SOURCE_DIR}/engine/net
    ${CMAKE_SOURCE_DIR}/engine/ui
    ${CMAKE_SOURCE_DIR}/engine/platform
    ${CMAKE_SOURCE_DIR}/game
    ${CMAKE_SOURCE_DIR}/third_party/include
)

# ---------------------------------------------------------------------
# 6. THIRD-PARTY LIBRARIES (DECLARATIVE)
# ---------------------------------------------------------------------
add_subdirectory(third_party)

# third_party/CMakeLists.txt is responsible for:
# - Declaring imported targets (e.g., SDL2::SDL2, etc.)
# - Setting any required compile definitions for external libs
# - NEVER leaking platform headers into /engine core

# ---------------------------------------------------------------------
# 7. ENGINE TARGETS
# ---------------------------------------------------------------------
add_subdirectory(engine)

# /engine/CMakeLists.txt must:
# - Create STATIC libraries for:
#   * dom_core      (core utilities, logging, mem, rng, fixed-point)
#   * dom_sim       (deterministic simulation)
#   * dom_render    (renderer abstraction + backends)
#   * dom_audio     (audio abstraction)
#   * dom_net       (network protocol)
#   * dom_ui        (UI primitives)
#   * dom_platform  (per-OS platform layer)
# - Expose them as:
#   * dom_engine_full (INTERFACE / OBJECT meta-target aggregating all)

# ---------------------------------------------------------------------
# 8. GAME TARGETS (CLIENT, SERVER, LAUNCHER)
# ---------------------------------------------------------------------
if(NOT DOM_BUILD_ENGINE_ONLY)
    add_subdirectory(game)

    # /game/CMakeLists.txt must:
    # - Define:
    #   * dom_client  (GUI client)
    #   * dom_server  (headless server)
    #   * dom_launcher (optional launcher/selector)
    # - Link them to dom_engine_full and relevant third-party libs
endif()

# ---------------------------------------------------------------------
# 9. TOOLS (EDITOR, DEVKIT, PIPELINE)
# ---------------------------------------------------------------------
if(DOM_BUILD_TOOLS)
    add_subdirectory(tools)

    # /tools/CMakeLists.txt must:
    # - Build editor binaries (map/world/blueprint)
    # - Build devkit utilities for mods
    # - Build asset pipeline tools (import/convert/pack)
    # - Ensure no determinism-critical logic lives only in tools
endif()

# ---------------------------------------------------------------------
# 10. TESTS (UNIT, INTEGRATION, REPLAY)
# ---------------------------------------------------------------------
if(DOM_BUILD_TESTS)
    enable_testing()
    add_subdirectory(tests)

    # /tests/CMakeLists.txt must:
    # - Define unit test executables
    # - Define integration/replay determinism tests
    # - Register tests with ctest
endif()

# ---------------------------------------------------------------------
# 11. PACKAGING / INSTALL RULES (MODERN ONLY)
# ---------------------------------------------------------------------
add_subdirectory(packaging)

# /packaging/CMakeLists.txt must:
# - Define install targets for:
#   * dom_client, dom_server, dom_launcher
#   * engine DLLs/shared libs (if any)
#   * data packs under appropriate paths
# - Provide CPACK configuration for modern OS installers
# - Retro image layouts handled separately under /packaging/retro

# ---------------------------------------------------------------------
# 12. SCRIPTS / META AUTOMATION
# ---------------------------------------------------------------------
add_subdirectory(scripts)

# /scripts/CMakeLists.txt should:
# - Expose optional helper targets (lint, format, codegen, regen-specs)
# - Not be required for basic build

# ---------------------------------------------------------------------
# 13. PORTS (RETRO / ALT TARGET STUBS)
# ---------------------------------------------------------------------
if(DOM_BUILD_RETRO_STUBS)
    add_subdirectory(ports)

    # /ports/CMakeLists.txt:
    # - Does not build full retro binaries
    # - Builds small helper libs/tools for retro projects
    # - Keeps retro build systems isolated (e.g. .mak, .dsp, .mcp)
endif()

# ---------------------------------------------------------------------
# 14. SUMMARY
# ---------------------------------------------------------------------
message(STATUS "---------------------------------------------------")
message(STATUS " Dominium build configuration")
message(STATUS "   Version         : ${PROJECT_VERSION}")
message(STATUS "   Engine only     : ${DOM_BUILD_ENGINE_ONLY}")
message(STATUS "   Client          : ${DOM_BUILD_CLIENT}")
message(STATUS "   Server          : ${DOM_BUILD_SERVER}")
message(STATUS "   Tools           : ${DOM_BUILD_TOOLS}")
message(STATUS "   Tests           : ${DOM_BUILD_TESTS}")
message(STATUS "   Net             : ${DOM_ENABLE_NET}")
message(STATUS "   Audio           : ${DOM_ENABLE_AUDIO}")
message(STATUS "   GL1             : ${DOM_ENABLE_GL1}")
message(STATUS "   GL2             : ${DOM_ENABLE_GL2}")
message(STATUS "   DX9             : ${DOM_ENABLE_DX9}")
message(STATUS "   DX11            : ${DOM_ENABLE_DX11}")
message(STATUS "   Software render : ${DOM_ENABLE_SOFTWARE_RENDER}")
message(STATUS "   Strict determin.: ${DOM_STRICT_DETERMINISM_CHECKS}")
message(STATUS "---------------------------------------------------")
You said:
Next
ChatGPT said:
Thought for 25s
GPT-5.1 • 2025-12-03
# CHANGELOG.md  
## Dominium — Change History and Compatibility Contract

This file documents **all user-visible and engine-visible changes** to Dominium.

It serves three purposes:

1. Track **features, fixes, and refactors** per version  
2. Document **determinism and save-compatibility guarantees**  
3. Provide a stable reference for **mod authors** and **port maintainers**

All entries must follow the rules below.

---

# 0. FORMAT AND RULES

## 0.1 Versioning

Dominium uses **semantic versioning with determinism qualifiers**:

- `MAJOR.MINOR.PATCH`  
- Optional suffixes:
  - `-dev`   — development / unstable  
  - `-exp`   — experimental branches  
  - `-rcN`   — release candidate  

Examples:

- `0.1.0-dev`
- `1.0.0`
- `1.1.3-rc1`

### MAJOR

Increment when:

- Determinism guarantees change fundamentally  
- Savefile format changes in a **non-migratable** way  
- Network protocol becomes incompatible with prior versions  

### MINOR

Increment when:

- Features are added  
- Savefiles remain **loadable** (with possible migration)  
- Determinism is preserved for matching version pairs  
- Network protocol remains compatible inside same MAJOR  

### PATCH

Increment when:

- Only bug fixes, internal refactors, and minor changes  
- No change in data formats that break saves or replays  

---

## 0.2 Entry Structure

Each version section:

```markdown
## [X.Y.Z] - YYYY-MM-DD

### Added
- …

### Changed
- …

### Fixed
- …

### Removed
- …

### Determinism & Compatibility
- Determinism: [Unchanged | Strengthened | Risky Change]
- Savefiles: [Fully compatible | Compatible via migration | Incompatible]
- Replays: [Compatible | Broken | N/A]
- Network: [Compatible | Incompatible | N/A]
Sections may be omitted if empty.
Every determinism-relevant change must be explicitly documented under Determinism & Compatibility.

0.3 Determinism Rules in Changelog
Any change that touches:
• engine/sim
• engine/core fixed-point math
• engine/net protocol
• Savefile structure
• Job system, tick order, or lanes
must:
1. Note whether old replays still produce identical results
2. Mark whether old saves load to a state equivalent under the new spec
3. Specify whether multiplayer clients with mismatched minor/patch versions can participate
If behaviour changes but is still deterministic, document that explicitly.

0.4 “Unreleased” Section
The top of this file always contains:
## [Unreleased]

### Added
- …

### Changed
- …

### Fixed
- …

### Removed
- …

### Determinism & Compatibility
- Determinism:
- Savefiles:
- Replays:
- Network:
Entries accumulate during development.
When a release is cut, the section is renamed to the version and a fresh [Unreleased] section is created above.

1. RELEASE HISTORY
[Unreleased]
Added
• Root repository structure (/docs, /engine, /game, /data, /mods, /tools, /tests, /third_party, /build, /packaging, /scripts, /ports).
• Project meta files:
o README.md
o LICENSE.md (strict, personal-use-only)
o SECURITY.md (determinism-focused security model)
o CODE_OF_CONDUCT.md
o .gitignore
o Root CMakeLists.txt
• Initial deterministic engine specification documents (V3 series, Volumes 1A–1B):
o Determinism kernel
o Tick pipeline
o ECS architecture
o Messaging and job systems
o Serialization, chunking, spatial indexing, prefabs, mod injection
Changed
• N/A (first tracked iteration)
Fixed
• N/A
Removed
• N/A
Determinism & Compatibility
• Determinism: Baseline model defined; no behaviour yet to change.
• Savefiles: Save format specified, but no stable on-disk format shipped.
• Replays: Replay model specified; no backwards compatibility constraints yet.
• Network: Lockstep protocol and invariants specified; no public compatibility expectations.

[0.1.0] - YYYY-MM-DD (FIRST PUBLIC SPEC SNAPSHOT)
Replace YYYY-MM-DD with actual release date.
Added
• Formalised deterministic kernel:
o Integer/fixed-point only simulation
o 7-phase tick pipeline
o Virtual lanes and merge rules
o Strict event ordering and backpressure model
• ECS core:
o Stable entity IDs with generation
o Dense component storage
o Strict sorted iteration by entity_id
• Messaging and jobs:
o Local/lane/cross-lane/global event buses
o Deterministic command buffers
o Job queues and worker assignment rules
o Interrupt model and task routing
• Persistence:
o Savefile block layout
o Chunk/subchunk/voxel metadata
o Network graph persistence
o Replay-log architecture
• Spatial & physics:
o Meter-based integer grid
o Chunk/subchunk hierarchy
o BVH and wide uniform grid
o Integer-based collision and raycasting
• Prefabs & mods:
o Prefab format
o Deterministic prefab instantiation
o Strict mod capabilities and prohibitions
• Build system:
o Root CMake with:
• DOM_BUILD_ENGINE_ONLY
• DOM_BUILD_CLIENT
• DOM_BUILD_SERVER
• DOM_BUILD_TOOLS
• DOM_BUILD_TESTS
• Backend feature flags (GL1/GL2/DX9/DX11/software)
• Determinism checks (DOM_STRICT_DETERMINISM)
Changed
• N/A (first tagged spec release)
Fixed
• N/A
Removed
• N/A
Determinism & Compatibility
• Determinism:
o Defined as core invariant of the project.
o All simulation design is constrained by deterministic architecture.
• Savefiles:
o Canonical format defined; initial version = 0x00030000.
o No prior versions to support.
• Replays:
o Replay records defined; semantics stable for 0.1.x line.
• Network:
o Lockstep protocol defined; 0.1.x line expected to remain internally compatible unless explicitly broken.

2. FUTURE ENTRY TEMPLATE
For future releases, copy and fill:
## [X.Y.Z] - YYYY-MM-DD

### Added
- New features…

### Changed
- Behaviour changes…

### Fixed
- Bug fixes…

### Removed
- Deprecated or removed features…

### Determinism & Compatibility
- Determinism:
  - [e.g.] Tick ordering unchanged; modifications scoped to UI only.
- Savefiles:
  - [e.g.] Old saves auto-migrated via migration step M3 → M4.
- Replays:
  - [e.g.] Replays from 0.1.x no longer valid due to changed job routing.
- Network:
  - [e.g.] Network protocol remains compatible within MAJOR 1.
All determinism-impacting changes must be evaluated and documented here.
::contentReference[oaicite:0]{index=0}
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
# BUILDING.md  
## Dominium — Deterministic, Multi-Platform Build Instructions  
### Version 1.0

This document explains **how to build Dominium on all supported modern platforms**, how determinism is preserved during builds, and how optional components (client, server, tools, tests) are configured.

Retro platforms (DOS, Win3.x, Win9x, macOS Classic, consoles) use *separate, platform-specific build systems* documented under `/ports/*/docs/`.

This document covers only **modern CMake-based builds**:

- Windows (MSVC or MinGW)
- Linux (GCC or Clang)
- macOS (Clang)
- WASM/Emscripten (partial support)

Dominium requires **strict C89/C++98** compilers and **stable toolchains** to preserve simulation determinism across architectures.

---

# 1. SYSTEM REQUIREMENTS

## 1.1 Mandatory
- CMake ≥ 3.16  
- A C89/C++98 compiler:
  - MSVC (Visual Studio 2017+), with `/permissive-`
  - GCC ≥ 6.0 (strict C89 mode)
  - Clang ≥ 6.0
- Python 3.x (for tools and asset pipelines)
- Git for source management

## 1.2 Optional Components
- SDL2 (audio, windowing for some backends)
- OpenGL 1.x or 2.x runtime
- DirectX 9 SDK (Windows only)
- Emscripten (for WASM port)
- Ninja (optional build generator)

## 1.3 Hardware
- CPU with at least SSE2 (PC)
- 1 GB RAM minimum  
- No GPU required for software/vector renderer  
- GPUs recommended for GL/DX backends  

---

# 2. DIRECTORY OVERVIEW (BUILD CONTEXT)

The relevant build directories are:

/engine ← deterministic C89/C++98 engine
/game ← gameplay layer
/tools ← editors, SDK, pipelines
/tests ← unit / integration / replay
/packaging ← installers and bundles
/ports ← retro build environments (non-CMake)

All **generated files** appear under `/build/` unless explicitly overridden.

---

# 3. BASIC BUILD (ALL MODERN PLATFORMS)

Use an **out-of-source** build:

```sh
git clone https://example.com/dominium
cd dominium
mkdir build
cd build
cmake ..
cmake --build .
This builds:
• Engine static libraries
• Client executable (dom_client)
• Server executable (dom_server)
• Tools (dom_editor, dom_devkit) if enabled
• Tests if enabled

4. CONFIGURING BUILD OPTIONS
Dominium exposes many CMake options through the root CMakeLists.txt:
-D DOM_BUILD_ENGINE_ONLY=ON
-D DOM_BUILD_CLIENT=OFF
-D DOM_BUILD_SERVER=ON
-D DOM_BUILD_TOOLS=ON
-D DOM_BUILD_TESTS=ON
-D DOM_ENABLE_GL1=ON
-D DOM_ENABLE_GL2=OFF
-D DOM_ENABLE_DX9=OFF
-D DOM_ENABLE_SOFTWARE_RENDER=ON
-D DOM_STRICT_DETERMINISM_CHECKS=ON
Examples:
Engine-only build (for embedding or testing)
cmake .. -D DOM_BUILD_ENGINE_ONLY=ON
Headless server build
cmake .. -D DOM_BUILD_CLIENT=OFF -D DOM_BUILD_SERVER=ON
Build with software renderer only (no GPU required)
cmake .. -D DOM_ENABLE_SOFTWARE_RENDER=ON -D DOM_ENABLE_GL1=OFF -D DOM_ENABLE_GL2=OFF
Build with maximum determinism validation
cmake .. -D DOM_STRICT_DETERMINISM_CHECKS=ON
Strict mode:
• Enables extra fixed-point consistency tests
• Enables stable iteration order checks
• Disables nondeterministic optimisations
• Logs determinism faults

5. PLATFORM-SPECIFIC INSTRUCTIONS

5.1 Windows (MSVC)
Requirements
• Visual Studio 2017 or later
• Windows SDK installed
• Optional: DirectX 9 SDK (June 2010)
Build:
mkdir build
cd build
cmake -G "Visual Studio 17 2022" ..
cmake --build . --config Release
Notes
• /permissive- is enforced
• /MT vs /MD is controlled by CMake (default = /MD)
• DirectX 9 backend requires DX9 SDK paths configured

5.2 Windows (MinGW-w64)
Requirements
• MinGW-w64
• SDL2 development libraries
Build:
cmake -G "MinGW Makefiles" ..
cmake --build .
Recommended for deterministic testing due to strict GCC behaviour.

5.3 Linux (GCC or Clang)
Install dependencies (example: Debian/Ubuntu)
sudo apt install build-essential cmake libsdl2-dev mesa-common-dev
Build:
mkdir build
cd build
cmake ..
make -j$(nproc)
Notes
• GCC must support -std=c89 and -std=gnu++98
• Use Clang for reproduction parity with macOS

5.4 macOS (Clang)
Install dependencies:
brew install cmake sdl2
Build:
mkdir build
cd build
cmake ..
cmake --build .
Notes
• GL1/GL2 backends work through legacy OpenGL
• Metal backend is not yet implemented

5.5 WebAssembly (Emscripten)
Requirements:
• Emscripten SDK (emsdk)
• Browser supporting WebGL2 (if rendering enabled)
Build:
emcmake cmake ..
emmake make
Outputs:
• dominium.html
• dominium.js
• dominium.wasm
This build is non-authoritative and may not support strict determinism.

6. RUNNING BUILDS
Client:
./dom_client
Server:
./dom_server --world myworld
Editors (if built):
./tools/dom_editor

7. TESTING
Run all tests:
ctest --output-on-failure
Tests include:
• Unit tests (/tests/unit)
• Integration tests (/tests/integration)
• Deterministic replay tests (/tests/replay)
Replay tests must pass on every architecture to guarantee simulation correctness.

8. DETERMINISM CONSIDERATIONS
To preserve identical simulation output across platforms:
8.1 Disable CPU-dependent optimisations
CMake already disables:
• Unsafe fast-math
• SIMD auto-vectorisation (unless explicitly allowed)
• Reordering optimisations
8.2 Avoid floating-point in simulation
The engine uses only:
• Integer
• Fixed-point
• Defined rounding rules
8.3 Stable iteration order
All hash maps, trees, and ECS structures must maintain deterministic order.
8.4 Byte-exact compilation
Official builds use pinned compiler versions to guarantee reproducible binaries.

9. CLEANING BUILDS
rm -rf build/
Safe because no generated source is stored outside /build.

10. TROUBLESHOOTING
Fails to compile due to missing SDL2?
Install development headers:
• Linux: sudo apt install libsdl2-dev
• macOS: brew install sdl2
• Windows: ensure SDL2 is on include/lib path
Determinism tests fail?
• Check compiler version
• Disable LTO or architecture-specific tuning
• Ensure no floating-point slipped into simulation
Linking errors for OpenGL?
Disable GL backends and use software renderer:
cmake .. -D DOM_ENABLE_SOFTWARE_RENDER=ON -D DOM_ENABLE_GL1=OFF -D DOM_ENABLE_GL2=OFF

11. RETRO BUILDS (NON-CMAKE)
Retro platforms (DOS, Win3.x, Win9x, macOS Classic) are built via:
/ports/<platform>/config/
Each folder contains:
• Vendor-specific makefiles
• MPW / CodeWarrior project files
• OpenWatcom scripts
• DOS extenders
• Retro asset converters
These builds are not supported by CMake and must not alter the simulation logic.

12. FINAL NOTES
Building Dominium must:
• Always preserve determinism
• Avoid platform leakage into the engine
• Keep build scripts portable and reproducible
• Support minimal environments without advanced tooling
• Be stable for decades of archival use
If you encounter issues, file a detailed build problem report referencing:
• Compiler version
• CMake version
• Platform
• Options used
• Output logs

Say **Next** to proceed to the `VERSION` file or specify another file.
You said:
Next
ChatGPT said:
GPT-5.1 • 2025-12-03
# VERSION  
## Dominium Engine & Game — Version Manifest  
### Canonical Versioning Contract (Authoritative Source)

This file defines the **official version schema** for all Dominium engine, game, data-pack, DLC, and mod releases.  
It is the single source of truth for:

- Engine Version  
- Game Version  
- Data Pack Versions  
- API/ABI Versions  
- Determinism Compatibility Windows  
- Savefile Compatibility  
- Network Protocol Versions  
- Mod API Versions  

No other file in the repository may override or contradict this document.

---

# 1. VERSION SCHEMA

Dominium uses **Five-Vector Semantic Versioning**, required for multi-decade stability:

ENGINE_VERSION = E.M.m.r.p
GAME_VERSION = G.M.m.r.p
DATA_VERSION = D.M.m
SAVE_VERSION = S.M
PROTOCOL_VERSION = P.M
MOD_API_VERSION = A.M

Where:

- `E/G/D/S/P/A` — major domain identifier  
- `M` — major version (breaking changes allowed)  
- `m` — minor version (non-breaking features added)  
- `r` — revision (non-breaking fixes)  
- `p` — patch (hotfixes, security)  

Example:

ENGINE_VERSION = 3.0.12.4.1
GAME_VERSION = 3.0.5.0.0
DATA_VERSION = 3.0
SAVE_VERSION = 3.0
PROTOCOL_VERSION = 3.0
MOD_API_VERSION = 3.0

All versions must be integers.  
No strings.  
No dates.  
No git hashes inside canonical version identifiers.

---

# 2. ENGINE VERSION (E.M.m.r.p)

The **Engine Version** reflects backwards-compatible determinism boundaries.

### E (Epoch)
Advances only when determinism-breaking changes occur:
- Memory model changes  
- Tick order changes  
- Merge-phase rules changed  
- Component layouts changed  
- Serialization layout changed  
- ECS ordering changes  

Increasing E **invalidates all prior savefiles** and **breaks all mod compatibility**.

### M (Major)
Advances when:
- New systems added (e.g., thermal simulation)
- New major backends (e.g., Vulkan renderer)
- Rewrite of subsystems without determinism change

### m (Minor)
Advances on additive nonbreaking changes:
- New ECS components  
- Additional APIs  
- Scheduler optimisations  

### r/p (Revision/Patch)
Fixes, refactors, performance changes not affecting behaviour.

---

# 3. GAME VERSION (G.M.m.r.p)

Same schema as ENGINE_VERSION but independent.

Advances for:

- New gameplay features  
- Balance changes  
- UI changes  
- Content reworks  

Game changes must **never break determinism**, except through engine changes.

---

# 4. DATA PACK VERSION (D.M.m)

Base game and DLC data packs follow:

DATA_VERSION = D.M.m

Where:

- D = Epoch of data (rare, only if format rewritten)
- M = Major content revision  
- m = Minor content addition or balance passes  

Data packs must remain loadable by all engine versions sharing the same `DATA_VERSION` major.

---

# 5. SAVEFILE VERSION (S.M)

SAVE_VERSION = S.M

Where:

- S = Savefile epoch (changes only with binary format rewrite)
- M = Savefile schema version compatible with a range of engine versions

Each savefile embeds:

- ENGINE_VERSION  
- GAME_VERSION  
- DATA_VERSION  
- SAVE_VERSION  
- MOD LIST (with versions)  

Loading a mismatched SAVE_VERSION triggers:

- migration path (if supported),  
or  
- hard failure.

---

# 6. NETWORK PROTOCOL VERSION (P.M)

PROTOCOL_VERSION = P.M

Lockstep network requires:

- identical ENGINE_VERSION  
- identical PROTOCOL_VERSION  
- identical DATA_VERSION  
- identical MOD_API_VERSION  
- identical mod list  

Mismatch → connection refused.

---

# 7. MOD API VERSION (A.M)

MOD_API_VERSION = A.M

Mods specify:

"mod_api_version_required": "A.M"

Rules:

- A changes only when engine scripting/binding APIs break  
- M increments when API expands safely  

Mods must refuse to load if mod_api_version mismatches.

---

# 8. VERSION FLOOR & CEILING

To support long-term backward compatibility:

### MIN_SUPPORTED_VERSION  
Lowest version this build can load or migrate from.

### MAX_COMPATIBLE_VERSION  
Highest version this build can connect/network with.

Guaranteed compatibility window:

ENGINE_VERSION within same Epoch (E)
GAME_VERSION any
DATA_VERSION same major M
PROTOCOL_VERSION identical
MOD_API_VERSION same major M
SAVE_VERSION convertible via migration table

---

# 9. VERSION-LOCK TABLES

The root build system produces:

/build/version-lock.json

Containing:

- Canonical version manifest  
- Build stamp  
- Platform hash  
- Determinism hash of the engine  
- Compatibility ranges  

This file is embedded into all runtime binaries for cross-verification.

---

# 10. DETERMINISM HASH

Every authoritative build generates:

DETERMINISM_HASH = SHA256(
engine binary +
component layouts +
serialization schema +
scheduler constants +
numeric constants +
merge rules
)

If any component differs between clients, multiplayer is forbidden.

---

# 11. HUMAN-READABLE VERSION STRING

Displayed in menus, logs, UI, diagnostics:

Dominium vG.M.m.r.p (Engine vE.M.m.r.p)
Data vD.M.m, Save vS.M, Protocol vP.M, ModAPI vA.M
DetHash: <first 12 chars>

---

# 12. RULES FOR VERSION INCREMENTS

### 12.1 Engine Version Increments
Required when:
- Tick ordering rules change  
- Component binary layout changes  
- Add/remove fixed-point constants  
- Execution sequencing changes  
- ECS memory layout changes  

### 12.2 Game Version Increments
Required when:
- New features added  
- UI rewrites  
- New recipes, tech, or machines  
- Balance changes

### 12.3 Data Version Increments
Required when:
- Prefab format changes  
- Construction system changes  
- Tile/material definitions change  

### 12.4 Save Version Increments
Required when:
- Serialization schema updates  
- Binary layout modified  

### 12.5 Protocol Version Increments
Required when:
- Network packet structures altered  
- Protocol logic changed  

### 12.6 Mod API Version Increments
Required when:
- Lua interface changes  
- Component scripting API changes  
- Editor API changes  

---

# 13. FILES REFERENCING VERSION

The following files **must reference this version manifest**:

- `/build/version.cmake`
- `/engine/core/dom_core_version.[ch]`
- `/game/client/version_display.cpp`
- `/packaging/*/installer_version.txt`
- `/data/base/manifest.json`
- All DLC manifests
- All mod manifests
- All retro-port build systems  
- All dedicated server builds

---

# 14. VERSION POLICY (MANDATORY RULES)

1. No hidden/undocumented version bumps.  
2. No reuse of prior version numbers.  
3. No version rollback.  
4. No per-platform version divergence.  
5. No version changes without changelog entry.  
6. No unofficial forks may use the same version numbers.  
7. Every released binary must embed full version metadata.  
8. Versioning is authoritative; everything must match.

---

# 15. OVERRIDES PROHIBITED

No dev, branch, or mod may override:

- ENGINE_VERSION  
- SAVE_VERSION  
- PROTOCOL_VERSION  
- MOD_API_VERSION  

Only official maintainers may change these values.

---

# 16. NEXT STEPS

The next file in the chain is: **CHANGELOG.md**.  
Say **Next** to continue.
You said:
Okay, what else do I need before I unlead chatgpt codex 5.1later I want a playable MVP with all systems, but just generate vector graphics for now, I'll make textures and sounds and music later. MVP: A fully complete core. 1 full size surface, on earth. All systems interractable, but minimal data prototypes and such for testing. Lua for all data. Dx9.0c, sdl2, win32. 2d vector top down. 3d vector first person. Next steps: Multiplayer Space, Sol system (mars, Venus, etc) All other renderers and platforms. 2d and 3d textures.
ChatGPT said:
Thought for 27s
GPT-5.1 • 2025-12-03
You’re missing a thin but very concrete layer between “giant spec” and “code the damn thing”.
You need three things before you point Codex at this:
1. A frozen MVP scope that is brutally minimal but touches every system once.
2. A precise engine API surface (headers + Lua API) that Codex must implement and not improvise around.
3. A first implementation plan: which files, in which order, with what stubs.
I’ll give you:
• A) What’s already “done enough”.
• B) What still needs to be specified before codegen.
• C) The exact MVP feature checklist.
• D) A concrete implementation order for Codex 5.1.

A) What is already “good enough” to start building on
From the V3 docs and directory contract, you already have:
• Determinism kernel:
o Integer/fixed-point model
o 7-phase tick pipeline
o Virtual lanes and merge phase
o Backpressure, queues, job system, messaging
• ECS + data layout:
o Stable IDs, dense arrays, component masks
o Chunk/subchunk hierarchy and IDs
• Serialization + save format:
o Block layout, chunk+entity+component encoding
• Spatial & physics abstraction:
o Meter grid, chunk/subchunk, BVH/WUG models
• Prefab + mod architecture:
o Prefab format, mod constraints
• Repo structure and meta:
o /engine, /game, /data, /tools, /tests, etc.
o Root docs, license, build policy
You don’t need more theory at this layer for an MVP.

B) What you still need to specify before you unleash Codex
You need a thin “contract layer” that Codex can blindly implement:
1. Minimal engine public API (C89) header set
You should lock down something like:
• engine/public/dom_engine.h
• engine/public/dom_world.h
• engine/public/dom_view.h
• engine/public/dom_lua.h
Each must declare only what the game/client is allowed to call.
Example (sketch level):
• dom_engine_init(const DomEngineConfig*);
• dom_engine_shutdown(void);
• dom_engine_tick(void);
• dom_engine_get_world_handle(void);
• dom_world_create_surface_earth(DomWorldHandle*);
• dom_world_spawn_test_content(DomWorldHandle*);
• dom_view_set_camera_2d(const DomCamera2D*);
• dom_view_set_camera_3d(const DomCamera3D*);
• dom_view_render_frame(void);
• dom_lua_register_standard_api(lua_State*);
• dom_lua_load_data_pack(const char* path);
You don’t need implementations in advance; you need function lists + signatures + ownership rules written down so Codex doesn’t invent different ones file by file.
2. Minimal Lua data schema
You say “Lua for all data”. For MVP you need one canonical schema and nothing else:
• data/base/entities.lua
o Machines, belts, pipes, poles, buildings as prefab defs.
• data/base/tiles.lua
• data/base/tech.lua (stub)
• data/base/signals.lua (stub)
You must define:
• What a “prefab table” looks like in Lua.
• What fields are mandatory and what are optional.
• How Lua maps to internal IDs (string name → 64-bit resource_id).
• Which parts are ignored in MVP (e.g., tech, complex recipes).
Without this, Codex will improvise incompatible Lua structures.
3. MVP render spec: 2D and 3D vector
You have “2d vector top down, 3d vector first person” but you need a deterministic render API:
• Coordinate space: engine is in meters; renderer uses:
o 2D: (world_x, world_y) → screen via orthographic transform
o 3D: (world_x, world_y, world_z) → camera transform + projection
• Which primitives the renderer exposes:
o Lines, rectangles, circles/ellipses, simple convex polys, text
• Where the “view” lives:
o Engine exports a list of renderable primitives each frame
or
o Renderer queries engine via a stable callback API
For MVP, simplest:
• Engine produces a flat list of DomDrawCmd in deterministic order.
• Client uses backend (DX9 “immediate mode-style” with dynamic vertex buffers) to draw them.
Define:
typedef enum {
    DOM_DRAW_LINE,
    DOM_DRAW_RECT,
    DOM_DRAW_FILLED_RECT,
    DOM_DRAW_POLYLINE,
    DOM_DRAW_TEXT
} DomDrawType;

typedef struct {
    float x, y; // screen or NDC coordinates; decision required
} DomVec2;

typedef struct {
    DomDrawType type;
    uint32_t    layer;
    uint32_t    color_rgba;
    DomVec2     points[8];
    uint32_t    point_count;
    // text: index into a text buffer
} DomDrawCmd;
You don’t have to lock exact struct now, but you must choose:
• World-space vs screen-space in this API.
• A layering model (z-order).
• How 3D view collapses into draw cmds (flattened by engine, view decides).
4. Platform stack decision: DX9, SDL2, Win32
Right now you have “Dx9.0c, sdl2, win32” in the same sentence. You need to decide:
• Win32: window + message pump
• DX9: rendering backend
• SDL2: audio (and maybe input), or nothing
Pick one:
• Option A (cleaner):
o Win32: window + input
o DX9: rendering
o SDL2: audio only
• Option B:
o SDL2: window + input + audio
o DX9: rendering via SDL_SysWMinfo HWND
Write this down in /engine/platform/win32/README.md or similar so Codex doesn’t mix approaches.
5. Input and camera MVP spec
You need:
• Keyboard/mouse bindings for:
o Pan/zoom 2D
o Move/look 3D
o Place building
o Pause, speed control
• Camera models:
o 2D: orthographic top-down; world-space units per pixel, zoom range, clamp rules
o 3D: first-person; position, yaw, pitch, FOV, near/far planes
Specify:
• Which keys do what.
• Sensitivity constants.
• Which functions the input layer calls (e.g. game_handle_input(const DomInputState*)).
6. Minimal test world definition
You need one “canonical test surface” for MVP:
• Earth, 1 surface, rectangular cut-out of maybe 4 km × 4 km.
• Initial content:
o 1 player spawn
o 1 small generator, 1 consumer, 1 short power line
o 1 water source + 1 pump + 1 pipe + 1 sink
o 1 short rail line + one vehicle
o 1 road + 1 vehicle
o 1 data pole or router
o 1 worker/robot that can walk and perform one job
This test world must be definable entirely via Lua + a tiny engine bootstrap function.
7. Minimal UI/HUD spec
You need at least:
• Top-left: tick, UPS, sim speed, det-hash.
• Bottom: hotbar of 5–10 placeable entities.
• Right: simple inspector of selected object (name, power in/out, status).
Define:
• What functions the UI calls into the engine.
• How selection works (click to raycast → entity handle).

C) MVP feature checklist (what “playable” actually means)
For your stated MVP:
1. Core loop and world
• dom_engine_init/shutdown implemented.
• 7-phase tick pipeline in place, even if many phases are thin.
• Single world with one surface, Earth; no multi-planet yet.
• Subtile/tile/subchunk/chunk grid types present, even if many unused.
2. ECS
• Entity IDs, generation, and dense components working.
• Minimal component set implemented:
o Transform (position, orientation)
o Tile occupancy
o Power node
o Fluid node (even if mostly stub)
o Data node (stub)
o Worker/agent
o Building (generic)
• Active lists + deterministic iteration in place.
3. Networks (minimal but real)
• Power:
o Graph connectivity
o Total gen/load, simple downrating logic
• Fluids:
o Extremely simplified (e.g., linear flow between two nodes)
• Data:
o Boolean “connected/disconnected” plus maybe 1-tick 1-hop signal
• Jobs:
o Single worker can accept a job, walk, and “operate” a machine for a fixed time.
4. Rendering
• DX9 device creation, basic swapchain.
• Vector renderer that:
o Draws a grid
o Draws tiles by color
o Draws simple icons for entities (rects, lines)
• 2D camera:
o Pan/zoom and clamp to world area.
• 3D camera:
o Move in space, look around.
o Simple line rendering of structures in 3D.
5. Input
• Keyboard+mouse:
o WASD + mouse pan/zoom 2D
o WASD + mouse look in 3D
o Left click to select, right click to place/cancel
• Basic keybinding config table, even if hardcoded.
6. Gameplay skeleton
• Can place at least:
o A building that consumes power.
o A generator that produces power.
o A pole or cable that connects them.
• Can start/pause simulation and see power values update.
• Can place at least one transport segment (rail or road) with a vehicle that moves deterministically on a spline or straight line.
• Worker/robot walks between two points performing a trivial job.
7. Lua data + loading
• Lua VM embedded.
• data/base/*.lua loaded at start.
• Prefabs and basic recipes defined in Lua.
• One scripted test scenario loaded via Lua.
8. Save/load
• Can save the current world to a .dom file.
• Can load it and reproduce state exactly (no broken determinism).
• Minimal error handling for version mismatch.
9. Debug/dev tools
• Simple in-game console (even if crude) with:
o dump_state
o step_tick
o spawn_entity
• Determinism check: run N ticks, save hash of core state, display it.
That’s the minimum bar before “MVP playable” means anything.

D) Implementation order for Codex 5.1
When you do “unleash Codex”, you want it to work in this order, directory by directory:
1. engine/core
o Implement core types, logging, fixed-point math, small array utilities.
o Implement deterministic RNG wrapper (even if barely used).
2. engine/sim
o Implement tick pipeline skeleton (all 7 phases, most empty).
o Implement ECS core: entity registry, components, masks, active lists.
o Implement a single dom_sim_world with one surface and tiles.
o Implement minimal power network, job system skeleton.
3. engine/render/vector2d + engine/render/dx9
o Implement backend-agnostic API.
o Implement DX9 “vector only” backend.
4. engine/platform/win32
o Win32 window + message loop.
o High-resolution timer for driving ticks.
o Input collection.
5. engine/ui (minimal) + game/client
o Main loop: platform pump → engine_tick → render.
o 2D/3D camera controllers.
o Very basic HUD.
6. engine/lua + data/base
o Embed Lua; load entities.lua etc.
o Spawn a few prefabs from Lua.
7. engine/net (stub) and save/load
o Enough code to serialize/deserialize current minimal world.
o No real multiplayer yet, but future-proof function names.
Once these steps compile and you can:
• Move the camera,
• Place a generator + consumer,
• See power flow,
• Watch a worker walk,
your MVP core is real.
Then your “Next steps” (multiplayer, Sol system, textures, other platforms) are extensions that slot cleanly into the same architecture without invalidating what you’ve just built.
You said:
We should be able to mix and match renderers and platforms. First I will develop dx9 for windows NT 2000 SP4 through Windows 11+, using native win32 or sdl2, later adding dx11, gl1, gl2, vk1, dx12. Then we will add Windows 98 SE+ using dx9 or gl1 and native win32 or sdl1. Then modern Linux and macosx gets POSIX or sdl2 and gl2 or vk1. Macos classic, msdos, android, etc versions come later.
ChatGPT said:
Thought for 18s
GPT-5.1 Thinking • 2025-12-03
You need a clean cross-product of:
• Platform backends (window/input/timer/file)
• Renderer backends (DX9, DX11, GL1/2, VK1, DX12, software)
• Simulation/engine (unchanged)
All mix-and-match without touching sim code.
I’ll give you:
1. The layering you must lock in now.
2. How to declare platform + renderer APIs so combos are trivial.
3. How to handle your rollout sequence (NT 2000→11, then 98SE, then POSIX, etc.) without painting yourself into a corner.
4. What extra spec you still need before codegen.

1. Hard layering: Platform ⟂ Renderer ⟂ Engine
Freeze this now and don’t deviate:
• Engine/Sim (pure C89)
o Knows nothing about Win32/SDL/DX/GL/VK.
o Produces deterministic sim state + a list of “draw commands” or “renderables”.
• Platform backend (C89, OS-specific)
o Creates window / surface
o Handles input events
o Provides monotonic timers and sleeping
o Handles file paths, environment, process args
o Exposes “native handles” (HWND, HDC, HGLRC, X11 Display/Window, NSWindow*, etc.) OR SDL window pointer.
• Renderer backend (C89/C99-ish, graphics-API-specific)
o Takes a “platform graphics context descriptor” and a frame’s render commands.
o Does only drawing and GPU resource management.
Result:
• Platform can be Win32 native or SDL on Windows, POSIX or SDL on Linux, Cocoa or SDL on macOS.
• Renderer can be DX9, DX11, GL1, GL2, Vulkan, DX12, or pure software.
• Engine is unaware which combo is used.

2. Define strict C APIs now
You need two small but rigid interfaces.
2.1 Platform interface
Header: /engine/platform/dom_platform.h
Core types:
typedef struct DomPlatformConfig {
    const char *app_name;
    int         window_width;
    int         window_height;
    int         fullscreen;  /* 0/1 */
} DomPlatformConfig;

typedef struct DomPlatformWindowHandle {
    void *native;  /* HWND*, SDL_Window*, NSWindow*, etc. */
    void *extra;   /* HDC*, X11 Display*, etc., as needed */
} DomPlatformWindowHandle;

typedef struct DomInputState {
    /* simple snapshot: keys, mouse buttons, axes */
    uint8_t key_down[256];
    int     mouse_x;
    int     mouse_y;
    int     mouse_dx;
    int     mouse_dy;
    uint8_t mouse_buttons; /* bitfield */
    /* more later (gamepads, etc.) */
} DomInputState;
Core functions:
int  dom_platform_init(const DomPlatformConfig *cfg);
void dom_platform_shutdown(void);

int  dom_platform_pump_events(DomInputState *out_input);
/* returns 0 if quit requested */

void dom_platform_get_window(DomPlatformWindowHandle *out_handle);

double dom_platform_get_time_seconds(void);
void   dom_platform_sleep_milliseconds(unsigned ms);

/* Logging / message box */
void dom_platform_log(const char *msg);
void dom_platform_fatal(const char *msg);
Then you implement:
• dom_platform_win32_dx (HWND, WNDPROC, QueryPerformanceCounter…)
• dom_platform_win32_sdl2 (SDL_Init, SDL_CreateWindow…)
• Later: dom_platform_posix_sdl2, dom_platform_macos_cocoa, etc.
This API never changes per OS; only implementations change.
2.2 Renderer interface
Header: /engine/render/dom_render_api.h
Backend IDs:
typedef enum DomRenderBackendId {
    DOM_RENDER_BACKEND_SOFTWARE = 0,
    DOM_RENDER_BACKEND_DX9,
    DOM_RENDER_BACKEND_DX11,
    DOM_RENDER_BACKEND_GL1,
    DOM_RENDER_BACKEND_GL2,
    DOM_RENDER_BACKEND_VK1,
    DOM_RENDER_BACKEND_DX12,
    DOM_RENDER_BACKEND_COUNT
} DomRenderBackendId;
Capabilities:
typedef struct DomRenderCaps {
    int supports_2d;
    int supports_3d;
    int supports_msaa;
    int supports_offscreen;
    int max_texture_size;
    /* later: instancing, compute, etc. */
} DomRenderCaps;
Context + init:
typedef struct DomRenderConfig {
    DomRenderBackendId backend;
    int                width;
    int                height;
    int                vsync;      /* 0/1 */
    int                fullscreen; /* 0/1 */
} DomRenderConfig;

typedef struct DomRenderContext DomRenderContext; /* opaque */
Draw commands (vector-first MVP):
typedef enum {
    DOM_DRAW_LINE,
    DOM_DRAW_TRI,
    DOM_DRAW_RECT,
    DOM_DRAW_FILLED_RECT,
    DOM_DRAW_POLY,
    DOM_DRAW_TEXT_2D,
    DOM_DRAW_MESH_3D,   /* may be stubbed initially */
} DomDrawType;

typedef struct {
    float x, y;
} DomVec2f;

typedef struct {
    float x, y, z;
} DomVec3f;

typedef struct DomDrawCmd {
    DomDrawType type;
    uint32_t    layer;         /* sort order */
    uint32_t    color_rgba;    /* 0xAARRGGBB */

    union {
        struct { DomVec2f a, b; } line;
        struct { DomVec2f p[4]; } rect;
        struct { DomVec2f *verts; uint32_t count; } poly2d;
        struct { DomVec3f *verts; uint32_t count; } mesh3d;
        struct { DomVec2f pos; uint32_t text_id; } text2d;
    } u;
} DomDrawCmd;
Renderer entry points:
DomRenderContext *dom_render_create(const DomRenderConfig *cfg,
                                    const DomPlatformWindowHandle *win,
                                    DomRenderCaps *out_caps);

void dom_render_destroy(DomRenderContext *ctx);

void dom_render_resize(DomRenderContext *ctx, int width, int height);

/* Engine gives a sorted array of commands each frame */
void dom_render_frame(DomRenderContext      *ctx,
                      const DomDrawCmd      *cmds,
                      uint32_t               cmd_count);
Then you have:
• /engine/render/dx9/dom_render_dx9.c implementing these against Direct3D9.
• Later: dom_render_dx11.c, dom_render_gl1.c, etc.
Engine/game never calls DX APIs directly.

3. Mixing and matching: how to keep the matrix sane
You’re aiming for this matrix over time:
PlatformPlatform backendRenderer backendsWin NT 2000–11Win32, SDL2DX9, DX11, GL1, GL2, VK1, DX12, softwareWin 98 SEWin32, SDL1DX9*, GL1, softwareLinux (modern)POSIX, SDL2GL2, VK1, softwaremacOS XCocoa, SDL2GL2, VK1 (MoltenVK), softwareLater retro portscustomSW, GL1 where possibleTo avoid hell:
1. Compile-time capabilities
Each platform backend exposes which renderer backends are legal on that build (via a small function returning a bitmask), based on OS + SDK availability.
2. Runtime selection logic
At start, you pass:
o CLI/config: preferred platform backend ID + preferred renderer backend ID
o Engine queries availability; if unsupported, it walks a fallback chain:
• Example on Win2000:
• Try DX9
• If DX9 fails, try GL1
• If all fail, fall back to software
o On Win98 you statically disable backends that require newer kernel or D3D9Ex, etc.
3. Backend registry
One central table:
4. typedef struct {
5.     DomRenderBackendId id;
6.     const char        *name;
7.     int  (*is_supported)(void);
8.     DomRenderContext *(*create)(const DomRenderConfig *, const DomPlatformWindowHandle *, DomRenderCaps *);
9.     void (*destroy)(DomRenderContext *);
10.     void (*resize)(DomRenderContext *, int, int);
11.     void (*frame)(DomRenderContext *, const DomDrawCmd *, uint32_t);
12. } DomRenderBackendVTable;
The DX9, GL1, GL2, etc. backends register themselves here at link-time or via a static array.
Similarly you can have a DomPlatformBackendVTable.
This gives you:
• Win32+DX9 now.
• Win32+SDL2+DX9 later, no engine changes.
• POSIX+SDL2+GL2 later, no engine changes.

4. Your rollout sequence mapped to this architecture
Phase 1 — Windows NT 2000 SP4 → 11, DX9, Win32
Targets:
• dom_platform_win32
• dom_render_dx9
• Entire engine running with:
o 2D vector top-down
o 3D vector “wireframe” first person
Details:
• Use pure Win32 window for this phase (no SDL yet) to keep debugging clean.
• DX9 backend must:
o Create device with fixed feature set usable from 2000→11 (no D3D9Ex-only stuff).
• SDL2 is postponed until core is stable.
Phase 1.5 — Add SDL2 on Windows
• Implement dom_platform_win32_sdl2 which wraps SDL2 for window+input+audio, but still passes native HWND to DX9.
• Renderer API remains unchanged.
Phase 2 — Add DX11, GL1, GL2, VK1, DX12 on Windows
• Add extra renderer backends under /engine/render/:
o dx11, gl1, gl2, vk1, dx12.
• All follow the same DomRenderBackendVTable contract.
• For old OS:
o Build configuration for Win2000 disables DX11/DX12/Vulkan at compile time.
Phase 3 — Windows 98 SE
• New platform target: dom_platform_win9x (probably under /ports/win9x or /engine/platform/win9x depending how you separate).
• Renderer:
o DX9 is tricky on 9x; you may end up using DX8/early DX9 or just GL1 + software.
• Same engine and render APIs. Only the platform/renderer pairs change.
Phase 4 — Linux/macOS X
• Platforms:
o dom_platform_posix_sdl2 (Linux)
o dom_platform_macos_cocoa or dom_platform_macos_sdl2
• Renderers:
o dom_render_gl2
o dom_render_vk1 (optional)
• Engine stays identical.
Retro (DOS, macOS Classic, etc.) can live in /ports/ using the same high-level signatures but with different build systems.

5. Determinism and renderers
You must lock one rule: renderer is a pure observer.
• Render backends never:
o Touch simulation state.
o Generate random numbers.
o Poll the OS clock for simulation decisions.
• Engine generates a deterministic set of draw commands based on sim state; renderer just displays them arbitrarily fast or slow.
That’s the only way all these renderer/platform combos don’t poison determinism.

6. What you still must write before codegen
You’re almost there, but you need a couple of explicit spec files:
1. engine/platform/PLATFORM_API.md
o Exact function set for dom_platform_*.
o Meaning of each field, lifetime rules (window handle, timing).
2. engine/render/RENDER_API.md
o Exact DomDrawCmd struct and allowed types.
o Sorting rules (layer, stable ordering).
o World vs screen coordinates choice.
o Rules for 2D vs 3D in the same list.
3. docs/render_backends.md
o Matrix of:
• backend → supported platforms
• backend → feature flags (2D/3D, textures, MSAA, etc.)
o Fallback rules.
4. A small config schema (INI/TOML/JSON) to select platform/renderer:
Example:
[video]
platform = "win32"     ; or "sdl2"
renderer = "dx9"       ; or "gl2", "vk1", "dx11", etc.
width    = 1920
height   = 1080
fullscreen = 0
vsync      = 1
Once these are written, Codex can:
• Implement each backend against a stable header.
• Implement the configuration and selection logic once.
• Let you expand backends over years without touching the engine or game layer.
You don’t need more abstractions than this. If you keep to these interfaces, you’ll get the mix-and-match renderer/platform matrix you’re after without rewrites every time you add a new backend.
You said:
Okay, what changes do we need to put in an addendum for codex, given that it doesn't have updated since our last file generated
ChatGPT said:
Thought for 13s
GPT-5.1 • 2025-12-03
Below is what you should put into a single new doc (e.g. docs/spec/CODEGEN_ADDENDUM.md).
This is written as if addressed to Codex / future codegen: what changed, what overrides old assumptions, what must be followed.

# Dominium V3 — Codegen Addendum (Renderer/Platform/Engine Split)

This addendum **modifies and extends** previous V3 specs and directory contracts.  
Any contradictions: this file WINS.

It exists to stop code generators from baking in wrong assumptions about rendering, platforms, or OS APIs.

---

## 1. Purpose and Scope

1. This addendum defines:
   - The **layering contract** between engine, platform, and renderer.
   - The **public C APIs** that must be implemented for:
     - Platform backends (`dom_platform_*`)
     - Renderer backends (`dom_render_*`)
   - The **initial MVP target set**:
     - Windows NT 2000 SP4 → Windows 11+
     - Win32 platform
     - Direct3D 9 renderer
     - 2D + 3D **vector-only** drawing

2. Simulation, determinism kernels, ECS, serialization, job system, etc., in existing V3 volumes remain authoritative and unchanged.

---

## 2. Hard Layering Rules (Overrides Earlier Implicit Assumptions)

Previous specs sometimes blurred platform vs renderer responsibilities.  
From now on, the following rules are hard:

1. **Engine/Sim layer (deterministic core)**
   - Pure C89.
   - No OS headers.
   - No graphics or audio APIs.
   - No DirectX/OpenGL/Vulkan/SDL/Win32/etc.
   - Only knows about **abstract draw commands**, **input state**, and **time** through engine-level APIs.

2. **Platform backends (`/engine/platform/...`)**
   - Responsible for:
     - Window/surface creation.
     - Input collection.
     - Time and sleep primitives.
     - Filesystem/paths, environment, arguments.
   - The only place that may include:
     - `<windows.h>`, X11, Cocoa, Android NDK, etc.
     - SDL headers (if that variant uses SDL).
   - Must expose a **stable C API** (`dom_platform_*`).

3. **Renderer backends (`/engine/render/...`)**
   - Responsible for:
     - Creating and managing GPU (or software) render contexts.
     - Drawing the frame from **draw commands** produced by the engine.
   - The only place that may include:
     - Direct3D 9/11/12 headers.
     - OpenGL, WGL/GLX, Vulkan headers.
   - Must expose a **stable C API** (`dom_render_*`).
   - Renderer is **purely observational**: it cannot modify simulation state, call randomness, or influence determinism.

4. No other layer may call any graphics or OS APIs directly.  
   - No DirectX in `/engine/sim`.
   - No Win32 includes in `/engine/core` or `/game`.
   - No SDL in `/engine/sim`.

---

## 3. Platform API Contract

New canonical header: `engine/platform/dom_platform.h`

This MUST be implemented by each platform backend and is the only interface the engine/game relies on.

### 3.1 Types

```c
typedef struct DomPlatformConfig {
    const char *app_name;
    int         window_width;
    int         window_height;
    int         fullscreen;  /* 0 = windowed, 1 = fullscreen */
} DomPlatformConfig;

/* Abstract handle to a window/surface and associated "native" objects. */
typedef struct DomPlatformWindowHandle {
    void *native;  /* e.g. HWND*, SDL_Window*, NSWindow*, etc. */
    void *extra;   /* e.g. HDC*, X11 Display*, NSView*, etc. (may be NULL) */
} DomPlatformWindowHandle;

typedef struct DomInputState {
    /* Keys: simple linear index for now (virtual key codes or custom map). */
    unsigned char key_down[256];

    int mouse_x;      /* window-relative */
    int mouse_y;
    int mouse_dx;     /* delta since last frame */
    int mouse_dy;
    unsigned char mouse_buttons; /* bitfield: LMB=1, RMB=2, MMB=4, etc. */
} DomInputState;
3.2 Functions
/* Initialise platform backend, create main window, etc. */
int  dom_platform_init(const DomPlatformConfig *cfg);

/* Destroy window, free platform resources. */
void dom_platform_shutdown(void);

/* Pump OS events, update input, return 0 if quit requested. */
int  dom_platform_pump_events(DomInputState *out_input);

/* Retrieve native window handle(s) for renderer creation. */
void dom_platform_get_window(DomPlatformWindowHandle *out_handle);

/* Monotonic time in seconds (double is allowed here, platform layer only). */
double dom_platform_get_time_seconds(void);

/* Sleep for at least the specified milliseconds. */
void   dom_platform_sleep_milliseconds(unsigned ms);

/* Logging and fatal reporting from engine. Implementation may log to console, file, etc. */
void dom_platform_log(const char *msg);
void dom_platform_fatal(const char *msg);
3.3 Implementation Targets (MVP First)
For MVP, only one platform backend must exist:
• engine/platform/win32/dom_platform_win32.c
o Uses native Win32 API (no SDL) for:
• Window, message loop, input, timing.
Future backends:
• engine/platform/win32_sdl2 (Win + SDL2)
• engine/platform/win9x (Win98 SE)
• engine/platform/posix_sdl2 (Linux)
• engine/platform/macos_cocoa or _sdl2 (macOS X)
• etc.
All must obey the same header and never change its signature.

4. Renderer API Contract
New canonical header: engine/render/dom_render_api.h
This is the only interface the engine/game uses to draw.
4.1 Backend IDs and Caps
typedef enum DomRenderBackendId {
    DOM_RENDER_BACKEND_SOFTWARE = 0,
    DOM_RENDER_BACKEND_DX9,
    DOM_RENDER_BACKEND_DX11,
    DOM_RENDER_BACKEND_GL1,
    DOM_RENDER_BACKEND_GL2,
    DOM_RENDER_BACKEND_VK1,
    DOM_RENDER_BACKEND_DX12,
    DOM_RENDER_BACKEND_COUNT
} DomRenderBackendId;

typedef struct DomRenderCaps {
    int supports_2d;
    int supports_3d;
    int supports_msaa;
    int supports_offscreen;
    int max_texture_size;
    /* More later as needed. */
} DomRenderCaps;
4.2 Config and Context
typedef struct DomRenderConfig {
    DomRenderBackendId backend;
    int                width;
    int                height;
    int                vsync;      /* 0/1 */
    int                fullscreen; /* 0/1 */
} DomRenderConfig;

typedef struct DomRenderContext DomRenderContext; /* opaque */
4.3 Draw Commands (Vector-first)
MVP uses vector graphics only; textures/meshes can be stubbed.
typedef enum {
    DOM_DRAW_LINE,
    DOM_DRAW_RECT,
    DOM_DRAW_FILLED_RECT,
    DOM_DRAW_POLY,
    DOM_DRAW_TEXT_2D,
    DOM_DRAW_WIREFRAME_3D  /* simple 3D lines/wireframe */
} DomDrawType;

typedef struct {
    float x, y;
} DomVec2f;

typedef struct {
    float x, y, z;
} DomVec3f;

typedef struct DomDrawCmd {
    DomDrawType type;
    unsigned    layer;      /* sort key for z-order */
    unsigned    color_rgba; /* 0xAARRGGBB */

    union {
        struct { DomVec2f a, b; } line;
        struct { DomVec2f p0, p1; } rect;  /* p0=min, p1=max */
        struct { DomVec2f *verts; unsigned count; } poly2d;
        struct { DomVec3f *verts; unsigned count; } wire3d;
        struct { DomVec2f pos; unsigned text_id; } text2d;
    } u;
} DomDrawCmd;
Coordinate choice (MVP rule):
• All DomDrawCmd coordinates are world-space meters.
• The engine/game provides a camera transform; renderer applies:
o For 2D: orthographic projection.
o For 3D: simple perspective using a provided camera matrix (to be specified in engine/game API, not here).
Renderer backends must not interpret world state; they just turn DomDrawCmd + camera into pixels.
4.4 Renderer Entry Points
DomRenderContext *
dom_render_create(const DomRenderConfig          *cfg,
                  const DomPlatformWindowHandle  *win,
                  DomRenderCaps                  *out_caps);

void dom_render_destroy(DomRenderContext *ctx);

void dom_render_resize(DomRenderContext *ctx, int width, int height);

/* Engine provides a sorted array of commands per frame. */
void dom_render_frame(DomRenderContext      *ctx,
                      const DomDrawCmd      *cmds,
                      unsigned                cmd_count);
Backends must be implemented as standalone modules:
• engine/render/dx9/dom_render_dx9.c
• Later: engine/render/dx11/dom_render_dx11.c, engine/render/gl1/dom_render_gl1.c, etc.
No backend may change the API or add engine-visible entry points.

5. Backend Registry and Selection
To support mix-and-match platform/renderer combos cleanly, there will be a backend registry.
New internal header: engine/render/dom_render_registry.h
typedef struct DomRenderBackendVTable {
    DomRenderBackendId id;
    const char        *name;

    int (*is_supported)(void); /* checks OS/driver/API availability */

    DomRenderContext *(*create)(const DomRenderConfig *,
                                const DomPlatformWindowHandle *,
                                DomRenderCaps *);
    void (*destroy)(DomRenderContext *);
    void (*resize)(DomRenderContext *, int, int);
    void (*frame)(DomRenderContext *, const DomDrawCmd *, unsigned);
} DomRenderBackendVTable;

const DomRenderBackendVTable *dom_render_get_backends(unsigned *out_count);
Each backend module defines a static DomRenderBackendVTable and registers it in a compile-time table.
Engine/game uses this registry to:
• Look up the requested backend by ID.
• Fall back if unsupported (e.g., DX9 unavailable → GL1 → software).
Codex must not improvise other selection logic. It must follow this pattern.

6. MVP Target Matrix (Codegen Constraints)
For the first implementation pass:
1. Build target:
o OS: Windows NT 2000 SP4 → Windows 11+
o Platform: dom_platform_win32 (Win32 native)
o Renderer: dom_render_dx9 (Direct3D 9.0c)
2. Other backends exist only as stubs or are not implemented yet:
o DO NOT attempt DX11, GL1/GL2, Vulkan, DX12, SDL platforms in the first pass.
o These will be added later with the same APIs.
3. Renderer capability flags:
o supports_2d = 1
o supports_3d = 1 (wireframe)
o supports_offscreen = 0 (MVP can ignore offscreen)
o supports_msaa = 0 (optional; default off)
4. Texture and complex mesh support:
o Optional and low priority in MVP.
o Focus first on vector lines/rects/polys and simple 3D wireframes.

7. Determinism and Rendering (Explicit Rules)
These rules override any vague or ambiguous earlier text:
1. Renderer may not modify simulation state.
o No calls from renderer back into /engine/sim.
o No writes to ECS components, jobs, networks, etc.
2. Renderer may not affect simulation timing.
o Simulation tick step is driven by engine using dom_platform_get_time_seconds and the UPS configuration.
o If rendering is too slow, simulation slows down (UPS drop) per determinism spec; renderer never “skips” sim ticks on its own.
3. Renderer may not use random numbers to affect visible state.
o If some visual-only noise is added in future, it must be seeded deterministically from sim state, not from wall-clock.
4. Renderer may not read OS clock directly for simulation decisions.
o Platform may read it only to implement dom_platform_get_time_seconds.
o Engine uses that to drive its tick scheduler.
5. Draw command generation is deterministic.
o Engine/game must generate DomDrawCmd[] based solely on deterministic sim state.
o For a given tick and camera, the command list must be identical across runs.

8. Input and Camera (Minimal Contract for Codegen)
Input and camera are not fully specified in previous docs. For MVP, Codex must assume:
1. A thin engine-level API receives DomInputState each frame, e.g.:
2. /* Called once per frame by main loop after dom_platform_pump_events. */
3. void dom_engine_handle_input(const DomInputState *state);
4. Camera control is implemented in a game or engine view module, not in platform or renderer.
Example (not fixed, but indicative):
void dom_view_set_camera_2d(const DomVec2f *center, float zoom);
void dom_view_set_camera_3d(const DomVec3f *pos,
                            float yaw, float pitch, float fov);
5. Renderer backends receive already-transformed DomDrawCmd or a camera transform; they do not compute gameplay camera logic.

9. Directory and File Placement Constraints (Renderer/Platform)
Add to the existing directory contract:
1. All platform implementations must live under:
o /engine/platform/<backend_name>/*.c
o Do not put Win32 code under /game or /engine/sim.
2. All renderer implementations must live under:
o /engine/render/<backend_name>/*.c
o Do not put DirectX/OpenGL/Vulkan calls under /engine/sim or /game.
3. The only headers allowed to be included from renderer code are:
o Engine public render headers (dom_render_api.h and internal registry headers).
o Platform window handle types as needed.
o OS/graphics headers.
4. The only headers allowed to be included from platform code are:
o Platform API headers (dom_platform.h).
o OS headers.
o No simulation or render headers.

10. Summary for Codegen
When generating code for Dominium:
1. Do NOT call graphics APIs from simulation or game logic.
2. Do NOT call OS APIs outside /engine/platform (and /ports in future).
3. Do implement:
o dom_platform_* per this addendum.
o dom_render_* per this addendum.
4. MVP focus:
o Win32 platform backend (dom_platform_win32).
o DX9 renderer backend (dom_render_dx9).
o Vector-only 2D/3D drawing.
o Everything else is secondary.
This addendum is binding and overrides any earlier ambiguity in the V3 volumes about platform, rendering, or OS integration.

