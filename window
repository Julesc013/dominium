source/domino/render\gdi\gdi_gfx.h:/* Forward-declare Windows types without pulling windows.h into headers */
source/domino/render\gdi\gdi_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\gdi\gdi_gfx.c:    bmi.bmiHeader.biHeight = -height; /* top-down */
source/domino/render\gdi\gdi_gfx.c:    if (!desc || !desc->window) {
source/domino/render\gdi\gdi_gfx.c:    g_gdi.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\gdi\gdi_gfx.c:    g_gdi.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\gdi\gdi_gfx.c:    g_gdi.native_window = dsys_window_get_native_handle(desc->window);
source/domino/render\gdi\gdi_gfx.c:        g_gdi.camera_offset_x = cam->offset_x;
source/domino/render\gdi\gdi_gfx.c:        g_gdi.camera_offset_y = cam->offset_y;
source/domino/render\gdi\gdi_gfx.c:        r = (BYTE)((spr->color_rgba >> 16) & 0xffu);
source/domino/render\gdi\gdi_gfx.c:        g = (BYTE)((spr->color_rgba >> 8) & 0xffu);
source/domino/render\gdi\gdi_gfx.c:        b = (BYTE)(spr->color_rgba & 0xffu);
source/domino/render\gdi\gdi_gfx.c:        rect.left = spr->x + g_gdi.camera_offset_x;
source/domino/render\gdi\gdi_gfx.c:        rect.top = spr->y + g_gdi.camera_offset_y;
source/domino/render\gdi\gdi_gfx.c:        rect.right = rect.left + spr->w;
source/domino/render\gdi\gdi_gfx.c:        rect.bottom = rect.top + spr->h;
source/domino/render\gdi\gdi_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\gdi\gdi_gfx.c:    ptr = cmd_buf->data;
source/domino/render\gdi\gdi_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\gdi\gdi_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\gdi\gdi_gfx.c:        switch (cmd->op) {
source/domino/render\xga\xga_hw.c:/* Stub VRAM buffer to mirror writes in non-XGA environments. */
source/domino/render\xga\xga_hw.c:        if (copy_w > mode->width)  copy_w = mode->width;
source/domino/render\xga\xga_hw.c:        if (copy_h > mode->height) copy_h = mode->height;
source/domino/render\dx\dx9\dom_render_dx9.c:    out_caps->supports_textures = 1;
source/domino/render\dx\dx9\dom_render_dx9.c:    out_caps->supports_blending = 1;
source/domino/render\dx\dx9\dom_render_dx9.c:    out_caps->supports_linear_filter = 1;
source/domino/render\dx\dx9\dom_render_dx9.c:    out_caps->supports_aniso = 0;
source/domino/render\dx\dx9\dom_render_dx9.c:    r->config = *cfg;
source/domino/render\dx\dx9\dom_render_dx9.c:    r->mode = cfg->mode;
source/domino/render\dx\dx9\dom_render_dx9.c:    r->width = cfg->width;
source/domino/render\dx\dx9\dom_render_dx9.c:    r->height = cfg->height;
source/domino/render\dx\dx9\dom_render_dx9.c:    hwnd = (HWND)cfg->platform_window;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->d3d = Direct3DCreate9(D3D_SDK_VERSION);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!st->d3d) {
source/domino/render\dx\dx9\dom_render_dx9.c:    memset(&st->pp, 0, sizeof(st->pp));
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.Windowed = TRUE;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.BackBufferFormat = D3DFMT_X8R8G8B8;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.BackBufferWidth = r->width;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.BackBufferHeight = r->height;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
source/domino/render\dx\dx9\dom_render_dx9.c:        st->d3d,
source/domino/render\dx\dx9\dom_render_dx9.c:        &st->pp,
source/domino/render\dx\dx9\dom_render_dx9.c:        &st->device);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (FAILED(hr) || !st->device) {
source/domino/render\dx\dx9\dom_render_dx9.c:        IDirect3D9_Release(st->d3d);
source/domino/render\dx\dx9\dom_render_dx9.c:    r->backend_state = st;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!r || !r->backend_state) {
source/domino/render\dx\dx9\dom_render_dx9.c:    st = (DomRenderDX9State *)r->backend_state;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (st->device) {
source/domino/render\dx\dx9\dom_render_dx9.c:        IDirect3DDevice9_Release(st->device);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (st->d3d) {
source/domino/render\dx\dx9\dom_render_dx9.c:        IDirect3D9_Release(st->d3d);
source/domino/render\dx\dx9\dom_render_dx9.c:    r->backend_state = 0;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!r || !r->backend_state) {
source/domino/render\dx\dx9\dom_render_dx9.c:    st = (DomRenderDX9State *)r->backend_state;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.BackBufferWidth = w;
source/domino/render\dx\dx9\dom_render_dx9.c:    st->pp.BackBufferHeight = h;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!st->device) {
source/domino/render\dx\dx9\dom_render_dx9.c:    hr = IDirect3DDevice9_Reset(st->device, &st->pp);
source/domino/render\dx\dx9\dom_render_dx9.c:    float x0 = (float)rc->rect.x;
source/domino/render\dx\dx9\dom_render_dx9.c:    float y0 = (float)rc->rect.y;
source/domino/render\dx\dx9\dom_render_dx9.c:    float x1 = (float)(rc->rect.x + rc->rect.w);
source/domino/render\dx\dx9\dom_render_dx9.c:    float y1 = (float)(rc->rect.y + rc->rect.h);
source/domino/render\dx\dx9\dom_render_dx9.c:    D3DCOLOR c = (D3DCOLOR)rc->color;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (poly->count < 2) {
source/domino/render\dx\dx9\dom_render_dx9.c:    for (i = 0; i < poly->count; ++i) {
source/domino/render\dx\dx9\dom_render_dx9.c:        DomVec2i a = poly->pts[i];
source/domino/render\dx\dx9\dom_render_dx9.c:        DomVec2i b = poly->pts[(i + 1u) % poly->count];
source/domino/render\dx\dx9\dom_render_dx9.c:        dom_dx9_draw_line(dev, (float)a.x, (float)a.y, (float)b.x, (float)b.y, (D3DCOLOR)poly->color);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!r || !r->backend_state) {
source/domino/render\dx\dx9\dom_render_dx9.c:    st = (DomRenderDX9State *)r->backend_state;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!st->device) {
source/domino/render\dx\dx9\dom_render_dx9.c:    IDirect3DDevice9_Clear(st->device, 0, NULL, D3DCLEAR_TARGET, (D3DCOLOR)r->state.clear_color, 1.0f, 0);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (FAILED(IDirect3DDevice9_BeginScene(st->device))) {
source/domino/render\dx\dx9\dom_render_dx9.c:    IDirect3DDevice9_SetFVF(st->device, DOM_DX9_FVF);
source/domino/render\dx\dx9\dom_render_dx9.c:        switch (cmd->type) {
source/domino/render\dx\dx9\dom_render_dx9.c:            dom_dx9_draw_line(st->device,
source/domino/render\dx\dx9\dom_render_dx9.c:                              (float)cmd->u.line.x0, (float)cmd->u.line.y0,
source/domino/render\dx\dx9\dom_render_dx9.c:                              (float)cmd->u.line.x1, (float)cmd->u.line.y1,
source/domino/render\dx\dx9\dom_render_dx9.c:                              (D3DCOLOR)cmd->u.line.color);
source/domino/render\dx\dx9\dom_render_dx9.c:            dom_dx9_draw_rect(st->device, &cmd->u.rect);
source/domino/render\dx\dx9\dom_render_dx9.c:            dom_dx9_draw_poly(st->device, &cmd->u.poly);
source/domino/render\dx\dx9\dom_render_dx9.c:            /* Vector-only path draws placeholders instead of sampling textures. */
source/domino/render\dx\dx9\dom_render_dx9.c:            if (r->mode == DOM_RENDER_MODE_VECTOR_ONLY || !r->caps.supports_textures) {
source/domino/render\dx\dx9\dom_render_dx9.c:                dom_dx9_draw_placeholder_sprite(st->device,
source/domino/render\dx\dx9\dom_render_dx9.c:                                                cmd->u.sprite.x,
source/domino/render\dx\dx9\dom_render_dx9.c:                                                cmd->u.sprite.y,
source/domino/render\dx\dx9\dom_render_dx9.c:                                                (D3DCOLOR)r->state.default_color);
source/domino/render\dx\dx9\dom_render_dx9.c:            dom_dx9_draw_placeholder_sprite(st->device,
source/domino/render\dx\dx9\dom_render_dx9.c:                                            cmd->u.sprite.x,
source/domino/render\dx\dx9\dom_render_dx9.c:                                            cmd->u.sprite.y,
source/domino/render\dx\dx9\dom_render_dx9.c:                                            (D3DCOLOR)r->state.default_color);
source/domino/render\dx\dx9\dom_render_dx9.c:    IDirect3DDevice9_EndScene(st->device);
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!r || !r->backend_state) {
source/domino/render\dx\dx9\dom_render_dx9.c:    st = (DomRenderDX9State *)r->backend_state;
source/domino/render\dx\dx9\dom_render_dx9.c:    if (!st->device) {
source/domino/render\dx\dx9\dom_render_dx9.c:    IDirect3DDevice9_Present(st->device, NULL, NULL, NULL, NULL);
source/domino/render\CMakeLists.txt:        "-framework Carbon"
source/domino/render\CMakeLists.txt:        "-framework CoreGraphics"
source/domino/render\CMakeLists.txt:        "-framework CoreFoundation"
source/domino/render\CMakeLists.txt:        "-framework Metal"
source/domino/render\CMakeLists.txt:        "-framework QuartzCore"
source/domino/render\CMakeLists.txt:        "-framework AppKit"
source/domino/render\CMakeLists.txt:        "-framework OpenGL"
source/domino/render\xga\xga_gfx.c:    req_w = (uint16_t)((desc->width > 0) ? desc->width : 640);
source/domino/render\xga\xga_gfx.c:    req_h = (uint16_t)((desc->height > 0) ? desc->height : 480);
source/domino/render\xga\xga_gfx.c:        memcpy(g_xga.view, cam->view, sizeof(g_xga.view));
source/domino/render\xga\xga_gfx.c:        memcpy(g_xga.proj, cam->proj, sizeof(g_xga.proj));
source/domino/render\xga\xga_gfx.c:        memcpy(g_xga.world, cam->world, sizeof(g_xga.world));
source/domino/render\xga\xga_gfx.c:        int x = spr->x + g_xga.camera2d_x;
source/domino/render\xga\xga_gfx.c:        int y = spr->y + g_xga.camera2d_y;
source/domino/render\xga\xga_gfx.c:        soft_raster_fill_rect_2d(&g_xga.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\xga\xga_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\xga\xga_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\xga\xga_gfx.c:    ptr = cmd_buf->data;
source/domino/render\xga\xga_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\xga\xga_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\xga\xga_gfx.c:        switch (cmd->op) {
source/domino/render\ega\ega_hw.c:        out_mode->kind = EGA_MODE_KIND_640x350_16;
source/domino/render\ega\ega_hw.c:        out_mode->width = 640u;
source/domino/render\ega\ega_hw.c:        out_mode->height = 350u;
source/domino/render\ega\ega_hw.c:        out_mode->logical_bpp = 4u;
source/domino/render\ega\ega_hw.c:        out_mode->pitch_bytes = EGA_PLANE_PITCH_BYTES;
source/domino/render\ega\ega_hw.c:        out_mode->vram_segment = 0xa000u;
source/domino/render\ega\ega_hw.c:                    packed[plane] |= (uint8_t)(bit_val << (7 - bit));
source/domino/render\vk1\vk1_gfx.h:    /* host window handle is platform-specific; dsys_window_get_native_handle
source/domino/render\vk1\vk1_gfx.h:       returns a platform-dependent pointer. vk1 backend is responsible
source/domino/render\vk1\vk1_gfx.h:       for bridging this to VkSurfaceKHR via platform-specific creation.
source/domino/render\vk1\vk1_gfx.h:    /* Optional: simple vertex buffers for immediate-mode style draws.
source/domino/render\quartz\quartz_gfx.c:    if (!desc || !desc->window) {
source/domino/render\quartz\quartz_gfx.c:    g_quartz.window = desc->window;
source/domino/render\quartz\quartz_gfx.c:    g_quartz.ns_window = dsys_window_get_native_handle(desc->window);
source/domino/render\quartz\quartz_gfx.c:    g_quartz.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\quartz\quartz_gfx.c:    g_quartz.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\quartz\quartz_gfx.c:        g_quartz.camera_offset_x = cam->offset_x;
source/domino/render\quartz\quartz_gfx.c:        g_quartz.camera_offset_y = cam->offset_y;
source/domino/render\quartz\quartz_gfx.c:        a = (CGFloat)((spr->color_rgba >> 24) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        r = (CGFloat)((spr->color_rgba >> 16) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        g = (CGFloat)((spr->color_rgba >> 8) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        b = (CGFloat)((spr->color_rgba >> 0) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(spr->x + g_quartz.camera_offset_x),
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(spr->y + g_quartz.camera_offset_y),
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)spr->w,
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)spr->h);
source/domino/render\quartz\quartz_gfx.c:        a = (CGFloat)((v0->color >> 24) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        r = (CGFloat)((v0->color >> 16) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        g = (CGFloat)((v0->color >> 8) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:        b = (CGFloat)((v0->color >> 0) & 0xffu) / 255.0f;
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(v0->x + g_quartz.camera_offset_x),
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(v0->y + g_quartz.camera_offset_y));
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(v1->x + g_quartz.camera_offset_x),
source/domino/render\quartz\quartz_gfx.c:            (CGFloat)(v1->y + g_quartz.camera_offset_y));
source/domino/render\quartz\quartz_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\quartz\quartz_gfx.c:    ptr = cmd_buf->data;
source/domino/render\quartz\quartz_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\quartz\quartz_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\quartz\quartz_gfx.c:        switch (cmd->op) {
source/domino/render\vesa\vesa_gfx.h:    /* Command-space state */
source/domino/render\ega\ega_gfx.c:        memcpy(g_ega.view, cam->view, sizeof(g_ega.view));
source/domino/render\ega\ega_gfx.c:        memcpy(g_ega.proj, cam->proj, sizeof(g_ega.proj));
source/domino/render\ega\ega_gfx.c:        memcpy(g_ega.world, cam->world, sizeof(g_ega.world));
source/domino/render\ega\ega_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\ega\ega_gfx.c:        int x = spr->x + g_ega.camera2d_x;
source/domino/render\ega\ega_gfx.c:        int y = spr->y + g_ega.camera2d_y;
source/domino/render\ega\ega_gfx.c:        soft_raster_fill_rect_2d(&g_ega.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\ega\ega_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\ega\ega_gfx.c:    ptr = cmd_buf->data;
source/domino/render\ega\ega_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\ega\ega_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\ega\ega_gfx.c:        switch (cmd->op) {
source/domino/render\vk1\vk1_gfx.c:    if (!desc || !desc->window) {
source/domino/render\vk1\vk1_gfx.c:    g_vk1.native_window = dsys_window_get_native_handle(desc->window);
source/domino/render\vk1\vk1_gfx.c:    g_vk1.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\vk1\vk1_gfx.c:    g_vk1.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\vk1\vk1_gfx.c:    g_vk1.vsync = desc->vsync ? 1 : 0;
source/domino/render\vk1\vk1_gfx.c:       are provided by helper functions or compile-time configuration. */
source/domino/render\vk1\vk1_gfx.c:       - For Win32: use VkWin32SurfaceCreateInfoKHR with HWND/HINSTANCE.
source/domino/render\vk1\vk1_gfx.c:       - For X11: VkXlibSurfaceCreateInfoKHR with Display* and Window.
source/domino/render\vk1\vk1_gfx.c:       - For macOS: VK_EXT_metal_surface / VK_MVK_macos_surface and CAMetalLayer.
source/domino/render\vk1\vk1_gfx.c:    /* TODO: create a host-visible uniform buffer for camera/world matrices. */
source/domino/render\vk1\vk1_gfx.c:    /* For now, rely on the begin-frame clear values. */
source/domino/render\vk1\vk1_gfx.c:        ubo->view[i] = 0.0f;
source/domino/render\vk1\vk1_gfx.c:        ubo->proj[i] = 0.0f;
source/domino/render\vk1\vk1_gfx.c:        ubo->world[i] = 0.0f;
source/domino/render\vk1\vk1_gfx.c:    ubo->view[0] = ubo->view[5] = ubo->view[10] = ubo->view[15] = 1.0f;
source/domino/render\vk1\vk1_gfx.c:    ubo->proj[0] = ubo->proj[5] = ubo->proj[10] = ubo->proj[15] = 1.0f;
source/domino/render\vk1\vk1_gfx.c:    ubo->world[0] = ubo->world[5] = ubo->world[10] = ubo->world[15] = 1.0f;
source/domino/render\vk1\vk1_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\vk1\vk1_gfx.c:    ptr = cmd_buf->data;
source/domino/render\vk1\vk1_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\vk1\vk1_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\vk1\vk1_gfx.c:        switch (cmd->op) {
source/domino/render\vesa\vesa_gfx.c:    req_w = (uint16_t)((desc->width > 0) ? desc->width : 640);
source/domino/render\vesa\vesa_gfx.c:    req_h = (uint16_t)((desc->height > 0) ? desc->height : 480);
source/domino/render\vesa\vesa_gfx.c:        memcpy(g_vesa.view, cam->view, sizeof(g_vesa.view));
source/domino/render\vesa\vesa_gfx.c:        memcpy(g_vesa.proj, cam->proj, sizeof(g_vesa.proj));
source/domino/render\vesa\vesa_gfx.c:        memcpy(g_vesa.world, cam->world, sizeof(g_vesa.world));
source/domino/render\vesa\vesa_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\vesa\vesa_gfx.c:        int x = spr->x + g_vesa.camera2d_x;
source/domino/render\vesa\vesa_gfx.c:        int y = spr->y + g_vesa.camera2d_y;
source/domino/render\vesa\vesa_gfx.c:        soft_raster_fill_rect_2d(&g_vesa.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\vesa\vesa_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\vesa\vesa_gfx.c:    ptr = cmd_buf->data;
source/domino/render\vesa\vesa_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\vesa\vesa_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\vesa\vesa_gfx.c:        switch (cmd->op) {
source/domino/render\cga\cga_hw.c:        out_mode->kind = CGA_MODE_KIND_320x200_4COL;
source/domino/render\cga\cga_hw.c:        out_mode->width = 320u;
source/domino/render\cga\cga_hw.c:        out_mode->height = 200u;
source/domino/render\cga\cga_hw.c:        out_mode->logical_bpp = 2u;
source/domino/render\cga\cga_hw.c:        out_mode->palette = (uint8_t)(palette ? 1u : 0u);
source/domino/render\cga\cga_hw.c:        out_mode->pitch_bytes = 80u;
source/domino/render\cga\cga_hw.c:        out_mode->vram_segment = 0xb800u;
source/domino/render\vesa\vesa_bios.c:/* Stub implementations; platform-specific VBE hooks can replace these. */
source/domino/render\vesa\vesa_bios.c:    return -1;
source/domino/render\vesa\vesa_bios.c:    return -1;
source/domino/render\vesa\vesa_bios.c:    return -1;
source/domino/render\cga\cga_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\cga\cga_gfx.c:    dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
source/domino/render\cga\cga_gfx.c:    dy = (y1 > y0) ? (y1 - y0) : (y0 - y1);
source/domino/render\cga\cga_gfx.c:    sx = (x0 < x1) ? 1 : -1;
source/domino/render\cga\cga_gfx.c:    sy = (y0 < y1) ? 1 : -1;
source/domino/render\cga\cga_gfx.c:    err = dx - dy;
source/domino/render\cga\cga_gfx.c:        if (e2 > -dy) {
source/domino/render\cga\cga_gfx.c:            err -= dy;
source/domino/render\cga\cga_gfx.c:        g_cga.camera_offset_x = cam->offset_x;
source/domino/render\cga\cga_gfx.c:        g_cga.camera_offset_y = cam->offset_y;
source/domino/render\cga\cga_gfx.c:        idx = cga_quantize_rgba(spr->color_rgba);
source/domino/render\cga\cga_gfx.c:        x = spr->x + g_cga.camera_offset_x;
source/domino/render\cga\cga_gfx.c:        y = spr->y + g_cga.camera_offset_y;
source/domino/render\cga\cga_gfx.c:        cga_fill_rect(x, y, spr->w, spr->h, idx);
source/domino/render\cga\cga_gfx.c:        v0 = &verts[i - 1u];
source/domino/render\cga\cga_gfx.c:        idx = cga_quantize_rgba(v0->color);
source/domino/render\cga\cga_gfx.c:        x0 = cga_round_to_int(v0->x) + g_cga.camera_offset_x;
source/domino/render\cga\cga_gfx.c:        y0 = cga_round_to_int(v0->y) + g_cga.camera_offset_y;
source/domino/render\cga\cga_gfx.c:        x1 = cga_round_to_int(v1->x) + g_cga.camera_offset_x;
source/domino/render\cga\cga_gfx.c:        y1 = cga_round_to_int(v1->y) + g_cga.camera_offset_y;
source/domino/render\cga\cga_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\cga\cga_gfx.c:    ptr = cmd_buf->data;
source/domino/render\cga\cga_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\cga\cga_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\cga\cga_gfx.c:        switch (cmd->op) {
source/domino/render\null\dom_rend_stub.c:    dev->width = desc->width;
source/domino/render\null\dom_rend_stub.c:    dev->height = desc->height;
source/domino/render\null\dom_rend_stub.c:    dev->pixels = (uint32_t*)malloc((size_t)desc->width * (size_t)desc->height * sizeof(uint32_t));
source/domino/render\null\dom_rend_stub.c:    if (dev->pixels) {
source/domino/render\null\dom_rend_stub.c:        memset(dev->pixels, 0, (size_t)desc->width * (size_t)desc->height * sizeof(uint32_t));
source/domino/render\null\dom_rend_stub.c:    if (dev->pixels) free(dev->pixels);
source/domino/render\null\dom_rend_stub.c:    if (!dev || !dev->pixels) return;
source/domino/render\null\dom_rend_stub.c:    n = (size_t)dev->width * (size_t)dev->height;
source/domino/render\null\dom_rend_stub.c:        dev->pixels[i] = rgba;
source/domino/render\null\dom_rend_stub.c:    if (!dev || !dev->pixels) return;
source/domino/render\null\dom_rend_stub.c:        if (py < 0 || py >= dev->height) continue;
source/domino/render\null\dom_rend_stub.c:            if (px < 0 || px >= dev->width) continue;
source/domino/render\null\dom_rend_stub.c:            dev->pixels[(size_t)py * (size_t)dev->width + (size_t)px] = rgba;
source/domino/render\dx9\dx9_gfx.c:    do { if (x) { (x)->lpVtbl->Release(x); (x) = NULL; } } while (0)
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetRenderState(
source/domino/render\dx9\dx9_gfx.c:    if (!desc || !desc->window) {
source/domino/render\dx9\dx9_gfx.c:    g_dx9.hwnd = (HWND)dsys_window_get_native_handle(desc->window);
source/domino/render\dx9\dx9_gfx.c:    g_dx9.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\dx9\dx9_gfx.c:    g_dx9.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\dx9\dx9_gfx.c:    pp->Windowed = TRUE;
source/domino/render\dx9\dx9_gfx.c:    pp->hDeviceWindow = g_dx9.hwnd;
source/domino/render\dx9\dx9_gfx.c:    pp->SwapEffect = D3DSWAPEFFECT_DISCARD;
source/domino/render\dx9\dx9_gfx.c:    pp->BackBufferCount = 1;
source/domino/render\dx9\dx9_gfx.c:    pp->BackBufferWidth = (UINT)g_dx9.width;
source/domino/render\dx9\dx9_gfx.c:    pp->BackBufferHeight = (UINT)g_dx9.height;
source/domino/render\dx9\dx9_gfx.c:    pp->BackBufferFormat = D3DFMT_UNKNOWN;
source/domino/render\dx9\dx9_gfx.c:    pp->MultiSampleType = D3DMULTISAMPLE_NONE;
source/domino/render\dx9\dx9_gfx.c:    pp->EnableAutoDepthStencil = TRUE;
source/domino/render\dx9\dx9_gfx.c:    pp->AutoDepthStencilFormat = D3DFMT_D24S8;
source/domino/render\dx9\dx9_gfx.c:    pp->PresentationInterval = desc->vsync ? D3DPRESENT_INTERVAL_ONE
source/domino/render\dx9\dx9_gfx.c:    hr = g_dx9.d3d->lpVtbl->CreateDevice(
source/domino/render\dx9\dx9_gfx.c:        pp->AutoDepthStencilFormat = D3DFMT_D16;
source/domino/render\dx9\dx9_gfx.c:        hr = g_dx9.d3d->lpVtbl->CreateDevice(
source/domino/render\dx9\dx9_gfx.c:        hr = g_dx9.d3d->lpVtbl->CreateDevice(
source/domino/render\dx9\dx9_gfx.c:    hr = g_dx9.device->lpVtbl->Reset(g_dx9.device, &g_dx9.pp);
source/domino/render\dx9\dx9_gfx.c:    hr = g_dx9.device->lpVtbl->TestCooperativeLevel(g_dx9.device);
source/domino/render\dx9\dx9_gfx.c:        hr = g_dx9.device->lpVtbl->Reset(g_dx9.device, &g_dx9.pp);
source/domino/render\dx9\dx9_gfx.c:    hr = g_dx9.device->lpVtbl->Clear(
source/domino/render\dx9\dx9_gfx.c:        hr = g_dx9.device->lpVtbl->BeginScene(g_dx9.device);
source/domino/render\dx9\dx9_gfx.c:        g_dx9.device->lpVtbl->EndScene(g_dx9.device);
source/domino/render\dx9\dx9_gfx.c:    hr = g_dx9.device->lpVtbl->Present(g_dx9.device, NULL, NULL, NULL, NULL);
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->Clear(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetViewport(g_dx9.device, &vp);
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetTexture(
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetTexture(g_dx9.device, 0, NULL);
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->SetFVF(g_dx9.device, DX9_LINE_FVF);
source/domino/render\dx9\dx9_gfx.c:    g_dx9.device->lpVtbl->DrawPrimitiveUP(
source/domino/render\dx9\dx9_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\dx9\dx9_gfx.c:    ptr = cmd_buf->data;
source/domino/render\dx9\dx9_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\dx9\dx9_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\dx9\dx9_gfx.c:        switch (cmd->op) {
source/domino/render\metal\metal_gfx.h:/* Opaque Objective-C types are viewed as void* here to keep the C interface. */
source/domino/render\api\gfx_stub.c:    if (cfg) dev->config = *cfg;
source/domino/render\api\gfx_stub.c:        dev->config.width  = 0;
source/domino/render\api\gfx_stub.c:        dev->config.height = 0;
source/domino/render\api\gfx_stub.c:        dev->config.flags  = 0;
source/domino/render\api\gfx_stub.c:    dev->impl = NULL;
source/domino/render\metal\metal_gfx.c:/* Objective-C++ implementations live in metal_backend.mm */
source/domino/render\dx7\dx7_gfx.c:    do { if (x) { (x)->lpVtbl->Release(x); (x) = NULL; } } while (0)
source/domino/render\dx7\dx7_gfx.c:    if (!desc || !desc->window) {
source/domino/render\dx7\dx7_gfx.c:    g_dx7.hwnd = (HWND)dsys_window_get_native_handle(desc->window);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\dx7\dx7_gfx.c:    g_dx7.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\dx7\dx7_gfx.c:    g_dx7.viewport->lpVtbl->SetViewport(g_dx7.viewport, &vp);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->Clear(
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->BeginScene(g_dx7.d3d_device);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->EndScene(g_dx7.d3d_device);
source/domino/render\dx7\dx7_gfx.c:        g_dx7.primary->lpVtbl->Flip(g_dx7.primary, NULL, DDFLIP_WAIT);
source/domino/render\dx7\dx7_gfx.c:        g_dx7.primary->lpVtbl->Blt(
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->SetCooperativeLevel(
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->SetDisplayMode(
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->CreateSurface(g_dx7.dd, &desc, &g_dx7.primary, NULL);
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.primary->lpVtbl->GetAttachedSurface(g_dx7.primary, &caps, &g_dx7.backbuffer);
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->SetCooperativeLevel(
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->CreateSurface(g_dx7.dd, &desc, &g_dx7.primary, NULL);
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->CreateSurface(g_dx7.dd, &desc, &g_dx7.backbuffer, NULL);
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.dd->lpVtbl->CreateClipper(g_dx7.dd, 0, &g_dx7.clipper, NULL);
source/domino/render\dx7\dx7_gfx.c:        g_dx7.clipper->lpVtbl->SetHWnd(g_dx7.clipper, 0, g_dx7.hwnd);
source/domino/render\dx7\dx7_gfx.c:        g_dx7.primary->lpVtbl->SetClipper(g_dx7.primary, g_dx7.clipper);
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.dd->lpVtbl->QueryInterface(g_dx7.dd, &IID_IDirect3D7, (void**)&g_dx7.d3d);
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.d3d->lpVtbl->CreateDevice(
source/domino/render\dx7\dx7_gfx.c:        hr = g_dx7.d3d->lpVtbl->CreateDevice(
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.d3d_device->lpVtbl->CreateViewport(g_dx7.d3d_device, &g_dx7.viewport, NULL);
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.d3d_device->lpVtbl->AddViewport(g_dx7.d3d_device, g_dx7.viewport);
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.viewport->lpVtbl->SetViewport(g_dx7.viewport, &vp);
source/domino/render\dx7\dx7_gfx.c:    hr = g_dx7.d3d_device->lpVtbl->SetRenderTarget(g_dx7.d3d_device, g_dx7.backbuffer, 0);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetRenderState(g_dx7.d3d_device, D3DRENDERSTATE_ZENABLE, D3DZB_FALSE);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetRenderState(g_dx7.d3d_device, D3DRENDERSTATE_LIGHTING, FALSE);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetRenderState(g_dx7.d3d_device, D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->Clear(
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetTexture(g_dx7.d3d_device, 0, NULL);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetRenderState(g_dx7.d3d_device, D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetTextureStageState(g_dx7.d3d_device, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->SetTextureStageState(g_dx7.d3d_device, 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
source/domino/render\dx7\dx7_gfx.c:    g_dx7.d3d_device->lpVtbl->DrawPrimitive(
source/domino/render\dx7\dx7_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\dx7\dx7_gfx.c:    ptr = cmd_buf->data;
source/domino/render\dx7\dx7_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\dx7\dx7_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\dx7\dx7_gfx.c:        switch (cmd->op) {
source/domino/render\vga\vga_hw.h:/* Initialize VGA hardware layer (stubbed on non-DOS builds). */
source/domino/render\metal\metal_backend.mm:    if (!desc || !desc->window) {
source/domino/render\metal\metal_backend.mm:    g_metal.ns_window = dsys_window_get_native_handle(desc->window);
source/domino/render\metal\metal_backend.mm:    g_metal.width = (desc->width > 0) ? desc->width : 1280;
source/domino/render\metal\metal_backend.mm:    g_metal.height = (desc->height > 0) ? desc->height : 720;
source/domino/render\metal\metal_backend.mm:    g_metal.vsync = desc->vsync ? 1 : 0;
source/domino/render\metal\metal_backend.mm:    verts[0].x = -0.5f; verts[0].y = -0.5f; verts[0].z = 0.0f;
source/domino/render\metal\metal_backend.mm:    verts[1].x = -0.5f; verts[1].y =  0.5f; verts[1].z = 0.0f;
source/domino/render\metal\metal_backend.mm:    verts[5].x =  0.5f; verts[5].y = -0.5f; verts[5].z = 0.0f;
source/domino/render\metal\metal_backend.mm:    verts[0].nx = 0.0f; verts[0].ny = 0.0f; verts[0].nz = -1.0f;
source/domino/render\metal\metal_backend.mm:    verts[1].x = -0.5f; verts[1].y = -0.5f; verts[1].z = 0.0f;
source/domino/render\metal\metal_backend.mm:    verts[1].nx = 0.0f; verts[1].ny = 0.0f; verts[1].nz = -1.0f;
source/domino/render\metal\metal_backend.mm:    verts[2].x = 0.5f;  verts[2].y = -0.5f; verts[2].z = 0.0f;
source/domino/render\metal\metal_backend.mm:    verts[2].nx = 0.0f; verts[2].ny = 0.0f; verts[2].nz = -1.0f;
source/domino/render\metal\metal_backend.mm:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\metal\metal_backend.mm:    ptr = cmd_buf->data;
source/domino/render\metal\metal_backend.mm:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\metal\metal_backend.mm:        payload_size = cmd->payload_size;
source/domino/render\metal\metal_backend.mm:        switch (cmd->op) {
source/domino/render\metal\metal_backend.mm:/* Stub implementations to satisfy non-Apple builds if this file is compiled. */
source/domino/render\api\dom_render_api.h: * - Backend-agnostic command buffer.
source/domino/render\api\dom_render_api.h: * - Supports vector-only or full (textured) modes per config.
source/domino/render\api\dom_render_api.h:/* ------------------------------------------------------------
source/domino/render\api\dom_render_api.h: * ------------------------------------------------------------ */
source/domino/render\api\dom_render_api.h:    dom_render_backend backend; /* compile-time choice, but tracked for completeness */
source/domino/render\api\dom_render_api.h:/* ------------------------------------------------------------
source/domino/render\api\dom_render_api.h: * ------------------------------------------------------------ */
source/domino/render\api\dom_render_api.h:/* ------------------------------------------------------------
source/domino/render\api\dom_render_api.h: * ------------------------------------------------------------ */
source/domino/render\api\dom_render_api.h:/* ------------------------------------------------------------
source/domino/render\api\dom_render_api.h: * ------------------------------------------------------------ */
source/domino/render\api\dom_render_api.h:/* New canonical renderer API wrapper (malloc-owning) */
source/domino/render\api\dom_render_api.h:/* ------------------------------------------------------------
source/domino/render\api\dom_render_api.h: * ------------------------------------------------------------ */
source/domino/render\api\domino_gfx_core.c:/*------------------------------------------------------------
source/domino/render\api\domino_gfx_core.c: *------------------------------------------------------------*/
source/domino/render\api\domino_gfx_core.c:/*------------------------------------------------------------
source/domino/render\api\domino_gfx_core.c: *------------------------------------------------------------*/
source/domino/render\api\domino_gfx_core.c:    if (desc && desc->backend != DOMINO_GFX_BACKEND_AUTO) {
source/domino/render\api\domino_gfx_core.c:        return desc->backend;
source/domino/render\api\domino_gfx_core.c:/*------------------------------------------------------------
source/domino/render\api\domino_gfx_core.c: *------------------------------------------------------------*/
source/domino/render\api\domino_gfx_core.c:    if (!out_dev) return -1;
source/domino/render\api\domino_gfx_core.c:    if (dev->vt && dev->vt->destroy) {
source/domino/render\api\domino_gfx_core.c:        dev->vt->destroy(dev);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->begin_frame) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->begin_frame(dev);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->end_frame) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->end_frame(dev);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->clear) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->clear(dev, r, g, b, a);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->draw_rect) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->draw_rect(dev, rect, r, g, b, a);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->tex_create) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->tex_create(dev, desc, out_tex);
source/domino/render\api\domino_gfx_core.c:    /* Texture destruction is backend-specific; stored on the object */
source/domino/render\api\domino_gfx_core.c:    if (!tex) return -1;
source/domino/render\api\domino_gfx_core.c:    return -1;
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->draw_texture) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->draw_texture(dev, tex, dst_rect, src_uv);
source/domino/render\api\domino_gfx_core.c:    if (!dev || !dev->vt || !dev->vt->draw_text) return -1;
source/domino/render\api\domino_gfx_core.c:    return dev->vt->draw_text(dev, font, x, y, text, r, g, b, a);
source/domino/render\api\dom_render_api.c:    s->clear_color = 0xFF000000;   /* opaque black */
source/domino/render\api\dom_render_api.c:    s->default_color = 0xFFFFFFFF; /* white */
source/domino/render\api\dom_render_api.c:    s->default_sprite = 0;
source/domino/render\api\dom_render_api.c:    return dom_render_cmd_push(&r->cmd, cmd);
source/domino/render\api\dom_render_api.c:    r->backend = backend;
source/domino/render\api\dom_render_api.c:    r->config = local_cfg;
source/domino/render\api\dom_render_api.c:    r->mode = local_cfg.mode;
source/domino/render\api\dom_render_api.c:    r->width = local_cfg.width;
source/domino/render\api\dom_render_api.c:    r->height = local_cfg.height;
source/domino/render\api\dom_render_api.c:    r->platform_window = local_cfg.platform_window;
source/domino/render\api\dom_render_api.c:    dom_render_state_init(&r->state);
source/domino/render\api\dom_render_api.c:    dom_render_cmd_init(&r->cmd);
source/domino/render\api\dom_render_api.c:    r->api = dom_render_get_backend(backend);
source/domino/render\api\dom_render_api.c:    if (!r->api || !r->api->init) {
source/domino/render\api\dom_render_api.c:    memset(&r->caps, 0, sizeof(r->caps));
source/domino/render\api\dom_render_api.c:    caps_ptr = out_caps ? out_caps : &r->caps;
source/domino/render\api\dom_render_api.c:    err = r->api->init(r, &local_cfg, caps_ptr);
source/domino/render\api\dom_render_api.c:        r->caps = *out_caps;
source/domino/render\api\dom_render_api.c:    if (!r || !r->api || !r->api->shutdown) {
source/domino/render\api\dom_render_api.c:    r->api->shutdown(r);
source/domino/render\api\dom_render_api.c:    r->backend_state = 0;
source/domino/render\api\dom_render_api.c:    r->width = width;
source/domino/render\api\dom_render_api.c:    r->height = height;
source/domino/render\api\dom_render_api.c:    r->config.width = width;
source/domino/render\api\dom_render_api.c:    r->config.height = height;
source/domino/render\api\dom_render_api.c:    if (r->api && r->api->resize) {
source/domino/render\api\dom_render_api.c:        r->api->resize(r, width, height);
source/domino/render\api\dom_render_api.c:    r->state.clear_color = clear_color;
source/domino/render\api\dom_render_api.c:    dom_render_cmd_init(&r->cmd);
source/domino/render\api\dom_render_api.c:    return dom_render_cmd_push(&r->cmd, &cmd);
source/domino/render\api\dom_render_api.c:    return dom_render_cmd_push(&r->cmd, &cmd);
source/domino/render\api\dom_render_api.c:    return dom_render_cmd_push(&r->cmd, &cmd);
source/domino/render\api\dom_render_api.c:        len = DOM_CMD_TEXT_MAX - 1u;
source/domino/render\api\dom_render_api.c:    return dom_render_cmd_push(&r->cmd, &cmd);
source/domino/render\api\dom_render_api.c:    if (!r || !r->api || !r->api->submit) {
source/domino/render\api\dom_render_api.c:        submit_cmds = r->cmd.cmds;
source/domino/render\api\dom_render_api.c:        submit_count = r->cmd.count;
source/domino/render\api\dom_render_api.c:    r->api->submit(r, submit_cmds, submit_count);
source/domino/render\api\dom_render_api.c:    if (!r || !r->api || !r->api->present) {
source/domino/render\api\dom_render_api.c:    r->api->present(r);
source/domino/render\api\dom_render_api.c:    err = dom_render_create(r, cfg->backend, cfg, out_caps);
source/domino/render\vga\vga_gfx.h:    uint16_t      vram_segment; /* real-mode segment (0xA000) */
source/domino/render\vga\vga_gfx.c:        memcpy(g_vga.view, cam->view, sizeof(g_vga.view));
source/domino/render\vga\vga_gfx.c:        memcpy(g_vga.proj, cam->proj, sizeof(g_vga.proj));
source/domino/render\vga\vga_gfx.c:        memcpy(g_vga.world, cam->world, sizeof(g_vga.world));
source/domino/render\vga\vga_gfx.c:        int x = spr->x + g_vga.camera2d_x;
source/domino/render\vga\vga_gfx.c:        int y = spr->y + g_vga.camera2d_y;
source/domino/render\vga\vga_gfx.c:        soft_raster_fill_rect_2d(&g_vga.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\vga\vga_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\vga\vga_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\vga\vga_gfx.c:    ptr = cmd_buf->data;
source/domino/render\vga\vga_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\vga\vga_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\vga\vga_gfx.c:        switch (cmd->op) {
source/domino/render\gfx.c:    ctx->desc = local_desc;
source/domino/render\gfx.c:    ctx->vtable = &g_dgfx_null_vtable;
source/domino/render\gfx.c:    init_desc = &ctx->desc;
source/domino/render\gfx.c:    switch (ctx->desc.backend) {
source/domino/render\gfx.c:    ctx->vtable = g_dgfx;
source/domino/render\gfx.c:    if (!ctx->vtable || !ctx->vtable->init(init_desc)) {
source/domino/render\gfx.c:        ctx->vtable = &g_dgfx_null_vtable;
source/domino/render\gfx.c:        if (!g_dgfx->init(init_desc)) {
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->shutdown) {
source/domino/render\gfx.c:        g_dgfx->shutdown();
source/domino/render\gfx.c:    ctx->vtable = NULL;
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->get_caps) {
source/domino/render\gfx.c:        return g_dgfx->get_caps();
source/domino/render\gfx.c:    ctx->desc.width = width;
source/domino/render\gfx.c:    ctx->desc.height = height;
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->resize) {
source/domino/render\gfx.c:        g_dgfx->resize(width, height);
source/domino/render\gfx.c:    buf->size = 0;
source/domino/render\gfx.c:    if (!buf || !buf->data) {
source/domino/render\gfx.c:    if (buf->size > buf->capacity) {
source/domino/render\gfx.c:    required = (uint32_t)buf->size + sizeof(dgfx_cmd) + (uint32_t)payload_size;
source/domino/render\gfx.c:    if (required > buf->capacity) {
source/domino/render\gfx.c:    cmd = (dgfx_cmd*)(buf->data + buf->size);
source/domino/render\gfx.c:    cmd->op = op;
source/domino/render\gfx.c:    cmd->payload_size = payload_size;
source/domino/render\gfx.c:    buf->size = (uint16_t)required;
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->begin_frame) {
source/domino/render\gfx.c:        g_dgfx->begin_frame();
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->execute) {
source/domino/render\gfx.c:        g_dgfx->execute(buf);
source/domino/render\gfx.c:    if (g_dgfx && g_dgfx->end_frame) {
source/domino/render\gfx.c:        g_dgfx->end_frame();
source/domino/render\dx11\dx11_gfx.c:        (*res)->lpVtbl->Release(*res);
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.device->lpVtbl->CreateBuffer(g_dx11.device, &desc, NULL, out_buf);
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.swap_chain->lpVtbl->GetBuffer(
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.device->lpVtbl->CreateRenderTargetView(
source/domino/render\dx11\dx11_gfx.c:    backbuffer->lpVtbl->Release(backbuffer);
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.device->lpVtbl->CreateTexture2D(
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.device->lpVtbl->CreateDepthStencilView(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->OMSetRenderTargets(
source/domino/render\dx11\dx11_gfx.c:        hr = g_dx11.device->lpVtbl->CreateBlendState(
source/domino/render\dx11\dx11_gfx.c:        hr = g_dx11.device->lpVtbl->CreateRasterizerState(
source/domino/render\dx11\dx11_gfx.c:    /* Depth-stencil state */
source/domino/render\dx11\dx11_gfx.c:        hr = g_dx11.device->lpVtbl->CreateDepthStencilState(
source/domino/render\dx11\dx11_gfx.c:        hr = g_dx11.device->lpVtbl->CreateBuffer(
source/domino/render\dx11\dx11_gfx.c:    if (!desc || !desc->window) {
source/domino/render\dx11\dx11_gfx.c:    g_dx11.hwnd = (HWND)dsys_window_get_native_handle(desc->window);
source/domino/render\dx11\dx11_gfx.c:    g_dx11.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\dx11\dx11_gfx.c:    g_dx11.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\dx11\dx11_gfx.c:    g_dx11.vsync = desc->vsync ? 1 : 0;
source/domino/render\dx11\dx11_gfx.c:    hr = g_dx11.swap_chain->lpVtbl->ResizeBuffers(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->OMSetRenderTargets(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->RSSetState(g_dx11.context, g_dx11.rs_solid);
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->OMSetDepthStencilState(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->RSSetViewports(g_dx11.context, 1, &vp);
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->ClearRenderTargetView(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->ClearDepthStencilView(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.swap_chain->lpVtbl->Present(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->ClearRenderTargetView(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->ClearDepthStencilView(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->RSSetViewports(g_dx11.context, 1, &vp);
source/domino/render\dx11\dx11_gfx.c:    if (FAILED(g_dx11.context->lpVtbl->Map(
source/domino/render\dx11\dx11_gfx.c:        g_dx11.context->lpVtbl->Unmap(
source/domino/render\dx11\dx11_gfx.c:        cb->view[i] = 0.0f;
source/domino/render\dx11\dx11_gfx.c:        cb->proj[i] = 0.0f;
source/domino/render\dx11\dx11_gfx.c:        cb->world[i] = 0.0f;
source/domino/render\dx11\dx11_gfx.c:    cb->view[0] = cb->view[5] = cb->view[10] = cb->view[15] = 1.0f;
source/domino/render\dx11\dx11_gfx.c:    cb->proj[0] = cb->proj[5] = cb->proj[10] = cb->proj[15] = 1.0f;
source/domino/render\dx11\dx11_gfx.c:    cb->world[0] = cb->world[5] = cb->world[10] = cb->world[15] = 1.0f;
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->Unmap(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->VSSetConstantBuffers(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->OMSetBlendState(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->RSSetState(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->OMSetDepthStencilState(
source/domino/render\dx11\dx11_gfx.c:    verts[0].x = -0.5f; verts[0].y = -0.5f; verts[0].z = 0.0f;
source/domino/render\dx11\dx11_gfx.c:    verts[1].x = -0.5f; verts[1].y =  0.5f; verts[1].z = 0.0f;
source/domino/render\dx11\dx11_gfx.c:    verts[5].x =  0.5f; verts[5].y = -0.5f; verts[5].z = 0.0f;
source/domino/render\dx11\dx11_gfx.c:    if (FAILED(g_dx11.context->lpVtbl->Map(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->Unmap(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetInputLayout(g_dx11.context, g_dx11.il_sprite);
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetVertexBuffers(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetPrimitiveTopology(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->VSSetShader(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->PSSetShader(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->Draw(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.vb_sprite->lpVtbl->GetDesc(g_dx11.vb_sprite, &vb_desc);
source/domino/render\dx11\dx11_gfx.c:    if (FAILED(g_dx11.context->lpVtbl->Map(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->Unmap(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetInputLayout(g_dx11.context, g_dx11.il_sprite);
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetVertexBuffers(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->IASetPrimitiveTopology(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->VSSetShader(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->PSSetShader(
source/domino/render\dx11\dx11_gfx.c:    g_dx11.context->lpVtbl->Draw(
source/domino/render\dx11\dx11_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\dx11\dx11_gfx.c:    ptr = cmd_buf->data;
source/domino/render\dx11\dx11_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\dx11\dx11_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\dx11\dx11_gfx.c:        switch (cmd->op) {
source/domino/render\soft\soft_config.c:    f->enable_2d = on;
source/domino/render\soft\soft_config.c:    f->enable_3d = on;
source/domino/render\soft\soft_config.c:    f->enable_vector = on;
source/domino/render\soft\soft_config.c:    f->enable_raster = on;
source/domino/render\soft\soft_config.c:    f->enable_depth = on;
source/domino/render\soft\soft_config.c:    f->enable_stencil = on;
source/domino/render\soft\soft_config.c:    f->enable_texturing = on;
source/domino/render\soft\soft_config.c:    f->enable_mipmaps = on;
source/domino/render\soft\soft_config.c:    f->enable_gamma = on;
source/domino/render\soft\soft_config.c:    f->enable_msaa = on;
source/domino/render\soft\soft_config.c:    f->enable_subpixel = on;
source/domino/render\soft\soft_config.c:    out_cfg->profile = DGFX_SOFT_PROFILE_BALANCED;
source/domino/render\soft\soft_config.c:    out_cfg->color_format = DGFX_SOFT_FMT_32_ARGB;
source/domino/render\soft\soft_config.c:    out_cfg->depth_bits = 24u;
source/domino/render\soft\soft_config.c:    out_cfg->stencil_bits = 8u;
source/domino/render\soft\soft_config.c:    out_cfg->allow_resize = 1u;
source/domino/render\soft\soft_config.c:    soft_features_set_all(&out_cfg->features, 1u);
source/domino/render\soft\soft_config.c:    out_cfg->max_triangles_per_frame = 65536u;
source/domino/render\soft\soft_config.c:    out_cfg->max_lines_per_frame = 65536u;
source/domino/render\soft\soft_config.c:    out_cfg->max_sprites_per_frame = 32768u;
source/domino/render\soft\soft_config.c:    out_cfg->prefer_fullscreen = 0u;
source/domino/render\soft\soft_config.c:    out_cfg->prefer_borderless = 0u;
source/domino/render\soft\soft_config.c:    cfg->profile = profile;
source/domino/render\soft\soft_config.c:        cfg->color_format = DGFX_SOFT_FMT_16_565;
source/domino/render\soft\soft_config.c:        cfg->depth_bits = 0u;
source/domino/render\soft\soft_config.c:        cfg->stencil_bits = 0u;
source/domino/render\soft\soft_config.c:        soft_features_set_all(&cfg->features, 0u);
source/domino/render\soft\soft_config.c:        cfg->features.enable_2d = 1u;
source/domino/render\soft\soft_config.c:        cfg->features.enable_vector = 1u;
source/domino/render\soft\soft_config.c:        cfg->features.enable_raster = 1u;
source/domino/render\soft\soft_config.c:        cfg->color_format = DGFX_SOFT_FMT_32_ARGB;
source/domino/render\soft\soft_config.c:        cfg->depth_bits = 32u;
source/domino/render\soft\soft_config.c:        cfg->stencil_bits = 8u;
source/domino/render\soft\soft_config.c:        soft_features_set_all(&cfg->features, 1u);
source/domino/render\soft\soft_config.c:        cfg->color_format = DGFX_SOFT_FMT_32_ARGB;
source/domino/render\soft\soft_config.c:        cfg->depth_bits = 24u;
source/domino/render\soft\soft_config.c:        cfg->stencil_bits = 8u;
source/domino/render\soft\soft_config.c:        soft_features_set_all(&cfg->features, 1u);
source/domino/render\soft\soft_config.c:        cfg->color_format = DGFX_SOFT_FMT_8_INDEXED;
source/domino/render\soft\soft_config.c:        cfg->depth_bits = 0u;
source/domino/render\soft\soft_config.c:        cfg->stencil_bits = 0u;
source/domino/render\soft\soft_config.c:        soft_features_set_all(&cfg->features, 0u);
source/domino/render\soft\soft_gfx.c:    g_soft.native_window = desc->window ? dsys_window_get_native_handle(desc->window) : NULL;
source/domino/render\soft\soft_gfx.c:    g_soft.width = (desc->width > 0) ? desc->width : 640;
source/domino/render\soft\soft_gfx.c:    g_soft.height = (desc->height > 0) ? desc->height : 480;
source/domino/render\soft\soft_gfx.c:        memcpy(g_soft.view, cam->view, sizeof(g_soft.view));
source/domino/render\soft\soft_gfx.c:        memcpy(g_soft.proj, cam->proj, sizeof(g_soft.proj));
source/domino/render\soft\soft_gfx.c:        memcpy(g_soft.world, cam->world, sizeof(g_soft.world));
source/domino/render\soft\soft_gfx.c:        int x = spr->x + g_soft.camera2d_x;
source/domino/render\soft\soft_gfx.c:        int y = spr->y + g_soft.camera2d_y;
source/domino/render\soft\soft_gfx.c:        soft_raster_fill_rect_2d(&g_soft.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\soft\soft_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\soft\soft_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\soft\soft_gfx.c:    ptr = cmd_buf->data;
source/domino/render\soft\soft_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\soft\soft_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\soft\soft_gfx.c:        switch (cmd->op) {
source/domino/render\herc\herc_gfx.c:        memcpy(g_herc.view, cam->view, sizeof(g_herc.view));
source/domino/render\herc\herc_gfx.c:        memcpy(g_herc.proj, cam->proj, sizeof(g_herc.proj));
source/domino/render\herc\herc_gfx.c:        memcpy(g_herc.world, cam->world, sizeof(g_herc.world));
source/domino/render\herc\herc_gfx.c:        int x = spr->x + g_herc.camera2d_x;
source/domino/render\herc\herc_gfx.c:        int y = spr->y + g_herc.camera2d_y;
source/domino/render\herc\herc_gfx.c:        soft_raster_fill_rect_2d(&g_herc.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\herc\herc_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\herc\herc_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\herc\herc_gfx.c:    ptr = cmd_buf->data;
source/domino/render\herc\herc_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\herc\herc_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\herc\herc_gfx.c:        switch (cmd->op) {
source/domino/render\mda\mda_hw.h:   - threshold src pixels to 1-bit (on/off)
source/domino/render\mda\mda_hw.h:   - pack 8 pixels into 1 byte
source/domino/render\mda\mda_hw.h:   - apply MDA memory layout (interlaced row addressing)
source/domino/render\mda\mda_hw.c:/* Stub VRAM buffer for non-DOS targets; sized for a single 32KB page. */
source/domino/render\mda\mda_hw.c:        return -1;
source/domino/render\mda\mda_hw.c:    out_mode->kind = MDA_MODE_KIND_720x350_1;
source/domino/render\mda\mda_hw.c:    out_mode->width = 720u;
source/domino/render\mda\mda_hw.c:    out_mode->height = 350u;
source/domino/render\mda\mda_hw.c:    out_mode->bits_per_pixel = 1u;
source/domino/render\mda\mda_hw.c:    out_mode->pitch_bytes = (uint16_t)((out_mode->width + 7u) / 8u);
source/domino/render\mda\mda_hw.c:    out_mode->vram_segment = 0xb000u;
source/domino/render\gl2\gl2_gfx.h:    void*        native_window;/* platform-specific native handle */
source/domino/render\herc\herc_hw.h:       - Threshold or map src values to on/off (1bpp)
source/domino/render\herc\herc_hw.h:       - Pack bits into bytes according to Hercules layout
source/domino/render\herc\herc_hw.h:       - Store to VRAM starting at 0xB000:0000
source/domino/render\herc\herc_hw.c:        out_mode->kind = HERC_MODE_KIND_720x348_1;
source/domino/render\herc\herc_hw.c:        out_mode->width = 720u;
source/domino/render\herc\herc_hw.c:        out_mode->height = 348u;
source/domino/render\herc\herc_hw.c:        out_mode->bits_per_pixel = 1u;
source/domino/render\herc\herc_hw.c:        out_mode->pitch_bytes = 90u; /* 720 / 8 */
source/domino/render\herc\herc_hw.c:        out_mode->vram_segment = 0xb000u;
source/domino/render\herc\herc_hw.c:                packed |= (uint8_t)(on << (7u - bit));
source/domino/render\mda\mda_gfx.h:    uint16_t      pitch_bytes;    /* bytes per scanline in VRAM after bit-packing */
source/domino/render\mda\mda_gfx.h:    soft_framebuffer fb;      /* system RAM framebuffer (8-bit indexed / grayscale) */
source/domino/render\gl2\gl2_gfx.c:            p_glGetShaderInfoLog(sh, (GLsizei)sizeof(log) - 1, &len, log);
source/domino/render\gl2\gl2_gfx.c:            p_glGetProgramInfoLog(prog, (GLsizei)sizeof(log) - 1, &len, log);
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_2d_mvp = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_2d_color = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_2d_tex = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_lines_mvp = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_lines_color = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_3d_view = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_3d_proj = -1;
source/domino/render\gl2\gl2_gfx.c:        g_gl2.u_3d_world = -1;
source/domino/render\gl2\gl2_gfx.c:    if (!desc || !desc->window) {
source/domino/render\gl2\gl2_gfx.c:    g_gl2.window = desc->window;
source/domino/render\gl2\gl2_gfx.c:    g_gl2.native_window = dsys_window_get_native_handle(desc->window);
source/domino/render\gl2\gl2_gfx.c:    g_gl2.width = (desc->width > 0) ? desc->width : 800;
source/domino/render\gl2\gl2_gfx.c:    g_gl2.height = (desc->height > 0) ? desc->height : 600;
source/domino/render\gl2\gl2_gfx.c:    g_gl2.vsync = desc->vsync ? 1 : 0;
source/domino/render\gl2\gl2_gfx.c:    verts[0].x = -0.5f; verts[0].y = -0.5f; verts[0].z = 0.0f;
source/domino/render\gl2\gl2_gfx.c:    verts[1].x = -0.5f; verts[1].y =  0.5f; verts[1].z = 0.0f;
source/domino/render\gl2\gl2_gfx.c:    verts[5].x =  0.5f; verts[5].y = -0.5f; verts[5].z = 0.0f;
source/domino/render\gl2\gl2_gfx.c:    verts[1].x = -0.5f; verts[1].y = -0.5f; verts[1].z = 0.0f;
source/domino/render\gl2\gl2_gfx.c:    verts[2].x = 0.5f; verts[2].y = -0.5f; verts[2].z = 0.0f;
source/domino/render\gl2\gl2_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\gl2\gl2_gfx.c:    ptr = cmd_buf->data;
source/domino/render\gl2\gl2_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\gl2\gl2_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\gl2\gl2_gfx.c:        switch (cmd->op) {
source/domino/render\mda\mda_gfx.c:        g_mda.camera2d_x = cam->offset_x;
source/domino/render\mda\mda_gfx.c:        g_mda.camera2d_y = cam->offset_y;
source/domino/render\mda\mda_gfx.c:        int x = spr->x + g_mda.camera2d_x;
source/domino/render\mda\mda_gfx.c:        int y = spr->y + g_mda.camera2d_y;
source/domino/render\mda\mda_gfx.c:        soft_raster_fill_rect_2d(&g_mda.fb, x, y, spr->w, spr->h, spr->color_rgba);
source/domino/render\mda\mda_gfx.c:    return (int)((v >= 0.0f) ? (v + 0.5f) : (v - 0.5f));
source/domino/render\mda\mda_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\mda\mda_gfx.c:    ptr = cmd_buf->data;
source/domino/render\mda\mda_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\mda\mda_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\mda\mda_gfx.c:        switch (cmd->op) {
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->color) {
source/domino/render\soft\soft_raster.c:    if (x >= fb->width || y >= fb->height) {
source/domino/render\soft\soft_raster.c:    offset = (size_t)y * (size_t)fb->stride_bytes;
source/domino/render\soft\soft_raster.c:    switch (fb->format) {
source/domino/render\soft\soft_raster.c:            fb->color[offset + (size_t)x] = idx;
source/domino/render\soft\soft_raster.c:            row16 = (uint16_t*)(fb->color + offset);
source/domino/render\soft\soft_raster.c:            row32 = (uint32_t*)(fb->color + offset);
source/domino/render\soft\soft_raster.c:    fb->color = color;
source/domino/render\soft\soft_raster.c:    fb->depth = depth;
source/domino/render\soft\soft_raster.c:    fb->stencil = stencil;
source/domino/render\soft\soft_raster.c:    fb->width = width;
source/domino/render\soft\soft_raster.c:    fb->height = height;
source/domino/render\soft\soft_raster.c:    fb->stride_bytes = (int)color_stride;
source/domino/render\soft\soft_raster.c:    fb->depth_stride = (int)depth_stride;
source/domino/render\soft\soft_raster.c:    fb->stencil_stride = (int)stencil_stride;
source/domino/render\soft\soft_raster.c:    fb->format = fmt;
source/domino/render\soft\soft_raster.c:    fb->depth_bits = depth_bits;
source/domino/render\soft\soft_raster.c:    fb->stencil_bits = stencil_bits;
source/domino/render\soft\soft_raster.c:    if (fb->color) {
source/domino/render\soft\soft_raster.c:        free(fb->color);
source/domino/render\soft\soft_raster.c:    if (fb->depth) {
source/domino/render\soft\soft_raster.c:        free(fb->depth);
source/domino/render\soft\soft_raster.c:    if (fb->stencil) {
source/domino/render\soft\soft_raster.c:        free(fb->stencil);
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->color) {
source/domino/render\soft\soft_raster.c:    switch (fb->format) {
source/domino/render\soft\soft_raster.c:            total = (size_t)fb->stride_bytes * (size_t)fb->height;
source/domino/render\soft\soft_raster.c:            memset(fb->color, idx, total);
source/domino/render\soft\soft_raster.c:            for (y = 0u; y < (size_t)fb->height; ++y) {
source/domino/render\soft\soft_raster.c:                uint16_t* row = (uint16_t*)(fb->color + (size_t)y * (size_t)fb->stride_bytes);
source/domino/render\soft\soft_raster.c:                for (x = 0; x < fb->width; ++x) {
source/domino/render\soft\soft_raster.c:            for (y = 0u; y < (size_t)fb->height; ++y) {
source/domino/render\soft\soft_raster.c:                uint32_t* row = (uint32_t*)(fb->color + (size_t)y * (size_t)fb->stride_bytes);
source/domino/render\soft\soft_raster.c:                for (x = 0; x < fb->width; ++x) {
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->depth || fb->depth_bits == 0u) {
source/domino/render\soft\soft_raster.c:    if (fb->depth_bits == 16u) {
source/domino/render\soft\soft_raster.c:        for (y = 0u; y < (uint32_t)fb->height; ++y) {
source/domino/render\soft\soft_raster.c:            uint16_t* row = (uint16_t*)(fb->depth + (size_t)y * (size_t)fb->depth_stride);
source/domino/render\soft\soft_raster.c:            for (x = 0; x < fb->width; ++x) {
source/domino/render\soft\soft_raster.c:    if (fb->depth_bits == 24u) {
source/domino/render\soft\soft_raster.c:        for (y = 0u; y < (uint32_t)fb->height; ++y) {
source/domino/render\soft\soft_raster.c:            uint8_t* row = fb->depth + (size_t)y * (size_t)fb->depth_stride;
source/domino/render\soft\soft_raster.c:            for (x = 0; x < fb->width; ++x) {
source/domino/render\soft\soft_raster.c:    for (y = 0u; y < (uint32_t)fb->height; ++y) {
source/domino/render\soft\soft_raster.c:        uint32_t* row = (uint32_t*)(fb->depth + (size_t)y * (size_t)fb->depth_stride);
source/domino/render\soft\soft_raster.c:        for (x = 0; x < fb->width; ++x) {
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->stencil || fb->stencil_bits == 0u) {
source/domino/render\soft\soft_raster.c:    memset(fb->stencil, s, (size_t)fb->stencil_stride * (size_t)fb->height);
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->color) {
source/domino/render\soft\soft_raster.c:    dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
source/domino/render\soft\soft_raster.c:    dy = (y1 > y0) ? (y1 - y0) : (y0 - y1);
source/domino/render\soft\soft_raster.c:    sx = (x0 < x1) ? 1 : -1;
source/domino/render\soft\soft_raster.c:    sy = (y0 < y1) ? 1 : -1;
source/domino/render\soft\soft_raster.c:    err = dx - dy;
source/domino/render\soft\soft_raster.c:        if (e2 > -dy) {
source/domino/render\soft\soft_raster.c:            err -= dy;
source/domino/render\soft\soft_raster.c:    if (!fb || !fb->color || w <= 0 || h <= 0) {
source/domino/render\soft\soft_raster.c:    if (x1 > fb->width)  x1 = fb->width;
source/domino/render\soft\soft_raster.c:    if (y1 > fb->height) y1 = fb->height;
source/domino/render\soft\soft_raster.c:                             (int)v0->x, (int)v0->y,
source/domino/render\soft\soft_raster.c:                             (int)v1->x, (int)v1->y,
source/domino/render\soft\soft_raster.c:                             v0->color);
source/domino/render\soft\soft_raster.c:                             (int)v1->x, (int)v1->y,
source/domino/render\soft\soft_raster.c:                             (int)v2->x, (int)v2->y,
source/domino/render\soft\soft_raster.c:                             v1->color);
source/domino/render\soft\soft_raster.c:                             (int)v2->x, (int)v2->y,
source/domino/render\soft\soft_raster.c:                             (int)v0->x, (int)v0->y,
source/domino/render\soft\soft_raster.c:                             v2->color);
source/domino/render\soft\core\dom_render_software.c:    if (h != 0 && w > ((size_t)-1) / h / sizeof(dom_u32)) {
source/domino/render\soft\core\dom_render_software.c:    if (st->pixels) {
source/domino/render\soft\core\dom_render_software.c:        free(st->pixels);
source/domino/render\soft\core\dom_render_software.c:    st->pixels = buf;
source/domino/render\soft\core\dom_render_software.c:    st->width = w;
source/domino/render\soft\core\dom_render_software.c:    st->height = h;
source/domino/render\soft\core\dom_render_software.c:    st->pitch_pixels = w;
source/domino/render\soft\core\dom_render_software.c:    st->pitch_bytes = w * (dom_u32)sizeof(dom_u32);
source/domino/render\soft\core\dom_render_software.c:    r->width = w;
source/domino/render\soft\core\dom_render_software.c:    r->height = h;
source/domino/render\soft\core\dom_render_software.c:    r->config.width = w;
source/domino/render\soft\core\dom_render_software.c:    r->config.height = h;
source/domino/render\soft\core\dom_render_software.c:    out_caps->supports_textures = 0;
source/domino/render\soft\core\dom_render_software.c:    out_caps->supports_blending = 0;
source/domino/render\soft\core\dom_render_software.c:    out_caps->supports_linear_filter = 0;
source/domino/render\soft\core\dom_render_software.c:    out_caps->supports_aniso = 0;
source/domino/render\soft\core\dom_render_software.c:    st->present = cfg->present;
source/domino/render\soft\core\dom_render_software.c:    st->present_user = cfg->present_user;
source/domino/render\soft\core\dom_render_software.c:    r->config = *cfg;
source/domino/render\soft\core\dom_render_software.c:    r->mode = cfg->mode;
source/domino/render\soft\core\dom_render_software.c:    r->backend_state = st;
source/domino/render\soft\core\dom_render_software.c:    err = dom_render_software_resize_buffer(r, st, cfg->width, cfg->height);
source/domino/render\soft\core\dom_render_software.c:        r->backend_state = 0;
source/domino/render\soft\core\dom_render_software.c:    if (!r || !r->backend_state) {
source/domino/render\soft\core\dom_render_software.c:    st = (DomRenderSoftwareState *)r->backend_state;
source/domino/render\soft\core\dom_render_software.c:    if (st->pixels) {
source/domino/render\soft\core\dom_render_software.c:        free(st->pixels);
source/domino/render\soft\core\dom_render_software.c:    r->backend_state = 0;
source/domino/render\soft\core\dom_render_software.c:    if (!r || !r->backend_state) {
source/domino/render\soft\core\dom_render_software.c:    st = (DomRenderSoftwareState *)r->backend_state;
source/domino/render\soft\core\dom_render_software.c:    if (!st || !st->pixels) {
source/domino/render\soft\core\dom_render_software.c:    total = st->width * st->height;
source/domino/render\soft\core\dom_render_software.c:        st->pixels[i] = c;
source/domino/render\soft\core\dom_render_software.c:    if (!st || !st->pixels) {
source/domino/render\soft\core\dom_render_software.c:    if ((dom_u32)x >= st->width || (dom_u32)y >= st->height) {
source/domino/render\soft\core\dom_render_software.c:    st->pixels[(dom_u32)y * st->pitch_pixels + (dom_u32)x] = c;
source/domino/render\soft\core\dom_render_software.c:    dom_i32 dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
source/domino/render\soft\core\dom_render_software.c:    dom_i32 sx = (x0 < x1) ? 1 : -1;
source/domino/render\soft\core\dom_render_software.c:    dom_i32 dy = (y1 > y0) ? (y1 - y0) : (y0 - y1);
source/domino/render\soft\core\dom_render_software.c:    dom_i32 sy = (y0 < y1) ? 1 : -1;
source/domino/render\soft\core\dom_render_software.c:    dom_i32 err = dx - dy;
source/domino/render\soft\core\dom_render_software.c:        if ((err << 1) > -dy) {
source/domino/render\soft\core\dom_render_software.c:            err -= dy;
source/domino/render\soft\core\dom_render_software.c:    if (!st || !st->pixels) {
source/domino/render\soft\core\dom_render_software.c:    x0 = rc->rect.x;
source/domino/render\soft\core\dom_render_software.c:    y0 = rc->rect.y;
source/domino/render\soft\core\dom_render_software.c:    x1 = rc->rect.x + rc->rect.w;
source/domino/render\soft\core\dom_render_software.c:    y1 = rc->rect.y + rc->rect.h;
source/domino/render\soft\core\dom_render_software.c:    if (x1 > (dom_i32)st->width)  x1 = (dom_i32)st->width;
source/domino/render\soft\core\dom_render_software.c:    if (y1 > (dom_i32)st->height) y1 = (dom_i32)st->height;
source/domino/render\soft\core\dom_render_software.c:        dom_u32 *row = st->pixels + (dom_u32)y * st->pitch_pixels;
source/domino/render\soft\core\dom_render_software.c:            row[x] = rc->color;
source/domino/render\soft\core\dom_render_software.c:    if (poly->count < 2) {
source/domino/render\soft\core\dom_render_software.c:    for (i = 0; i < poly->count; ++i) {
source/domino/render\soft\core\dom_render_software.c:        DomVec2i a = poly->pts[i];
source/domino/render\soft\core\dom_render_software.c:        DomVec2i b = poly->pts[(i + 1u) % poly->count];
source/domino/render\soft\core\dom_render_software.c:        dom_sw_draw_line(st, a.x, a.y, b.x, b.y, poly->color);
source/domino/render\soft\core\dom_render_software.c:    if (!r || !r->backend_state) {
source/domino/render\soft\core\dom_render_software.c:    st = (DomRenderSoftwareState *)r->backend_state;
source/domino/render\soft\core\dom_render_software.c:    dom_sw_clear(st, r->state.clear_color);
source/domino/render\soft\core\dom_render_software.c:        switch (cmd->type) {
source/domino/render\soft\core\dom_render_software.c:                             cmd->u.line.x0, cmd->u.line.y0,
source/domino/render\soft\core\dom_render_software.c:                             cmd->u.line.x1, cmd->u.line.y1,
source/domino/render\soft\core\dom_render_software.c:                             cmd->u.line.color);
source/domino/render\soft\core\dom_render_software.c:            dom_sw_draw_rect(st, &cmd->u.rect);
source/domino/render\soft\core\dom_render_software.c:            dom_sw_draw_poly(st, &cmd->u.poly);
source/domino/render\soft\core\dom_render_software.c:            if (r->mode == DOM_RENDER_MODE_VECTOR_ONLY || !r->caps.supports_textures) {
source/domino/render\soft\core\dom_render_software.c:                                               cmd->u.sprite.x,
source/domino/render\soft\core\dom_render_software.c:                                               cmd->u.sprite.y,
source/domino/render\soft\core\dom_render_software.c:                                               r->state.default_color);
source/domino/render\soft\core\dom_render_software.c:                                           cmd->u.sprite.x,
source/domino/render\soft\core\dom_render_software.c:                                           cmd->u.sprite.y,
source/domino/render\soft\core\dom_render_software.c:                                           r->state.default_color);
source/domino/render\soft\core\dom_render_software.c:                                           cmd->u.text.x,
source/domino/render\soft\core\dom_render_software.c:                                           cmd->u.text.y,
source/domino/render\soft\core\dom_render_software.c:                                           r->state.default_color);
source/domino/render\soft\core\dom_render_software.c:            /* No-op */
source/domino/render\soft\core\dom_render_software.c:    if (!r || !r->backend_state) {
source/domino/render\soft\core\dom_render_software.c:    st = (DomRenderSoftwareState *)r->backend_state;
source/domino/render\soft\core\dom_render_software.c:    if (st->present && st->pixels) {
source/domino/render\soft\core\dom_render_software.c:        st->present(st->present_user,
source/domino/render\soft\core\dom_render_software.c:                    st->pixels,
source/domino/render\soft\core\dom_render_software.c:                    (int)st->width,
source/domino/render\soft\core\dom_render_software.c:                    (int)st->height,
source/domino/render\soft\core\dom_render_software.c:                    (int)st->pitch_bytes);
source/domino/render\api\core\dom_draw_common.h: * Shared draw-command definitions for all renderers.
source/domino/render\api\core\dom_draw_common.h: * Pure C89, no platform headers. Deterministic and backend-agnostic.
source/domino/render\soft\soft_raster.h:/* 3D triangles: assumes transformed vertices already in screen-space or NDC */
source/domino/render\soft\core\domino_soft_core.c:    if (!dev || !dev->backend_data) return -1;
source/domino/render\soft\core\domino_soft_core.c:    st = (domino_soft_state*)dev->backend_data;
source/domino/render\soft\core\domino_soft_core.c:    if (st->target && st->target->present) {
source/domino/render\soft\core\domino_soft_core.c:        return st->target->present(st->target_state,
source/domino/render\soft\core\domino_soft_core.c:                                   st->pixels,
source/domino/render\soft\core\domino_soft_core.c:                                   st->width,
source/domino/render\soft\core\domino_soft_core.c:                                   st->height,
source/domino/render\soft\core\domino_soft_core.c:                                   st->stride_bytes);
source/domino/render\soft\core\domino_soft_core.c:    st = (domino_soft_state*)dev->backend_data;
source/domino/render\soft\core\domino_soft_core.c:        if (st->target && st->target->shutdown) {
source/domino/render\soft\core\domino_soft_core.c:            st->target->shutdown(st->target_state);
source/domino/render\soft\core\domino_soft_core.c:        if (st->pixels) {
source/domino/render\soft\core\domino_soft_core.c:            free(st->pixels);
source/domino/render\soft\core\domino_soft_core.c:    if (!dev || !dev->backend_data) return -1;
source/domino/render\soft\core\domino_soft_core.c:    st = (domino_soft_state*)dev->backend_data;
source/domino/render\soft\core\domino_soft_core.c:    row = (unsigned int*)st->pixels;
source/domino/render\soft\core\domino_soft_core.c:    for (y = 0; y < st->height; ++y) {
source/domino/render\soft\core\domino_soft_core.c:        for (x = 0; x < st->width; ++x) {
source/domino/render\soft\core\domino_soft_core.c:        row = (unsigned int*)((unsigned char*)row + st->stride_bytes);
source/domino/render\soft\core\domino_soft_core.c:    if (!dev || !dev->backend_data || !rect) return -1;
source/domino/render\soft\core\domino_soft_core.c:    st = (domino_soft_state*)dev->backend_data;
source/domino/render\soft\core\domino_soft_core.c:    x0 = (int)rect->x;
source/domino/render\soft\core\domino_soft_core.c:    y0 = (int)rect->y;
source/domino/render\soft\core\domino_soft_core.c:    x1 = x0 + (int)rect->w;
source/domino/render\soft\core\domino_soft_core.c:    y1 = y0 + (int)rect->h;
source/domino/render\soft\core\domino_soft_core.c:    if (x1 > st->width)  x1 = st->width;
source/domino/render\soft\core\domino_soft_core.c:    if (y1 > st->height) y1 = st->height;
source/domino/render\soft\core\domino_soft_core.c:        unsigned int* row = (unsigned int*)((unsigned char*)st->pixels + y * st->stride_bytes);
source/domino/render\soft\core\domino_soft_core.c:    if (!out_tex) return -1;
source/domino/render\soft\core\domino_soft_core.c:    if (!tex) return -1;
source/domino/render\soft\core\domino_soft_core.c:    tex->placeholder = 0;
source/domino/render\soft\core\domino_soft_core.c:    return -1;
source/domino/render\soft\core\domino_soft_core.c:    return -1;
source/domino/render\soft\core\domino_soft_core.c:    return -1;
source/domino/render\soft\core\domino_soft_core.c:    if (!out_dev || !desc) return -1;
source/domino/render\soft\core\domino_soft_core.c:    if (!dev) return -1;
source/domino/render\soft\core\domino_soft_core.c:        return -1;
source/domino/render\soft\core\domino_soft_core.c:    st->width = desc->width;
source/domino/render\soft\core\domino_soft_core.c:    st->height = desc->height;
source/domino/render\soft\core\domino_soft_core.c:    st->fmt = desc->framebuffer_fmt;
source/domino/render\soft\core\domino_soft_core.c:    st->stride_bytes = st->width * 4;
source/domino/render\soft\core\domino_soft_core.c:    st->pixels = (unsigned char*)malloc((size_t)st->stride_bytes * (size_t)st->height);
source/domino/render\soft\core\domino_soft_core.c:    if (!st->pixels) {
source/domino/render\soft\core\domino_soft_core.c:        return -1;
source/domino/render\soft\core\domino_soft_core.c:    memset(st->pixels, 0, (size_t)st->stride_bytes * (size_t)st->height);
source/domino/render\soft\core\domino_soft_core.c:    st->target = target;
source/domino/render\soft\core\domino_soft_core.c:    if (target && target->init) {
source/domino/render\soft\core\domino_soft_core.c:        if (target->init(sys, st->width, st->height, st->fmt, &st->target_state) != 0) {
source/domino/render\soft\core\domino_soft_core.c:            st->target = target;
source/domino/render\soft\core\domino_soft_core.c:            st->target_state = NULL;
source/domino/render\soft\core\domino_soft_core.c:            if (target && target->init) {
source/domino/render\soft\core\domino_soft_core.c:                target->init(sys, st->width, st->height, st->fmt, &st->target_state);
source/domino/render\soft\core\domino_soft_core.c:    dev->backend = DOMINO_GFX_BACKEND_SOFT;
source/domino/render\soft\core\domino_soft_core.c:    dev->profile = desc->profile_hint;
source/domino/render\soft\core\domino_soft_core.c:    dev->framebuffer_fmt = desc->framebuffer_fmt;
source/domino/render\soft\core\domino_soft_core.c:    dev->width = desc->width;
source/domino/render\soft\core\domino_soft_core.c:    dev->height = desc->height;
source/domino/render\soft\core\domino_soft_core.c:    dev->fullscreen = desc->fullscreen;
source/domino/render\soft\core\domino_soft_core.c:    dev->vsync = desc->vsync;
source/domino/render\soft\core\domino_soft_core.c:    dev->sys = sys;
source/domino/render\soft\core\domino_soft_core.c:    dev->vt = &g_soft_vtable;
source/domino/render\soft\core\domino_soft_core.c:    dev->backend_data = st;
source/domino/render\api\core\dom_draw_common.c:    cb->count = 0;
source/domino/render\api\core\dom_draw_common.c:    if (cb->count >= DOM_DRAW_COMMAND_MAX) {
source/domino/render\api\core\dom_draw_common.c:    cb->cmds[cb->count] = *cmd;
source/domino/render\api\core\dom_draw_common.c:    cb->count += 1;
source/domino/render\api\core\dom_draw_common.c:/* Optional stable depth sort for triangle commands (back-to-front). */
source/domino/render\api\core\dom_draw_common.c:    for (i = 1; i < cb->count; ++i) {
source/domino/render\api\core\dom_draw_common.c:        DomDrawCommand key = cb->cmds[i];
source/domino/render\api\core\dom_draw_common.c:            if (cb->cmds[j - 1].type == DOM_CMD_TRIANGLE && is_tri) {
source/domino/render\api\core\dom_draw_common.c:                dom_i64 prev_depth = (dom_i64)cb->cmds[j - 1].u.tri.z0 +
source/domino/render\api\core\dom_draw_common.c:                                     (dom_i64)cb->cmds[j - 1].u.tri.z1 +
source/domino/render\api\core\dom_draw_common.c:                                     (dom_i64)cb->cmds[j - 1].u.tri.z2;
source/domino/render\api\core\dom_draw_common.c:            cb->cmds[j] = cb->cmds[j - 1];
source/domino/render\api\core\dom_draw_common.c:            j -= 1;
source/domino/render\api\core\dom_draw_common.c:        cb->cmds[j] = key;
source/domino/render\api\core\dom_camera.c:            cam->type = type;
source/domino/render\api\core\dom_camera.c:            cam->cam2d.zoom_q16_16 = (dom_i32)(1 << 16);
source/domino/render\api\core\dom_camera.c:            cam->cam3d.fov_y_q16_16 = (dom_i32)(60 << 16);
source/domino/render\api\core\dom_camera.c:            cam->cam3d.near_mm = 1;
source/domino/render\api\core\dom_camera.c:            cam->cam3d.far_mm = 100000;
source/domino/render\soft\targets\null\dom_render_null.c:    out_caps->supports_textures = 0;
source/domino/render\soft\targets\null\dom_render_null.c:    out_caps->supports_blending = 0;
source/domino/render\soft\targets\null\dom_render_null.c:    out_caps->supports_linear_filter = 0;
source/domino/render\soft\targets\null\dom_render_null.c:    out_caps->supports_aniso = 0;
source/domino/render\soft\targets\null\dom_render_null.c:    r->config = *cfg;
source/domino/render\soft\targets\null\dom_render_null.c:    r->mode = cfg->mode;
source/domino/render\soft\targets\null\dom_render_null.c:    r->width = cfg->width;
source/domino/render\soft\targets\null\dom_render_null.c:    r->height = cfg->height;
source/domino/render\soft\targets\null\dom_render_null.c:    r->backend_state = malloc(sizeof(DomRenderNullState));
source/domino/render\soft\targets\null\dom_render_null.c:    if (!r->backend_state) {
source/domino/render\soft\targets\null\dom_render_null.c:    memset(r->backend_state, 0, sizeof(DomRenderNullState));
source/domino/render\soft\targets\null\dom_render_null.c:    if (r && r->backend_state) {
source/domino/render\soft\targets\null\dom_render_null.c:        free(r->backend_state);
source/domino/render\soft\targets\null\dom_render_null.c:        r->backend_state = 0;
source/domino/render\soft\targets\null\dom_render_null.c: * A future revision can map this to GL1/GL2 immediate-mode vector drawing.
source/domino/render\api\core\dom_render_debug.c:    cx = (dom_i32)(r->width / 2u);
source/domino/render\api\core\dom_render_debug.c:    cy = (dom_i32)(r->height / 2u);
source/domino/render\api\core\dom_render_debug.c:    dom_render_line(r, 0, cy, (dom_i32)r->width, cy, color);
source/domino/render\api\core\dom_render_debug.c:    dom_render_line(r, cx, 0, cx, (dom_i32)r->height, color);
source/domino/render\api\core\dom_render_debug.c:    for (x = 0; x < (dom_i32)r->width; x += spacing) {
source/domino/render\api\core\dom_render_debug.c:        dom_render_line(r, x, 0, x, (dom_i32)r->height, color);
source/domino/render\api\core\dom_render_debug.c:    for (y = 0; y < (dom_i32)r->height; y += spacing) {
source/domino/render\api\core\dom_render_debug.c:        dom_render_line(r, 0, y, (dom_i32)r->width, y, color);
source/domino/render\api\core\dom_sprite_batch.c:    dom_draw_cmd_buffer_init(&batch->buffer);
source/domino/render\api\core\dom_sprite_batch.c:    return dom_draw_cmd_buffer_push(&batch->buffer, cmd);
source/domino/render\api\core\dom_sprite_batch.c:    return &batch->buffer;
source/domino/render\soft\targets\win32\soft_target_win32.c:        return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:    if (!out_state) return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:        return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:                         rect.right - rect.left,
source/domino/render\soft\targets\win32\soft_target_win32.c:                         rect.bottom - rect.top,
source/domino/render\soft\targets\win32\soft_target_win32.c:        return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:        return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->hwnd = hwnd;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->hdc = GetDC(hwnd);
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->width = width;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->height = height;
source/domino/render\soft\targets\win32\soft_target_win32.c:    memset(&st->bmi, 0, sizeof(st->bmi));
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biWidth = width;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biHeight = -height; /* top-down */
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biPlanes = 1;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biBitCount = 32;
source/domino/render\soft\targets\win32\soft_target_win32.c:    st->bmi.bmiHeader.biCompression = BI_RGB;
source/domino/render\soft\targets\win32\soft_target_win32.c:    if (st->hwnd && st->hdc) {
source/domino/render\soft\targets\win32\soft_target_win32.c:        ReleaseDC(st->hwnd, st->hdc);
source/domino/render\soft\targets\win32\soft_target_win32.c:    if (st->hwnd) {
source/domino/render\soft\targets\win32\soft_target_win32.c:        DestroyWindow(st->hwnd);
source/domino/render\soft\targets\win32\soft_target_win32.c:    if (!st || !st->hdc) return -1;
source/domino/render\soft\targets\win32\soft_target_win32.c:    while (PeekMessage(&msg, st->hwnd, 0, 0, PM_REMOVE)) {
source/domino/render\soft\targets\win32\soft_target_win32.c:    StretchDIBits(st->hdc,
source/domino/render\soft\targets\win32\soft_target_win32.c:                  0, 0, st->width, st->height,
source/domino/render\soft\targets\win32\soft_target_win32.c:                  &st->bmi,
source/domino/render\quickdraw\quickdraw_gfx.c:    out->red = (r << 8) | r;
source/domino/render\quickdraw\quickdraw_gfx.c:    out->green = (g << 8) | g;
source/domino/render\quickdraw\quickdraw_gfx.c:    out->blue = (b << 8) | b;
source/domino/render\quickdraw\quickdraw_gfx.c:    if (!desc || !desc->window) {
source/domino/render\quickdraw\quickdraw_gfx.c:    g_quickdraw.native_window = dsys_window_get_native_handle(desc->window);
source/domino/render\quickdraw\quickdraw_gfx.c:    g_quickdraw.width = (desc->width > 0) ? desc->width : 640;
source/domino/render\quickdraw\quickdraw_gfx.c:    g_quickdraw.height = (desc->height > 0) ? desc->height : 480;
source/domino/render\quickdraw\quickdraw_gfx.c:        v0 = &verts[i - 1u];
source/domino/render\quickdraw\quickdraw_gfx.c:        quickdraw_color_from_rgba(v0->color, &c);
source/domino/render\quickdraw\quickdraw_gfx.c:        MoveTo((int)(v0->x + (float)g_quickdraw_camera.offset_x),
source/domino/render\quickdraw\quickdraw_gfx.c:               (int)(v0->y + (float)g_quickdraw_camera.offset_y));
source/domino/render\quickdraw\quickdraw_gfx.c:        LineTo((int)(v1->x + (float)g_quickdraw_camera.offset_x),
source/domino/render\quickdraw\quickdraw_gfx.c:               (int)(v1->y + (float)g_quickdraw_camera.offset_y));
source/domino/render\quickdraw\quickdraw_gfx.c:    if (!cmd_buf || !cmd_buf->data || cmd_buf->size == 0u) {
source/domino/render\quickdraw\quickdraw_gfx.c:    ptr = cmd_buf->data;
source/domino/render\quickdraw\quickdraw_gfx.c:    end = cmd_buf->data + cmd_buf->size;
source/domino/render\quickdraw\quickdraw_gfx.c:        payload_size = cmd->payload_size;
source/domino/render\quickdraw\quickdraw_gfx.c:        switch (cmd->op) {
source/domino/render\api\core\dom_view.c:    if (desc->camera == DOM_CAMERA_ID_INVALID) {
source/domino/render\api\core\dom_view.c:    cam = dom_camera_lookup(desc->camera);
source/domino/render\api\core\dom_view.c:    if (desc->viewport_w <= 0 || desc->viewport_h <= 0) {
source/domino/render\api\core\dom_view.c:    if (view->desc.type != DOM_VIEW_TYPE_TOPDOWN_2D) {
source/domino/render\api\core\dom_view.c:    cam = dom_camera_lookup(view->desc.camera);
source/domino/render\api\core\dom_view.c:    dx = world_x_q32_32 - cam->cam2d.world_x_q32_32;
source/domino/render\api\core\dom_view.c:    dy = world_y_q32_32 - cam->cam2d.world_y_q32_32;
source/domino/render\api\core\dom_view.c:    /* zoom q16.16, dx/dy q32.32 -> sx_fp q32.16 */
source/domino/render\api\core\dom_view.c:    sx_fp = (dx >> 16) * cam->cam2d.zoom_q16_16;
source/domino/render\api\core\dom_view.c:    sy_fp = (dy >> 16) * cam->cam2d.zoom_q16_16;
source/domino/render\api\core\dom_view.c:    *out_sx = view->desc.viewport_x + (dom_i32)(sx_fp >> 16);
source/domino/render\api\core\dom_view.c:    *out_sy = view->desc.viewport_y + (dom_i32)(sy_fp >> 16);
source/domino/render\api\core\dom_text_layout.h:/* Deterministic placeholder text metrics used by vector-only paths. */
source/domino/render\api\core\dom_view_build.c: * Placeholder view-to-draw-command builder.
source/domino/render\api\core\dom_view_build.c:    if (view->desc.type == DOM_VIEW_TYPE_TOPDOWN_2D) {
source/domino/render\api\core\dom_view_build.c:        if (view->desc.mode == DOM_VIEW_MODE_VECTOR) {
source/domino/render\api\core\dom_view_build.c:    } else if (view->desc.type == DOM_VIEW_TYPE_FIRSTPERSON_3D) {
source/domino/render\api\core\dom_view_build.c:        if (view->desc.mode == DOM_VIEW_MODE_VECTOR) {
