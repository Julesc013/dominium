#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime


ALLOWED_SCOPES = {
    "engine",
    "game",
    "client",
    "server",
    "tools",
    "launcher",
    "setup",
    "docs",
    "schema",
    "data",
    "tests",
    "ci",
    "repox",
    "build",
    "ops",
    "dev",
}


def now_timestamp(deterministic: bool) -> str:
    if deterministic or os.environ.get("REPOX_DETERMINISTIC") == "1":
        return "2000-01-01T00:00:00Z"
    return datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")


def run_git(repo_root: str, args):
    try:
        result = subprocess.run(
            ["git"] + args,
            cwd=repo_root,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="replace",
            check=False,
        )
    except OSError:
        return None
    if result.returncode != 0:
        return None
    return result.stdout


def load_commits(repo_root: str, since_ref: str, commits_file: str):
    entries = []
    if commits_file:
        with open(commits_file, "r", encoding="utf-8") as handle:
            for raw in handle:
                line = raw.strip()
                if not line:
                    continue
                parts = line.split("|", 1)
                if len(parts) == 2:
                    entries.append((parts[0].strip(), parts[1].strip()))
                else:
                    entries.append(("", line))
        return entries

    args = ["log", "--pretty=format:%H|%s"]
    if since_ref:
        args.append("{}..HEAD".format(since_ref))
    output = run_git(repo_root, args)
    if output is None:
        return []
    for line in output.splitlines():
        if not line.strip():
            continue
        parts = line.split("|", 1)
        if len(parts) == 2:
            entries.append((parts[0].strip(), parts[1].strip()))
        else:
            entries.append(("", line.strip()))
    return entries


def parse_subject(subject: str):
    match = re.match(r"^([a-z0-9_.-]+):\s*(.+)$", subject.strip())
    if not match:
        return "uncategorized", subject.strip()
    scope = match.group(1).strip()
    summary = match.group(2).strip()
    if scope not in ALLOWED_SCOPES:
        return "uncategorized", subject.strip()
    return scope, summary


def group_commits(commits):
    grouped = {}
    for full_hash, subject in commits:
        scope, summary = parse_subject(subject)
        grouped.setdefault(scope, []).append((full_hash, summary, subject))
    return grouped


def render_changelog(grouped, commits, generated_at: str):
    lines = []
    lines.append("# Dominium â€” Change History")
    lines.append("")
    lines.append("This file is generated by scripts/repox/repox_changelog.py. Do not edit by hand.")
    lines.append("")
    lines.append("Generated: {}".format(generated_at))
    lines.append("")
    lines.append("## Unreleased")
    if not commits:
        lines.append("- (no changes)")
        lines.append("")
        return "\n".join(lines) + "\n"
    for scope in sorted(grouped.keys()):
        lines.append("### {}".format(scope))
        for full_hash, summary, _subject in grouped[scope]:
            short_hash = full_hash[:12] if full_hash else ""
            suffix = " ({})".format(short_hash) if short_hash else ""
            lines.append("- {}{}".format(summary, suffix))
        lines.append("")
    return "\n".join(lines) + "\n"


def render_feed(grouped, commits, generated_at: str):
    entries = []
    for full_hash, subject in commits:
        scope, summary = parse_subject(subject)
        entries.append({
            "hash": full_hash,
            "scope": scope,
            "summary": summary,
            "subject": subject,
        })
    return {
        "schema_version": 1,
        "generated_at": generated_at,
        "entries": entries,
    }


def write_text(path: str, text: str) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8", newline="\n") as handle:
        handle.write(text)


def write_json(path: str, payload: dict) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8", newline="\n") as handle:
        json.dump(payload, handle, indent=2, sort_keys=False)
        handle.write("\n")


def main() -> int:
    parser = argparse.ArgumentParser(description="RepoX changelog generator.")
    parser.add_argument("--repo-root", default=".")
    parser.add_argument("--since", default="")
    parser.add_argument("--commits-file", default="")
    parser.add_argument("--output", default="")
    parser.add_argument("--feed", default="")
    parser.add_argument("--deterministic", action="store_true")
    parser.add_argument("--check", action="store_true")
    args = parser.parse_args()

    repo_root = os.path.abspath(args.repo_root)
    changelog_path = args.output or os.path.join(repo_root, "CHANGELOG.md")
    feed_path = args.feed or os.path.join(repo_root, "updates", "changelog.json")

    commits = load_commits(repo_root, args.since, args.commits_file)
    grouped = group_commits(commits)
    generated_at = now_timestamp(args.deterministic)

    changelog_text = render_changelog(grouped, commits, generated_at)
    feed_payload = render_feed(grouped, commits, generated_at)

    if args.check:
        existing_text = ""
        if os.path.isfile(changelog_path):
            with open(changelog_path, "r", encoding="utf-8", errors="replace") as handle:
                existing_text = handle.read()
        if existing_text != changelog_text:
            sys.stderr.write("CHANGELOG.md is out of date.\n")
            return 1
        existing_feed = None
        if os.path.isfile(feed_path):
            with open(feed_path, "r", encoding="utf-8", errors="replace") as handle:
                try:
                    existing_feed = json.load(handle)
                except ValueError:
                    existing_feed = None
        if existing_feed != feed_payload:
            sys.stderr.write("updates/changelog.json is out of date.\n")
            return 1
        return 0

    write_text(changelog_path, changelog_text)
    write_json(feed_path, feed_payload)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
