@echo off
setlocal EnableExtensions EnableDelayedExpansion

rem Offline, deterministic changelog draft generator.
rem - Groups by prompt prefix (p1..pN) and subsystem keywords (docs/sys/gfx/io/net).
rem - Uses commit subjects only; no network, no extra deps.

if /i "%~1"=="--help" goto :usage
if /i "%~1"=="/?" goto :usage

set "ROOT=%~dp0.."
pushd "%ROOT%" >nul

call :find_git
if errorlevel 1 (
  echo FAIL: git not found. Install Git or ensure git is on PATH.
  popd >nul
  exit /b 1
)

set "OUT=docs\CHANGELOG_DRAFT.md"
set "RANGE_ARG="
set "RANGE_DESC=all commits"

rem Supported args:
rem   (none)             -> since last tag (or all commits if no tags)
rem   --since <rev>      -> <rev>..HEAD
rem   --range <a..b>     -> explicit range (e.g., v0.1.0..HEAD)
rem   --out <path>       -> output path (defaults to docs/CHANGELOG_DRAFT.md)

if not "%~1"=="" (
  if /i "%~1"=="--since" (
    if "%~2"=="" goto :usage
    set "RANGE_ARG=%~2..HEAD"
    set "RANGE_DESC=range %~2..HEAD"
    shift /1
    shift /1
    goto :parse_tail
  )
  if /i "%~1"=="--range" (
    if "%~2"=="" goto :usage
    set "RANGE_ARG=%~2"
    set "RANGE_DESC=range %~2"
    shift /1
    shift /1
    goto :parse_tail
  )
  if /i "%~1"=="--since-tag" (
    shift /1
    goto :default_range
  )
  if /i "%~1"=="--out" (
    goto :default_range
  )
  goto :usage
)

:default_range
rem Default (or --since-tag): since most recent tag (if present), else all commits.
for /f "usebackq delims=" %%T in (`"%GIT%" describe --tags --abbrev^=0 2^>nul`) do set "LAST_TAG=%%T"
if defined LAST_TAG (
  set "RANGE_ARG=%LAST_TAG%..HEAD"
  set "RANGE_DESC=since tag %LAST_TAG%"
)

:parse_tail
if not "%~1"=="" (
  if /i "%~1"=="--out" (
    if "%~2"=="" goto :usage
    set "OUT=%~2"
    shift /1
    shift /1
    goto :parse_tail
  )
  goto :usage
)

set "TMPDIR=%TEMP%\dominium_changelog_%RANDOM%%RANDOM%"
mkdir "%TMPDIR%" >nul 2>&1
if errorlevel 1 (
  echo FAIL: could not create temp dir: %TMPDIR%
  popd >nul
  exit /b 1
)

call :write_header "%OUT%" "%RANGE_DESC%" "%RANGE_ARG%"
if errorlevel 1 goto :cleanup_fail

rem Generate in descending prompt order; include "other" for non-pN commits.
for %%P in (p9 p8 p7 p6 p5 p4 p3 p2 p1 other) do (
  call :emit_prefix "%%P" "%OUT%" "%TMPDIR%" "%RANGE_ARG%"
  if errorlevel 1 goto :cleanup_fail
)

call :cleanup "%TMPDIR%"
popd >nul
echo Wrote %OUT%
exit /b 0

:usage
echo Usage:
echo   scripts\gen_changelog.bat
echo   scripts\gen_changelog.bat --since ^<rev^>
echo   scripts\gen_changelog.bat --range ^<a..b^>
echo   scripts\gen_changelog.bat --since-tag
echo   scripts\gen_changelog.bat [--since ^<rev^> ^| --range ^<a..b^> ^| --since-tag] --out ^<path^>
exit /b 2

:find_git
set "GIT=git"
where git >nul 2>&1 && goto :eof
if exist "C:\msys64\usr\bin\git.exe" (
  set "GIT=C:\msys64\usr\bin\git.exe"
  exit /b 0
)
exit /b 1

:write_header
set "OUTF=%~1"
set "DESC=%~2"
set "RANGE=%~3"

> "%OUTF%" echo # Changelog (Draft)
>>"%OUTF%" echo.
>>"%OUTF%" echo Generated by `scripts\gen_changelog.bat` from repo commit subjects.
>>"%OUTF%" echo.
>>"%OUTF%" echo Range: %DESC%
if not "%RANGE%"=="" (
  >>"%OUTF%" echo Git range: `%RANGE%`
)
>>"%OUTF%" echo.
>>"%OUTF%" echo Notes:
>>"%OUTF%" echo - This file is generated. Curate/promote entries into `CHANGELOG.md` as needed.
>>"%OUTF%" echo - Best results come from subject lines like `pN: docs: ...` / `pN: sys: ...` (see `docs/COMMIT_CONVENTIONS.md`).
>>"%OUTF%" echo.
exit /b 0

:emit_prefix
set "PFX=%~1"
set "OUTF=%~2"
set "TDIR=%~3"
set "RANGE=%~4"

set "HAS_ANY="
set "ALL=%TDIR%\%PFX%_all.txt"
set "WORK=%TDIR%\%PFX%_work.txt"
set "DOCS=%TDIR%\%PFX%_docs.txt"
set "SYS=%TDIR%\%PFX%_sys.txt"
set "GFX=%TDIR%\%PFX%_gfx.txt"
set "IO=%TDIR%\%PFX%_io.txt"
set "NET=%TDIR%\%PFX%_net.txt"
set "MISC=%TDIR%\%PFX%_misc.txt"

type nul > "%ALL%"
type nul > "%WORK%"
type nul > "%DOCS%"
type nul > "%SYS%"
type nul > "%GFX%"
type nul > "%IO%"
type nul > "%NET%"
type nul > "%MISC%"

if /i "%PFX%"=="other" (
  if "%RANGE%"=="" (
    "%GIT%" --no-pager log --no-merges --format="- %%h %%s" --invert-grep --grep="^p[0-9][0-9]*[: ]" > "%ALL%"
  ) else (
    "%GIT%" --no-pager log %RANGE% --no-merges --format="- %%h %%s" --invert-grep --grep="^p[0-9][0-9]*[: ]" > "%ALL%"
  )
) else (
  if "%RANGE%"=="" (
    "%GIT%" --no-pager log --no-merges --format="- %%h %%s" --grep="^%PFX%[: ]" > "%ALL%"
  ) else (
    "%GIT%" --no-pager log %RANGE% --no-merges --format="- %%h %%s" --grep="^%PFX%[: ]" > "%ALL%"
  )
)

rem Work from ALL -> subgroup files; anything not tagged ends up in misc.
copy /y "%ALL%" "%WORK%" >nul

rem Explicit subsystem tags (preferred): pN: docs: / sys: / gfx: / io: / net:
findstr /i /c:"%PFX%: docs:" "%WORK%" > "%DOCS%"
findstr /i /c:"%PFX%: sys:"  "%WORK%" > "%SYS%"
findstr /i /c:"%PFX%: gfx:"  "%WORK%" > "%GFX%"
findstr /i /c:"%PFX%: io:"   "%WORK%" > "%IO%"
findstr /i /c:"%PFX%: net:"  "%WORK%" > "%NET%"

findstr /i /v /c:"%PFX%: docs:" /c:"%PFX%: sys:" /c:"%PFX%: gfx:" /c:"%PFX%: io:" /c:"%PFX%: net:" "%WORK%" > "%MISC%"

rem Heuristic grouping for older subjects that don't include an explicit subsystem tag.
rem These are intentionally simple substring matches; ordering is the tiebreaker.
set "MISC_WORK=%TDIR%\%PFX%_misc_work.txt"
set "TMP_MATCH=%TDIR%\%PFX%_tmp_match.txt"
set "TMP_REST=%TDIR%\%PFX%_tmp_rest.txt"

copy /y "%MISC%" "%MISC_WORK%" >nul

rem docs
findstr /i /c:" docs" /c:": docs" /c:"doc" /c:"spec" /c:"readme" /c:"changelog" /c:"matrix" "%MISC_WORK%" > "%TMP_MATCH%"
for %%F in ("%TMP_MATCH%") do if %%~zF gtr 0 type "%TMP_MATCH%" >> "%DOCS%"
findstr /i /v /c:" docs" /c:": docs" /c:"doc" /c:"spec" /c:"readme" /c:"changelog" /c:"matrix" "%MISC_WORK%" > "%TMP_REST%"
copy /y "%TMP_REST%" "%MISC_WORK%" >nul

rem net
findstr /i /c:": net" /c:" net" /c:"netcode" /c:"network" /c:"socket" /c:"handshake" "%MISC_WORK%" > "%TMP_MATCH%"
for %%F in ("%TMP_MATCH%") do if %%~zF gtr 0 type "%TMP_MATCH%" >> "%NET%"
findstr /i /v /c:": net" /c:" net" /c:"netcode" /c:"network" /c:"socket" /c:"handshake" "%MISC_WORK%" > "%TMP_REST%"
copy /y "%TMP_REST%" "%MISC_WORK%" >nul

rem io
findstr /i /c:": io" /c:" io" /c:"tlv" /c:"serialize" /c:"serialization" /c:"save" /c:"replay" /c:"pack" /c:"container" /c:" fs" /c:"file" "%MISC_WORK%" > "%TMP_MATCH%"
for %%F in ("%TMP_MATCH%") do if %%~zF gtr 0 type "%TMP_MATCH%" >> "%IO%"
findstr /i /v /c:": io" /c:" io" /c:"tlv" /c:"serialize" /c:"serialization" /c:"save" /c:"replay" /c:"pack" /c:"container" /c:" fs" /c:"file" "%MISC_WORK%" > "%TMP_REST%"
copy /y "%TMP_REST%" "%MISC_WORK%" >nul

rem gfx
findstr /i /c:": gfx" /c:" gfx" /c:"dgfx" /c:"render" /c:"renderer" /c:"dx9" /c:"dx11" /c:"gl2" /c:"vk1" /c:"metal" /c:"present" "%MISC_WORK%" > "%TMP_MATCH%"
for %%F in ("%TMP_MATCH%") do if %%~zF gtr 0 type "%TMP_MATCH%" >> "%GFX%"
findstr /i /v /c:": gfx" /c:" gfx" /c:"dgfx" /c:"render" /c:"renderer" /c:"dx9" /c:"dx11" /c:"gl2" /c:"vk1" /c:"metal" /c:"present" "%MISC_WORK%" > "%TMP_REST%"
copy /y "%TMP_REST%" "%MISC_WORK%" >nul

rem sys
findstr /i /c:": sys" /c:" sys" /c:"dsys" /c:"platform" /c:"win32" /c:"window" /c:"launcher" /c:"cmake" /c:"preset" /c:"toolchain" /c:"verify" "%MISC_WORK%" > "%TMP_MATCH%"
for %%F in ("%TMP_MATCH%") do if %%~zF gtr 0 type "%TMP_MATCH%" >> "%SYS%"
findstr /i /v /c:": sys" /c:" sys" /c:"dsys" /c:"platform" /c:"win32" /c:"window" /c:"launcher" /c:"cmake" /c:"preset" /c:"toolchain" /c:"verify" "%MISC_WORK%" > "%TMP_REST%"
copy /y "%TMP_REST%" "%MISC_WORK%" >nul

copy /y "%MISC_WORK%" "%MISC%" >nul
del "%MISC_WORK%" "%TMP_MATCH%" "%TMP_REST%" >nul 2>&1

for %%F in ("%DOCS%" "%SYS%" "%GFX%" "%IO%" "%NET%" "%MISC%") do (
  if %%~zF gtr 0 set "HAS_ANY=1"
)
if not defined HAS_ANY exit /b 0

>>"%OUTF%" echo ## %PFX%
>>"%OUTF%" echo.

call :emit_section "%OUTF%" "docs" "%DOCS%"
call :emit_section "%OUTF%" "sys"  "%SYS%"
call :emit_section "%OUTF%" "gfx"  "%GFX%"
call :emit_section "%OUTF%" "io"   "%IO%"
call :emit_section "%OUTF%" "net"  "%NET%"
call :emit_section "%OUTF%" "misc" "%MISC%"

>>"%OUTF%" echo.
exit /b 0

:emit_section
set "OUTF=%~1"
set "NAME=%~2"
set "FILE=%~3"

for %%F in ("%FILE%") do (
  if %%~zF leq 0 exit /b 0
)

>>"%OUTF%" echo ### %NAME%
>>"%OUTF%" echo.
type "%FILE%" >> "%OUTF%"
>>"%OUTF%" echo.
exit /b 0

:cleanup_fail
call :cleanup "%TMPDIR%"
popd >nul
exit /b 1

:cleanup
set "TD=%~1"
if not "%TD%"=="" (
  rmdir /s /q "%TD%" >nul 2>&1
)
exit /b 0
